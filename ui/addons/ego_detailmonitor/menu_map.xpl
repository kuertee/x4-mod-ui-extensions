
-- section == gMain_map
-- param == { 0, 0, showzone, focuscomponent [, history] [, mode, modeparam] [, showmultiverse] [, focusoffset] }

-- modes: - "orderparam_object",	param: { returnfunction, paramdata, toprow, ordercontrollable }
--		  - "orderparam_position",	param: { returnfunction, paramdata, toprow, ordercontrollable }
--		  - "selectbuildlocation",	param: { returnsection, { 0, 0, trader, buildership_or_module, object, macro } }
--		  - "tradecontext",			param: { station, initialtradingship, iswareexchange, shadyOnly, loop, trader }
--		  - "selectCV",				param: { buildstorage }
--		  - "infomode",				param: { mode, ... }
--		  - "boardingcontext",		param: { target, boardingships }
--		  - "hire",					param: { returnsection, npc_or_context, ishiring[, npctemplate] }
--		  - "sellships",			param: { shipyard, ships }
--		  - "dropwarescontext",		param: { mode, entity }
--		  - "renamecontext",		param: { component, renamefleet }

--        -- kuertee start: multi-rename: requires menu_interactmenu.uix_forcedShowMenu
--		  - "renamecontext",		param: { component, renamefleet, uix_multiRename_objects }
--        -- kuertee end: multi-rename

--		  - "changelogocontext",	param: { component }
--		  - "selectComponent",		param: { returnsection, classlist[, category][, playerowned][, customheading] }
--		  - "crewtransfercontext",	param: { othership, ship }
--		  - "ventureconsole",		param: { ventureplatform }
--		  - "venturepatroninfo",	param: { ventureplatform }
--		  - "venturereport",		param: { mode, reason[, timestamp, author][, transactionid] }

-- ffi setup
local ffi = require("ffi")
local C = ffi.C
ffi.cdef[[
	typedef uint64_t AIOrderID;
	typedef int32_t BlacklistID;
	typedef uint64_t BuildTaskID;
	typedef int32_t FightRuleID;
	typedef uint64_t MissionID;
	typedef uint64_t NPCSeed;
	typedef uint64_t TradeID;
	typedef int32_t TradeRuleID;
	typedef uint64_t UniverseID;

	typedef struct {
		const char* id;
		uint32_t textid;
		uint32_t descriptionid;
		uint32_t value;
		uint32_t relevance;
		const char* ware;
	} SkillInfo;

	typedef struct {
		const char* macro;
		const char* ware;
		uint32_t amount;
		uint32_t capacity;
	} AmmoData;
	typedef struct {
		const char* id;
		const char* text;
	} BoardingBehaviour;
	typedef struct {
		const char* id;
		const char* text;
	} BoardingPhase;
	typedef struct {
		uint32_t approach;
		uint32_t insertion;
	} BoardingRiskThresholds;
	typedef struct {
		BuildTaskID id;
		UniverseID buildingcontainer;
		UniverseID component;
		const char* macro;
		const char* factionid;
		UniverseID buildercomponent;
		int64_t price;
		bool ismissingresources;
		uint32_t queueposition;
	} BuildTaskInfo;
	typedef struct {
		const char* newroleid;
		NPCSeed seed;
		uint32_t amount;
	} CrewTransferContainer;
	typedef struct {
		const char* id;
		const char* name;
	} ControlPostInfo;
	typedef struct {
		UniverseID entity;
		UniverseID personcontrollable;
		NPCSeed personseed;
	} GenericActor;
	typedef struct {
		const char* id;
		const char* name;
		const char* description;
	} ResponseInfo;
	typedef struct {
		const char* id;
		const char* name;
		const char* description;
		uint32_t numresponses;
		const char* defaultresponse;
		bool ask;
	} SignalInfo;
	typedef struct {
		const char* name;
		const char* transport;
		uint32_t spaceused;
		uint32_t capacity;
	} StorageInfo;
	typedef struct {
		int x;
		int y;
	} Coord2D;
	typedef struct {
		float x;
		float y;
		float z;
	} Coord3D;
	typedef struct {
		float dps;
		uint32_t quadranttextid;
	} DPSData;
	typedef struct {
		const char* id;
		const char* name;
		bool possible;
	} DroneModeInfo;
	typedef struct {
		const char* factionID;
		const char* factionName;
		const char* factionIcon;
	} FactionDetails;
	typedef struct {
		const char* icon;
		const char* caption;
	} MissionBriefingIconInfo;
	typedef struct {
		const char* missionName;
		const char* missionDescription;
		int difficulty;
		int upkeepalertlevel;
		const char* threadType;
		const char* mainType;
		const char* subType;
		const char* subTypeName;
		const char* faction;
		int64_t reward;
		const char* rewardText;
		size_t numBriefingObjectives;
		int activeBriefingStep;
		const char* opposingFaction;
		const char* license;
		float timeLeft;
		double duration;
		bool abortable;
		bool hasObjective;
		UniverseID associatedComponent;
		UniverseID threadMissionID;
	} MissionDetails;
	typedef struct {
		const char* id;
		const char* name;
	} MissionGroupDetails;
	typedef struct {
		MissionID missionid;
		uint32_t amount;
		uint32_t numskills;
		SkillInfo* skills;
	} MissionNPCInfo;
	typedef struct {
		const char* text;
		const char* actiontext;
		const char* detailtext;
		int step;
		bool failed;
		bool completedoutofsequence;
	} MissionObjectiveStep3;
	typedef struct {
		uint32_t id;
		bool ispin;
		bool ishome;
	} MultiverseMapPickInfo;
	typedef struct {
		NPCSeed seed;
		const char* roleid;
		int32_t tierid;
		const char* name;
		int32_t combinedskill;
	} NPCInfo;
	typedef struct {
		const char* chapter;
		const char* onlineid;
	} OnlineMissionInfo;
	typedef struct {
		const char* id;
		const char* name;
		const char* icon;
		const char* description;
		const char* category;
		const char* categoryname;
		bool infinite;
		uint32_t requiredSkill;
	} OrderDefinition;
	typedef struct {
		size_t queueidx;
		const char* state;
		const char* statename;
		const char* orderdef;
		size_t actualparams;
		bool enabled;
		bool isinfinite;
		bool issyncpointreached;
		bool istemporder;
	} Order;
	typedef struct {
		size_t queueidx;
		const char* state;
		const char* statename;
		const char* orderdef;
		size_t actualparams;
		bool enabled;
		bool isinfinite;
		bool issyncpointreached;
		bool istemporder;
		bool isoverride;
	} Order2;
	typedef struct {
		uint32_t id;
		AIOrderID orderid;
		const char* orderdef;
		const char* message;
		double timestamp;
		bool wasdefaultorder;
		bool wasinloop;
	} OrderFailure;
	typedef struct {
		const char* id;
		const char* name;
		const char* desc;
		uint32_t amount;
		uint32_t numtiers;
		bool canhire;
	} PeopleInfo;
	typedef struct {
		const char* id;
		const char* name;
	} ProductionMethodInfo;
	typedef struct {
		const char* id;
		const char* name;
		const char* shortname;
		const char* description;
		const char* icon;
	} RaceInfo;
	typedef struct {
		const char* name;
		int32_t skilllevel;
		uint32_t amount;
	} RoleTierData;
	typedef struct {
		UniverseID context;
		const char* group;
		UniverseID component;
	} ShieldGroup;
	typedef struct {
		uint32_t textid;
		uint32_t descriptionid;
		uint32_t value;
		uint32_t relevance;
	} Skill2;
	typedef struct {
		UniverseID softtargetID;
		const char* softtargetConnectionName;
		uint32_t messageID;
	} SofttargetDetails2;
	typedef struct {
		const char* max;
		const char* current;
	} SoftwareSlot;
	typedef struct {
		UniverseID controllableid;
		int group;
	} SubordinateGroup;
	typedef struct {
		uint32_t id;
		UniverseID owningcontrollable;
		size_t owningorderidx;
		bool reached;
	} SyncPointInfo2;
	typedef struct {
		const char* reason;
		NPCSeed person;
		NPCSeed partnerperson;
	} UICrewExchangeResult;
	typedef struct {
		const char* shape;
		const char* name;
		uint32_t requiredSkill;
		float radius;
		bool rollMembers;
		bool rollFormation;
		size_t maxShipsPerLine;
	} UIFormationInfo;
	typedef struct {
		const char* file;
		const char* icon;
		bool ispersonal;
	} UILogo;
	typedef struct {
		const char* icon;
		Color color;
		uint32_t volume_s;
		uint32_t volume_m;
		uint32_t volume_l;
	} UIMapTradeVolumeParameter;
	typedef struct {
		const char* id;
		const char* name;
	} UIModuleSet;
	typedef struct {
		float x;
		float y;
		float z;
		float yaw;
		float pitch;
		float roll;
	} UIPosRot;
	typedef struct {
		const char* wareid;
		uint32_t amount;
	} UIWareAmount;
	typedef struct {
		bool primary;
		uint32_t idx;
	} UIWeaponGroup;
	typedef struct {
		UniverseID contextid;
		const char* path;
		const char* group;
	} UpgradeGroup2;
	typedef struct {
		UniverseID currentcomponent;
		const char* currentmacro;
		const char* slotsize;
		uint32_t count;
		uint32_t operational;
		uint32_t total;
	} UpgradeGroupInfo;
	typedef struct {
		const char* id;
		const char* icon;
		const char* factoryname;
		const char* factorydesc;
		const char* factorymapicon;
		const char* factoryhudicon;
		uint32_t tier;
	} WareGroupInfo;
	typedef struct {
		UniverseID reserverid;
		const char* ware;
		uint32_t amount;
		bool isbuyreservation;
		double eta;
		TradeID tradedealid;
		MissionID missionid;
		bool isvirtual;
		bool issupply;
	} WareReservationInfo2;
	typedef struct {
		const char* ware;
		int32_t current;
		int32_t max;
	} WareYield;
	typedef struct {
		const char* id;
		const char* name;
		bool active;
	} WeaponSystemInfo;
	typedef struct {
		uint32_t current;
		uint32_t capacity;
		uint32_t optimal;
		uint32_t available;
		uint32_t maxavailable;
		double timeuntilnextupdate;
	} WorkForceInfo;
	typedef struct {
		const char* wareid;
		int32_t amount;
	} YieldInfo;

	typedef struct {
		UIPosRot offset;
		float cameradistance;
	} HoloMapState;
	typedef struct {
		UniverseID target;
		UIWareAmount* wares;
		uint32_t numwares;
	} MissionWareDeliveryInfo;
	typedef struct {
		size_t idx;
		const char* macroid;
		UniverseID componentid;
		UIPosRot offset;
		const char* connectionid;
		size_t predecessoridx;
		const char* predecessorconnectionid;
		bool isfixed;
	} UIConstructionPlanEntry;
	typedef struct {
		const char* objectiveText;
		float timeout;
		const char* progressname;
		uint32_t curProgress;
		uint32_t maxProgress;
		size_t numTargets;
	} MissionObjective2;
	bool AbortBoardingOperation(UniverseID defensibletargetid, const char* boarderfactionid);
	void AbortMission(MissionID missionid);
	bool AddAttackerToBoardingOperation(UniverseID defensibletargetid, UniverseID defensibleboarderid, const char* boarderfactionid, const char* actionid, uint32_t* marinetieramounts, int32_t* marinetierskilllevels, uint32_t nummarinetiers);
	UniverseID AddHoloMap(const char* texturename, float x0, float x1, float y0, float y1, float aspectx, float aspecty);
	void AddPlayerMoney(int64_t money);
	void AddResearch(const char* wareid);
	void AddSimilarMapComponentsToSelection(UniverseID holomapid, UniverseID componentid);
	bool AdjustOrder(UniverseID controllableid, size_t idx, size_t newidx, bool enabled, bool forcestates, bool checkonly);
	bool AreVenturesCompatible(void);
	bool AreVenturesEnabled(void);
	const char* AssignHiredActor(GenericActor actor, UniverseID targetcontrollableid, const char* postid, const char* roleid, bool checkonly);
	bool GetAskToSignalForControllable(const char* signalid, UniverseID controllableid);
	bool GetAskToSignalForFaction(const char* signalid, const char* factionid);
	uint32_t GetAttackersOfBoardingOperation(UniverseID* result, uint32_t resultlen, UniverseID defensibletargetid, const char* boarderfactionid);
	bool CanContainerMineTransport(UniverseID containerid, const char* transportname);
	bool CanContainerTransport(UniverseID containerid, const char* transportname);
	bool CanControllableHaveAnyTrainees(UniverseID controllableid);
	bool CanControllableHaveControlEntity(UniverseID controllableid, const char* postid);
	bool CanPlayerCommTarget(UniverseID componentid);
	const char* CanTeleportPlayerTo(UniverseID controllableid, bool allowcontrolling, bool force);
	void ChangeMapBuildPlot(UniverseID holomapid, float x, float y, float z);
	void CheatDockingTraffic(void);
	void CheatLiveStreamViewChannels(void);
	void ClearSelectedMapComponents(UniverseID holomapid);
	void ClearMapBuildPlot(UniverseID holomapid);
	void ClearMapObjectFilter(UniverseID holomapid);
	void ClearMapOrderParamObjectFilter(UniverseID holomapid);
	void ClearMapTradeFilterByMinTotalVolume(UniverseID holomapid);
	void ClearMapTradeFilterByPlayerOffer(UniverseID holomapid, bool buysellswitch);
	void ClearMapTradeFilterByWare(UniverseID holomapid);
	void ClearMapTradeFilterByWillingToTradeWithPlayer(UniverseID holomapid);
	const char* ConvertInputString(const char* text, const char* defaultvalue);
	uint64_t ConvertStringTo64Bit(const char* idstring);
	bool CreateBoardingOperation(UniverseID defensibletargetid, const char* boarderfactionid, uint32_t approachthreshold, uint32_t insertionthreshold);
	uint32_t CreateDeployToStationOrder(UniverseID controllableid);
	UniverseID CreateNPCFromPerson(NPCSeed person, UniverseID controllableid);
	uint32_t CreateOrder(UniverseID controllableid, const char* orderid, bool default);
	uint32_t CreateOrder3(UniverseID controllableid, const char* orderid, bool defaultorder, bool isoverride, bool istemp);
	bool DropCargo(UniverseID containerid, const char* wareid, uint32_t amount);
	void EnableAllCheats(void);
	bool EnableOrder(UniverseID controllableid, size_t idx);
	bool EnablePlannedDefaultOrder(UniverseID controllableid, bool checkonly);
	void EndGuidance(void);
	bool ExtendBuildPlot(UniverseID stationid, Coord3D poschange, Coord3D negchange, bool allowreduction);
	bool FilterComponentByText(UniverseID componentid, uint32_t numtexts, const char** textarray, bool includecontainedobjects);
	bool FilterComponentForDefaultOrderParamObjectMode(UniverseID componentid, UniverseID ordercontrollableid, bool planned, size_t paramidx);
	bool FilterComponentForMapMode(UniverseID componentid, const char** classes, uint32_t numclasses, int32_t playerowned, bool allowentitydeliverymissionobject);
	bool FilterComponentForOrderParamObjectMode(UniverseID componentid, UniverseID ordercontrollableid, size_t orderidx, size_t paramidx);
	uint64_t GetActiveMissionID();
	uint32_t GetAllBoardingBehaviours(BoardingBehaviour* result, uint32_t resultlen);
	uint32_t GetAllBoardingPhases(BoardingPhase* result, uint32_t resultlen);
	uint32_t GetAllControlPosts(ControlPostInfo* result, uint32_t resultlen);
	uint32_t GetAllCountermeasures(AmmoData* result, uint32_t resultlen, UniverseID defensibleid);
	uint32_t GetAllInventoryBombs(AmmoData* result, uint32_t resultlen, UniverseID entityid);
	uint32_t GetAllLaserTowers(AmmoData* result, uint32_t resultlen, UniverseID defensibleid);
	uint32_t GetAllMines(AmmoData* result, uint32_t resultlen, UniverseID defensibleid);
	uint32_t GetAllMissiles(AmmoData* result, uint32_t resultlen, UniverseID defensibleid);
	uint32_t GetAllNavBeacons(AmmoData* result, uint32_t resultlen, UniverseID defensibleid);
	uint32_t GetAllRaces(RaceInfo* result, uint32_t resultlen);
	uint32_t GetAllResourceProbes(AmmoData* result, uint32_t resultlen, UniverseID defensibleid);
	uint32_t GetAllSatellites(AmmoData* result, uint32_t resultlen, UniverseID defensibleid);
	uint32_t GetAllModuleSets(UIModuleSet* result, uint32_t resultlen);
	uint32_t GetAllowedWeaponSystems(WeaponSystemInfo* result, uint32_t resultlen, UniverseID defensibleid, size_t orderidx, bool usedefault);
	uint32_t GetAllResponsesToSignal(ResponseInfo* result, uint32_t resultlen, const char* signalid);
	uint32_t GetAllSignals(SignalInfo* result, uint32_t resultlen);
	uint32_t GetAllWareGroups(WareGroupInfo* result, uint32_t resultlen);
	const char* GetBoardingActionOfAttacker(UniverseID defensibletargetid, UniverseID defensibleboarderid, const char* boarderfactionid);
	uint32_t GetBoardingCasualtiesOfTier(int32_t marinetierskilllevel, UniverseID defensibletargetid, const char* boarderfactionid);
	bool GetBoardingMarineTierAmountsFromAttacker(uint32_t* resultmarinetieramounts, int32_t* inputmarinetierskilllevels, uint32_t inputnummarinetiers, UniverseID defensibletargetid, UniverseID defensibleboarderid, const char* boarderfactionid);
	BoardingRiskThresholds GetBoardingRiskThresholds(UniverseID defensibletargetid, const char* boarderfactionid);
	uint32_t GetBoardingStrengthFromOperation(UniverseID defensibletargetid, const char* boarderfactionid);
	uint32_t GetBoardingStrengthOfControllableTierAmounts(UniverseID controllableid, uint32_t* marinetieramounts, int32_t* marinetierskilllevels, uint32_t nummarinetiers);
	int64_t GetBuilderHiringFee(void);
	UniverseID GetBuildMapStationLocation2(UniverseID holomapid, UIPosRot* location);
	double GetBuildProcessorEstimatedTimeLeft(UniverseID buildprocessorid);
	Coord3D GetBuildPlotCenterOffset(UniverseID stationid);
	int64_t GetBuildPlotPayment(UniverseID stationid, bool* positionchanged);
	int64_t GetBuildPlotPrice(UniverseID sectorid, UIPosRot location, float x, float y, float z, const char* factionid);
	Coord3D GetBuildPlotSize(UniverseID stationid);
	double GetBuildTaskDuration(UniverseID containerid, BuildTaskID id);
	uint32_t GetBuildTasks(BuildTaskInfo* result, uint32_t resultlen, UniverseID containerid, UniverseID buildmoduleid, bool isinprogress, bool includeupgrade);
	uint32_t GetCargoTransportTypes(StorageInfo* result, uint32_t resultlen, UniverseID containerid, bool merge, bool aftertradeorders);
	Coord2D GetCenteredMousePos(void);
	UniverseID GetCommonContext(UniverseID componentid, UniverseID othercomponentid, bool includeself, bool includeother, UniverseID limitid, bool includelimit);
	const char* GetComponentClass(UniverseID componentid);
	const char* GetComponentName(UniverseID componentid);
	int GetConfigSetting(const char*const setting);
	const char* GetContainerBuildMethod(UniverseID containerid);
	uint32_t GetContainerCriticalWares(const char** result, uint32_t resultlen, UniverseID containerid);
	TradeRuleID GetContainerTradeRuleID(UniverseID containerid, const char* ruletype, const char* wareid);
	uint32_t GetContainerWareReservations2(WareReservationInfo2* result, uint32_t resultlen, UniverseID containerid, bool includevirtual, bool includemission, bool includesupply);
	UniverseID GetContextByClass(UniverseID componentid, const char* classname, bool includeself);
	UniverseID GetContextByRealClass(UniverseID componentid, const char* classname, bool includeself);
	BlacklistID GetControllableBlacklistID(UniverseID controllableid, const char* listtype, const char* defaultgroup);
	FightRuleID GetControllableFightRuleID(UniverseID controllableid, const char* listtype);
	const char* GetCurrentAmmoOfWeapon(UniverseID weaponid);
	const char* GetCurrentBoardingPhase(UniverseID defensibletargetid, const char* boarderfactionid);
	float GetCurrentBuildProgress(UniverseID containerid);
	const char* GetCurrentDroneMode(UniverseID defensibleid, const char* dronetype);
	UILogo GetCurrentFleetLogo(UniverseID controllableid);
	uint32_t GetCurrentMissionOffers(uint64_t* result, uint32_t resultlen, bool showninbbs);
	UILogo GetCurrentPlayerLogo(void);
	int64_t GetCurrentUTCDataTime(void);
	bool GetDefaultOrder(Order* result, UniverseID controllableid);
	bool GetDefaultOrderFailure(OrderFailure* result, UniverseID controllableid);
	const char* GetDefaultResponseToSignalForControllable(const char* signalid, UniverseID controllableid);
	const char* GetDefaultResponseToSignalForFaction2(const char* signalid, const char* factionid, const char* purposeid);
	uint32_t GetDefensibleActiveWeaponGroup(UniverseID defensibleid, bool primary);
	uint32_t GetDefensibleDPS(DPSData* result, UniverseID defensibleid, bool primary, bool secondary, bool lasers, bool missiles, bool turrets, bool includeheat, bool includeinactive);
	uint32_t GetDefensibleDeployableCapacity(UniverseID defensibleid);
	float GetDefensibleWeaponFireRange(UniverseID defensibleid, bool primary, bool secondary, bool lasers, bool missiles, bool turrets, bool includeinactive);
	float GetDefensibleLoadoutLevel(UniverseID defensibleid);
	uint32_t GetDiscoveredSectorResources(WareYield* result, uint32_t resultlen, UniverseID sectorid);
	const char* GetDisplayedModifierKey(const char* uimodifier);
	uint32_t GetDockedShips(UniverseID* result, uint32_t resultlen, UniverseID dockingbayorcontainerid, const char* factionid);
	uint32_t GetDroneModes(DroneModeInfo* result, uint32_t resultlen, UniverseID defensibleid, const char* dronetype);
	int32_t GetEntityCombinedSkill(UniverseID entityid, const char* role, const char* postid);
	FactionDetails GetFactionDetails(const char* factionid);
	const char* GetFleetName(UniverseID controllableid);
	uint32_t GetFormationShapes(UIFormationInfo* result, uint32_t resultlen);
	uint32_t GetFreeCountermeasureStorageAfterTradeOrders(UniverseID defensibleid);
	uint32_t GetFreeDeployableStorageAfterTradeOrders(UniverseID defensibleid);
	uint32_t GetFreeMissileStorageAfterTradeOrders(UniverseID defensibleid);
	uint32_t GetFreePeopleCapacity(UniverseID controllableid);
	uint32_t GetIllegalToFactions(const char** result, uint32_t resultlen, const char* wareid);
	UniverseID GetInstantiatedPerson(NPCSeed person, UniverseID controllableid);
	uint32_t GetMapComponentMissions(MissionID* result, uint32_t resultlen, UniverseID holomapid, UniverseID componentid);
	UniverseID GetMapFocusComponent(UniverseID holomapid);
	UniverseID GetMapPositionOnEcliptic2(UniverseID holomapid, UIPosRot* position, bool adaptiveecliptic, UniverseID eclipticsectorid, UIPosRot eclipticoffset);
	uint32_t GetMapRenderedComponents(UniverseID* result, uint32_t resultlen, UniverseID holomapid);
	uint32_t GetMapSelectedComponents(UniverseID* result, uint32_t resultlen, UniverseID holomapid);
	void GetMapState(UniverseID holomapid, HoloMapState* state);
	UIMapTradeVolumeParameter GetMapTradeVolumeParameter(void);
	uint32_t GetMaxProductionStorage(UIWareAmount* result, uint32_t resultlen, UniverseID containerid);
	uint32_t GetMineablesAtSectorPos(YieldInfo* result, uint32_t resultlen, UniverseID sectorid, Coord3D position);
	Coord3D GetMinimumBuildPlotCenterOffset(UniverseID stationid);
	Coord3D GetMinimumBuildPlotSize(UniverseID stationid);
	MissionBriefingIconInfo GetMissionBriefingIcon(MissionID missionid);
	void GetMissionDeliveryWares(MissionWareDeliveryInfo* result, MissionID missionid);
	MissionGroupDetails GetMissionGroupDetails(MissionID missionid);
	const char* GetMissionHelpOverlayID(MissionID missionid);
	MissionObjective2 GetMissionIDObjective2(uint64_t missionid);
	MissionDetails GetMissionIDDetails(uint64_t missionid);
	MissionObjectiveStep3 GetMissionObjectiveStep3(uint64_t missionid, size_t objectiveIndex);
	OnlineMissionInfo GetMissionOnlineInfo(MissionID missionid);
	uint32_t GetMissionThreadSubMissions(MissionID* result, uint32_t resultlen, MissionID missionid);
	uint32_t GetNumAllBoardingBehaviours(void);
	uint32_t GetNumAllBoardingPhases(void);
	uint32_t GetNumAllControlPosts(void);
	uint32_t GetNumAllCountermeasures(UniverseID defensibleid);
	uint32_t GetNumAllInventoryBombs(UniverseID entityid);
	uint32_t GetNumAllLaserTowers(UniverseID defensibleid);
	uint32_t GetNumAllMines(UniverseID defensibleid);
	uint32_t GetNumAllMissiles(UniverseID defensibleid);
	uint32_t GetNumAllNavBeacons(UniverseID defensibleid);
	uint32_t GetNumAllResourceProbes(UniverseID defensibleid);
	uint32_t GetNumAllSatellites(UniverseID defensibleid);
	uint32_t GetNumAllModuleSets();
	uint32_t GetNumAllowedWeaponSystems(void);
	uint32_t GetNumAllRaces(void);
	uint32_t GetNumAllResponsesToSignal(const char* signalid);
	uint32_t GetNumAllRoles(void);
	uint32_t GetNumAllSignals(void);
	uint32_t GetNumAllWareGroups(void);
	uint32_t GetNumAttackersOfBoardingOperation(UniverseID defensibletargetid, const char* boarderfactionid);
	uint32_t GetNumBoardingMarinesFromOperation(UniverseID defensibletargetid, const char* boarderfactionid);
	uint32_t GetNumBuildTasks(UniverseID containerid, UniverseID buildmoduleid, bool isinprogress, bool includeupgrade);
	uint32_t GetNumCargoTransportTypes(UniverseID containerid, bool merge);
	uint32_t GetNumContainerCriticalWares(UniverseID containerid);
	uint32_t GetNumContainerWareReservations2(UniverseID containerid, bool includevirtual, bool includemission, bool includesupply);
	uint32_t GetNumCurrentMissionOffers(bool showninbbs);
	uint32_t GetNumDiscoveredSectorResources(UniverseID sectorid);
	uint32_t GetNumDockedShips(UniverseID dockingbayorcontainerid, const char* factionid);
	uint32_t GetNumDroneModes(UniverseID defensibleid, const char* dronetype);
	uint32_t GetNumFormationShapes(void);
	uint32_t GetNumIllegalToFactions(const char* wareid);
	uint32_t GetNumMapComponentMissions(UniverseID holomapid, UniverseID componentid);
	uint32_t GetNumMapRenderedComponents(UniverseID holomapid);
	uint32_t GetNumMapSelectedComponents(UniverseID holomapid);
	uint32_t GetNumMaxProductionStorage(UniverseID containerid);
	uint32_t GetNumMineablesAtSectorPos(UniverseID sectorid, Coord3D position);
	uint32_t GetNumMissionDeliveryWares(MissionID missionid);
	uint32_t GetNumMissionThreadSubMissions(MissionID missionid);
	uint32_t GetNumObjectsWithSyncPoint(uint32_t syncid, bool onlyreached);
	uint32_t GetNumOrderDefinitions(void);
	uint32_t GetNumOrderFailures(UniverseID controllableid, bool includelooporders);
	uint32_t GetNumOrderLocationData(UniverseID controllableid, size_t orderidx, bool usedefault);
	uint32_t GetNumOrders(UniverseID controllableid);
	uint32_t GetNumPeopleAfterOrders(UniverseID controllableid, int32_t numorders);
	uint32_t GetNumPersonSuitableControlPosts(UniverseID controllableid, UniverseID personcontrollableid, NPCSeed person, bool free);
	size_t GetNumPlannedStationModules(UniverseID defensibleid, bool includeall);
	uint32_t GetNumPlayerBuildMethods(void);
	uint32_t GetNumPlayerLogos(bool includestandard, bool includecustom);
	uint32_t GetNumPlayerShipBuildTasks(bool isinprogress, bool includeupgrade);
	uint32_t GetNumRequestedMissionNPCs(UniverseID containerid);
	uint32_t GetNumSkills(void);
	uint32_t GetNumShieldGroups(UniverseID defensibleid);
	uint32_t GetNumSoftwareSlots(UniverseID controllableid, const char* macroname);
	uint32_t GetNumStationModules(UniverseID stationid, bool includeconstructions, bool includewrecks);
	uint32_t GetNumStoredUnits(UniverseID defensibleid, const char* cat, bool virtualammo);
	uint32_t GetNumSubordinatesOfGroup(UniverseID commanderid, int group);
	uint32_t GetNumSuitableControlPosts(UniverseID controllableid, UniverseID entityid, bool free);
	uint32_t GetNumTiersOfRole(const char* role);
	size_t GetNumTradeComputerOrders(UniverseID controllableid);
	uint32_t GetNumUpgradeGroups(UniverseID destructibleid, const char* macroname);
	size_t GetNumUpgradeSlots(UniverseID destructibleid, const char* macroname, const char* upgradetypename);
	size_t GetNumVirtualUpgradeSlots(UniverseID objectid, const char* macroname, const char* upgradetypename);
	uint32_t GetNumWareBlueprintOwners(const char* wareid);
	uint32_t GetNumWares(const char* tags, bool research, const char* licenceownerid, const char* exclusiontags);
	uint32_t GetNumWeaponGroupsByWeapon(UniverseID defensibleid, UniverseID weaponid);
	const char* GetObjectIDCode(UniverseID objectid);
	UIPosRot GetObjectPositionInSector(UniverseID objectid);
	bool GetOrderDefinition(OrderDefinition* result, const char* orderdef);
	uint32_t GetOrderDefinitions(OrderDefinition* result, uint32_t resultlen);
	uint32_t GetOrderFailures(OrderFailure* result, uint32_t resultlen, UniverseID controllableid, bool includelooporders);
	AIOrderID GetOrderID(UniverseID controllableid, size_t orderidx);
	uint32_t GetOrderLocationData(UniverseID* result, uint32_t resultlen, UniverseID controllableid, size_t orderidx, bool usedefault);
	uint32_t GetOrderLoopSkillLimit();
	size_t GetOrderQueueCurrentIdx(UniverseID controllableid);
	size_t GetOrderQueueFirstLoopIdx(UniverseID controllableid, bool* isvalid);
	uint32_t GetOrders(Order* result, uint32_t resultlen, UniverseID controllableid);
	uint32_t GetOrders2(Order2* result, uint32_t resultlen, UniverseID controllableid);
	FactionDetails GetOwnerDetails(UniverseID componentid);
	Coord3D GetPaidBuildPlotCenterOffset(UniverseID stationid);
	Coord3D GetPaidBuildPlotSize(UniverseID stationid);
	UniverseID GetParentComponent(UniverseID componentid);
	uint32_t GetPeople2(PeopleInfo* result, uint32_t resultlen, UniverseID controllableid, bool includearriving);
	uint32_t GetPeopleAfterOrders(NPCInfo* result, uint32_t resultlen, UniverseID controllableid, int32_t numorders);
	uint32_t GetPeopleCapacity(UniverseID controllableid, const char* macroname, bool includecrew);
	int32_t GetPersonCombinedSkill(UniverseID controllableid, NPCSeed person, const char* role, const char* postid);
	const char* GetPersonName(NPCSeed person, UniverseID controllableid);
	const char* GetPersonRole(NPCSeed person, UniverseID controllableid);
	uint32_t GetPersonSkills3(SkillInfo* result, uint32_t resultlen, NPCSeed person, UniverseID controllableid);
	uint32_t GetPersonSkillsForAssignment(Skill2* result, NPCSeed person, UniverseID controllableid, const char* role, const char* postid);
	uint32_t GetPersonSuitableControlPosts(ControlPostInfo* result, uint32_t resultlen, UniverseID controllableid, UniverseID personcontrollableid, NPCSeed person, bool free);
	int32_t GetPersonTier(NPCSeed npc, const char* role, UniverseID controllableid);
	UniverseID GetPickedMapComponent(UniverseID holomapid);
	SubordinateGroup GetPickedMapInterSectorDefence(UniverseID holomapid);
	MissionID GetPickedMapMission(UniverseID holomapid);
	UniverseID GetPickedMapMissionOffer(UniverseID holomapid);
	UniverseID GetPickedMapOrder(UniverseID holomapid, Order* result, bool* intermediate);
	uint32_t GetPickedMapSyncPoint(UniverseID holomapid);
	UniverseID GetPickedMapSyncPointOwningOrder(UniverseID holomapid, Order* result);
	TradeID GetPickedMapTradeOffer(UniverseID holomapid);
	MultiverseMapPickInfo GetPickedMultiverseMapPlayer(UniverseID holomapid);
	bool GetPlannedDefaultOrder(Order* result, UniverseID controllableid);
	size_t GetPlannedStationModules(UIConstructionPlanEntry* result, uint32_t resultlen, UniverseID defensibleid, bool includeall);
	const char* GetPlayerBuildMethod(void);
	uint32_t GetPlayerBuildMethods(ProductionMethodInfo* result, uint32_t resultlen);
	UniverseID GetPlayerComputerID(void);
	UniverseID GetPlayerContainerID(void);
	UniverseID GetPlayerControlledShipID(void);
	float GetPlayerGlobalLoadoutLevel(void);
	UniverseID GetPlayerID(void);
	uint32_t GetPlayerLogos(UILogo* result, uint32_t resultlen, bool includestandard, bool includecustom);
	UniverseID GetPlayerObjectID(void);
	UniverseID GetPlayerOccupiedShipID(void);
	uint32_t GetPlayerShipBuildTasks(BuildTaskInfo* result, uint32_t resultlen, bool isinprogress, bool includeupgrade);
	UniverseID GetPlayerShipID(void);
	bool GetPlayerGlobalTradeLoopCargoReservationSetting(void);
	UIPosRot GetPlayerTargetOffset(void);
	const char* GetRealComponentClass(UniverseID componentid);
	uint32_t GetRequestedMissionNPCs(MissionNPCInfo* result, uint32_t resultlen, UniverseID containerid);
	uint32_t GetRoleTierNPCs(NPCSeed* result, uint32_t resultlen, UniverseID controllableid, const char* role, int32_t skilllevel);
	uint32_t GetRoleTiers(RoleTierData* result, uint32_t resultlen, UniverseID controllableid, const char* role);
	uint32_t GetRoleTiers2(RoleTierData* result, uint32_t resultlen, UniverseID controllableid, const char* role, bool includearriving);
	UniverseID GetSectorControlStation(UniverseID sectorid);
	uint64_t GetSectorPopulation(UniverseID sectorid);
	uint32_t GetShieldGroups(ShieldGroup* result, uint32_t resultlen, UniverseID defensibleid);
	int32_t GetShipCombinedSkill(UniverseID shipid);
	bool GetShipTradeLoopCargoReservationSetting(UniverseID shipid);
	SofttargetDetails2 GetSofttarget2(void);
	uint32_t GetSoftwareSlots(SoftwareSlot* result, uint32_t resultlen, UniverseID controllableid, const char* macroname);
	uint32_t GetStationModules(UniverseID* result, uint32_t resultlen, UniverseID stationid, bool includeconstructions, bool includewrecks);
	const char* GetSubordinateGroupAssignment(UniverseID controllableid, int group);
	UIPosRot GetSubordinateGroupProtectedPosition(UniverseID controllableid, int group);
	UniverseID GetSubordinateGroupProtectedSector(UniverseID controllableid, int group);
	uint32_t GetSubordinatesOfGroup(UniverseID* result, uint32_t resultlen, UniverseID commanderid, int group);
	uint32_t GetSuitableControlPosts(ControlPostInfo* result, uint32_t resultlen, UniverseID controllableid, UniverseID entityid, bool free);
	bool GetSyncPointAutoRelease(uint32_t syncid, bool checkall);
	bool GetSyncPointAutoReleaseFromOrder(UniverseID controllableid, size_t orderidx, bool checkall);
	bool GetSyncPointInfo2(UniverseID controllableid, size_t orderidx, SyncPointInfo2* result);
	float GetTextHeight(const char*const text, const char*const fontname, const float fontsize, const float wordwrapwidth);
	uint32_t GetTiersOfRole(RoleTierData* result, uint32_t resultlen, const char* role);
	UniverseID GetTopLevelContainer(UniverseID componentid);
	int64_t GetTradeWareBudget(UniverseID containerid);
	const char* GetTurretGroupMode2(UniverseID defensibleid, UniverseID contextid, const char* path, const char* group);
	UpgradeGroupInfo GetUpgradeGroupInfo2(UniverseID destructibleid, const char* macroname, UniverseID contextid, const char* path, const char* group, const char* upgradetypename);
	uint32_t GetUpgradeGroups2(UpgradeGroup2* result, uint32_t resultlen, UniverseID destructibleid, const char* macroname);
	UniverseID GetUpgradeSlotCurrentComponent(UniverseID destructibleid, const char* upgradetypename, size_t slot);
	UpgradeGroup GetUpgradeSlotGroup(UniverseID destructibleid, const char* macroname, const char* upgradetypename, size_t slot);
	const char* GetVirtualUpgradeSlotCurrentMacro(UniverseID defensibleid, const char* upgradetypename, size_t slot);
	uint32_t GetWareBlueprintOwners(const char** result, uint32_t resultlen, const char* wareid);
	uint32_t GetWareReservationsForWare(UniverseID containerid, const char* wareid, bool buy);
	uint32_t GetWares(const char** result, uint32_t resultlen, const char* tags, bool research, const char* licenceownerid, const char* exclusiontags);
	uint32_t GetWeaponGroupsByWeapon(UIWeaponGroup* result, uint32_t resultlen, UniverseID defensibleid, UniverseID weaponid);
	const char* GetWeaponMode(UniverseID weaponid);
	WorkForceInfo GetWorkForceInfo(UniverseID containerid, const char* raceid);
	UniverseID GetZoneAt(UniverseID sectorid, UIPosRot* uioffset);
	bool HasAcceptedOnlineMission(void);
	bool HasContainerOwnTradeRule(UniverseID containerid, const char* ruletype, const char* wareid);
	bool HasControllableAnyOrderFailures(UniverseID controllableid);
	bool HasControllableOwnBlacklist(UniverseID controllableid, const char* listtype);
	bool HasControllableOwnFightRule(UniverseID controllableid, const char* listtype);
	bool HasControllableOwnResponse(UniverseID controllableid, const char* signalid);
	bool HasPersonArrived(UniverseID controllableid, NPCSeed person);
	bool HasShipTradeLoopCargoReservationOverride(UniverseID shipid);
	bool HasSubordinateAssignment(UniverseID controllableid, const char* assignment);
	bool IsAmmoMacroCompatible(const char* weaponmacroname, const char* ammomacroname);
	bool IsBuilderBusy(UniverseID shipid);
	bool IsComponentBlacklisted(UniverseID componentid, const char* listtype, const char* defaultgroup, UniverseID controllableid);
	bool IsComponentClass(UniverseID componentid, const char* classname);
	bool IsComponentOperational(UniverseID componentid);
	bool IsComponentWrecked(UniverseID componentid);
	bool IsContainerTradingWithFactionRescricted(UniverseID containerid, const char* factionid);
	bool IsContestedSector(UniverseID sectorid);
	bool IsControlPressed(void);
	bool IsCurrentBuildMapPlotPositionDiscovered(UniverseID sectorid, UIPosRot location, float x, float y, float z);
	bool IsCurrentBuildMapPlotValid(UniverseID holomapid);
	bool IsCurrentOrderCritical(UniverseID controllableid);
	bool IsDefensibleBeingBoardedBy(UniverseID defensibleid, const char* factionid);
	bool IsDroneTypeArmed(UniverseID defensibleid, const char* dronetype);
	bool IsDroneTypeBlocked(UniverseID defensibleid, const char* dronetype);
	bool IsExternalTargetMode();
	bool IsExternalViewActive();
	bool IsExternalViewDisabled();
	bool IsIconValid(const char* iconid);
	bool IsInfoUnlockedForPlayer(UniverseID componentid, const char* infostring);
	bool IsKnownToPlayer(UniverseID componentid);
	bool IsMasterVersion(void);
	bool IsMissionLimitReached(bool includeupkeep, bool includeguidance, bool includeplot);
	bool IsNewGame(void);
	bool IsObjectKnown(const UniverseID componentid);
	bool IsOrderLoopable(const char* orderdefid);
	bool IsOrderSelectableFor(const char* orderdefid, UniverseID controllableid);
	bool IsPerson(NPCSeed person, UniverseID controllableid);
	bool IsPersonTransferScheduled(UniverseID controllableid, NPCSeed person);
	bool IsPlayerCameraTargetViewPossible(UniverseID targetid, bool force);
	bool IsRealComponentClass(UniverseID componentid, const char* classname);
	bool IsShiftPressed(void);
	bool IsShipAtExternalDock(UniverseID shipid);
	bool IsStoryFeatureUnlocked(const char* featureid);
	bool IsTurretGroupArmed(UniverseID defensibleid, UniverseID contextid, const char* path, const char* group);
	bool IsUICoverOverridden(void);
	bool IsUnit(UniverseID controllableid);
	bool IsVentureSeasonSupported(void);
	bool IsWeaponArmed(UniverseID weaponid);
	void LaunchLaserTower(UniverseID defensibleid, const char* lasertowermacroname);
	void LaunchMine(UniverseID defensibleid, const char* minemacroname);
	void LaunchNavBeacon(UniverseID defensibleid, const char* navbeaconmacroname);
	void LaunchResourceProbe(UniverseID defensibleid, const char* resourceprobemacroname);
	void LaunchSatellite(UniverseID defensibleid, const char* satellitemacroname);
	void PayBuildPlotSize(UniverseID stationid, Coord3D plotsize, Coord3D plotcenter);
	UICrewExchangeResult PerformCrewExchange2(UniverseID controllableid, UniverseID partnercontrollableid, NPCSeed* npcs, uint32_t numnpcs, NPCSeed* partnernpcs, uint32_t numpartnernpcs, NPCSeed captainfromcontainer, NPCSeed captainfrompartner, bool exchangecaptains, bool checkonly);
	bool QuickMenuAccess(const char* menu);
	void ReassignPeople(UniverseID controllableid, CrewTransferContainer* reassignedcrew, uint32_t amount);
	void ReleasePersonFromCrewTransfer(UniverseID controllableid, NPCSeed person);
	void ReleaseOrderSyncPoint(uint32_t syncid);
	void ReleaseOrderSyncPointFromOrder(UniverseID controllableid, size_t idx);
	bool RemoveAllOrders(UniverseID controllableid);
	bool RemoveAttackerFromBoardingOperation(UniverseID defensibleboarderid);
	bool RemoveBuildPlot(UniverseID stationid);
	bool RemoveCommander2(UniverseID controllableid);
	void RemoveDefaultOrderFailure(UniverseID controllableid);
	void RemoveHoloMap(void);
	bool RemoveOrder(UniverseID controllableid, size_t idx, bool playercancelled, bool checkonly);
	void RemoveOrderFailure(UniverseID controllableid, uint32_t id);
	void RemoveOrderSyncPointID(UniverseID controllableid, size_t orderidx);
	void RemovePerson(UniverseID controllableid, NPCSeed person);
	void RemovePlannedDefaultOrder(UniverseID controllableid);
	void RemoveShipTradeLoopCargoReservationOverride(UniverseID shipid);
	UniverseID ReserveBuildPlot(UniverseID sectorid, const char* factionid, const char* set, UIPosRot location, float x, float y, float z);
	void ResetOrderLoop(UniverseID controllableid);
	bool ResetResponseToSignalForControllable(const char* signalid, UniverseID controllableid);
	void RevealEncyclopedia(void);
	void RevealMap(void);
	void RevealStations(void);
	bool SetActiveMission(MissionID missionid);
	void SelectSimilarMapComponents(UniverseID holomapid, UniverseID componentid);
	void SellPlayerShip(UniverseID shipid, UniverseID shipyardid);
	void SetAllMissileTurretModes(UniverseID defensibleid, const char* mode);
	void SetAllMissileTurretsArmed(UniverseID defensibleid, bool arm);
	void SetAllNonMissileTurretModes(UniverseID defensibleid, const char* mode);
	void SetAllNonMissileTurretsArmed(UniverseID defensibleid, bool arm);
	void SetAllowedWeaponSystems(UniverseID defensibleid, size_t orderidx, bool usedefault, WeaponSystemInfo* uiweaponsysteminfo, uint32_t numuiweaponsysteminfo);
	void SetAllTurretModes(UniverseID defensibleid, const char* mode);
	void SetAllTurretsArmed(UniverseID defensibleid, bool arm);
	bool SetAmmoOfWeapon(UniverseID weaponid, const char* newammomacro);
	void SetCheckBoxChecked2(const int checkboxid, bool checked, bool update);
	bool SetCommander(UniverseID controllableid, UniverseID commanderid, const char* assignment);
	void SetConfigSetting(const char*const setting, const bool value);
	void SetContainerBuildMethod(UniverseID containerid, const char* buildmethodid);
	void SetContainerTradeRule(UniverseID containerid, TradeRuleID id, const char* ruletype, const char* wareid, bool value);
	void SetControllableBlacklist(UniverseID controllableid, BlacklistID id, const char* listtype, bool value);
	void SetControllableFightRule(UniverseID controllableid, FightRuleID id, const char* listtype, bool value);
	bool SetDefaultResponseToSignalForControllable(const char* newresponse, bool ask, const char* signalid, UniverseID controllableid);
	bool SetDefaultResponseToSignalForFaction2(const char* newresponse, bool ask, const char* signalid, const char* factionid, const char* purposeid);
	void SetDefensibleActiveWeaponGroup(UniverseID defensibleid, bool primary, uint32_t groupidx);
	void SetDefensibleLoadoutLevel(UniverseID defensibleid, float value);
	void SetDroneMode(UniverseID defensibleid, const char* dronetype, const char* mode);
	void SetDroneTypeArmed(UniverseID defensibleid, const char* dronetype, bool arm);
	void SetEditBoxText(const int editboxid, const char* text);
	void SetFleetLogo(UniverseID controllableid, UILogo logo);
	void SetFleetName(UniverseID controllableid, const char* fleetname);
	void SetFocusMapComponent(UniverseID holomapid, UniverseID componentid, bool resetplayerpan);
	void SetFocusMapOrder(UniverseID holomapid, UniverseID controllableid, size_t orderidx, bool resetplayerpan);
	UIFormationInfo SetFormationShape(UniverseID objectid, const char* formationshape);
	bool SetEntityToPost(UniverseID controllableid, UniverseID entityid, const char* postid);
	void SetGuidance(UniverseID componentid, UIPosRot offset);
	void SetMapDefaultOrderParamObjectFilter(UniverseID holomapid, UniverseID ordercontrollableid, bool planned, size_t paramidx);
	void SetMapFactionRelationColorOption(UniverseID holomapid, bool value);
	void SetMapFilterSectors(UniverseID holomapid, uint32_t numsectorids, UniverseID* sectorids);
	void SetMapFilterString(UniverseID holomapid, uint32_t numtexts, const char** textarray);
	void SetMapObjectFilter(UniverseID holomapid, const char** classes, uint32_t numclasses, int32_t playerowned, bool allowentitydeliverymissionobject);
	void SetMapOrderParamObjectFilter(UniverseID holomapid, UniverseID ordercontrollableid, size_t orderidx, size_t paramidx);
	void SetMapPanOffset(UniverseID holomapid, UniverseID offsetcomponentid);
	void SetMapPicking(UniverseID holomapid, bool enable);
	void SetMapRelativeMousePosition(UniverseID holomapid, bool valid, float x, float y);
	void SetMapRenderAllAllyOrderQueues(UniverseID holomapid, bool value);
	void SetMapRenderAllGateConnections(UniverseID holomapid, bool value);
	void SetMapRenderAllOrderQueues(UniverseID holomapid, bool value);
	void SetMapRenderCivilianShips(UniverseID holomapid, bool value);
	void SetMapRenderEclipticLines(UniverseID holomapid, bool value);
	void SetMapRenderMissionGuidance(UniverseID holomapid, MissionID missionid);
	void SetMapRenderMissionOffers(UniverseID holomapid, bool value);
	void SetMapRenderResourceInfo(UniverseID holomapid, bool value);
	void SetMapRenderSatelliteRadarRange(UniverseID holomapid, bool value);
	void SetMapRenderSelectionLines(UniverseID holomapid, bool value);
	void SetMapRenderTradeOffers(UniverseID holomapid, bool value);
	void SetMapRenderWrecks(UniverseID holomapid, bool value);
	void SetMapSelectedFleetCommander(UniverseID holomapid, UniverseID controllableid);
	void SetMapState(UniverseID holomapid, HoloMapState state);
	void SetMapStationInfoBoxMargin(UniverseID holomapid, const char* margin, uint32_t width);
	void SetMapTargetDistance(UniverseID holomapid, float distance);
	void SetMapTopTradesCount(UniverseID holomapid, uint32_t count);
	void SetMapTradeFilterByMaxPrice(UniverseID holomapid, int64_t price);
	void SetMapTradeFilterByMinTotalVolume(UniverseID holomapid, uint32_t minvolume);
	void SetMapTradeFilterByPlayerOffer(UniverseID holomapid, bool buysellswitch, bool enable);
	void SetMapTradeFilterByWare(UniverseID holomapid, const char** wareids, uint32_t numwareids);
	void SetMapTradeFilterByWareTransport(UniverseID holomapid, const char** transporttypes, uint32_t numtransporttypes);
	void SetMapTradeFilterByWillingToTradeWithPlayer(UniverseID holomapid);
	void SetMapAlertFilter(UniverseID holomapid, uint32_t alertlevel);
	bool SetOrderLoop(UniverseID controllableid, size_t orderidx, bool checkonly);
	bool SetOrderSyncPointID(UniverseID controllableid, size_t orderidx, uint32_t syncid, bool checkonly);
	void SetPlayerCameraCockpitView(bool force);
	void SetPlayerCameraTargetView(UniverseID targetid, bool force);
	void SetSelectedMapComponent(UniverseID holomapid, UniverseID componentid);
	void SetSelectedMapComponents(UniverseID holomapid, UniverseID* componentids, uint32_t numcomponentids);
	void SetShipTradeLoopCargoReservationOverride(UniverseID shipid, bool value);
	bool SetSofttarget(UniverseID componentid, const char*const connectionname);
	void SetSubordinateGroupDockAtCommander(UniverseID controllableid, int group, bool value);
	void SetSubordinateGroupProtectedLocation(UniverseID controllableid, int group, UniverseID sectorid, UIPosRot offset);
	void SetSyncPointAutoRelease(uint32_t syncid, bool all, bool any);
	void SetSyncPointAutoReleaseFromOrder(UniverseID controllableid, size_t orderidx, bool all, bool any);
	void SetTrackedMenuFullscreen(const char* menu, bool fullscreen);
	void SetTurretGroupArmed(UniverseID defensibleid, UniverseID contextid, const char* path, const char* group, bool arm);
	void SetTurretGroupMode2(UniverseID defensibleid, UniverseID contextid, const char* path, const char* group, const char* mode);
	void SetUICoverOverride(bool override);
	void SetWeaponArmed(UniverseID weaponid, bool arm);
	void SetWeaponGroup(UniverseID defensibleid, UniverseID weaponid, bool primary, uint32_t groupidx, bool value);
	void SetWeaponMode(UniverseID weaponid, const char* mode);
	bool ShouldSubordinateGroupDockAtCommander(UniverseID controllableid, int group);
	void ShowBuildPlotPlacementMap(UniverseID holomapid, UniverseID sectorid);
	void ShowMultiverseMap(UniverseID holomapid);
	void ShowUniverseMap2(UniverseID holomapid, bool setoffset, bool showzone, bool forcebuildershipicons, UniverseID startsectorid, UIPosRot startpos);
	void SignalObjectWithNPCSeedAndMissionID(UniverseID objecttosignalid, const char* param, MissionID missionid, NPCSeed person, UniverseID controllableid);
	bool StartBoardingOperation(UniverseID defensibletargetid, const char* boarderfactionid);
	void StartPanMap(UniverseID holomapid);
	void StartRotateMap(UniverseID holomapid);
	bool StopPanMap(UniverseID holomapid);
	bool StopRotateMap(UniverseID holomapid);
	void ZoomMap(UniverseID holomapid, float zoomstep);
	void StartMapBoxSelect(UniverseID holomapid, bool selectenemies);
	void StopMapBoxSelect(UniverseID holomapid);
	bool TeleportPlayerTo(UniverseID controllableid, bool allowcontrolling, bool instant, bool force);
	bool ToggleAutoPilot(bool checkonly);
	void TriggerInputFeedback(const char* type, const char* idname, const char* triggerid, const char* contextid);
	bool UpdateAttackerOfBoardingOperation(UniverseID defensibletargetid, UniverseID defensibleboarderid, const char* boarderfactionid, const char* actionid, uint32_t* marinetieramounts, int32_t* marinetierskilllevels, uint32_t nummarinetiers);
	bool UpdateBoardingOperation(UniverseID defensibletargetid, const char* boarderfactionid, uint32_t approachthreshold, uint32_t insertionthreshold);
	void UpdateMapBuildPlot(UniverseID holomapid);
	bool WasSessionOnline(void);
]]

local utf8 = require("utf8")

local menu = {
	name = "MapMenu",
	infoTableMode = "objectlist",
	ventureMode = C.IsVentureSeasonSupported() and "ventureseason" or "venturelogbook",
	displayedFilterLayer = "layer_trade",
	mouseCursorOverrides = { [1] = "default" },
	currentMouseCursor = "default",
	picking = true,
	missionOfferMode = "normal",
	missionMode = "plot",
	expandedMissionGroups = {},
	infoMode = { left = "objectinfo", right = "objectinfo" },
	seasonMode = { left = "currentseason", right = "currentseason" },
	highlightLeftBar = {},
	objectMode = "objectall",
	propertyMode = "propertyall",
	objectSorterType = "name",
	propertySorterType = "name",
	crewSort = "role",
	crewRole = "current",
	showMultiverse = false,
	cachedOrderFailures = {},
}

local config = {
	mainFrameLayer = 6,
	infoFrameLayer2 = 5,
	infoFrameLayer = 4,
	contextFrameLayer = 2,

	complexOrderParams = {
		["trade"] = {
			[1] = { id = "trade_location", name = ReadText(1001, 2943), type = "object", inputparams = { class = "sector" }, value = function (data) return next(data) and data.station and GetComponentData(data.station, "zoneid") or nil end },
			[2] = { id = "trade_partner", name = ReadText(1001, 23), type = "object", inputparams = { class = "container" }, value = function (data) return data.station end },
			[3] = { id = "trade_ware", name = ReadText(1001, 7104), type = "trade_ware", value = function (data) return next(data) and data.ware and {data.isbuyoffer, data.ware} or nil end },
			[4] = { id = "trade_amount", name = ReadText(1001, 6521), type = "trade_amount", value = function (data) return data.ware and {data.desiredamount, data.amount} or nil end },
			data = function (value) return (value and IsValidTrade(value) and menu.isInfoModeValidFor(menu.infoSubmenuObject, "orderqueue")) and GetTradeData(value, ConvertStringTo64Bit(tostring(menu.infoSubmenuObject))) or {} end
		}
	},
	moduletypes = {
		{ type = "moduletypes_production", name = ReadText(1001, 2421) },
		{ type = "moduletypes_build",      name = ReadText(1001, 2439) },
		{ type = "moduletypes_storage",    name = ReadText(1001, 2422) },
		{ type = "moduletypes_habitation", name = ReadText(1001, 2451) },
		{ type = "moduletypes_welfare",    name = ReadText(1001, 9620) },
		{ type = "moduletypes_dock",       name = ReadText(1001, 2452) },
		{ type = "moduletypes_defence",    name = ReadText(1001, 2424) },
		{ type = "moduletypes_processing", name = ReadText(1001, 9621) },
		{ type = "moduletypes_other",      name = ReadText(1001, 2453) },
		{ type = "moduletypes_venture",    name = ReadText(1001, 2454) },
	},
	stateKeys = {
		{"mode"},
		{"modeparam"},
		{"lastactivetable"},
		{"focuscomponent", "UniverseID"},
		{"currentsector", "UniverseID"},
		{"selectedcomponents"},
		{"searchtext"},
		{"infoTableMode"},
		{"ventureMode"},
		{"searchTableMode"},
		{"infoSubmenuObject", "UniverseID"},
		{"showMultiverse", "bool"},
		{"objectMode"},
		{"propertyMode"},
		{"seasonMode"},
	},
	leftBar = {
		{ name = ReadText(1001, 3224),	icon = "mapst_objectlist",			mode = "objectlist",	helpOverlayID = "map_sidebar_objectlist",			helpOverlayText = ReadText(1028, 3201) },
		{ name = ReadText(1001, 1000),	icon = "mapst_propertyowned",		mode = "propertyowned",	helpOverlayID = "map_sidebar_propertyowned",		helpOverlayText = ReadText(1028, 3203) },
		{ spacing = true },
		{ name = ReadText(1001, 3324),	icon = "mapst_mission_offers",		mode = "missionoffer",	helpOverlayID = "map_sidebar_mission_offers",		helpOverlayText = ReadText(1028, 3205) },
		{ name = ReadText(1001, 3323),	icon = "mapst_mission_accepted",	mode = "mission",		helpOverlayID = "map_sidebar_mission_accepted",		helpOverlayText = ReadText(1028, 3207) },
		{ spacing = true },
		{ name = ReadText(1001, 2427),	icon = "mapst_information",			mode = "info",			helpOverlayID = "map_sidebar_information",			helpOverlayText = ReadText(1028, 3209) },
		{ spacing = true },
		{ name = ReadText(1001, 3226),	icon = "mapst_plotmanagement",		mode = "plots",			helpOverlayID = "map_sidebar_plotmanagement",		helpOverlayText = ReadText(1028, 3211) },
		{ spacing = true,																			condition = IsCheatVersion }, -- (cheats only)
		{ name = "Cheats",				icon = "mapst_cheats",				mode = "cheats",		condition = IsCheatVersion }, -- (cheats only)
	},
	leftBarMultiverse = {
		{ name = ReadText(1001, 11288),	icon = "vt_season",					mode = "ventureseason",		helpOverlayID = "multimap_season",				helpOverlayText = ReadText(1028, 3263),		condition = C.IsVentureSeasonSupported },
		{ spacing = true,		condition = C.IsVentureSeasonSupported },
		{ name = ReadText(1001, 11318),	icon = "vt_mission",				mode = "ventureoperation",	helpOverlayID = "multimap_operation",			helpOverlayText = ReadText(1028, 3266),		condition = C.IsVentureSeasonSupported },
		{ name = ReadText(1001, 11319),	icon = "vt_logbook",				mode = "venturelogbook",	helpOverlayID = "multimap_logbook",				helpOverlayText = ReadText(1028, 3267) },
		{ spacing = true, },
		{ name = ReadText(1001, 7720),	icon = "vt_inventory",				mode = "ventureinventory",	helpOverlayID = "multimap_inventory",			helpOverlayText = ReadText(1028, 3269) },
		{ name = ReadText(1001, 11386),	icon = "vt_contactlist",			mode = "venturecontacts",	helpOverlayID = "multimap_contacts",			helpOverlayText = ReadText(1028, 3275) },
	},
	rightBar = {
		{ name = ReadText(1001, 3227),	icon = "mapst_filtersystem",		mode = "filter",		helpOverlayID = "mapst_filter",						helpOverlayText = ReadText(1028, 3212) },
		{ name = ReadText(1001, 9801),	icon = "mapst_legend",				mode = "legend",		helpOverlayID = "mapst_legend",						helpOverlayText = ReadText(1028, 3213) },
		{ spacing = true },
		{ name = ReadText(1001, 2427),	icon = "mapst_information",			mode = "info",			helpOverlayID = "map_sidebar_information2",			helpOverlayText = ReadText(1028, 3209) },
	},
	infoCategories = {
		{ category = "objectinfo",				name = ReadText(1001, 2427),	icon = "mapst_information",			helpOverlayID = "mapst_ao_information",			helpOverlayText = ReadText(1028, 3234) },
		{ category = "objectcrew",				name = ReadText(1001, 80),		icon = "shipbuildst_crew",			helpOverlayID = "mapst_ao_info_crew",			helpOverlayText = ReadText(1028, 3237) },
		{ category = "objectloadout",			name = ReadText(1001, 9413),	icon = "mapst_loadout",				helpOverlayID = "mapst_ao_info_loadout",		helpOverlayText = ReadText(1028, 3238) },
		{ category = "objectlogbook",			name = ReadText(1001, 5700),	icon = "pi_logbook",				helpOverlayID = "mapst_ao_info_logbook",		helpOverlayText = ReadText(1028, 3238) },
		{ empty = true },
		{ category = "orderqueue",				name = ReadText(1001, 8360),	icon = "mapst_ao_orderqueue",		helpOverlayID = "mapst_ao_orderqueue",			helpOverlayText = ReadText(1028, 3235) },
		{ category = "orderqueue_advanced",		name = ReadText(1001, 8361),	icon = "mapst_orderqueue_advanced",	helpOverlayID = "mapst_ao_orderqueue_advanced",	helpOverlayText = ReadText(1028, 3236) },
		{ category = "standingorders",			name = ReadText(1001, 8396),	icon = "mapst_standing_orders",		helpOverlayID = "mapst_ao_standing_orders",		helpOverlayText = ReadText(1028, 3239) },
	},
	objectCategories = {
		{ category = "objectall",				name = ReadText(1001, 8380),	icon = "mapst_objectlist",			helpOverlayID = "mapst_ol_objectlist",			helpOverlayText = ReadText(1028, 3220) },
		{ category = "stations",				name = ReadText(1001, 8379),	icon = "mapst_ol_stations",			helpOverlayID = "mapst_ol_stations",			helpOverlayText = ReadText(1028, 3221) },
		{ category = "ships",					name = ReadText(1001, 6),		icon = "mapst_ol_ships",			helpOverlayID = "mapst_ol_fleets",				helpOverlayText = ReadText(1028, 3222) },
		{ category = "deployables",				name = ReadText(1001, 1332),	icon = "mapst_ol_deployables",		helpOverlayID = "mapst_ol_deployables",			helpOverlayText = ReadText(1028, 3226) },
	},
	propertyCategories = {
		{ category = "propertyall",				name = ReadText(1001, 8380),	icon = "mapst_propertyowned",		helpOverlayID = "mapst_po_propertyowned",		helpOverlayText = ReadText(1028, 3220) },
		{ category = "stations",				name = ReadText(1001, 8379),	icon = "mapst_ol_stations",			helpOverlayID = "mapst_po_stations",			helpOverlayText = ReadText(1028, 3221) },
		{ category = "fleets",					name = ReadText(1001, 8326),	icon = "mapst_ol_fleets",			helpOverlayID = "mapst_po_fleets",				helpOverlayText = ReadText(1028, 3223) },
		{ category = "unassignedships",			name = ReadText(1001, 8327),	icon = "mapst_ol_unassigned",		helpOverlayID = "mapst_po_unassigned",			helpOverlayText = ReadText(1028, 3224) },
		{ category = "inventoryships",			name = ReadText(1001, 8381),	icon = "mapst_ol_inventory",		helpOverlayID = "mapst_po_inventory",			helpOverlayText = ReadText(1028, 3225) },
		{ category = "deployables",				name = ReadText(1001, 1332),	icon = "mapst_ol_deployables",		helpOverlayID = "mapst_po_deployables",			helpOverlayText = ReadText(1028, 3226) },
	},
	seasonCategories = {
		{ category = "currentseason",			name = ReadText(1001, 11322),	icon = "vt_season_current",			helpOverlayID = "mapst_ven_curseason",			helpOverlayText = ReadText(1028, 3270) },
		{ category = "coalition",				name = ReadText(1001, 11323),	icon = "vt_guild",					helpOverlayID = "mapst_ven_coalitions",			helpOverlayText = ReadText(1028, 3271) },
		{ category = "ventureteam",				name = ReadText(1001, 11320),	icon = "vt_team",					helpOverlayID = "multimap_team",				helpOverlayText = ReadText(1028, 3268) },
		{ category = "pastseasons",				name = ReadText(1001, 11324),	icon = "vt_season_previous",		helpOverlayID = "mapst_ven_pastseason",			helpOverlayText = ReadText(1028, 3264) },
	},
	layers = {
		{ name = ReadText(1001, 3252),	shortname = ReadText(1001, 11626),	icon = "mapst_fs_trade",		mode = "layer_trade",		helpOverlayID = "layer_trade",		helpOverlayText = ReadText(1028, 3214),		toggleHelpOverlayID = "toggle_trade" },
		{ name = ReadText(1001, 8329),	shortname = ReadText(1001, 11629),	icon = "mapst_fs_mining",		mode = "layer_mining",		helpOverlayID = "layer_mining",		helpOverlayText = ReadText(1028, 3216),		toggleHelpOverlayID = "toggle_mining" },
		{ name = ReadText(1001, 3254),	shortname = ReadText(1001, 11628),	icon = "mapst_fs_other",		mode = "layer_other",		helpOverlayID = "layer_other",		helpOverlayText = ReadText(1028, 3217),		toggleHelpOverlayID = "toggle_other" },
	},
	layersettings = {
		["layer_trade"] = {
			callback = function (value) return C.SetMapRenderTradeOffers(menu.holomap, value) end,
			[1] = {
				caption = ReadText(1001, 46),
				info = ReadText(1001, 3279),
				overrideText = ReadText(1001, 8378),
				type = "multiselectlist",
				id = "trade_wares",
				callback = function (...) return menu.filterTradeWares(...) end,
				listOptions = function (...) return menu.getFilterTradeWaresOptions(...) end,
				displayOption = function (option) return "\27[maptr_supply] " .. GetWareData(option, "name") end,
				helpOverlayID = "tradefilters_wares",
				helpOverlayText = " ",
				helpOverlayHighlightOnly = true,
				savegame = true,
			},
			[2] = {
				caption = ReadText(1001, 1400),
				type = "checkbox",
				callback = function (...) return menu.filterTradeStorage(...) end,
				helpOverlayID = "tradefilters_storage",
				helpOverlayText = " ",
				helpOverlayHighlightOnly = true,
				savegame = true,
				[1] = {
					id = "trade_storage_container",
					name = ReadText(20205, 100),
					info = ReadText(1001, 3280),
					param = "container",
				},
				[2] = {
					id = "trade_storage_solid",
					name = ReadText(20205, 200),
					info = ReadText(1001, 3281),
					param = "solid",
				},
				[3] = {
					id = "trade_storage_liquid",
					name = ReadText(20205, 300),
					info = ReadText(1001, 3282),
					param = "liquid",
				},
				[4] = {
					id = "trade_storage_condensate",
					name = ReadText(20205, 1100),
					info = ReadText(1001, 11614),
					param = "condensate",
				},
			},
			[3] = {
				caption = ReadText(1001, 2808),
				type = "slidercell",
				callback = function (...) return menu.filterTradePrice(...) end,
				helpOverlayID = "tradefilters_price",
				helpOverlayText = " ",
				helpOverlayHighlightOnly = true,
				[1] = {
					id = "trade_price_maxprice",
					name = ReadText(1001, 3284),
					info = ReadText(1001, 3283),
					param = "maxprice",
					scale = {
						min       = 0,
						max       = 10000,
						step      = 1,
						suffix    = ReadText(1001, 101),
						exceedmax = true
					}
				},
			},
			[4] = {
				caption = ReadText(1001, 8357),
				type = "dropdown",
				callback = function (...) return menu.filterTradeVolume(...) end,
				helpOverlayID = "tradefilters_volume",
				helpOverlayText = " ",
				helpOverlayHighlightOnly = true,
				[1] = {
					id = "trade_volume",
					info = ReadText(1001, 8358),
					listOptions = function (...) return menu.getFilterTradeVolumeOptions(...) end,
					param = "volume"
				},
			},
			[5] = {
				caption = ReadText(1001, 11205),
				type = "dropdown",
				callback = function (...) return menu.filterTradePlayerOffer(...) end,
				helpOverlayID = "tradefilters_playeroffer",
				helpOverlayText = " ",
				helpOverlayHighlightOnly = true,
				[1] = {
					id = "trade_playeroffer_buy",
					info = ReadText(1001, 11209),
					listOptions = function (...) return menu.getFilterTradePlayerOfferOptions(true) end,
					param = "playeroffer_buy"
				},
				[2] = {
					id = "trade_playeroffer_sell",
					info = ReadText(1001, 11210),
					listOptions = function (...) return menu.getFilterTradePlayerOfferOptions(false) end,
					param = "playeroffer_sell"
				},
			},
			[6] = {
				caption = ReadText(1001, 11240),
				type = "checkbox",
				callback = function (...) return menu.filterTradeRelation(...) end,
				helpOverlayID = "tradefilters_relation",
				helpOverlayText = " ",
				helpOverlayHighlightOnly = true,
				[1] = {
					id = "trade_relation_enemy",
					name = ReadText(1001, 11241),
					info = ReadText(1001, 11242),
					param = "enemy",
				},
			},
			[7] = {
				caption = ReadText(1001, 8343),
				type = "slidercell",
				callback = function (...) return menu.filterTradeOffer(...) end,
				helpOverlayID = "tradefilters_number",
				helpOverlayText = " ",
				helpOverlayHighlightOnly = true,
				[1] = {
					id = "trade_offer_number",
					name = ReadText(1001, 8344),
					info = ReadText(1001, 8345),
					param = "number",
					scale = {
						min       = 0,
						minSelect = 1,
						max       = 5,
						step      = 1,
						exceedmax = true,
					}
				},
			},
		},
		["layer_fight"] = {},
		["layer_think"] = {},
		["layer_build"] = {},
		["layer_diplo"] = {},
		["layer_mining"] = {
			callback = function (value) return menu.filterMining(value) end,
			[1] = {
				caption = ReadText(1001, 8330),
				type = "checkbox",
				callback = function (...) return menu.filterMiningResources(...) end,
				helpOverlayID = "miningfilters_display",
				helpOverlayText = " ",
				helpOverlayHighlightOnly = true,
				[1] = {
					id = "mining_resource_display",
					name = ReadText(1001, 8331),
					info = ReadText(1001, 8332),
					param = "display"
				},
			},
		},
		["layer_other"] = {
			callback = function (value) return menu.filterOther(value) end,
			[1] = {
				caption = ReadText(1001, 3285),
				type = "dropdown",
				callback = function (...) return menu.filterThinkAlert(...) end,
				helpOverlayID = "otherfilters_alerts",
				helpOverlayText = " ",
				helpOverlayHighlightOnly = true,
				[1] = {
					info = ReadText(1001, 3286),
					id = "think_alert",
					listOptions = function (...) return menu.getFilterThinkAlertOptions(...) end,
					param = "alert"
				},
			},
			[2] = {
				caption = ReadText(1001, 11204),
				type = "checkbox",
				callback = function (...) return menu.filterThinkDiplomacy(...) end,
				helpOverlayID = "otherfilters_diplomacy",
				helpOverlayText = " ",
				helpOverlayHighlightOnly = true,
				[1] = {
					id = "think_diplomacy_factioncolor",
					name = ReadText(1001, 11203),
					param = "factioncolor",
				},
				[2] = {
					id = "think_diplomacy_highlightvisitor",
					name = ReadText(1001, 11216),
					info = ReadText(1001, 11217),
					param = "highlightvisitors",
				},
			},
			[3] = {
				caption = ReadText(1001, 2664),
				type = "checkbox",
				callback = function (...) return menu.filterOtherMisc(...) end,
				helpOverlayID = "otherfilters_misc",
				helpOverlayText = " ",
				helpOverlayHighlightOnly = true,
				[1] = {
					id = "other_misc_ecliptic",
					name = ReadText(1001, 3297),
					info = ReadText(1001, 3298),
					param = "ecliptic",
				},
				[2] = {
					id = "other_misc_wrecks",
					name = ReadText(1001, 8382),
					info = ReadText(1001, 8383),
					param = "wrecks",
				},
				[3] = {
					id = "other_misc_selection_lines",
					name = ReadText(1001, 11214),
					info = ReadText(1001, 11215),
					param = "selectionlines",
				},
				[4] = {
					id = "other_misc_gate_connections",
					name = ReadText(1001, 11243),
					info = ReadText(1001, 11244),
					param = "gateconnections",
				},
				[5] = {
					id = "other_misc_opacity",
					name = ReadText(1001, 11245),
					info = ReadText(1001, 11246),
					param = "opacity",
				},
				[6] = {
					id = "other_misc_coveroverride",
					name = ReadText(1001, 11604),
					info = ReadText(1001, 11605),
					param = "coveroverride",
					active = Helper.isPlayerCovered,
				},
				[7] = {
					id = "other_misc_rendersatelliteradarrange",
					name = ReadText(1001, 11637),
					info = ReadText(1001, 11638),
					param = "rendersatelliteradarrange",
				},
			},
			[4] = {
				caption = ReadText(1001, 8336),
				type = "checkbox",
				callback = function (...) return menu.filterOtherShip(...) end,
				helpOverlayID = "otherfilters_shipprops",
				helpOverlayText = " ",
				helpOverlayHighlightOnly = true,
				[1] = {
					id = "other_misc_orderqueue",
					name = ReadText(1001, 3287),
					info = ReadText(1001, 8372),
					param = "orderqueue",
				},
				[2] = {
					id = "other_misc_allyorderqueue",
					name = ReadText(1001, 8370),
					info = ReadText(1001, 8371),
					param = "allyorderqueue",
				},
			},
			[5] = {
				caption = ReadText(1001, 8335),
				type = "checkbox",
				callback = function (...) return menu.filterOtherStation(...) end,
				helpOverlayID = "otherfilters_stationprops",
				helpOverlayText = " ",
				helpOverlayHighlightOnly = true,
				[1] = {
					id = "other_misc_missions",
					name = ReadText(1001, 3291),
					info = ReadText(1001, 3292),
					param = "missions",
				},
				[2] = {
					id = "other_misc_civilian",
					name = ReadText(1001, 8333),
					info = ReadText(1001, 8334),
					param = "civilian",
				},
			},
		},
	},
	mapfilterversion = 20,
	mapfiltersaveversion = 1,

	-- custom default row properties, different from Helper defaults
	mapRowHeight = Helper.standardTextHeight,
	mapFontSize = Helper.standardFontSize,
	plotPairedDimension = { posX = "negX", negX = "posX", posY = "negY", negY = "posY", posZ = "negZ", negZ = "posZ" },
	maxPlotSize = 20,
	cameraResetThresholdAngle = 2, -- in degrees

	contextBorder = 5,

	classOrder = {
		["station"]		= 1,
		["ship_xl"]		= 2,
		["ship_l"]		= 3,
		["ship_m"]		= 4,
		["ship_s"]		= 5,
		["ship_xs"]		= 6,
		["spacesuit"]	= 7,
	},
	purposeOrder = {
		["fight"]		= 1,
		["auxiliary"]	= 2,
		["build"]		= 3,
		["mine"]		= 4,
		["trade"]		= 5,
	},

	missionMainTypeOrder = {
		["plot"] = 1,
		["tutorial"] = 2,
		["generic"] = 3,
		["upkeep"] = 4,
		["guidance"] = 5,
	},

	missionOfferCategories = {
		{ category = "plot",		name = ReadText(1001, 3340),	icon = "mapst_mission_main",		helpOverlayID = "mapst_mission_offer_plot",			helpOverlayText = ReadText(1028, 3240) },
		{ category = "guild",		name = ReadText(1001, 3331),	icon = "mapst_mission_guild",		helpOverlayID = "mapst_mission_offer_guild",		helpOverlayText = ReadText(1028, 3227) },
		{ category = "coalition",	name = ReadText(1001, 8801),	icon = "mapst_mission_other",		helpOverlayID = "mapst_mission_offer_coalition",	helpOverlayText = "",					showtab = false },
		{ category = "other",		name = ReadText(1001, 3332),	icon = "mapst_mission_other",		helpOverlayID = "mapst_mission_offer_other",		helpOverlayText = ReadText(1028, 3228) },
	},

	missionOfferTabs = {
		{ category = "normal",		name = ReadText(1001, 3324),	icon = "mapst_mission_offers",		helpOverlayID = "mapst_mission_offer_tab_normal",		helpOverlayText = ReadText(1028, 3273) },
		{ category = "operation",	name = ReadText(1001, 11318),	icon = "vt_season",					helpOverlayID = "mapst_mission_offer_tab_operation",	helpOverlayText = ReadText(1028, 3274) },
	},

	missionCategories = {
		{ category = "plot",		name = ReadText(1001, 3341),	icon = "mapst_mission_main",		helpOverlayID = "mapst_mission_active_main",		helpOverlayText = ReadText(1028, 3241) },
		{ category = "guild",		name = ReadText(1001, 3333),	icon = "mapst_mission_guild",		helpOverlayID = "mapst_mission_active_guild",		helpOverlayText = ReadText(1028, 3229),	showtab = false },
		{ category = "coalition",	name = ReadText(1001, 8801),	icon = "mapst_mission_other",		helpOverlayID = "mapst_mission_active_coalition",	helpOverlayText = "",					showtab = false },
		{ category = "other",		name = ReadText(1001, 3334),	icon = "mapst_mission_other",		helpOverlayID = "mapst_mission_active_other",		helpOverlayText = ReadText(1028, 3230),	showtab = false },
		{ category = "upkeep",		name = ReadText(1001, 3305),	icon = "mapst_mission_upkeep",		helpOverlayID = "mapst_mission_active_upkeep",		helpOverlayText = ReadText(1028, 3231) },
		{ category = "guidance",	name = ReadText(1001, 3329),	icon = "mapst_mission_guidance",	helpOverlayID = "mapst_mission_active_guidance",	helpOverlayText = ReadText(1028, 3232) },
	},

	missionContextWidth = 400,
	missionContextIconWidthFactor = 0.4,

	autopilotmarker = ">> ",
	softtargetmarker_l = "> ",

	tradeContextMenuWidth = math.min(Helper.scaleX(900), 0.5 * Helper.viewWidth + Helper.scrollbarWidth),
	tradeContextMenuInfoBorder = 15,

	legend = {
		-- hexes
		{ icon = "maplegend_hexagon_fog_01",		text = ReadText(10002, 606),	width = Helper.sidebarWidth,	height = Helper.sidebarWidth },														-- Unknown location
		{ icon = "maplegend_hexagon_01",			text = ReadText(1001, 9806),	width = Helper.sidebarWidth,	height = Helper.sidebarWidth,	color = Color["resource_mineral"] },				-- Mineral Region
		{ icon = "maplegend_hexagon_01",			text = ReadText(1001, 9807),	width = Helper.sidebarWidth,	height = Helper.sidebarWidth,	color = Color["resource_liquid"]  },				-- Gas Region
		{ icon = "maplegend_hexagon_01",			text = ReadText(1001, 9812),	width = Helper.sidebarWidth,	height = Helper.sidebarWidth,	color = Color["resource_mineral_liquid"]  },		-- Mineral/Gas Region
		-- highways, gates, etc
		{ icon = "solid",							text = ReadText(1001, 9809),	width = Helper.sidebarWidth,	height = Helper.standardTextHeight / 2,	minRowHeight = Helper.sidebarWidth / 2 },	-- Jump Gate Connection
		{ icon = "maplegend_hw_01",					text = ReadText(20001, 601),	width = Helper.sidebarWidth,	height = Helper.sidebarWidth / 2,	color = "superhighwaycolor" },					-- Superhighway
		{ icon = "maplegend_hw_01",					text = ReadText(20001, 501),	width = Helper.sidebarWidth,	height = Helper.sidebarWidth / 2,	color = "highwaycolor" },						-- Local Highway
		{ icon = "mapob_jumpgate",					text = ReadText(20001, 701),	color = "gatecolor" },			-- Jump Gate
		{ icon = "mapob_transorbital_accelerator",	text = ReadText(20001, 1001),	color = "gatecolor" },			-- Accelarator
		{ icon = "mapob_superhighway",				text = ReadText(1001, 9810),	color = "highwaygatecolor" },	-- Superhighway Gate
		{ icon = "ship_s_fight_01",					text = ReadText(1001, 5200),	color = "playercolor" },		-- Owned
		{ icon = "ship_s_fight_01",					text = ReadText(1001, 5202),	color = "friendcolor" },		-- Neutral
		{ icon = "ship_s_fight_01",					text = ReadText(1001, 5201),	color = "enemycolor" },			-- Enemy
		{ icon = "ship_s_fight_01",					text = ReadText(1001, 5212),	color = "hostilecolor" },		-- Hostile
		-- stations
		{ text = ReadText(1001, 4) },																																					-- Stations
		{ icon = "mapob_playerhq",					text = ReadText(20102, 2011),	width = 0.8 * Helper.sidebarWidth,	height = 0.8 * Helper.sidebarWidth,	color = "playercolor" },	-- Headquarters
		{ icon = "maplegend_hq_01",					text = ReadText(1001, 9808),	width = 0.8 * Helper.sidebarWidth,	height = 0.8 * Helper.sidebarWidth,	color = "friendcolor" },	-- Faction Headquarters
		{ icon = "mapob_shipyard",					text = ReadText(1001, 92),		width = 0.8 * Helper.sidebarWidth,	height = 0.8 * Helper.sidebarWidth,	color = "friendcolor" },	-- Shipyard
		{ icon = "mapob_wharf",						text = ReadText(1001, 9805),	width = 0.8 * Helper.sidebarWidth,	height = 0.8 * Helper.sidebarWidth,	color = "friendcolor" },	-- Wharf
		{ icon = "mapob_equipmentdock",				text = ReadText(1001, 9804),	width = 0.8 * Helper.sidebarWidth,	height = 0.8 * Helper.sidebarWidth,	color = "friendcolor" },	-- Equipment Dock
		{ icon = "mapob_tradestation",				text = ReadText(1001, 9803),	width = 0.8 * Helper.sidebarWidth,	height = 0.8 * Helper.sidebarWidth,	color = "friendcolor" },	-- Trading Station
		{ icon = "mapob_defensestation",			text = ReadText(1001, 9802),	width = 0.8 * Helper.sidebarWidth,	height = 0.8 * Helper.sidebarWidth,	color = "friendcolor" },	-- Defence Platform
		{ icon = "mapob_piratestation",				text = ReadText(20102, 1511),	width = 0.8 * Helper.sidebarWidth,	height = 0.8 * Helper.sidebarWidth,	color = "friendcolor" },	-- Free Port
		{ station_factory_placeholder = true },
		{ icon = "mapob_factory",					text = ReadText(20102, 1001),	width = 0.8 * Helper.sidebarWidth,	height = 0.8 * Helper.sidebarWidth,	color = "friendcolor" },	-- Factory
		-- xl ships
		{ text = ReadText(1001, 6) .. ReadText(1001, 120) .. " " .. ReadText(20111, 5041) },					-- Ships: XL
		{ icon = "ship_xl_battleship_01",			text = ReadText(1001, 9822),	color = "friendcolor" },	-- Battleship
		{ icon = "ship_xl_carrier_01",				text = ReadText(1001, 9823),	color = "friendcolor" },	-- Carrier
		{ icon = "ship_xl_destroyer_01",			text = ReadText(1001, 9824),	color = "friendcolor" },	-- Destroyer
		{ icon = "ship_xl_freighter_01",			text = ReadText(1001, 9819),	color = "friendcolor" },	-- Freighter
		{ icon = "ship_xl_resupplier_01",			text = ReadText(1001, 9820),	color = "friendcolor" },	-- Auxiliary
		{ icon = "ship_xl_builder_01",				text = ReadText(1001, 9821),	color = "friendcolor" },	-- Builder
		-- l ships
		{ text = ReadText(1001, 6) .. ReadText(1001, 120) .. " " .. ReadText(20111, 5031) },					-- Ships: L
		{ icon = "ship_l_carrier_01",				text = ReadText(1001, 9823),	color = "friendcolor" },	-- Carrier
		{ icon = "ship_l_destroyer_01",				text = ReadText(1001, 9824),	color = "friendcolor" },	-- Destroyer
		{ icon = "ship_l_scavenger_01",				text = ReadText(1001, 9825),	color = "friendcolor" },	-- Scavenger
		{ icon = "ship_l_freighter_01",				text = ReadText(1001, 9819),	color = "friendcolor" },	-- Freighter
		{ icon = "ship_l_miner_01",					text = ReadText(1001, 9818),	color = "friendcolor" },	-- Miner
		{ icon = "ship_l_compactor_01",				text = ReadText(1001, 9826),	color = "friendcolor" },	-- Compactor
		-- m ships
		{ text = ReadText(1001, 6) .. ReadText(1001, 120) .. " " .. ReadText(20111, 5021) },					-- Ships: M
		{ icon = "ship_m_frigate_01",				text = ReadText(1001, 9829),	color = "friendcolor" },	-- Frigate
		{ icon = "ship_m_corvette_01",				text = ReadText(1001, 9828),	color = "friendcolor" },	-- Corvette
		{ icon = "ship_m_gunboat_01",				text = ReadText(1001, 9830),	color = "friendcolor" },	-- Gunboat
		{ icon = "ship_m_scavenger_01",				text = ReadText(1001, 9825),	color = "friendcolor" },	-- Scavenger
		{ icon = "ship_m_transporter_01",			text = ReadText(1001, 9817),	color = "friendcolor" },	-- Transporter
		{ icon = "ship_m_miner_01",					text = ReadText(1001, 9818),	color = "friendcolor" },	-- Miner
		{ icon = "ship_m_tug_01",					text = ReadText(1001, 9827),	color = "friendcolor" },	-- Tug
		-- s ships
		{ text = ReadText(1001, 6) .. ReadText(1001, 120) .. " " .. ReadText(20111, 5011) },					-- Ships: S
		{ icon = "ship_s_heavyfighter_01",			text = ReadText(1001, 9833),	color = "friendcolor" },	-- Heavy Fighter
		{ icon = "ship_s_fighter_01",				text = ReadText(1001, 9816),	color = "friendcolor" },	-- Fighter
		{ icon = "ship_s_scout_01",					text = ReadText(1001, 9834),	color = "friendcolor" },	-- Scout
		{ icon = "ship_s_lasertower_01",			text = ReadText(1001, 9835),	color = "friendcolor" },	-- Lasertower
		{ icon = "ship_s_drone_fight_01",			text = ReadText(20101, 100401),	color = "friendcolor" },	-- Defence Drone
		{ icon = "ship_s_courier_01",				text = ReadText(1001, 9832),	color = "friendcolor" },	-- Courier
		{ icon = "ship_s_drone_trade_01",			text = ReadText(20101, 100101),	color = "friendcolor" },	-- Cargo Drone
		{ icon = "ship_s_miner_01",					text = ReadText(1001, 9818),	color = "friendcolor" },	-- Miner
		{ icon = "ship_s_drone_mine_01",			text = ReadText(20101, 100501),	color = "friendcolor" },	-- Mining Drone
		{ icon = "ship_s_racer_01",					text = ReadText(1001, 9831),	color = "friendcolor" },	-- Racing
		-- xs ships
		{ text = ReadText(1001, 22) },																			-- Units
		{ icon = "ship_xs_drone_fight_01",			text = ReadText(20101, 100401),	color = "friendcolor" },	-- Defence Drone
		{ icon = "ship_xs_policeship_01",			text = ReadText(20214, 800),	color = "friendcolor" },	-- Police Vehicles
		{ icon = "ship_xs_boardingpod_01",			text = ReadText(20101, 101301),	color = "friendcolor" },	-- Boarding Pod
		{ icon = "ship_xs_distressdrone_01",		text = ReadText(1001, 9836),	color = "friendcolor" },	-- Distress Drone
		{ icon = "ship_xs_lasertower_01_inactive",	text = ReadText(1001, 9835),	color = "friendcolor" },	-- Lasertower
		{ icon = "ship_xs_drone_trade_01",			text = ReadText(20101, 100101),	color = "friendcolor" },	-- Cargo Drone
		{ icon = "ship_xs_personalvehicle_01",		text = ReadText(20101, 110201),	color = "friendcolor" },	-- Civilian Ship
		{ icon = "ship_xs_drone_build_01",			text = ReadText(20101, 100301),	color = "friendcolor" },	-- Building Drone
		-- trade offers
		{ text = ReadText(1001, 1113) },																		-- Trade Offers
		{ icon = "maptr_illegal",					text = ReadText(1001, 9813) },								-- Illegal Trades
		{ icon = "maptr_buildstorage",				text = ReadText(1001, 11032) },								-- Station Construction Trades
		{ icon = "maptr_supply",					text = ReadText(1001, 9814) },								-- Supply Trades
		{ icon = "maptr_hexagon",					text = ReadText(1001, 9815),	color = Color["trade_buyoffer"] },	-- Trade Volume
		-- misc
		{ text = ReadText(1001, 2664) },																								-- Misc
		{ icon = "mapob_lasertower_xs",				text = ReadText(20201, 20501),	color = "friendcolor" },							-- Laser Tower Mk1
		{ icon = "mapob_lasertower_s",				text = ReadText(20201, 20601),	color = "friendcolor" },							-- Laser Tower Mk2
		{ icon = "mapob_mine",						text = ReadText(20201, 20201),	color = "friendcolor" },							-- Mine
		{ icon = "solid",							text = ReadText(1001, 1304),	width = 4,	height = 4,	color = "missilecolor" },	-- Missiles
		{ icon = "mapob_satellite_01",				text = ReadText(20201, 20301),	color = "friendcolor" },							-- Satellite
		{ icon = "mapob_satellite_02",				text = ReadText(20201, 20401),	color = "friendcolor" },							-- Advanced Satellite
		{ icon = "mapob_resourceprobe",				text = ReadText(20201, 20701),	color = "friendcolor" },							-- Resource Probe
		{ icon = "mapob_navbeacon",					text = ReadText(20201, 20801),	color = "friendcolor" },							-- Nav Beacon
		{ icon = "mapob_poi",						text = ReadText(1001, 9811),	color = "friendcolor" },							-- Point of Interest
		{ icon = "mapob_unknown",					text = ReadText(20109, 5001) },														-- Unknown Object
		{ icon = "npc_factionrep",					text = ReadText(20208, 10601),	color = "friendcolor" },							-- Faction Representative
		{ icon = "npc_missionactor",				text = ReadText(30260, 1901),	color = "missioncolor" },							-- Person of Interest
		{ icon = "npc_shadyguy",					text = ReadText(20208, 10801),	color = "friendcolor" },							-- Black Marketeer
		{ icon = "missiontype_fight",				text = ReadText(1001, 3291),	color = "missioncolor" },							-- Mission Offers
		{ icon = "mapob_missiontarget",				text = ReadText(1001, 3325),	color = "missioncolor" },							-- Accepted Missions
		-- orders
		{ text = ReadText(1001, 8360) },												-- Behaviours
		{ icon = "order_movegeneric",				text = ReadText(1041, 541) },		-- Fly
		{ icon = "order_wait",						text = ReadText(1041, 101) },		-- Hold Position
		{ icon = "order_waitforsignal",				text = ReadText(1041, 111) },		-- Wait for Signal
		{ icon = "order_dockat",					text = ReadText(1041, 441) },		-- Dock
		{ icon = "order_dockandwait",				text = ReadText(1041, 451) },		-- Dock and Wait
		{ icon = "order_undock",					text = ReadText(1041, 531) },		-- Undock
		{ icon = "order_follow",					text = ReadText(1041, 321) },		-- Follow Ship

		{ icon = "order_attack",					text = ReadText(1041, 431) },		-- Attack
		{ icon = "order_attackinrange",				text = ReadText(1041, 631) },		-- Attack targets in range
		{ icon = "order_patrol",					text = ReadText(1041, 391) },		-- Patrol
		{ icon = "order_protectposition",			text = ReadText(1041, 381) },		-- Protect Position
		{ icon = "order_police",					text = ReadText(1041, 671) },		-- Police
		{ icon = "order_plunder",					text = ReadText(1041, 231) },		-- Plunder
		{ icon = "order_board",						text = ReadText(1041, 421) },		-- Board
		{ icon = "order_escort",					text = ReadText(1041, 411) },		-- Escort Ship
		{ icon = "order_recon",						text = ReadText(1041, 291) },		-- Recon
		{ icon = "order_flee",						text = ReadText(1041, 551) },		-- Flee

		{ icon = "order_findbuildtasks",			text = ReadText(1041, 491) },		-- Find Build Tasks
		{ icon = "order_deploytostation",			text = ReadText(1041, 511) },		-- Deploy to Station

		{ icon = "order_explore",					text = ReadText(1041, 311) },		-- Explore
		{ icon = "order_exploreupdate",				text = ReadText(1041, 301) },		-- Revisit known stations

		{ icon = "order_miningroutine",				text = ReadText(1041, 561) },		-- Mine Resources

		{ icon = "order_tradeperform",				text = ReadText(1041, 171) },		-- Execute Trade
		{ icon = "order_tradeexchange",				text = ReadText(1041, 121) },		-- Ware Exchange
		{ icon = "order_traderoutine",				text = ReadText(1041, 161) },		-- AutoTrade
		{ icon = "order_player_docktotrade",		text = ReadText(1041, 461) },		-- Dock to Trade
		{ icon = "order_disitributewares",			text = ReadText(1041, 181) },		-- Distribute Wares
		{ icon = "order_crewexchange",				text = ReadText(1041, 681) },		-- Transfer Crew

		{ icon = "order_supplyfleet",				text = ReadText(1041, 641) },		-- Supply Fleet
		{ icon = "order_getsupplies",				text = ReadText(1041, 621) },		-- Get Supplies
		{ icon = "order_resupply",					text = ReadText(1041, 191) },		-- Repair and Resupply
		{ icon = "order_restocksubordinates",		text = ReadText(1041, 201) },		-- Restock Subordinates
		{ icon = "order_recallsubordinates",		text = ReadText(1041, 221) },		-- Recall Subordinates
		{ icon = "order_assigncommander",			text = ReadText(1041, 521) },		-- Assign to new Commander
		{ icon = "order_equip",						text = ReadText(1041, 501) },		-- Change Equipment

		{ icon = "order_collect",					text = ReadText(1041, 481) },		-- Collect
		{ icon = "order_collectdropsinradius",		text = ReadText(1041, 571) },		-- Collect Drops
		{ icon = "order_collectlockbox",			text = ReadText(1041, 661) },		-- Collect Lockbox
		{ icon = "order_deployobjectatposition",	text = ReadText(1041, 471) },		-- Deploy Object At Position
		{ icon = "order_depositinventory",			text = ReadText(1041, 651) },		-- Deposit Inventory
	},

	dropInventoryWidth = 500,
	crewTransferWidth = 600,
	renameWidth = 300,
	changeLogoWidth = 450,
	orderqueueContextWidth = 350,
	tradeLoopWidth = 500,
	venturePatronWidth = 400,
	hireContextWidth = 350,
	ventureTeamContextWidth = 260,
	ventureContactContextWidth = 260,

	orderDragSupport = {
	--	order name					position parameter
		["MoveWait"]				= 1,
		["CollectDropsInRadius"]	= 1,
		["SalvageInRadius"]			= 1,
		["DeployObjectAtPosition"]	= 1,
		["AttackInRange"]			= 1,
		["RescueInRange"]			= 1,
		["ProtectPosition"]			= 1,
		["MiningCollect"]			= 1,
		["MiningPlayer"]			= 1,
		["Explore"]					= 2,
		["ExploreUpdate"]			= 2,
	},

	assignments = {
		["defence"]					= { name = ReadText(20208, 40301) },
		["positiondefence"]			= { name = ReadText(20208, 41501) },
		["attack"]					= { name = ReadText(20208, 40901) },
		["interception"]			= { name = ReadText(20208, 41001) },
		["bombardment"]				= { name = ReadText(20208, 41601) },
		["follow"]					= { name = ReadText(20208, 41301) },
		["supplyfleet"]				= { name = ReadText(20208, 40701) },
		["mining"]					= { name = ReadText(20208, 40201) },
		["trade"]					= { name = ReadText(20208, 40101) },
		["tradeforbuildstorage"]	= { name = ReadText(20208, 40801) },
		["assist"]					= { name = ReadText(20208, 41201) },
		["salvage"]					= { name = ReadText(20208, 41401) },
	},

	infoLogbook = {
		category = "all",
		pageSize = 100,
		queryLimit = 1000,
	},

	ventureSeasons = {
		maxDescRows = 12,
	},

	plots = {
		maxPlotRows = 10,
	},
}

__CORE_DETAILMONITOR_MAPFILTER = __CORE_DETAILMONITOR_MAPFILTER or {
	version = config.mapfilterversion,
	["layer_trade"] = true,
	["layer_fight"] = false,
	["layer_think"] = true,
	["layer_build"] = false,
	["layer_diplo"] = false,
	["layer_mining"] = true,
	["layer_other"] = true,
	["trade_price_maxprice"] = 0,
	["trade_playeroffer_buy"] = 0,
	["trade_playeroffer_sell"] = 0,
	["trade_offer_number"] = 3,
	["trade_relation_enemy"] = true,
	["trade_volume"] = 0,
	["think_alert"] = 1,
	["think_diplomacy_factioncolor"] = false,
	["think_diplomacy_highlightvisitor"] = true,
	["mining_resource_display"] = true,
	["other_misc_orderqueue"] = true,
	["other_misc_allyorderqueue"] = true,
	["other_misc_missions"] = true,
	["other_misc_ecliptic"] = true,
	["other_misc_civilian"] = true,
	["other_misc_wrecks"] = true,
	["other_misc_selection_lines"] = true,
	["other_misc_opacity"] = false,
	["other_misc_gate_connections"] = false,
	["other_misc_coveroverride"] = false,
	["other_misc_rendersatelliteradarrange"] = true,
}

-- kuertee start:
local callbacks = {}
local distanceTool_from_component
local distanceTool_from_posRot
local distanceTool_to_component
local distanceTool_to_posRot
-- kuertee end

local function init()
	Menus = Menus or { }
	table.insert(Menus, menu)
	if Helper then
		Helper.registerMenu(menu)
	end
	menu.extendedmoduletypes = {}
	menu.extendedsubordinates = {}
	menu.extendeddockedships = {}
	menu.extendedconstruction = {}
	menu.extendedproperty = { ships = true, stations = true }
	menu.extendedorders = {}
	menu.extendedinfo = {}
	menu.infoTablePersistentData = {
		left = {
			crew = { ["object"] = nil, ["capacity"] = 0, ["total"] = 0, ["current"] = { ["total"] = 0, ["roles"] = {} }, ["reassigned"] = { ["total"] = 0, ["roles"] = {} }, ["unassigned"] = { ["total"] = 0, ["persons"] = {} } },
			cashtransferdetails = {},
			macrostolaunch = {},
			drops = {},
			venturelogbook = { curPage = 1, searchtext = "" },
			pastseasons = { curPage = 1, searchtext = "" },
			venturecontacts = { curPage = 1, searchtext = "", forumsearch = "" },
			claimedOutcomes = {},
		},
		right = {
			crew = { ["object"] = nil, ["capacity"] = 0, ["total"] = 0, ["current"] = { ["total"] = 0, ["roles"] = {} }, ["reassigned"] = { ["total"] = 0, ["roles"] = {} }, ["unassigned"] = { ["total"] = 0, ["persons"] = {} } },
			cashtransferdetails = {},
			macrostolaunch = {},
			drops = {},
			venturelogbook = { curPage = 1, searchtext = "" },
			pastseasons = { curPage = 1, searchtext = "" },
			venturecontacts = { curPage = 1, searchtext = "", forumsearch = "" },
			claimedOutcomes = {},
		},
	}
	menu.holomap = 0

	if __CORE_DETAILMONITOR_MAPFILTER.version < config.mapfilterversion then
		menu.upgradeMapFilterVersion()
	end

	RegisterEvent("mapfilter", menu.filterUpdate)
	registerForEvent("gameLoadingDone", getElement("Scene.UIContract"), menu.onLoadingDone)

	-- kuertee start:
	menu.init_kuertee()
	-- kuertee end
end

function menu.onLoadingDone()
	__CORE_DETAILMONITOR_MAPFILTER_SAVE = __CORE_DETAILMONITOR_MAPFILTER_SAVE or {
		version = C.IsNewGame() and config.mapfiltersaveversion or 0,
		["trade_storage_container"] = true,
		["trade_storage_solid"] = true,
		["trade_storage_liquid"] = true,
		["trade_storage_condensate"] = true,
	}

	if __CORE_DETAILMONITOR_MAPFILTER_SAVE.version < config.mapfiltersaveversion then
		menu.upgradeMapFilterSaveVersion()
	end
end

-- kuertee start:
function menu.init_kuertee ()
	menu.loadModLuas()
	-- DebugError("uix load success: " .. tostring(debug.getinfo(1).source))
end
-- kuertee end

function menu.createLegend()
	if menu.haslegend then
		return
	end
	menu.haslegend = true

	for i = 1, #config.legend do
		local entry = config.legend[i]
		if entry.station_factory_placeholder then
			local waregroups = {}
			local n = C.GetNumAllWareGroups()
			local buf = ffi.new("WareGroupInfo[?]", n)
			n = C.GetAllWareGroups(buf, n)
			for j = 0, n - 1 do
				if buf[j].tier > 0 then
					table.insert(waregroups, { icon = ffi.string(buf[j].factorymapicon), text = ffi.string(buf[j].factoryname), tier = buf[j].tier })
				end
			end
			table.sort(waregroups, menu.sortWareGroupsByTier)

			for j, group in ipairs(waregroups) do
				if j == 1 then
					config.legend[i] = { icon = group.icon, text = group.text, width = 0.8 * Helper.sidebarWidth, height = 0.8 * Helper.sidebarWidth, color = "friendcolor" }
				else
					table.insert(config.legend, i + j - 1, { icon = group.icon, text = group.text, width = 0.8 * Helper.sidebarWidth, height = 0.8 * Helper.sidebarWidth, color = "friendcolor" })
				end
			end
		end
	end
end

function menu.sortWareGroupsByTier(a, b)
	if a.tier == b.tier then
		return a.text < b.text
	end
	return a.tier > b.tier
end

function menu.cleanup()
	if not menu.minimized then
		if (menu.mode == nil) or (menu.mode == "selectbuildlocation") then
			menu.state = menu.onSaveState()
		end

		UnregisterAddonBindings("ego_detailmonitor")
		menu.arrowsRegistered = nil
		UnregisterEvent("updateHolomap", menu.updateHolomap)
		UnregisterEvent("info_updatePeople", menu.infoUpdatePeople)

		if menu.contextMenuMode == "trade" then
			if C.IsComponentOperational(menu.contextMenuData.currentShip) then
				SetVirtualCargoMode(ConvertStringToLuaID(tostring(menu.contextMenuData.currentShip)), false)
			end
			if menu.contextMenuData.wareexchange then
				if C.IsComponentOperational(menu.contextMenuData.component) then
					SetVirtualCargoMode(ConvertStringToLuaID(tostring(menu.contextMenuData.component)), false)
				end
			end
		end
		unregisterForEvent("inputModeChanged", getElement("Scene.UIContract"), menu.onInputModeChanged)

		if Helper.hasExtension("multiverse") then
			Helper.callExtensionFunction("multiverse", "unregisterOnlineEvents", menu)
		end
	end

	if Helper.hasExtension("multiverse") then
		Helper.callExtensionFunction("multiverse", "cleanup", menu)
	end

	if menu.mode == "hire" then
		menu.searchTableMode = nil
	elseif menu.mode == "selectCV" then
		for k, v in pairs(menu.layerBackup) do
			__CORE_DETAILMONITOR_MAPFILTER[k] = v
			if k == "think_diplomacy_highlightvisitor" then
				C.SetConfigSetting("highlightvisitors", v)
			end
		end
	end

	menu.title = nil
	menu.activatemap = nil
	menu.setrow = nil
	menu.settoprow = nil
	menu.setcol = nil
	menu.mode = nil
	menu.modeparam = {}
	menu.createInfoFrameRunning = nil
	menu.createInfoFrame2Running = nil
	menu.createMainFrameRunning = nil
	menu.lastUpdateHolomapTime = nil
	menu.noupdate = nil
	if menu.holomap ~= 0 then
		C.RemoveHoloMap()
		menu.holomap = 0
	end
	menu.autopilottarget = nil
	menu.softtarget = nil
	menu.lastactivetable = nil
	menu.focuscomponent = nil
	menu.currentsector = nil
	menu.selectedcomponents = {}
	menu.closemapwithmenu = nil
	menu.oldmode = nil
	menu.oldInfoTableMode = nil
	menu.cachedOrderFailures = {}

	menu.boardingData = {}
	menu.boardingtable_shipselection = {}
	menu.queuecontextrefresh = nil
	menu.contexttoprow = nil
	menu.contextselectedrow = nil

	menu.infoSubmenuObject = nil
	menu.infoTablePersistentData.left.crew.object = nil
	menu.infoTablePersistentData.right.crew.object = nil
	menu.infoTablePersistentData.left.resetcrew = nil
	menu.infoTablePersistentData.right.resetcrew = nil
	menu.infoTablePersistentData.left.cashtransferdetails = {}
	menu.infoTablePersistentData.right.cashtransferdetails = {}
	menu.infoTablePersistentData.left.macrostolaunch = {}
	menu.infoTablePersistentData.right.macrostolaunch = {}
	menu.infoTablePersistentData.left.drops = {}
	menu.infoTablePersistentData.right.drops = {}
	menu.infoTablePersistentData.left.planneddefaultorderloop = nil
	menu.infoTablePersistentData.right.planneddefaultorderloop = nil
	menu.infoTablePersistentData.left.planneddefaultorderiscopy = nil
	menu.infoTablePersistentData.right.planneddefaultorderiscopy = nil
	if menu.infoTablePersistentData.left.orderqueuemode and (menu.infoTablePersistentData.left.orderqueuemode.mode == "plandefaultorder") then
		C.RemovePlannedDefaultOrder(menu.infoTablePersistentData.left.orderqueuemode.curobject)
	end
	menu.infoTablePersistentData.left.orderqueuemode = nil
	if menu.infoTablePersistentData.right.orderqueuemode and (menu.infoTablePersistentData.right.orderqueuemode.mode == "plandefaultorder") then
		C.RemovePlannedDefaultOrder(menu.infoTablePersistentData.right.orderqueuemode.curobject)
	end
	menu.infoTablePersistentData.right.orderqueuemode = nil

	menu.plots = {}
	menu.plotDoNotUpdate = nil
	menu.table_plotlist = {}
	menu.plotsliders = {}
	menu.plotbuttons = {}
	menu.plots_initialized = nil
	--menu.setplotrow = nil
	--menu.setplottoprow = nil
	-- do not clean this up to reselect the last selected plot if re-accessing the map. for example, from the station configuration menu.
	--menu.plotData = {}

	menu.missionOfferList = {}
	menu.missionList = {}
	menu.missionDoNotUpdate = nil

	menu.rendertargetWidth = nil
	menu.rendertargetHeight = nil
	menu.editboxHeight = nil
	menu.sideBarWidth = nil

	menu.searchtext = {}
	menu.holomapcolor = {}
	menu.ownerDetails = nil

	menu.buttonline = nil
	menu.orderdefs = {}
	menu.orderdefsbycategory = {}

	menu.turrets = {}
	menu.turretgroups = {}

	menu.mainFrame = nil
	menu.infoFrame = nil
	menu.infoFrame2 = nil
	menu.infoTableData = {}
	menu.contextMenuMode = nil
	menu.contextMenuData = {}
	menu.contextFrame = nil

	menu.topRows = {}
	menu.selectedRows = {}
	menu.selectedCols = {}

	menu.highlightedbordercomponent = nil
	menu.highlightedbordermoduletype = nil
	menu.highlightedplannedmodule = nil
	menu.highlightedbordersection = nil
	menu.highlightedborderstationcategory = nil
	menu.selectedstationcategory = nil
	menu.highlightedconstruction = nil
	menu.selectedconstruction = nil
	menu.selectedfleetcommander = nil

	menu.lock = nil
	menu.leftdown = nil
	menu.rightdown = nil

	menu.panningmap = nil
	menu.rotatingmap = nil
	menu.orderdrag = nil
	menu.intersectordrag = nil

	menu.refreshed = nil
	menu.picking = true
	menu.pickstate = nil

	if menu.map then
		SetMouseOverOverride(menu.map, nil)
	end

	menu.searchField = nil
	menu.sideBar = nil
	selectedShipsTable = nil
	menu.topLevel = nil
	menu.map = nil

	menu.infoTable = nil
	menu.infoTable2 = nil
	menu.infoTable3 = nil
	menu.infoTableRight = nil
	menu.infoTableRight2 = nil
	menu.infoTableRight3 = nil

	menu.contextMenu = nil

	if menu.sound_ambient then
		StopPlayingSound(menu.sound_ambient)
	end
	if menu.sound_panmap then
		StopPlayingSound(menu.sound_panmap)
	end
	if menu.sound_rotatemap and menu.sound_rotatemap.sound then
		StopPlayingSound(menu.sound_rotatemap.sound)
	end
	if menu.sound_zoom then
		StopPlayingSound(menu.sound_zoom)
	end
	menu.sound_ambient = nil
	menu.sound_panmap = nil
	menu.sound_rotatemap = nil
	menu.sound_zoom = nil

	menu.sound_selectedelement = nil

	menu.lastzoom = nil
	menu.zoom_newdir = nil

	menu.clearMouseCursorOverrides()

	C.SetUICoverOverride(false)
	__CORE_DETAILMONITOR_MAPFILTER["other_misc_coveroverride"] = false
end

-- Menu member functions

-- button scripts
function menu.updateMapAndInfoFrame()
	if menu.holomap ~= 0 then
		C.ClearSelectedMapComponents(menu.holomap)
	end
	menu.createInfoFrame()
end

function menu.buttonBoardingAddShip()
	-- TODO: implement boarding_selectplayerobject mode and return to boarding menu if object is selected.
	--if not menu.boardingData.contextmenudata then
	--	menu.boardingData.contextmenudata = menu.contextMenuData
	--end
	menu.mode = "boarding_selectplayerobject"
	menu.infoTableMode = "propertyowned"
	menu.boardingData.changed = true
	menu.closeContextMenu()
	menu.refreshMainFrame = true
	menu.refreshInfoFrame()
end

function menu.buttonBoardingRemoveShip(shipid)
	menu.boardingData.shipdata[shipid] = nil
	for i, locship in ipairs(menu.contextMenuData.boarders) do
		if locship == shipid then
			table.remove(menu.contextMenuData.boarders, i)
			break
		end
	end
	for i, locship in ipairs(menu.boardingData.ships) do
		if locship == shipid then
			table.remove(menu.boardingData.ships, i)
			break
		end
	end
	if not C.RemoveAttackerFromBoardingOperation(shipid) then
		DebugError("Failed to remove " .. ffi.string(C.GetComponentName(shipid)) .. " " .. tostring(shipid) .. " from boarding operation.")
	end
	menu.boardingData.changed = true
	if #menu.boardingData.ships > 0 then
		menu.refreshContextFrame()
	else
		menu.closeContextMenu()
	end
end

function menu.buttonUpdateBoardingOperation(alreadystarted)
	--print("risk 1 threshold: " .. tostring(menu.boardingData.riskleveldata[menu.boardingData.risk1].threshold) .. ", risk 2 threshold: " .. tostring(menu.boardingData.riskleveldata[menu.boardingData.risk2].threshold))
	if not alreadystarted then
		if not C.CreateBoardingOperation(menu.boardingData.target, "player", menu.boardingData.riskleveldata[menu.boardingData.risk1].threshold, menu.boardingData.riskleveldata[menu.boardingData.risk2].threshold) then
			DebugError("Failed to create boarding operation involving target: " .. ffi.string(C.GetComponentName(menu.boardingData.target)) .. " " .. tostring(menu.boardingData.target))
		end
	else
		C.UpdateBoardingOperation(menu.boardingData.target, "player", menu.boardingData.riskleveldata[menu.boardingData.risk1].threshold, menu.boardingData.riskleveldata[menu.boardingData.risk2].threshold)
	end

	for _, shipid in pairs(menu.boardingData.ships) do
		--print("adding " .. ffi.string(C.GetComponentName(shipid)))
		menu.addShipToBoardingOperation(shipid, menu.boardingData.shipdata[shipid])
	end

	if not alreadystarted then
		if not C.StartBoardingOperation(menu.boardingData.target, "player") then
			DebugError("Failed to start boarding operation involving target: " .. ffi.string(C.GetComponentName(menu.boardingData.target)) .. " " .. tostring(menu.boardingData.target))
		end
	end

	-- reset boarding data to retrieve new information from boarding operation.
	menu.boardingData.ships = {}
	menu.boardingData.shipdata = {}
	menu.boardingData.changed = false
	-- in case of emergency, press below.
	--C.AbortBoardingOperation(menu.boardingData.target, "player")
	menu.refreshContextFrame()
end

function menu.buttonExtendModuleType(station, type)
	menu.extendModuleType(station, type)

	menu.settoprow = GetTopRow(menu.infoTable)
	menu.createInfoFrame()
end

function menu.buttonExtendSubordinate(name, group)
	if menu.isSubordinateExtended(name, group) then
		if menu.extendedsubordinates[name .. group] == false then
			menu.extendedsubordinates[name .. group] = nil
		else
			menu.extendedsubordinates[name .. group] = false
		end
		menu.clearSelectedComponents()
		menu.highlightedbordercomponent = ConvertStringTo64Bit(name)
		menu.highlightedborderstationcategory = "subordinates" .. name .. group
	else
		menu.extendedsubordinates[name .. group] = true
	end
	menu.settoprow = GetTopRow(menu.infoTable)
	menu.createInfoFrame()
end

function menu.buttonExtendDockedShips(name, isstation)
	if menu.isDockedShipsExtended(name, isstation) then
		if isstation then
			menu.extendeddockedships[name] = nil
		else
			menu.extendeddockedships[name] = false
		end
		menu.clearSelectedComponents()
		menu.highlightedbordercomponent = ConvertStringTo64Bit(name)
		menu.highlightedborderstationcategory = "dockedships"
	else
		menu.extendeddockedships[name] = true
	end
	menu.settoprow = GetTopRow(menu.infoTable)
	menu.createInfoFrame()
end

function menu.buttonExtendConstruction(name)
	if menu.isConstructionExtended(name) then
		menu.extendedconstruction[name] = nil
		menu.clearSelectedComponents()
		menu.highlightedbordercomponent = ConvertStringTo64Bit(name)
		menu.highlightedborderstationcategory = "constructions"
	else
		menu.extendedconstruction[name] = true
	end
	menu.settoprow = GetTopRow(menu.infoTable)
	menu.createInfoFrame()
end

function menu.buttonExtendProperty(name)
	if menu.isPropertyExtended(name) then
		menu.extendedproperty[name] = nil
		menu.addSelectedComponent(ConvertStringTo64Bit(name), true)
	else
		menu.extendedproperty[name] = true
	end
	menu.settoprow = GetTopRow(menu.infoTable)
	menu.createInfoFrame()
end

function menu.buttonExtendOrder(controllable, orderidx, instance, row, col)
	menu.extendOrder(controllable, orderidx, instance)
	if instance == "left" then
		menu.refreshInfoFrame(row, col)
	elseif instance == "right" then
		menu.refreshInfoFrame2(row, col)
	end
end

function menu.handlePlannedDefaultOrder(instance, confirmed, callback)
	if ((instance == "left") and (menu.infoTableMode == "info")) or ((instance == "right") and (menu.searchTableMode == "info")) then
		if menu.infoTablePersistentData[instance].orderqueuemode and (menu.infoTablePersistentData[instance].orderqueuemode.mode == "plandefaultorder") then
			if confirmed then
				C.RemovePlannedDefaultOrder(menu.infoTablePersistentData[instance].orderqueuemode.curobject)
				menu.infoTablePersistentData[instance].planneddefaultorderloop = nil
				menu.infoTablePersistentData[instance].planneddefaultorderiscopy = nil
				menu.infoTablePersistentData[instance].orderqueuemode = nil

				menu.closeContextMenu()
			else
				menu.contextMenuMode = "userquestion"
				menu.contextMenuData = { mode = "discardplanneddefaultbehaviour", xoffset = (Helper.viewWidth - Helper.scaleX(400)) / 2, yoffset = Helper.viewHeight / 2, callback = callback }

				menu.createContextFrame(Helper.scaleX(400), nil, menu.contextMenuData.xoffset, menu.contextMenuData.yoffset)
				return false
			end
		end
	end
	return true
end

function menu.handlePlannedDefaultOrderRendertargetSelect(confirmed)
	if not menu.handlePlannedDefaultOrder("left", confirmed, function () return menu.handlePlannedDefaultOrderRendertargetSelect(true) end) then
		return false
	end
	if not menu.handlePlannedDefaultOrder("right", confirmed, function () return menu.handlePlannedDefaultOrderRendertargetSelect(true) end) then
		return false
	end
	if confirmed then
		if menu.infoTableMode == "info" then
			menu.refreshInfoFrame(nil, 0)
		elseif menu.searchTableMode == "info" then
			menu.refreshInfoFrame2(nil, 0)
		end
	end
	return true
end

function menu.buttonToggleObjectList(objectlistparam, confirmed, override)
	-- kuertee start: callback
	if callbacks ["buttonToggleObjectList_on_start"] then
		for _, callback in ipairs (callbacks ["buttonToggleObjectList_on_start"]) do
			callback (objectlistparam, config)
		end
	end
	-- kuertee end: callback

	local oldidx, newidx
	local leftbar = menu.showMultiverse and config.leftBarMultiverse or config.leftBar
	local count = 1
	for _, entry in ipairs(leftbar) do
		if (entry.condition == nil) or entry.condition() then
			if entry.mode then
				if type(entry.mode) == "table" then
					for _, mode in ipairs(entry.mode) do
						if mode == menu.infoTableMode then
							oldidx = count
						end
						if mode == objectlistparam then
							newidx = count
						end
					end
				else
					if entry.mode == menu.infoTableMode then
						oldidx = count
					end
					if entry.mode == objectlistparam then
						newidx = count
					end
				end
			end
			count = count + 1
		end
		if oldidx and newidx then
			break
		end
	end

	if not menu.handlePlannedDefaultOrder("left", confirmed, function () menu.buttonToggleObjectList(objectlistparam, true) end) then
		return
	end

	local deactivate = false
	if override == nil then
		if menu.showMultiverse then
			deactivate = menu.ventureMode == objectlistparam
		else
			deactivate = menu.infoTableMode == objectlistparam
		end
	else
		deactivate = not override
	end

	if newidx then
		Helper.updateButtonColor(menu.sideBar, newidx, 1, Color["row_background_selected"])
	end
	if oldidx then
		Helper.updateButtonColor(menu.sideBar, oldidx, 1, Color["button_background_default"])
	end

	menu.createInfoFrameRunning = true
	if menu.showMultiverse then
		if (menu.ventureMode == "ventureoperation") or (menu.ventureMode == "ventureinventory") or (menu.ventureMode == "ventureseason") or (menu.ventureMode == "venturecontacts") then
			Helper.callExtensionFunction("multiverse", "onCloseMenuTab", menu, menu.ventureMode, objectlistparam)
		end
	else
		if (menu.infoTableMode == "missionoffer") or (menu.infoTableMode == "mission") then
			if (menu.infoTableMode == "missionoffer") and (menu.missionOfferMode == "operation") then
				if Helper.hasExtension("multiverse") then
					Helper.callExtensionFunction("multiverse", "unregisterOnlineEvents", menu)
					Helper.callExtensionFunction("multiverse", "onCloseMenuTab", menu, "ventureoperation", objectlistparam)
				end
			end
			menu.missionModeCurrent = nil
			if menu.missionModeContext then
				menu.closeContextMenu()
				menu.missionModeContext = nil
			end
		end
	end
	AddUITriggeredEvent(menu.name, objectlistparam, menu.infoTableMode == objectlistparam and "off" or "on")
	if deactivate then
		menu.settoprow = GetTopRow(menu.infoTable)
		menu.topRows.infotableleft = menu.settoprow
		PlaySound("ui_negative_back")
		if menu.showMultiverse then
			menu.ventureMode = nil
		else
			menu.infoTableMode = nil
		end
		if oldidx then
			SelectRow(menu.sideBar, oldidx)
		end
	else
		menu.settoprow = nil
		menu.topRows.infotableleft = nil
		PlaySound("ui_positive_select")
		if menu.infoTableMode == "objectlist" then
			menu.topRows.objectlist = GetTopRow(menu.infoTable)
			menu.selectedRows.objectlist = Helper.currentTableRow[menu.infoTable]
			menu.selectedCols.objectlist = Helper.currentTableCol[menu.infoTable]
		elseif menu.infoTableMode == "propertyowned" then
			menu.topRows.propertyowned = GetTopRow(menu.infoTable)
			menu.selectedRows.propertyowned = Helper.currentTableRow[menu.infoTable]
			menu.selectedCols.propertyowned = Helper.currentTableCol[menu.infoTable]
		elseif (menu.infoTableMode == "missionoffer") or (menu.infoTableMode == "mission") then
			if menu.missionModeContext then
				menu.closeContextMenu()
				menu.missionModeContext = nil
			end
		end
		menu.infoTable = nil
		menu.infoTable2 = nil
		if menu.showMultiverse then
			menu.ventureMode = objectlistparam
		else
			menu.infoTableMode = objectlistparam
		end
		if newidx then
			SelectRow(menu.sideBar, newidx)
		end

		local tab
		if menu.infoTableMode == "objectlist" then
			tab = menu.objectMode
		elseif menu.infoTableMode == "propertyowned" then
			tab = menu.propertyMode
		elseif menu.infoTableMode == "info" then
			tab = menu.infoMode
		elseif menu.infoTableMode == "missionoffer" then
			tab = menu.missionOfferMode
		elseif menu.infoTableMode == "mission" then
			tab = menu.missionMode
		end
		if tab then
			AddUITriggeredEvent(menu.name, "infoTableTab", tab)
		end

		if menu.infoTableMode == "plots" then
			menu.updatePlotData("plots_new", true)
			menu.storeCurrentPlots()
			--menu.plotDoNotUpdate = true
			menu.mode = "selectbuildlocation"
			C.ShowBuildPlotPlacementMap(menu.holomap, menu.currentsector)
		elseif (menu.mode ~= "selectCV") and (menu.mode ~= "hire") and (menu.mode ~= "orderparam_object") and (menu.mode ~= "selectComponent") then
			menu.plots_initialized = nil
			menu.plotData = {}
			menu.mode = nil
			menu.removeMouseCursorOverride(3)
			if not menu.showMultiverse then
				local mapstate = ffi.new("HoloMapState")
				C.GetMapState(menu.holomap, mapstate)
				local startpos = ffi.new("UIPosRot")
				C.ShowUniverseMap2(menu.holomap, false, false, false, 0, startpos)
				C.SetMapState(menu.holomap, mapstate)
			end
		end
		if menu.infoTableMode == "missionoffer" then
			menu.updateMissionOfferList(true)
		end
		Helper.textArrayHelper(menu.searchtext, function (numtexts, texts) return C.SetMapFilterString(menu.holomap, numtexts, texts) end, "text")
		menu.applyFilterSettings()
	end
	menu.setrow = nil
	menu.setcol = nil
	menu.selectedRows.infotableleft = nil
	menu.selectedCols.infotableleft = nil
	menu.topRows.infotable2 = nil
	menu.selectedRows.infotable2 = nil
	menu.selectedCols.infotable2 = nil
	menu.refreshMainFrame = true
	menu.createInfoFrame()
end

function menu.deactivateObjectList(confirmed)
	local oldidx
	local leftbar = menu.showMultiverse and config.leftBarMultiverse or config.leftBar
	local count = 1
	for _, entry in ipairs(leftbar) do
		if (entry.condition == nil) or entry.condition() then
			if entry.mode then
				if type(entry.mode) == "table" then
					for _, mode in ipairs(entry.mode) do
						if mode == menu.infoTableMode then
							oldidx = count
						end
					end
				else
					if entry.mode == menu.infoTableMode then
						oldidx = count
					end
				end
			end
			count = count + 1
		end
		if oldidx then
			break
		end
	end

	if not menu.handlePlannedDefaultOrder("left", confirmed, function () menu.deactivateObjectList(true) end) then
		return
	end

	if oldidx then
		Helper.updateButtonColor(menu.sideBar, oldidx, 1, Color["button_background_default"])
	end

	menu.createInfoFrameRunning = true
	if menu.showMultiverse then
		if (menu.ventureMode == "ventureoperation") or (menu.ventureMode == "ventureinventory") or (menu.ventureMode == "ventureseason") or (menu.ventureMode == "venturecontacts") then
			Helper.callExtensionFunction("multiverse", "onCloseMenuTab", menu, menu.ventureMode, menu.ventureMode)
		end
	else
		if menu.infoTableMode == "objectlist" then
			menu.topRows.objectlist = GetTopRow(menu.infoTable)
			menu.selectedRows.objectlist = Helper.currentTableRow[menu.infoTable]
			menu.selectedCols.objectlist = Helper.currentTableCol[menu.infoTable]
		elseif menu.infoTableMode == "propertyowned" then
			menu.topRows.propertyowned = GetTopRow(menu.infoTable)
			menu.selectedRows.propertyowned = Helper.currentTableRow[menu.infoTable]
			menu.selectedCols.propertyowned = Helper.currentTableCol[menu.infoTable]
		elseif (menu.infoTableMode == "missionoffer") or (menu.infoTableMode == "mission") then
			if (menu.infoTableMode == "missionoffer") and (menu.missionOfferMode == "operation") then
				if Helper.hasExtension("multiverse") then
					Helper.callExtensionFunction("multiverse", "unregisterOnlineEvents", menu)
					Helper.callExtensionFunction("multiverse", "onCloseMenuTab", menu, "ventureoperation", "ventureoperation")
				end
			end
			if menu.missionModeContext then
				menu.closeContextMenu()
				menu.missionModeContext = nil
			end
		end
	end

	menu.settoprow = GetTopRow(menu.infoTable)
	PlaySound("ui_negative_back")
	if menu.showMultiverse then
		menu.ventureMode = nil
	else
		menu.infoTableMode = nil
	end
	if oldidx then
		SelectRow(menu.sideBar, oldidx)
	end

	menu.refreshMainFrame = true
	menu.createInfoFrame()
end

function menu.deactivateSearchTable()
	menu.searchTableMode = nil
	menu.refreshMainFrame = true
end

function menu.buttonToggleRightBar(searchlistmode, confirmed)
	if not menu.handlePlannedDefaultOrder("right", confirmed, function () menu.buttonToggleRightBar(searchlistmode, true) end) then
		return
	end

	AddUITriggeredEvent(menu.name, searchlistmode, menu.searchTableMode == searchlistmode and "off" or menu.displayedFilterLayer)
	if menu.searchTableMode == searchlistmode then
		PlaySound("ui_negative_back")
		menu.searchTableMode = nil
	else
		PlaySound("ui_positive_select")
		menu.searchTableMode = searchlistmode
		menu.disregardFilterTable = true
	end
	menu.refreshMainFrame = true
	menu.refreshInfoFrame2()
end

function menu.buttonResetView()
	if menu.holomap and (menu.holomap ~= 0) then
		C.ResetMapPlayerRotation(menu.holomap)
		C.SetFocusMapComponent(menu.holomap, C.GetPlayerObjectID(), true)
		if menu.infoTableMode == "objectlist" then
			menu.refreshInfoFrame()
		end
	end
end

function menu.buttonNewOrder(orderid, default, instance)
	if orderid then
		if orderid == "TradePerform" then
			Helper.closeMenuForNewConversation(menu, "gTrade_offerselect", ConvertStringToLuaID(tostring(C.GetPlayerComputerID())), { 0, 0, true, ConvertStringToLuaID(tostring(menu.contextMenuData.currentShip)) })
			menu.cleanup()
		elseif orderid == "loop" then
			menu.infoTablePersistentData[instance].planneddefaultorderloop = { curobject = menu.infoSubmenuObject }
			menu.closeContextMenu()
			menu.infoTablePersistentData[instance].orderqueuemode = { mode = "plandefaultorder", curobject = menu.infoSubmenuObject }
			menu.refreshInfoFrame()
		elseif menu.isInfoModeValidFor(menu.infoSubmenuObject, "orderqueue") then
			C.CreateOrder(menu.infoSubmenuObject, orderid, default)
			local buf = ffi.new("Order")
			if C.GetPlannedDefaultOrder(buf, menu.infoSubmenuObject) then
				menu.infoTableData[instance].planneddefaultorder.state = ffi.string(buf.state)
				menu.infoTableData[instance].planneddefaultorder.statename = ffi.string(buf.statename)
				menu.infoTableData[instance].planneddefaultorder.orderdef = ffi.string(buf.orderdef)
				menu.infoTableData[instance].planneddefaultorder.actualparams = tonumber(buf.actualparams)
				menu.infoTableData[instance].planneddefaultorder.enabled = buf.enabled
				menu.infoTablePersistentData[instance].planneddefaultorderiscopy = nil
				menu.infoTablePersistentData[instance].planneddefaultorderloop = nil

				local found = false
				for _, orderdef in ipairs(menu.orderdefs) do
					if (orderdef.id == menu.infoTableData[instance].planneddefaultorder.orderdef) then
						menu.infoTableData[instance].planneddefaultorder.orderdefref = orderdef
						found = true
						break
					end
				end
				if not found then
					DebugError("Planned default order of '" .. tostring(menu.infoSubmenuObject) .. "' is of unknown definition '" .. ffi.string(buf.orderdef) .. "' [Florian]")
				end
			end

			menu.closeContextMenu()
			if default then
				menu.infoTablePersistentData[instance].orderqueuemode = { mode = "plandefaultorder", curobject = menu.infoSubmenuObject }
			else
				menu.infoTablePersistentData[instance].selectedorder = { #menu.infoTableData[instance].orders + 1 }
				menu.extendOrder(menu.infoSubmenuObject, #menu.infoTableData[instance].orders + 1, instance)
			end
			menu.refreshInfoFrame()
		else
			DebugError("menu.buttonNewOrder: function called with invalid object: " .. ffi.string(C.GetComponentName(menu.infoSubmenuObject)) .. " " .. tostring(menu.infoSubmenuObject))
		end
	else
		menu.contextMenuMode = "neworder"
		menu.contextMenuData = { default = default, instance = instance }
		local offsetx = menu.infoTableOffsetX + menu.infoTableWidth + config.contextBorder
		if instance == "right" then
			offsetx = Helper.viewWidth - offsetx - Helper.scaleX(config.orderqueueContextWidth)
		end
		menu.createContextFrame(Helper.scaleX(config.orderqueueContextWidth), Helper.viewHeight - menu.infoTableOffsetY, offsetx, menu.infoTableOffsetY)
	end
end

function menu.buttonOrderUp(order, instance, modified)
	local oldidx, newidx, enable
	oldidx = order
	if modified == "ctrl" then
		newidx = 1
		enable = true
	else
		if menu.infoTableData[instance].disabledmarker == order then
			newidx = order
			enable = true
		else
			newidx = order - 1
			enable = menu.infoTableData[instance].orders[order].enabled
		end
	end

	if menu.isInfoModeValidFor(menu.infoSubmenuObject, "orderqueue") then
		if C.AdjustOrder(menu.infoSubmenuObject, oldidx, newidx, enable, false, false) then
			menu.swapExtendedOrder(menu.infoSubmenuObject, oldidx, newidx, instance)
			menu.resetOrderParamMode()
		end
	else
		DebugError("menu.buttonOrderUp: function called with invalid object: " .. ffi.string(C.GetComponentName(menu.infoSubmenuObject)) .. " " .. tostring(menu.infoSubmenuObject))
	end
end

function menu.buttonOrderDown(order, instance, modified)
	local oldidx, newidx, enable
	oldidx = order
	if modified == "ctrl" then
		if menu.infoTableData[instance].disabledmarker == order + 1 then
			newidx = order
			enable = false
		elseif order < menu.infoTableData[instance].disabledmarker then
			newidx = menu.infoTableData[instance].disabledmarker - 1
			enable = true
		else
			newidx = #menu.infoTableData[instance].orders
			enable = false
		end
	else
		if menu.infoTableData[instance].disabledmarker == order + 1 then
			newidx = order
			enable = false
		else
			newidx = order + 1
			enable = menu.infoTableData[instance].orders[order].enabled
		end
	end

	if menu.isInfoModeValidFor(menu.infoSubmenuObject, "orderqueue") then
		if C.AdjustOrder(menu.infoSubmenuObject, oldidx, newidx, enable, false, false) then
			menu.swapExtendedOrder(menu.infoSubmenuObject, oldidx, newidx, instance)
			menu.resetOrderParamMode()
		end
	else
		DebugError("menu.buttonOrderDown: function called with invalid object: " .. ffi.string(C.GetComponentName(menu.infoSubmenuObject)) .. " " .. tostring(menu.infoSubmenuObject))
	end
end

function menu.buttonRemoveOrder(order, instance)
	if menu.removeOrder(order, instance) then
		menu.resetOrderParamMode()
	end
end

function menu.removeOrder(orderidx, instance)
	if menu.isInfoModeValidFor(menu.infoSubmenuObject, "orderqueue") then
		if C.RemoveOrder(menu.infoSubmenuObject, orderidx, false, false) then
			menu.removeExtendedOrder(menu.infoSubmenuObject, orderidx, instance)
			if orderidx == #menu.infoTableData[instance].orders then
				menu.infoTablePersistentData[instance].selectedorder = (orderidx > 1) and { (orderidx - 1), object = menu.infoSubmenuObject } or nil
			end
			if menu.infoTablePersistentData[instance].selectedorder and (type(menu.infoTablePersistentData[instance].selectedorder[1]) == "number") then
				menu.infoTablePersistentData[instance].selectedorder = { math.min(menu.infoTablePersistentData[instance].selectedorder[1], #menu.infoTableData[instance].orders - 1), object = menu.infoSubmenuObject }
			end

			return true
		end
	else
		DebugError("menu.removeOrder: function called with invalid object: " .. ffi.string(C.GetComponentName(menu.infoSubmenuObject)) .. " " .. tostring(menu.infoSubmenuObject))
	end

	return false
end

function menu.buttonStartOrders(instance)
	if menu.isInfoModeValidFor(menu.infoSubmenuObject, "orderqueue") then
		for i, order in ipairs(menu.infoTableData[instance].orders) do
			if order.state == "disabled" then
				C.EnableOrder(menu.infoSubmenuObject, i)
			end
			if order.state == "setup" then
				break
			end
		end
		menu.refreshInfoFrame()
	else
		DebugError("menu.buttonStartOrders: function called with invalid object: " .. ffi.string(C.GetComponentName(menu.infoSubmenuObject)) .. " " .. tostring(menu.infoSubmenuObject))
	end
end

function menu.buttonDeleteAllOrders(instance)
	if menu.isInfoModeValidFor(menu.infoSubmenuObject, "orderqueue") then
		for i = #menu.infoTableData[instance].orders, 1, -1 do
			if C.RemoveOrder(menu.infoSubmenuObject, i, false, false) then
				menu.removeExtendedOrder(menu.infoSubmenuObject, i, instance)
			end
		end
		menu.refreshInfoFrame()
	else
		DebugError("menu.buttonDeleteAllOrders: function called with invalid object: " .. ffi.string(C.GetComponentName(menu.infoSubmenuObject)) .. " " .. tostring(menu.infoSubmenuObject))
	end
end

function menu.buttonDefaultOrderDiscard(instance)
	if menu.isInfoModeValidFor(menu.infoSubmenuObject, "orderqueue") then
		C.RemovePlannedDefaultOrder(menu.infoSubmenuObject)
	else
		DebugError("menu.buttonDefaultOrderDiscard: function called with invalid object: " .. ffi.string(C.GetComponentName(menu.infoSubmenuObject)) .. " " .. tostring(menu.infoSubmenuObject))
	end

	menu.infoTablePersistentData[instance].planneddefaultorderloop = nil
	menu.infoTablePersistentData[instance].planneddefaultorderiscopy = nil
	menu.infoTablePersistentData[instance].orderqueuemode = nil
	menu.refreshInfoFrame(0, 0)
end

function menu.buttonDefaultOrderConfirm(instance)
	if menu.isInfoModeValidFor(menu.infoSubmenuObject, "orderqueue") then
		if menu.infoTablePersistentData[instance].planneddefaultorderloop then
			C.RemoveAllOrders(menu.infoSubmenuObject)
			C.CreateOrder(menu.infoSubmenuObject, "Wait", true)
			C.EnablePlannedDefaultOrder(menu.infoSubmenuObject, false)
			C.SetOrderLoop(menu.infoSubmenuObject, 0, false)
		else
			C.ResetOrderLoop(menu.infoSubmenuObject)
			C.EnablePlannedDefaultOrder(menu.infoSubmenuObject, false)
		end
	else
		DebugError("menu.buttonDefaultOrderConfirm: function called with invalid object: " .. ffi.string(C.GetComponentName(menu.infoSubmenuObject)) .. " " .. tostring(menu.infoSubmenuObject))
	end

	menu.infoTablePersistentData[instance].planneddefaultorderloop = nil
	menu.infoTablePersistentData[instance].planneddefaultorderiscopy = nil
	menu.infoTablePersistentData[instance].orderqueuemode = nil
	menu.refreshInfoFrame(0, 0)
end

function menu.buttonSetOrderParam(order, param, index, value, instance)
	if menu.isInfoModeValidFor(menu.infoSubmenuObject, "orderqueue") then
		local paramdata
		if order == "default" then
			menu.copyDefaultOrderForPlanning(instance)

			order = "planneddefault"
			paramdata = menu.infoTableData[instance].planneddefaultorder.params[param]
		elseif order == "planneddefault" then
			paramdata = menu.infoTableData[instance].planneddefaultorder.params[param]
		else
			paramdata = menu.infoTableData[instance].orders[order].params[param]
		end

		local paramtype, oldvalue
		if paramdata.type == "list" then
			paramtype = paramdata.inputparams.type
			if not paramtype then
				DebugError("Order parameter of type 'list' does not specify a input parameter 'type' [Florian]")
			end
			if index then
				oldvalue = paramdata.value[index]
			end
		else
			paramtype = paramdata.type
			oldvalue = paramdata.value
		end

		if paramtype == "bool" then
			SetOrderParam(ConvertStringToLuaID(tostring(menu.infoSubmenuObject)), order, param, index, not (oldvalue ~= 0))
			menu.refreshInfoFrame()
		elseif paramtype == "object" then
			menu.currentInfoMode = { menu.infoTableMode, menu.infoMode.left }
			menu.infoTableMode = "objectlist"
			menu.mode = "orderparam_object"
			local controllable = ConvertStringToLuaID(tostring(menu.infoSubmenuObject))
			local toprow = 1
			if instance == "left" then
				toprow = GetTopRow(menu.infoTable)
			elseif instance == "right" then
				toprow = GetTopRow(menu.infoTableRight)
			end
			menu.modeparam = { function (value) return menu.setOrderParamFromMode(controllable, order, param, index, value, instance) end, paramdata, toprow, controllable, order, param }

			if type(menu.modeparam[5]) == "string" then
				C.SetMapDefaultOrderParamObjectFilter(menu.holomap, ConvertStringTo64Bit(tostring(menu.modeparam[4])), menu.modeparam[5] == "planneddefault", menu.modeparam[6])
			else
				C.SetMapOrderParamObjectFilter(menu.holomap, ConvertStringTo64Bit(tostring(menu.modeparam[4])), menu.modeparam[5], menu.modeparam[6])
			end

			local orderdefid
			if order == "default" then
				orderdefid = menu.infoTableData[instance].defaultorder.orderdefref.id
			elseif order == "planneddefault" then
				orderdefid = menu.infoTableData[instance].planneddefaultorder.orderdefref.id
			else
				orderdefid = menu.infoTableData[instance].orders[order].orderdefref.id
			end
			if (orderdefid == "Attack") then
				menu.setMouseCursorOverride("targetred", 3)
			else
				menu.setMouseCursorOverride("target", 3)
			end

			menu.settoprow = 0

			menu.closeContextMenu()
			menu.refreshInfoFrame()
			menu.refreshMainFrame = true
		elseif paramtype == "sector" then
			if value then
				local object64 = ConvertStringTo64Bit(tostring(menu.infoSubmenuObject))
				if (paramdata.type == "list") and (type(value) == "table") then
					local skip = true

					local sorted = {}
					for sector in pairs(value) do
						table.insert(sorted, ConvertStringTo64Bit(sector))
					end
					-- we want to re-add the complete list to keep it alphabetical
					if not paramdata.value then
						-- no values yet, we need to set
						skip = false
					else
						if #paramdata.value ~= #sorted then
							-- number is not the same, we need to set
							skip = false
						else
							for _, sector in ipairs(paramdata.value) do
								if not value[tostring(sector)] then
									-- exisiting value not in new list, we need to set
									skip = false
									break
								end
							end
							-- if skip is still true here, all existing values are in the new list and previous check excludes the case of only new entries added, nothing to do
						end
						if not skip then
							-- remove all old
							for listidx = #paramdata.value, 1, -1 do
								RemoveOrderListParam(object64, order, param, listidx)
							end
						end
					end
					if not skip then
						-- add all new
						table.sort(sorted, Helper.sortComponentName)
						for _, sector in ipairs(sorted) do
							SetOrderParam(object64, order, param, nil, ConvertStringToLuaID(tostring(sector)))
						end
					end
				else
					SetOrderParam(object64, order, param, index, ConvertStringToLuaID(tostring(value)))
					AddUITriggeredEvent(menu.name, menu.contextMenuMode, ConvertStringToLuaID(tostring(value)))
				end
				menu.closeContextMenu()
				menu.refreshInfoFrame()
			else
				menu.contextMenuMode = "set_orderparam_sector"
				menu.contextMenuData = { order = order, param = param, index = index, instance = instance }
				local offsetx = menu.infoTableOffsetX + menu.infoTableWidth + config.contextBorder
				if instance == "right" then
					offsetx = Helper.viewWidth - offsetx - config.orderqueueContextWidth
				end
				menu.createContextFrame(config.orderqueueContextWidth, Helper.viewHeight - menu.infoTableOffsetY, offsetx, menu.infoTableOffsetY)
			end
		elseif paramtype == "ware" then
			if value then
				local object64 = ConvertStringTo64Bit(tostring(menu.infoSubmenuObject))
				if (paramdata.type == "list") and (type(value) == "table") then
					local skip = true

					local sorted = {}
					for ware in pairs(value) do
						table.insert(sorted, ware)
					end
					-- we want to re-add the complete list to keep it alphabetical
					if not paramdata.value then
						-- no values yet, we need to set
						skip = false
					else
						if #paramdata.value ~= #sorted then
							-- number is not the same, we need to set
							skip = false
						else
							for _, ware in ipairs(paramdata.value) do
								if not value[ware] then
									-- exisiting value not in new list, we need to set
									skip = false
									break
								end
							end
							-- if skip is still true here, all existing values are in the new list and previous check excludes the case of only new entries added, nothing to do
						end
						if not skip then
							-- remove all old
							for listidx = #paramdata.value, 1, -1 do
								RemoveOrderListParam(object64, order, param, listidx)
							end
						end
					end
					if not skip then
						-- add all new
						table.sort(sorted, Helper.sortWareName)
						for _, ware in ipairs(sorted) do
							SetOrderParam(object64, order, param, nil, ware)
						end
					end
				else
					SetOrderParam(object64, order, param, index, value)
					AddUITriggeredEvent(menu.name, "orderparam_" .. paramdata.name, value)
				end
				menu.closeContextMenu()
				Helper.clearTableConnectionColumn(menu, 3)
				menu.refreshInfoFrame()
			else
				menu.contextMenuMode = "set_orderparam_ware"
				menu.contextMenuData = { order = order, param = param, index = index, instance = instance }
				local offsetx = menu.infoTableOffsetX + menu.infoTableWidth + config.contextBorder
				if instance == "right" then
					offsetx = Helper.viewWidth - offsetx - config.orderqueueContextWidth
				end
				menu.createContextFrame(config.orderqueueContextWidth, Helper.viewHeight - menu.infoTableOffsetY, offsetx, menu.infoTableOffsetY)
			end
		elseif paramtype == "macro" then
			-- TODO
		elseif paramtype == "position" then
			menu.currentInfoMode = { menu.infoTableMode, menu.infoMode.left }
			menu.mode = "orderparam_position"
			local controllable = ConvertStringToLuaID(tostring(menu.infoSubmenuObject))
			local toprow = 1
			if instance == "left" then
				toprow = GetTopRow(menu.infoTable)
			elseif instance == "right" then
				toprow = GetTopRow(menu.infoTableRight)
			end
			menu.modeparam = { function (value) return menu.setOrderParamFromMode(controllable, order, param, index, value, instance) end, paramdata, toprow, controllable }

			menu.setMouseCursorOverride("target", 3)

			menu.settoprow = 0
			menu.closeContextMenu()
			menu.refreshInfoFrame()
		elseif paramtype == "formationshape" then
			if value then
				SetOrderParam(ConvertStringToLuaID(tostring(menu.infoSubmenuObject)), order, param, index, value)
				menu.closeContextMenu()
				menu.refreshInfoFrame()
			else
				menu.contextMenuMode = "set_orderparam_formationshape"
				menu.contextMenuData = { order = order, param = param, index = index, instance = instance }
				local offsetx = menu.infoTableOffsetX + menu.infoTableWidth + config.contextBorder
				if instance == "right" then
					offsetx = Helper.viewWidth - offsetx - config.orderqueueContextWidth
				end
				menu.createContextFrame(config.orderqueueContextWidth, Helper.viewHeight - menu.infoTableOffsetY, offsetx, menu.infoTableOffsetY)
			end
		else
			DebugError("Unsupported order parameter type '" .. tostring(paramtype) .. "' [Florian]")
		end
	else
		DebugError("menu.buttonSetOrderParam: function called with invalid object: " .. ffi.string(C.GetComponentName(menu.infoSubmenuObject)) .. " " .. tostring(menu.infoSubmenuObject))
	end
end

function menu.checkboxOrderPlayerOverride(order, param, paramdata, overrideparam, overrideparamdata, checked)
	local object = ConvertStringToLuaID(tostring(menu.infoSubmenuObject))

	if checked then
		-- remove all overrides
		for listidx = #overrideparamdata.value, 1, -1 do
			RemoveOrderListParam(object, order, overrideparam, listidx)
		end
	else
		-- init override list with current list
		for _, value in ipairs(paramdata.value) do
			SetOrderParam(object, order, overrideparam, nil, value)
		end
	end
	menu.refreshInfoFrame()
end

function menu.checkboxOrderPlayerOverrideValue(order, overrideparam, listidx, value)
	local object = ConvertStringToLuaID(tostring(menu.infoSubmenuObject))

	if listidx then
		RemoveOrderListParam(object, order, overrideparam, listidx)
	else
		SetOrderParam(object, order, overrideparam, nil, value)
	end
	menu.refreshInfoFrame()
end

function menu.slidercellSetOrderParam(order, param, index, value, instance)
	if menu.isInfoModeValidFor(menu.infoSubmenuObject, "orderqueue") then
		local paramdata
		if order == "default" then
			menu.copyDefaultOrderForPlanning(instance)

			order = "planneddefault"
			paramdata = menu.infoTableData[instance].planneddefaultorder.params[param]
		elseif order == "planneddefault" then
			paramdata = menu.infoTableData[instance].planneddefaultorder.params[param]
		else
			paramdata = menu.infoTableData[instance].orders[order].params[param]
		end

		local type, oldvalue
		if paramdata.type == "list" then
			type = paramdata.inputparams.type
			if not type then
				DebugError("Order parameter of type 'list' does not specify a input parameter 'type' [Florian]")
			end
			if index then
				oldvalue = paramdata.value[index]
			end
		else
			type = paramdata.type
			oldvalue = paramdata.value
		end

		if type == "number" then
			if value then
				menu.noupdate = true
				SetOrderParam(ConvertStringToLuaID(tostring(menu.infoSubmenuObject)), order, param, index, value)
			end
		elseif type == "length" then
			if value then
				menu.noupdate = true
				if paramdata.inputparams.step >= 1000 then
					value = value * 1000
				end
				SetOrderParam(ConvertStringToLuaID(tostring(menu.infoSubmenuObject)), order, param, index, value)
			end
		elseif type == "time" then
			if value then
				menu.noupdate = true
				SetOrderParam(ConvertStringToLuaID(tostring(menu.infoSubmenuObject)), order, param, index, value * 60)
			end
		elseif type == "money" then
			if value then
				menu.noupdate = true
				SetOrderParam(ConvertStringToLuaID(tostring(menu.infoSubmenuObject)), order, param, index, value * 100)
			end
		end
	else
		DebugError("menu.slidercellSetOrderParam: function called with invalid object: " .. ffi.string(C.GetComponentName(menu.infoSubmenuObject)) .. " " .. tostring(menu.infoSubmenuObject))
	end
	menu.noupdate = false
	menu.refreshInfoFrame()
end

function menu.buttonRemoveListParam(order, param, index, instance)
	if menu.isInfoModeValidFor(menu.infoSubmenuObject, "orderqueue") then
		if order == "default" then
			menu.copyDefaultOrderForPlanning(instance)

			order = "planneddefault"
		end

		RemoveOrderListParam(ConvertStringToLuaID(tostring(menu.infoSubmenuObject)), order, param, index)

		menu.refreshInfoFrame()
	else
		DebugError("menu.buttonRemoveListParam: function called with invalid object: " .. ffi.string(C.GetComponentName(menu.infoSubmenuObject)) .. " " .. tostring(menu.infoSubmenuObject))
	end
end

function menu.buttonNewPlot()
	--print("x: " .. tostring(menu.plotData.size.x) .. ", y: " .. tostring(menu.plotData.size.y) .. ", z: " .. tostring(menu.plotData.size.z))
	menu.plotData.active = true
	C.ChangeMapBuildPlot(menu.holomap, menu.plotData.size.x * 1000, menu.plotData.size.y * 1000, menu.plotData.size.z * 1000)
end

function menu.buttonRemovePlot(station)
	if not station then
		DebugError("menu.buttonRemovePlot called with no station set. station: " .. tostring(station))
		return
	end

	local newselection = nil
	if menu.plotData.component == station then
		newselection = "plots_new"
	end
	local breaknext = nil
	for i, plot in ipairs(menu.plots) do
		if station == plot.station then
			if C.RemoveBuildPlot(station) then
				plot.removed = true
				breaknext = true
			end
		elseif breaknext then
			if newselection then
				newselection = plot.station
			end
			break
		end
	end

	if newselection then
		menu.updatePlotData(newselection, true)
	end
	menu.refreshInfoFrame()
end

function menu.buttonToggleMultiverseMap()
	if (not C.AreVenturesCompatible()) or ((not C.IsVentureSeasonSupported()) and (not C.WasSessionOnline())) then
		return
	end

	menu.closeContextMenu()
	if menu.showMultiverse then
		menu.showMultiverse = false
		if Helper.hasExtension("multiverse") then
			Helper.callExtensionFunction("multiverse", "unregisterOnlineEvents", menu)
		end

		menu.mode = nil
		menu.removeMouseCursorOverride(3)

		local startpos = ffi.new("UIPosRot")
		C.ShowUniverseMap2(menu.holomap, false, false, false, 0, startpos)

		if menu.normalmapstate then
			C.SetMapState(menu.holomap, menu.normalmapstate)
			menu.normalmapstate = nil
		end
	else
		menu.showMultiverse = true
		if Helper.hasExtension("multiverse") then
			Helper.callExtensionFunction("multiverse", "registerOnlineEvents", menu)
		end

		menu.mode = nil
		menu.plots_initialized = nil
		menu.plotData = {}
		menu.seasonMode.left = "currentseason"
		menu.removeMouseCursorOverride(3)

		Helper.callExtensionFunction("multiverse", "getVentures")
		Helper.updateVenturePlatforms()

		menu.normalmapstate = ffi.new("HoloMapState")
		C.GetMapState(menu.holomap, menu.normalmapstate)

		C.ShowMultiverseMap(menu.holomap)

		local isonline = Helper.isOnlineGame()
		local operationRewardPending = Helper.hasVentureRewards()
		if C.IsVentureSeasonSupported() and (not isonline) then
			menu.contextMenuMode = "onlinemode"
			menu.contextMenuData = { xoffset = 0, yoffset = menu.topLevelHeight, instance = instance, width = Helper.viewWidth, height = Helper.viewHeight - 2 * menu.topLevelHeight }
			menu.createContextFrame(nil, nil, nil, nil, 0)
		elseif operationRewardPending then
			menu.contextMenuMode = "onlinereward"
			menu.contextMenuData = { xoffset = 0, yoffset = menu.topLevelHeight, instance = instance, width = Helper.viewWidth, height = Helper.viewHeight - 2 * menu.topLevelHeight, rewardentries = OnlineGetLogbookRewards() }
			menu.createContextFrame(nil, nil, nil, nil, 0)
		end
	end
	AddUITriggeredEvent(menu.name, "venture_map", menu.showMultiverse)
	menu.refreshMainFrame = true
	menu.selectedRows.propertytabs = 1
	menu.selectedCols.propertytabs = 1
	menu.refreshInfoFrame(0, 0)
	Helper.textArrayHelper(menu.searchtext, function (numtexts, texts) return C.SetMapFilterString(menu.holomap, numtexts, texts) end, "text")
	menu.applyFilterSettings()
end

function menu.buttonConvertVentureSave()
	SaveOnlineGame()

	menu.closeContextMenu()
end

function menu.buttonConfirmConvertVentureSave()
	menu.contextMenuMode = "onlinemode"
	menu.contextMenuData = { xoffset = 0, yoffset = menu.topLevelHeight, instance = instance, width = Helper.viewWidth, height = Helper.viewHeight - 2 * menu.topLevelHeight, confirmoverwrite = true }
	menu.createContextFrame(nil, nil, nil, nil, 0)
end

function menu.editboxInfoLogbookPageActivated(widget, instance)
	menu.noupdate = true
	if menu.logbookPageEditBox and (widget == menu.logbookPageEditBox.id) then
		C.SetEditBoxText(menu.logbookPageEditBox.id, tostring(menu.infoTablePersistentData[instance].logbookData.curPage))
	end
end

function menu.editboxInfoLogbookPage(instance, text, textchanged)
	local logbookdata = menu.infoTablePersistentData[instance].logbookData
	local newpage = tonumber(text)
	if newpage and (newpage ~= logbookdata.curPage) then
		logbookdata.curPage = math.max(1, math.min(newpage, logbookdata.numPages))
		menu.refreshInfoFrame()
	else
		C.SetEditBoxText(menu.logbookPageEditBox.id, logbookdata.curPage .. " / " .. logbookdata.numPages)
	end
	menu.noupdate = false
end

function menu.orderMoveWait(component, sector, offset, playerprecise, clear)
	if not C.IsOrderSelectableFor("MoveWait", component) then
		return
	end

	if clear then
		C.RemoveAllOrders(component)
	end
	local orderidx = C.CreateOrder(component, "MoveWait", false)
	if orderidx > 0 then
		SetOrderParam(ConvertStringToLuaID(tostring(component)), orderidx, 1, nil, { ConvertStringToLuaID(tostring(sector)), {offset.x, offset.y,offset.z} })
		if playerprecise then
			SetOrderParam(ConvertStringToLuaID(tostring(component)), orderidx, 5, nil, true)
		end
		C.EnableOrder(component, orderidx)
	end

	return orderidx
end

function menu.selectCV(component)
	local convertedComponent = ConvertStringTo64Bit(tostring(component))
	local isplayerowned, isenemy = GetComponentData(convertedComponent, "isplayerowned", "isenemy")
	if (not C.IsBuilderBusy(component)) and (not isenemy) then
		if not isplayerowned then
			local playermoney = GetPlayerMoney()
			local fee = tonumber(C.GetBuilderHiringFee())
			if playermoney >= fee then
				TransferPlayerMoneyTo(fee, convertedComponent)
			else
				return
			end
		end

		menu.orderDeployToStation(component, ConvertIDTo64Bit(menu.modeparam[1]), true)

		Helper.closeMenu(menu, "back")
		menu.cleanup()
	end
end

function menu.orderDeployToStation(component, station, clear)
	if not C.IsOrderSelectableFor("DeployToStation", component) then
		return
	end

	if clear then
		C.RemoveAllOrders(component)
	end
	local orderidx = C.CreateDeployToStationOrder(component)
	if orderidx > 0 then
		SetOrderParam(ConvertStringToLuaID(tostring(component)), orderidx, 1, nil, ConvertStringToLuaID(tostring(station)))
		C.EnableOrder(component, orderidx)
	end
end

function menu.orderAttack(component, target, clear)
	if not C.IsOrderSelectableFor("Attack", component) then
		return
	end

	if clear then
		C.RemoveAllOrders(component)
	end
	local orderidx = C.CreateOrder(component, "Attack", false)
	if orderidx > 0 then
		SetOrderParam(ConvertStringToLuaID(tostring(component)), orderidx, 1, nil, ConvertStringToLuaID(tostring(target)))
		C.EnableOrder(component, orderidx)
	end

	return orderidx
end

function menu.orderAttackMultiple(component, maintarget, secondarytargets, clear)
	if not C.IsOrderSelectableFor("Attack", component) then
		return
	end

	if clear then
		C.RemoveAllOrders(component)
	end
	local orderidx = C.CreateOrder(component, "Attack", false)
	if orderidx > 0 then
		SetOrderParam(ConvertStringToLuaID(tostring(component)), orderidx, 1, nil, ConvertStringToLuaID(tostring(maintarget)))
		for _, secondarytarget in ipairs(secondarytargets) do
			SetOrderParam(ConvertStringToLuaID(tostring(component)), orderidx, 2, nil, ConvertStringToLuaID(tostring(secondarytarget)))
		end
		C.EnableOrder(component, orderidx)
	end

	return orderidx
end

function menu.orderCollectDeployables(component, deployables, clear)
	if not C.IsOrderSelectableFor("CollectDeployables", component) then
		return
	end

	if clear then
		C.RemoveAllOrders(component)
	end
	local orderidx = C.CreateOrder(component, "CollectDeployables", false)
	if orderidx > 0 then
		for _, deployable in ipairs(deployables) do
			SetOrderParam(ConvertStringTo64Bit(tostring(component)), orderidx, 1, nil, ConvertStringToLuaID(tostring(deployable)))
		end
		C.EnableOrder(component, orderidx)
	end

	return orderidx
end

function menu.buttonContextTrade(wareexchange)
	menu.contextMenuMode = "trade"
	menu.contextMenuData = { component = menu.contextMenuData.component, currentShip = menu.contextMenuData.currentShip, shadyOnly = menu.contextMenuData.shadyOnly, orders = {}, xoffset = menu.contextMenuData.xoffset, yoffset = menu.contextMenuData.yoffset, wareexchange = wareexchange }

	local numwarerows, numinforows = menu.initTradeContextData()
	menu.updateTradeContextDimensions(numwarerows, numinforows)

	if menu.contextMenuData.xoffset + menu.tradeContext.width > Helper.viewWidth - Helper.frameBorder then
		menu.contextMenuData.xoffset = Helper.viewWidth - menu.tradeContext.width - Helper.frameBorder
	end
	local height = menu.tradeContext.shipheight + menu.tradeContext.buttonheight + 1 * Helper.borderSize
	if menu.contextMenuData.yoffset + height > Helper.viewHeight - Helper.frameBorder then
		menu.contextMenuData.yoffset = Helper.viewHeight - height - Helper.frameBorder
	end

	menu.createContextFrame(menu.tradeContext.width, height, menu.contextMenuData.xoffset, menu.contextMenuData.yoffset)
end

function menu.buttonContextTradeLoop()
	menu.contextMenuMode = "tradeloop"
	menu.contextMenuData = { component = ConvertStringTo64Bit(tostring(menu.contextMenuData.component)), currentShip = menu.contextMenuData.currentShip, orders = {}, xoffset = menu.contextMenuData.xoffset, yoffset = menu.contextMenuData.yoffset, loop = menu.contextMenuData.loop, reservecargo = true }

	menu.createContextFrame(config.tradeLoopWidth, nil, menu.contextMenuData.xoffset, menu.contextMenuData.yoffset)
end

function menu.buttonContextResearch()
	Helper.closeMenuAndOpenNewMenu(menu, "ResearchMenu", {0, 0}, true)
	menu.cleanup()
end

function menu.buttonConfirmTrade()
	-- Station buys first
	for id, amount in pairs(menu.contextMenuData.orders) do
		if amount > 0 then
			AddTradeToShipQueue(ConvertStringToLuaID(tostring(id)), ConvertStringTo64Bit(tostring(menu.contextMenuData.currentShip)), amount, menu.contextMenuData.immediate)
		end
	end
	-- Station sells
	for id, amount in pairs(menu.contextMenuData.orders) do
		if amount < 0 then
			AddTradeToShipQueue(ConvertStringToLuaID(tostring(id)), ConvertStringTo64Bit(tostring(menu.contextMenuData.currentShip)), -amount, menu.contextMenuData.immediate)
		end
	end
	if menu.contextMenuData.immediate then
		SignalObject(ConvertStringTo64Bit(tostring(C.GetPlayerID())), "docked_player_trade_added", ConvertStringToLuaID(tostring(menu.contextMenuData.immediateObject)))
	end
	menu.closeContextMenu("back")
	if (menu.infoTableMode == "info") and ((menu.infoMode.left == "orderqueue") or (menu.infoMode.left == "orderqueue_advanced")) then
		menu.refreshInfoFrame()
	elseif (menu.infoTableMode == "missionoffer") or (menu.infoTableMode == "mission") then
		menu.refreshIF = getElapsedTime()
	end
	if (menu.searchTableMode == "info") and ((menu.infoMode.right == "orderqueue") or (menu.infoMode.right == "orderqueue_advanced")) then
		menu.refreshInfoFrame2()
	end
end

function menu.buttonConfirmTradeLoop()
	local volume = GetWareData(menu.contextMenuData.ware, "volume")

	local orderidx = C.CreateOrder(menu.contextMenuData.currentShip, menu.contextMenuData.loop, false)
	if orderidx > 0 then
		SetOrderParam(menu.contextMenuData.currentShip, orderidx, 1, nil, menu.contextMenuData.ware)
		SetOrderParam(menu.contextMenuData.currentShip, orderidx, 4, nil, ConvertStringToLuaID(tostring(menu.contextMenuData.component)))
		SetOrderParam(menu.contextMenuData.currentShip, orderidx, 5, nil, (menu.contextMenuData.amount or ((menu.contextMenuData.loop == "SingleBuy") and menu.contextMenuData.max or 0)))
		SetOrderParam(menu.contextMenuData.currentShip, orderidx, 7, nil, (menu.contextMenuData.price or GetWareData(menu.contextMenuData.ware, "avgprice")) * 100)
		C.EnableOrder(menu.contextMenuData.currentShip, orderidx)
	end

	menu.closeContextMenu("back")
	if (menu.infoTableMode == "info") and ((menu.infoMode.left == "orderqueue") or (menu.infoMode.left == "orderqueue_advanced")) then
		menu.refreshInfoFrame()
	elseif (menu.infoTableMode == "missionoffer") or (menu.infoTableMode == "mission") then
		menu.refreshIF = getElapsedTime()
	end
	if (menu.searchTableMode == "info") and ((menu.infoMode.right == "orderqueue") or (menu.infoMode.right == "orderqueue_advanced")) then
		menu.refreshInfoFrame2()
	end
end

function menu.buttonCancelTrade()
	menu.closeContextMenu("back")
end

function menu.buttonDockToTrade()
	local ship = menu.contextMenuData.currentShip
	local container = menu.contextMenuData.component
	if not C.IsOrderSelectableFor("Player_DockToTrade", ship) then
		return
	end
	local orderidx = C.CreateOrder(ship, "Player_DockToTrade", false)
	if orderidx > 0 then
		SetOrderParam(ship, orderidx, 1, nil, ConvertStringToLuaID(tostring(container)))
		C.EnableOrder(ship, orderidx)
	end

	menu.closeContextMenu("back")
end

function menu.buttonMissionAbort()
	C.AbortMission(menu.contextMenuData.missionid)
	menu.closeContextMenu()
	menu.refreshIF = getElapsedTime()
end

function menu.buttonMissionBriefing()
	local missionid
	if menu.contextMenuData.threadMissionID ~= 0 then
		missionid = menu.contextMenuData.threadMissionID
	else
		missionid = menu.contextMenuData.missionid
	end
	menu.closeContextMenu()
	Helper.closeMenuAndOpenNewMenu(menu, "MissionBriefingMenu", { 0, 0, ConvertStringToLuaID(tostring(missionid)), false })
	menu.cleanup()
end

function menu.buttonMissionActivate()
	local active = menu.contextMenuData.missionid == C.GetActiveMissionID()
	for _, submissionEntry in ipairs(menu.contextMenuData.subMissions) do
		if submissionEntry.active then
			active = true
		end
	end
	if active then
		C.SetActiveMission(0)
	else
		C.SetActiveMission(menu.contextMenuData.missionid)
		PlaySound("ui_mission_set_active")

		-- kuertee start: callback
		if callbacks ["buttonMissionActivate_on_activate"] then
			-- get active mission first, because the clicked item may have been a group
			local activeMissionId
			local numMissions = GetNumMissions ()
			for i = 1, numMissions do
				local entry = mapMenu.getMissionInfoHelper (i)
				if entry.active then
					activeMissionId = entry.ID
				end
			end
			for _, callback in ipairs (callbacks ["buttonMissionActivate_on_activate"]) do
				-- callback (menu.contextMenuData.missionid)
				callback (activeMissionId)
			end
		end
		-- kuertee end: callback

	end
	menu.closeContextMenu()
	menu.refreshIF = getElapsedTime()
end

function menu.buttonMissionDeliverWares()
	SignalObject(ConvertStringTo64Bit(tostring(menu.contextMenuData.deliveryWares.target)), "ware_mission_delivery", ConvertStringToLuaID(tostring(menu.contextMenuData.missionid)))
	menu.refreshIF = getElapsedTime()
end

function menu.buttonMissionOfferBriefing()
	local offerid = menu.contextMenuData.missionid
	menu.closeContextMenu()
	Helper.closeMenuAndOpenNewMenu(menu, "MissionBriefingMenu", { 0, 0, offerid, true })
	menu.cleanup()
end

function menu.buttonMissionOfferAccept()
	local offerid = menu.contextMenuData.missionid
	local offeractor = menu.contextMenuData.offeractor
	local onlinechapter = menu.contextMenuData.onlinechapter
	menu.closeContextMenu()

	if onlinechapter ~= "" then
		if C.HasAcceptedOnlineMission() then
			if #menu.missionList["coalition"] > 0 then
				C.AbortMission(ConvertStringTo64Bit(menu.missionList["coalition"][1].ID))
			else
				DebugError("menu.buttonMissionOfferAccept(): Could not find accepted online mission. Aborting.")
				return
			end
		end
	end
	SignalObject(offeractor, "accept", ConvertStringToLuaID(tostring(offerid)))

	if menu.missionOfferList then
		local found = false
		for i, entry in ipairs(menu.missionOfferList["plot"] or {}) do
			if ConvertStringTo64Bit(entry.ID) == offerid then
				found = true
				entry.accepted = true
				menu.highlightLeftBar["mission"] = true
				menu.refreshMainFrame = true
				break
			end
		end
		if not found then
			for _, data in ipairs(menu.missionOfferList["guild"] or {}) do
				for _, entry in ipairs(data.missions) do
					if ConvertStringTo64Bit(entry.ID) == offerid then
						found = true
						entry.accepted = true
						menu.highlightLeftBar["mission"] = true
						menu.refreshMainFrame = true
						break
					end
				end
				if found then
					break
				end
			end
		end
		if not found then
			for i, entry in ipairs(menu.missionOfferList["other"] or {}) do
				if ConvertStringTo64Bit(entry.ID) == offerid then
					found = true
					entry.accepted = true
					menu.highlightLeftBar["mission"] = true
					menu.refreshMainFrame = true
					break
				end
			end
		end
	end
	menu.refreshIF = getElapsedTime()
	if onlinechapter ~= "" then
		menu.refreshMissionContext = { id = offerid, time = menu.refreshIF + 0.1 }
	end
end

function menu.buttonSellShips()
	TransferMoneyToPlayer(menu.contextMenuData.totalprice, menu.contextMenuData.shipyard, "sellship") -- add eventtype
	for i, data in ipairs(menu.contextMenuData.ships) do
		if #data[2] == 0 then
			C.SellPlayerShip(data[1], menu.contextMenuData.shipyard)
		end
	end
	menu.closeContextMenu()
end

function menu.buttonInfoSubMode(mode, col, instance, confirmed)
	if mode ~= menu.infoMode[instance] then
		if (menu.infoMode[instance] == "orderqueue") or (menu.infoMode[instance] == "orderqueue_advanced") then
			if (mode ~= "orderqueue") and (mode ~= "orderqueue_advanced") then
				if not menu.handlePlannedDefaultOrder(instance, confirmed, function () menu.buttonInfoSubMode(mode, col, instance, true) end) then
					return
				end
			end
		end

		menu.infoMode[instance] = mode

		AddUITriggeredEvent(menu.name, menu.infoMode[instance])

		menu.selectedRows["orderHeaderTable" .. instance] = 1
		menu.selectedCols["orderHeaderTable" .. instance] = col
		menu.settoprow = 1
		if instance == "left" then
			menu.refreshInfoFrame(1, 0)
		elseif instance == "right" then
			menu.refreshInfoFrame2(1, 0)
		end
	end
end

function menu.buttonObjectSubMode(mode, col)
	if mode ~= menu.objectMode then
		menu.objectMode = mode

		AddUITriggeredEvent(menu.name, menu.objectMode)

		menu.selectedRows.propertytabs = 1
		menu.selectedCols.propertytabs = col
		menu.refreshInfoFrame(1, col)
	end
end

function menu.buttonPropertySubMode(mode, col)
	if mode ~= menu.propertyMode then
		menu.propertyMode = mode

		AddUITriggeredEvent(menu.name, menu.propertyMode)

		menu.selectedRows.propertytabs = 1
		menu.selectedCols.propertytabs = col
		menu.refreshInfoFrame(1, col)
	end
end

function menu.buttonMissionSubMode(mode, col)
	if mode ~= menu.missionMode then
		menu.closeContextMenu()
		menu.missionMode = mode
		menu.updateMissions()

		AddUITriggeredEvent(menu.name, menu.missionMode)

		menu.missionModeCurrent = "tabs"
		menu.refreshInfoFrame(0, 0)
	end
end

function menu.buttonMissionOfferSubMode(mode, col)
	if mode ~= menu.missionOfferMode then
		menu.closeContextMenu()
		menu.missionOfferMode = mode
		if menu.missionOfferMode ~= "operation" then
			if Helper.hasExtension("multiverse") then
				Helper.callExtensionFunction("multiverse", "unregisterOnlineEvents", menu)
			end
		end
		menu.updateMissionOfferList(true)

		AddUITriggeredEvent(menu.name, menu.missionOfferMode)

		menu.missionModeCurrent = "tabs"
		menu.refreshInfoFrame(0, 0)
	end
end

function menu.buttonVentureSeasonSubMode(mode, col, instance)
	if mode ~= menu.seasonMode[instance] then
		menu.seasonMode[instance] = mode

		AddUITriggeredEvent(menu.name, menu.seasonMode[instance])

		menu.selectedRows["ventureSeasonHeaderTable" .. instance] = 1
		menu.selectedCols["ventureSeasonHeaderTable" .. instance] = col
		menu.settoprow = 1
		if instance == "left" then
			menu.refreshInfoFrame(1, 0, 1, 0)
		elseif instance == "right" then
			menu.refreshInfoFrame2(1, 0, 1, 0)
		end
	end
end

function menu.buttonExpandMissionGroup(id, row, contextCallback)
	menu.missionModeCurrent = id
	if menu.expandedMissionGroups[id] then
		menu.expandedMissionGroups[id] = false
	else
		menu.expandedMissionGroups[id] = true
	end
	menu.setrow = row
	menu.closeContextMenu()
	if contextCallback then
		contextCallback()
	end
	menu.refreshInfoFrame()
end

function menu.onMissionOfferRemoved(event, id)
	if id == menu.contextMenuData.missionid then
		menu.contextMenuData.expired = true

		local desc = Helper.createButton(Helper.createTextInfo(ReadText(1001, 6402), "center", Helper.standardFont, Helper.standardFontSize, 255, 255, 255, 100), nil, false, false, 0, 0, 0, Helper.standardButtonHeight)
		Helper.setCellContent(menu, menu.contextbottomtable, desc, menu.contextMenuData.bottomLines, 1, nil, "button")
		local desc = Helper.createButton(Helper.createTextInfo("-", "center", Helper.standardFont, Helper.standardFontSize, 255, 255, 255, 100), nil, false, false, 0, 0, 0, Helper.standardButtonHeight)
		Helper.setCellContent(menu, menu.contextbottomtable, desc, menu.contextMenuData.bottomLines, 2, nil, "button")
	end
end

function menu.onMissionRemoved(event, id)
	if id == menu.contextMenuData.missionid then
		menu.contextMenuData.expired = true

		local desc = Helper.createButton(Helper.createTextInfo(ReadText(1001, 6403), "center", Helper.standardFont, Helper.standardFontSize, 255, 255, 255, 100), nil, false, false, 0, 0, 0, Helper.standardButtonHeight)
		Helper.setCellContent(menu, menu.contextbottomtable, desc, menu.contextMenuData.bottomLines - 1, 1, nil, "button")
		local desc = Helper.createButton(Helper.createTextInfo("-", "center", Helper.standardFont, Helper.standardFontSize, 255, 255, 255, 100), nil, false, false, 0, 0, 0, Helper.standardButtonHeight)
		Helper.setCellContent(menu, menu.contextbottomtable, desc, menu.contextMenuData.bottomLines - 1, 2, true, "button")
		Helper.setCellContent(menu, menu.contextbottomtable, desc, menu.contextMenuData.bottomLines, 1, nil, "button")
	end
end

function menu.buttonSelectSector()
	if menu.checkForOrderParamObject(menu.currentsector) then
		menu.modeparam[1](ConvertStringToLuaID(tostring(menu.currentsector)))
		AddUITriggeredEvent(menu.name, menu.mode, ConvertStringToLuaID(tostring(menu.currentsector)))
	end
end

function menu.buttonRemoveOrderSyncPoint(orderidx, instance)
	if menu.isInfoModeValidFor(menu.infoSubmenuObject, "orderqueue") then
		local order = menu.infoTableData[instance].orders[orderidx]

		C.RemoveOrderSyncPointID(menu.infoSubmenuObject, orderidx)
		if instance == "left" then
			menu.refreshInfoFrame()
		elseif instance == "right" then
			menu.refreshInfoFrame2()
		end
	else
		DebugError("menu.buttonRemoveOrderSyncPoint: function called with invalid object: " .. ffi.string(C.GetComponentName(menu.infoSubmenuObject)) .. " " .. tostring(menu.infoSubmenuObject))
	end
end

function menu.buttonSetFilterLayer(mode, row, col)
	__CORE_DETAILMONITOR_MAPFILTER[mode] = not __CORE_DETAILMONITOR_MAPFILTER[mode]
	AddUITriggeredEvent(menu.name, mode .. "_toggle", __CORE_DETAILMONITOR_MAPFILTER[mode] and "true" or "false")
	menu.applyFilterSettings()
	menu.refreshMainFrame = true
end

function menu.filterUpdate(_, params)
	local settingid, value = string.match(params, "(.+);(.+)")

	local found = false
	local usesavegame = false
	for mode, settings in pairs(config.layersettings) do
		for _, setting in ipairs(settings) do
			if setting.id == settingid then
				found = true
				usesavegame = setting.savegame
				break
			end
			for _, option in ipairs(setting) do
				if option.id == settingid then
					found = true
					usesavegame = setting.savegame
					break
				end
			end
		end
		if found then
			break
		end
	end

	if value == "true" then
		value = true
	elseif value == "false" then
		value = false
	else
		value = tonumber(value) or 0
	end

	local settings = usesavegame and __CORE_DETAILMONITOR_MAPFILTER_SAVE or __CORE_DETAILMONITOR_MAPFILTER
	settings[settingid] = value
	menu.refreshFilterSettings = true
end

function menu.buttonFilterSwitch(mode, row, col)
	if menu.displayedFilterLayer ~= mode then
		menu.displayedFilterLayer = mode

		AddUITriggeredEvent(menu.name, menu.displayedFilterLayer)

		menu.refreshMainFrame = true
	end
end

function menu.buttonWeaponConfig(component, orderidx, usedefault, instance)
	menu.contextMenuMode = "weaponconfig"
	menu.contextMenuData = { component = component, orderidx = orderidx, usedefault = usedefault, weaponsystems = {}, instance = instance }

	local n = C.GetNumAllowedWeaponSystems()
	local buf = ffi.new("WeaponSystemInfo[?]", n)
	n = C.GetAllowedWeaponSystems(buf, n, ConvertIDTo64Bit(component), menu.contextMenuData.orderidx or 0, menu.contextMenuData.usedefault)
	for i = 0, n - 1 do
		table.insert(menu.contextMenuData.weaponsystems, { id = ffi.string(buf[i].id), name = ffi.string(buf[i].name), active = buf[i].active })
	end
	if not menu.contextMenuData.usedefault then
		for _, entry in ipairs(menu.contextMenuData.weaponsystems) do
			if entry.id == "default" then
				menu.contextMenuData.default = entry.active
			end
		end
	end

	local offsetx = menu.infoTableOffsetX + menu.infoTableWidth + config.contextBorder
	if instance == "right" then
		offsetx = Helper.viewWidth - offsetx - config.orderqueueContextWidth
	end
	menu.createContextFrame(config.orderqueueContextWidth, Helper.viewHeight - menu.infoTableOffsetY, offsetx, menu.infoTableOffsetY)
end

function menu.buttonClearWeaponConfig()
	for i, entry in ipairs(menu.contextMenuData.weaponsystems) do
		menu.contextMenuData.weaponsystems[i].active = false
	end
	menu.createContextFrame()
end

function menu.buttonCancelWeaponConfig()
	menu.closeContextMenu()
end

function menu.buttonConfirmWeaponConfig()
	local weaponsystems = ffi.new("WeaponSystemInfo[?]", #menu.contextMenuData.weaponsystems)
	for i, entry in ipairs(menu.contextMenuData.weaponsystems) do
		weaponsystems[i - 1].id = Helper.ffiNewString(entry.id)
		weaponsystems[i - 1].active = entry.active
	end
	C.SetAllowedWeaponSystems(menu.contextMenuData.component, menu.contextMenuData.orderidx or 0, menu.contextMenuData.usedefault, weaponsystems, #menu.contextMenuData.weaponsystems)
	menu.closeContextMenu()
end

function menu.buttonHire()
	local playerMoney = GetPlayerMoney()
	local npcseed = C.ConvertStringTo64Bit(tostring(menu.modeparam[4]))
	local npc, object
	if npcseed ~= 0 then
		object = ConvertIDTo64Bit(menu.modeparam[2])
	else
		npc = ConvertIDTo64Bit(menu.modeparam[2])
	end
	local ishiring = menu.modeparam[3] ~= 0
	local fee
	if ishiring and npc then
		fee = GetNPCBlackboard(npc, "$HiringFee")
	else
		fee = 0
	end
	if fee then
		fee = RoundTotalTradePrice(fee) * menu.hiringdiscounts.totalfactor
	else
		DebugError("menu.buttonHire(): Could not find hiring fee. [Florian]")
		fee = 0
	end

	if (not ishiring) or (playerMoney >= fee) then
		C.ClearMapObjectFilter(menu.holomap)
		if ishiring then
			TransferPlayerMoneyTo(fee, GetContextByClass(npc or object, "container", true))
		end
		if menu.contextMenuData.hireIsMission then
			if npc then
				SignalObject(ConvertStringTo64Bit(tostring(menu.contextMenuData.hireObject)), "npc_mission_delivery", ConvertStringToLuaID(menu.contextMenuData.hireRole), ConvertStringToLuaID(tostring(npc)))
				menu.closeContextMenu()
				menu.onCloseElement("close")
			else
				C.SignalObjectWithNPCSeedAndMissionID(menu.contextMenuData.hireObject, "npctemplate_mission_delivery", ConvertStringTo64Bit(menu.contextMenuData.hireRole), npcseed, object)
				menu.closeContextMenu()
				menu.onCloseElement("back")
			end
		elseif menu.modeparam[1] == "signal" then
			-- actor must be either entity or person (controllable and seed)
			local actor = { entity = npc, personcontrollable = object, personseed = npcseed }
			C.AssignHiredActor(actor, menu.contextMenuData.hireObject, menu.contextMenuData.hireIsPost and menu.contextMenuData.hireRole or nil, not menu.contextMenuData.hireIsPost and menu.contextMenuData.hireRole or nil, false)
			menu.closeContextMenu()
			menu.onCloseElement("back")
		else
			Helper.closeMenuForSection(menu, menu.modeparam[1], { ConvertStringToLuaID(tostring(menu.contextMenuData.hireObject)), menu.contextMenuData.hireRole, menu.contextMenuData.hireIsPost })
			menu.cleanup()
		end
	else
		menu.closeContextMenu()
		menu.refreshMainFrame = true
	end
end

function menu.buttonSelectHandler()
	if menu.mode == "selectCV" then
		menu.selectCV(menu.contextMenuData.component)
	elseif menu.mode == "orderparam_object" then
		if menu.checkForOrderParamObject(menu.contextMenuData.component) then
			AddUITriggeredEvent(menu.name, menu.mode, ConvertStringToLuaID(tostring(menu.contextMenuData.component)))
			menu.modeparam[1](ConvertStringToLuaID(tostring(menu.contextMenuData.component)))
		end
	elseif menu.mode == "selectComponent" then

		-- kuertee start: callback
		if menu.modeparam[6] ~= nil then
			-- if selectComponent returnsection is nil, then do a AddUITriggeredEvent instead
			-- DebugError ("kuertee_menu_map.ui.buttonSelectHandler menu.contextMenuData.component " .. tostring (menu.contextMenuData.component))
			-- DebugError ("kuertee_menu_map.ui.buttonSelectHandler menu.contextMenuData.component " .. tostring (ConvertStringToLuaID (tostring (menu.contextMenuData.component))))
			AddUITriggeredEvent (menu.modeparam[6], "select_component", ConvertStringToLuaID (tostring (menu.contextMenuData.component)))
			menu.mode = menu.old_mode
			menu.modeparam = menu.old_modeparam
			menu.infoTableMode = menu.old_infoTableMode
			menu.closeContextMenu()
			menu.refreshMainFrame = true
			menu.refreshInfoFrame()
			return

			-- DebugError ("kuertee_menu_map buttonSelectHandler menu.modeparam [1]: " .. tostring (menu.modeparam [1]))
			-- if menu.checkForSelectComponent(menu.contextMenuData.component) then
		elseif menu.checkForSelectComponent(menu.contextMenuData.component) then
			-- kuertee end: callback

			C.ClearMapObjectFilter(menu.holomap)
			Helper.closeMenuForSection(menu, menu.modeparam[1], { ConvertStringToLuaID(tostring(menu.contextMenuData.component)) })
			menu.cleanup()
		end
	end
	menu.closeContextMenu()
end

function menu.buttonRemoveAssignment()
	if C.RemoveCommander2(menu.infoSubmenuObject) then
		C.CreateOrder(menu.infoSubmenuObject, "Wait", true)
		C.EnablePlannedDefaultOrder(menu.infoSubmenuObject, false)
	end

	menu.refreshInfoFrame()
end

function menu.plotModeUpdateValue(dimension, valchange)
	local axis = "x"
	local bigaxis = "X"
	if dimension == "posY" or dimension == "negY" then
		axis = "y"
		bigaxis = "Y"
	elseif dimension == "posZ" or dimension == "negZ" then
		axis = "z"
		bigaxis = "Z"
	end
	menu.plotData.size[axis] = menu.plotData.dimensions["pos" .. bigaxis] + menu.plotData.dimensions["neg" .. bigaxis]
	menu.plotModeUpdatePrice()
	menu.updatePlotSize(dimension, axis, valchange)
end

function menu.plotModeUpdatePrice()
	if not menu.plotData.price then
		return
	end
	--print("size.x: " .. tostring(menu.plotData.size.x * 1000) .. ", boughtrawsize.x: " .. tostring(menu.plotData.boughtrawsize.x) .. ". size.y: " .. tostring(menu.plotData.size.y * 1000) .. ", boughtrawsize.y: " .. tostring(menu.plotData.boughtrawsize.y) .. ". size.z: " .. tostring(menu.plotData.size.z * 1000) .. ", boughtrawsize.z: " .. tostring(menu.plotData.boughtrawsize.z))
	local numchanged = 3
	local x = menu.plotData.size.x * 1000
	if x == menu.plotData.boughtrawsize.x then
		numchanged = numchanged - 1
	end
	local y = menu.plotData.size.y * 1000
	if y == menu.plotData.boughtrawsize.y then
		numchanged = numchanged - 1
	end
	local z = menu.plotData.size.z * 1000
	if z == menu.plotData.boughtrawsize.z then
		numchanged = numchanged - 1
	end

	local owner = GetComponentData(ConvertStringTo64Bit(tostring(menu.plotData.component)), "owner")
	local buf = ffi.new("bool[1]", 0)
	local plotpayment = tonumber(C.GetBuildPlotPayment(menu.plotData.component, buf))
	local haspositionchanged = buf[0]
	menu.plotData.price = tonumber(C.GetBuildPlotPrice(menu.plotData.sector, menu.plotData.position, x, y, z, owner)) - plotpayment
	menu.plotData.affordable = GetPlayerMoney() >= menu.plotData.price

	menu.plotData.fullypaid = menu.plotData.price <= 0
end

function menu.buttonBuyPlot()
	local station = menu.plotData.component
	local size = { x = menu.plotData.size.x * 1000, y = menu.plotData.size.y * 1000, z = menu.plotData.size.z * 1000 }
	if not menu.plotData.price or GetPlayerMoney() < menu.plotData.price then
		DebugError("menu.buttonBuyPlot() called but there is no price or the player cannot afford the plot. price: " .. tostring(menu.plotData.price) .. ", player cash: " .. tostring(GetPlayerMoney()))
		return
	end
	local offset = C.GetBuildPlotCenterOffset(station)
	for _, plot in ipairs(menu.plots) do
		if plot.station == station then
			plot.boughtrawcenteroffset = offset
			break
		end
	end
	local controlstation = C.GetSectorControlStation(menu.plotData.sector)
	TransferPlayerMoneyTo(menu.plotData.price, ConvertStringTo64Bit(tostring(controlstation)))
	C.PayBuildPlotSize(station, size, offset)
	menu.updatePlotData(nil, true)
	menu.refreshInfoFrame()
end

function menu.buttonDropPilotInventory(pilot, wares)
	menu.contextMenuMode = "dropwares"
	menu.contextMenuData = { mode = "inventory", entity = pilot, wares = wares }

	local height = (#wares + 4) * (Helper.scaleY(config.mapRowHeight) + Helper.borderSize)
	local offsetx = menu.infoTableOffsetX + menu.infoTableWidth + config.contextBorder
	if instance == "right" then
		offsetx = Helper.viewWidth - offsetx - config.dropInventoryWidth
	end
	local offsety = (Helper.viewHeight + menu.infoTableOffsetY - height) / 2
	if offsety + height > Helper.viewHeight then
		offsety = menu.infoTableOffsetY
	end

	menu.createContextFrame(config.dropInventoryWidth, nil, offsetx, offsety)
end

function menu.buttonFireCrew(instance, object)
	for _, entry in ipairs(menu.infoTablePersistentData[instance].crew.unassigned.persons) do
		C.RemovePerson(object, entry.person)
	end

	menu.closeContextMenu()
	menu.updatePeopleInfo = getElapsedTime()
end

function menu.buttonConfirmUserQuestion()
	if menu.contextMenuData.saveOption then
		__CORE_DETAILMONITOR_USERQUESTION[menu.contextMenuData.mode] = true
	end

	if menu.contextMenuData.mode == "markashostile" then
		C.SetRelationBoostToFaction(menu.contextMenuData.controllable, "player", "markedashostile", -1, 1, 600)
		menu.closeContextMenu()
	end
end

function menu.buttonObjectSorter(sorttype)
	if menu.objectSorterType == sorttype then
		menu.objectSorterType = sorttype .. "inverse"
	else
		menu.objectSorterType = sorttype
	end
	menu.refreshInfoFrame()
end

function menu.buttonPropertySorter(sorttype)
	if menu.propertySorterType == sorttype then
		menu.propertySorterType = sorttype .. "inverse"
	else
		menu.propertySorterType = sorttype
	end
	menu.refreshInfoFrame()
end

function menu.buttonDeploy(instance)
	local infomacrostolaunch = menu.infoTablePersistentData[instance].macrostolaunch
	if next(infomacrostolaunch) then
		if infomacrostolaunch.mine then
			C.LaunchMine(menu.infoSubmenuObject, infomacrostolaunch.mine)
		elseif infomacrostolaunch.navbeacon then
			C.LaunchNavBeacon(menu.infoSubmenuObject, infomacrostolaunch.navbeacon)
		elseif infomacrostolaunch.satellite then
			C.LaunchSatellite(menu.infoSubmenuObject, infomacrostolaunch.satellite)
		elseif infomacrostolaunch.lasertower then
			C.LaunchLaserTower(menu.infoSubmenuObject, infomacrostolaunch.lasertower)
		elseif infomacrostolaunch.resourceprobe then
			C.LaunchResourceProbe(menu.infoSubmenuObject, infomacrostolaunch.resourceprobe)
		end
		menu.refreshInfoFrame()
	end
end

function menu.buttonLogbookInteraction(entry)
	if IsValidComponent(entry.interactioncomponent) then
		if entry.interaction == "showonmap" then
			C.SetFocusMapComponent(menu.holomap, ConvertIDTo64Bit(entry.interactioncomponent), true)
		elseif entry.interaction == "guidance" then
			local convertedInteractionComponent = ConvertIDTo64Bit(entry.interactioncomponent)
			if convertedInteractionComponent ~= C.GetPlayerControlledShipID() then
				local offset = ffi.new("UIPosRot", 0)
				C.SetGuidance(convertedInteractionComponent, offset)
			end
		end
	else
		menu.refreshInfoFrame()
	end
end

function menu.buttonInfoLogbookClearQuestion(instance)
	menu.contextMenuMode = "userquestion"
	menu.contextMenuData = { mode = "clearlogbook", xoffset = (Helper.viewWidth - Helper.scaleX(400)) / 2, yoffset = Helper.viewHeight / 2, instance = instance }

	menu.createContextFrame(Helper.scaleX(400), nil, menu.contextMenuData.xoffset, menu.contextMenuData.yoffset)
end

function menu.buttonInfoLogbookClear(instance)
	menu.closeContextMenu()
	local logbookdata = menu.infoTablePersistentData[instance].logbookData
	if #logbookdata.logbook > 0 then
		for i = #logbookdata.logbook, 1, -1 do
			local entry = logbookdata.logbook[i]
			RemoveLogbookEntry(entry.index)
		end
		menu.refreshInfoFrame()
	end
end

function menu.buttonEditTradeRule()
	Helper.closeMenuAndOpenNewMenu(menu, "PlayerInfoMenu", { 0, 0, "globalorders" })
	menu.cleanup()
end

function menu.buttonEditBlacklist()
	Helper.closeMenuAndOpenNewMenu(menu, "PlayerInfoMenu", { 0, 0, "globalorders" })
	menu.cleanup()
end

function menu.buttonEditFightRule()
	Helper.closeMenuAndOpenNewMenu(menu, "PlayerInfoMenu", { 0, 0, "globalorders" })
	menu.cleanup()
end

function menu.slidercellPlotValue(_, value, dimension, fullsize)
	if not dimension then
		DebugError("menu.slidercellPlotValue(): no dimension passed in.")
		return
	end

	local shiftpressed = C.IsShiftPressed()
	local dimensions = { dimension }
	if shiftpressed then
		dimensions = {
			[1] = "posX",
			[2] = "negX",
			[3] = "posY",
			[4] = "negY",
			[5] = "posZ",
			[6] = "negZ",
		}

		value = math.min(value, config.maxPlotSize / 2)
	end

	if fullsize then
		for i, dimension2 in ipairs(dimensions) do
			menu.plotData.size[dimension2] = value
		end
		menu.updatePlotSize()
	else
		for i, dimension2 in ipairs(dimensions) do
			local minimumdimension = menu.plotData.minimumdimensions[dimension2] or 0
			local locvalue = math.max(value, minimumdimension)

			local valchange = locvalue - menu.plotData.dimensions[dimension2]
			menu.plotData.dimensions[dimension2] = locvalue
			menu.plotModeUpdateValue(dimension2, valchange)
		end
		if shiftpressed then
			menu.updatePlotSliders()
		end
	end
end

function menu.tradeContextCostAndStorageUpdateHelper(storagetype, ware)
	menu.updateTradeCost()
	if not menu.contextMenuData.wareexchange then
		-- profit
		local profit = menu.contextMenuData.referenceprofit
		local profitcolor = Color["text_normal"]
		if profit < 0 then
			profitcolor = Color["text_negative"]
		elseif profit > 0 then
			profitcolor = Color["text_positive"]
		end
		Helper.updateCellText(menu.contextbuttontable, menu.tradeContext.numinforows + 1, 3 + menu.tradeContext.coloffset, ConvertMoneyString(profit, false, true, nil, true) .. " " .. ReadText(1001, 101), profitcolor)
		-- transaction value
		local total = menu.contextMenuData.totalbuyprofit - menu.contextMenuData.totalsellcost
		local transactioncolor = Color["text_normal"]
		if total < 0 then
			transactioncolor = Color["text_negative"]
		elseif total > 0 then
			transactioncolor = Color["text_positive"]
		end
		Helper.updateCellText(menu.contextbuttontable, menu.tradeContext.numinforows + 2, 3 + menu.tradeContext.coloffset, ConvertMoneyString(total, false, true, nil, true) .. " " .. ReadText(1001, 101), transactioncolor)
	end
	-- ship
	for i, waredata in ipairs(menu.contextMenuData.waredatalist) do
		if waredata.ware == ware then
			local content = menu.getTradeContextRowContent(waredata)
			if content[2].text then
				Helper.updateCellText(menu.contextshiptable, 4 + i, 2, content[2].text, content[2].color)
			end
			if content[3].text then
				Helper.updateCellText(menu.contextshiptable, 4 + i, 3, content[3].text, content[3].color)
			end
			if content[6].text then
				Helper.updateCellText(menu.contextshiptable, 4 + i, waredata.sellcol, content[6].text, content[6].color)
			end
			if content[7].text then
				Helper.updateCellText(menu.contextshiptable, 4 + i, waredata.buycol, content[7].text, content[7].color)
			end
			break
		end
	end

	-- storage
	local storagecontent = menu.getTradeContextShipStorageContent()
	for i, content in ipairs(storagecontent) do
		if i <= menu.tradeContext.numinforows then
			Helper.setSliderCellValue(menu.contextbuttontable, 2 + i, 1, content.scale.start)
		end
	end
	if menu.contextMenuData.wareexchange then
		storagecontent = menu.getTradeContextShipStorageContent(true)
		for i, content in ipairs(storagecontent) do
			if i <= menu.tradeContext.numinforows then
				Helper.setSliderCellValue(menu.contextbuttontable, 2 + i, 2, content.scale.start)
			end
		end
	end
end

function menu.orderAmountHelper(sellid, buyid, newvalue)
	if newvalue > 0 then
		if sellid then
			menu.contextMenuData.orders[ConvertIDTo64Bit(sellid)] = 0
		end
		if buyid then
			menu.contextMenuData.orders[ConvertIDTo64Bit(buyid)] = newvalue
		end
	elseif newvalue < 0 then
		if sellid then
			menu.contextMenuData.orders[ConvertIDTo64Bit(sellid)] = newvalue
		end
		if buyid then
			menu.contextMenuData.orders[ConvertIDTo64Bit(buyid)] = 0
		end
	else
		if sellid then
			menu.contextMenuData.orders[ConvertIDTo64Bit(sellid)] = 0
		end
		if buyid then
			menu.contextMenuData.orders[ConvertIDTo64Bit(buyid)] = 0
		end
	end
end

function menu.slidercellBoardingAssignedMarines(ship, marinelevel, newvalue)
	local change = newvalue - menu.boardingData.shipdata[ship].assignedgroupmarines[marinelevel]
	--print("assigned group marines: " .. menu.boardingData.shipdata[ship].assignedgroupmarines[marinelevel] .. ", newvalue: " .. tostring(newvalue) .. ", change: " .. tostring(change))

	menu.boardingData.shipdata[ship].assignedgroupmarines[marinelevel] = newvalue
	--print("recording " .. tostring(newvalue) .. " assigned group marines from " .. ffi.string(C.GetComponentName(ship)))

	if (change > 0) then
		--print("adding")
		if (newvalue > menu.boardingData.shipdata[ship].marines[marinelevel]) then
			local numtoadd = menu.boardingData.shipdata[ship].marines[marinelevel]
			local remaining = newvalue - numtoadd
			menu.boardingData.shipdata[ship].assignedmarines[marinelevel] = numtoadd
			--print("recording " .. tostring(numtoadd) .. " assigned marines from " .. ffi.string(C.GetComponentName(ship)) .. ". remaining: " .. tostring(remaining))

			if remaining > 0 then
				for _, subordinate in ipairs(menu.boardingData.shipdata[ship].subordinates) do
					--print("subordinate: " .. ffi.string(C.GetComponentName(subordinate)) .. " " .. tostring(subordinate) .. " level: " .. tostring(marinelevel) .. ", subordinate marines: " .. tostring(menu.boardingData.shipdata[subordinate].marines[marinelevel]) .. ", assigned subordinate marines: " .. tostring(menu.boardingData.shipdata[subordinate].assignedmarines[marinelevel]))
					if menu.boardingData.shipdata[subordinate].marines[marinelevel] and (menu.boardingData.shipdata[subordinate].marines[marinelevel] > 0) then
						numtoadd = math.min(remaining, menu.boardingData.shipdata[subordinate].marines[marinelevel])
						remaining = remaining - numtoadd
						menu.boardingData.shipdata[subordinate].assignedmarines[marinelevel] = numtoadd
						--print("recording " .. tostring(numtoadd) .. " assigned marines from " .. ffi.string(C.GetComponentName(subordinate)) .. ". remaining: " .. tostring(remaining))
						if remaining < 1 then
							--print("done adding")
							break
						end
					end
				end
			end
		else
			menu.boardingData.shipdata[ship].assignedmarines[marinelevel] = newvalue
			--print("recording " .. tostring(menu.boardingData.shipdata[ship].assignedmarines[marinelevel]) .. " assigned marines from " .. ffi.string(C.GetComponentName(ship)))
		end
	else
		--print("removing. change: " .. tostring(change) .. ", numassignedmarines: " .. tostring(menu.boardingData.shipdata[ship].assignedmarines[marinelevel]))
		if (-change > menu.boardingData.shipdata[ship].assignedmarines[marinelevel]) then
			local numtosubtract = menu.boardingData.shipdata[ship].assignedmarines[marinelevel]
			local remaining = -change - numtosubtract
			menu.boardingData.shipdata[ship].assignedmarines[marinelevel] = menu.boardingData.shipdata[ship].assignedmarines[marinelevel] - numtosubtract

			if remaining > 0 then
				for _, subordinate in ipairs(menu.boardingData.shipdata[ship].subordinates) do
					--print("subordinate: " .. ffi.string(C.GetComponentName(subordinate)) .. " " .. tostring(subordinate) .. " level: " .. tostring(marinelevel) .. ", assigned subordinate marines: " .. tostring(menu.boardingData.shipdata[subordinate].assignedmarines[marinelevel]))
					if (menu.boardingData.shipdata[subordinate].assignedmarines[marinelevel] > 0) then
						numtosubtract = math.min(remaining, menu.boardingData.shipdata[subordinate].assignedmarines[marinelevel])
						remaining = remaining - numtosubtract
						menu.boardingData.shipdata[subordinate].assignedmarines[marinelevel] = menu.boardingData.shipdata[subordinate].assignedmarines[marinelevel] - numtosubtract
						--print("recording removal of " .. tostring(numtosubtract) .. " assigned marines from " .. ffi.string(C.GetComponentName(subordinate)) .. ". remaining: " .. tostring(remaining))
						if remaining < 1 then
							--print("done removing")
							break
						end
					end
				end
			end
		else
			menu.boardingData.shipdata[ship].assignedmarines[marinelevel] = menu.boardingData.shipdata[ship].assignedmarines[marinelevel] + change
			--print("recording " .. tostring(menu.boardingData.shipdata[ship].assignedmarines[marinelevel]) .. " assigned marines from " .. ffi.string(C.GetComponentName(ship)))
		end
	end
	menu.boardingData.changed = true
end

function menu.slidercellShipCargo(sellid, buyid, ware, cargoamount, value)
	menu.tradeAmountChanged = ware

	local oldsellvalue = sellid and (menu.contextMenuData.orders[ConvertIDTo64Bit(sellid)] or 0) or 0
	local oldbuyvalue = buyid and (menu.contextMenuData.orders[ConvertIDTo64Bit(buyid)] or 0) or 0
	menu.orderAmountHelper(sellid, buyid, cargoamount - value)
	local newsellvalue = sellid and (menu.contextMenuData.orders[ConvertIDTo64Bit(sellid)] or 0) or 0
	local newbuyvalue = buyid and (menu.contextMenuData.orders[ConvertIDTo64Bit(buyid)] or 0) or 0

	local change = oldsellvalue - newsellvalue + oldbuyvalue - newbuyvalue
	if change > 0 then
		change = AddCargo(ConvertStringToLuaID(tostring(menu.contextMenuData.currentShip)), ware, change, true)
		if menu.contextMenuData.wareexchange then
			RemoveCargo(ConvertStringToLuaID(tostring(menu.contextMenuData.component)), ware, change, true)
		end
	elseif change < 0 then
		if menu.contextMenuData.wareexchange then
			change = -AddCargo(ConvertStringToLuaID(tostring(menu.contextMenuData.component)), ware, -change, true)
		end
		RemoveCargo(ConvertStringToLuaID(tostring(menu.contextMenuData.currentShip)), ware, -change, true)
	end

	-- fix order amounts in case adding cargo failed
	value = cargoamount - oldsellvalue - oldbuyvalue + change
	menu.orderAmountHelper(sellid, buyid, cargoamount - value)

	menu.tradeContextCostAndStorageUpdateHelper("cargo", ware)
end

function menu.slidercellShipAmmo(sellid, buyid, ware, ammoamount, value)
	menu.tradeAmountChanged = ware

	local oldsellvalue = sellid and (menu.contextMenuData.orders[ConvertIDTo64Bit(sellid)] or 0) or 0
	local oldbuyvalue = buyid and (menu.contextMenuData.orders[ConvertIDTo64Bit(buyid)] or 0) or 0
	menu.orderAmountHelper(sellid, buyid, ammoamount - value)
	local newsellvalue = sellid and (menu.contextMenuData.orders[ConvertIDTo64Bit(sellid)] or 0) or 0
	local newbuyvalue = buyid and (menu.contextMenuData.orders[ConvertIDTo64Bit(buyid)] or 0) or 0

	local waremacro = GetWareData(ware, "component")
	local change = oldsellvalue - newsellvalue + oldbuyvalue - newbuyvalue
	if change > 0 then
		change = AddAmmo(ConvertStringToLuaID(tostring(menu.contextMenuData.currentShip)), waremacro, change, false, true)
		if menu.contextMenuData.wareexchange then
			RemoveAmmo(ConvertStringToLuaID(tostring(menu.contextMenuData.component)), waremacro, change, false, true)
		end
	elseif change < 0 then
		if menu.contextMenuData.wareexchange then
			change = -AddAmmo(ConvertStringToLuaID(tostring(menu.contextMenuData.component)), waremacro, -change, false, true)
		end
		RemoveAmmo(ConvertStringToLuaID(tostring(menu.contextMenuData.currentShip)), waremacro, -change, false, true)
	end

	-- fix order amounts in case adding cargo failed
	value = ammoamount - oldsellvalue - oldbuyvalue + change
	menu.orderAmountHelper(sellid, buyid, ammoamount - value)

	menu.tradeContextCostAndStorageUpdateHelper("ammo", ware)
end

function menu.onSliderCellDown()
	if menu.contextMenuMode == "trade" then
		menu.tradeSliderLock = true
	end
end

function menu.onSliderCellActivated()
	if menu.contextMenuMode == "trade" then
		menu.tradeSliderLock = true
	end
end

function menu.slidercellTradeConfirmed(ware)
	if menu.tradeAmountChanged then
		menu.tradeAmountChanged = nil
		menu.showOptionalWarningWare = nil
	else
		menu.showOptionalWarningWare = ware
	end

	--menu.topRows.contextoffertable = GetTopRow(menu.contextoffertable)
	--menu.selectedRows.contextoffertable = Helper.currentTableRow[menu.contextoffertable]
	menu.topRows.contextshiptable = GetTopRow(menu.contextshiptable)
	menu.selectedRows.contextshiptable = Helper.currentTableRow[menu.contextshiptable]
	menu.tradeSliderLock = nil
	menu.createContextFrame()
end

function menu.slidercellStorageWarePriceOverride(container, ware, buysellswitch, value)
	if value then
		SetContainerWarePriceOverride(container, ware, buysellswitch, value)
	end
end

function menu.dropdownBoardingSetAction(ship, newaction)
	menu.boardingData.shipdata[ship].action = newaction
	menu.boardingData.changed = true
end

function menu.dropdownBoardingSetRisk(newrisklevel, phaseindex)
	--print("newrisklevel: " .. tostring(newrisklevel))
	local stage = ("risk" .. phaseindex)
	menu.boardingData[stage] = newrisklevel
	menu.boardingData.changed = true
end

function menu.dropdownShip(_, shipid)
	local shipid64 = ConvertStringTo64Bit(shipid)
	if shipid64 ~= menu.contextMenuData.currentShip then
		if C.IsComponentOperational(menu.contextMenuData.currentShip) then
			SetVirtualCargoMode(ConvertStringToLuaID(tostring(menu.contextMenuData.currentShip)), false)
		end

		menu.contextMenuData.currentShip = shipid64
		SetVirtualCargoMode(ConvertStringToLuaID(tostring(menu.contextMenuData.currentShip)), false)

		menu.contextMenuData.orders = {}

		menu.initTradeContextData()

		--menu.topRows.contextoffertable = GetTopRow(menu.contextoffertable)
		--menu.selectedRows.contextoffertable = Helper.currentTableRow[menu.contextoffertable]
		menu.topRows.contextshiptable = GetTopRow(menu.contextshiptable)
		menu.selectedRows.contextshiptable = Helper.currentTableRow[menu.contextshiptable]
		menu.createContextFrame()
	end
end

function menu.dropdownNewSyncPoint(orderidx, idstring)
	if menu.isInfoModeValidFor(menu.infoSubmenuObject, "orderqueue") then
		local id = tonumber(idstring)

		if id == 0 then
			C.RemoveOrderSyncPointID(menu.infoSubmenuObject, orderidx)
		else
			C.SetOrderSyncPointID(menu.infoSubmenuObject, orderidx, id, false)
		end

		menu.refreshInfoFrame()
	else
		DebugError("menu.dropdownNewSyncPoint: function called with invalid object: " .. ffi.string(C.GetComponentName(menu.infoSubmenuObject)) .. " " .. tostring(menu.infoSubmenuObject))
	end
end

function menu.dropdownChangeOverrideOrder(idstring, attacker, instance)
	-- remove all override orders
	for i = #menu.infoTableData[instance].orders, 1, -1 do
		local entry = menu.infoTableData[instance].orders[i]
		if entry.isoverride then
			menu.removeOrder(i, instance)
		end
	end

	local orderidx
	if idstring == "Flee" then
		orderidx = C.CreateOrder3(menu.infoSubmenuObject, "Flee", false, true, true)
		if orderidx > 0 then
			SetOrderParam(menu.infoSubmenuObject, orderidx, 1, nil, 'boost')
			SetOrderParam(menu.infoSubmenuObject, orderidx, 3, nil, true)
			SetOrderParam(menu.infoSubmenuObject, orderidx, 4, nil, true)
			if attacker then
				SetOrderParam(menu.infoSubmenuObject, orderidx, 6, nil, ConvertStringToLuaID(tostring(attacker)))
			end
		end
	elseif idstring == "Attack" then
		orderidx = C.CreateOrder3(menu.infoSubmenuObject, "Attack", false, true, true)
		if orderidx > 0 then
			if attacker then
				SetOrderParam(menu.infoSubmenuObject, orderidx, 1, nil, ConvertStringToLuaID(tostring(attacker)))
			end
		end
	elseif idstring == "Wait" then
		orderidx = C.CreateOrder3(menu.infoSubmenuObject, "Wait", false, true, true)
		if orderidx > 0 then
			SetOrderParam(menu.infoSubmenuObject, orderidx, 4, nil, true)
			if attacker then
				SetOrderParam(menu.infoSubmenuObject, orderidx, 5, nil, ConvertStringToLuaID(tostring(attacker)))
			end
		end
	end

	if orderidx > 0 then
		C.EnableOrder(menu.infoSubmenuObject, orderidx)
		local newidx = 1
		if not C.AdjustOrder(menu.infoSubmenuObject, orderidx, newidx, true, false, true) then
			newidx = 2
		end
		C.AdjustOrder(menu.infoSubmenuObject, orderidx, newidx, true, false, false)
	end

	menu.noupdate = false
end

function menu.buttonReleaseSyncPoint(syncpointinfo)
	if syncpointinfo.id > 0 then
		C.ReleaseOrderSyncPoint(syncpointinfo.id)
	else
		C.ReleaseOrderSyncPointFromOrder(syncpointinfo.owningcontrollable, syncpointinfo.owningorderidx)
	end
	menu.refreshInfoFrame()
end

function menu.buttonContextSetLogo(logo)
	menu.contextMenuData.currentlogo = logo
	C.SetFleetLogo(menu.contextMenuData.component, logo)
end

function menu.buttonChangeLogoCancel()
	C.SetFleetLogo(menu.contextMenuData.component, menu.contextMenuData.origlogo)
	menu.closeContextMenu("back")
end

function menu.dropdownModuleSet(_, idstring)
	menu.plotData.set = idstring
	menu.noupdate = false
end

-- mode: "factionresponses", "controllableresponses"
function menu.dropdownOrdersSetResponse(_, newresponseid, factionorcontrollable, signalid, mode)
	if mode ~= "factionresponses" and mode ~= "controllableresponses" then
		DebugError("menu.dropdownOrdersSetResponse called with invalid mode set. only 'factionresponses' and 'controllableresponses' are supported at this time. mode: " .. tostring(mode))
		return
	elseif not factionorcontrollable then
		DebugError("menu.dropdownOrdersSetResponse called with invalid faction or controllable set. factionorcontrollable: " .. tostring(factionorcontrollable))
		return
	elseif not signalid then
		DebugError("menu.dropdownOrdersSetResponse called with invalid signal id set. signalid: " .. tostring(signalid))
		return
	end

	if newresponseid == "reset" then
		if mode == "controllableresponses" then
			if not C.ResetResponseToSignalForControllable(signalid, factionorcontrollable) then
				DebugError("Failed resetting response to signal " .. tostring(signalid) .. " for controllable " .. ffi.string(C.GetComponentName(factionorcontrollable)) .. " " .. tostring(factionorcontrollable))
			end
		else
			local factionobjects = GetContainedObjectsByOwner(factionorcontrollable)
			for _, object in ipairs(factionobjects) do
				local object64 = ConvertIDTo64Bit(object)
				if C.IsComponentClass(object64, "controllable") then
					if not C.ResetResponseToSignalForControllable(signalid, object64) then
						DebugError("Failed resetting response to signal " .. tostring(signalid) .. " for controllable " .. ffi.string(C.GetComponentName(object64)) .. " " .. tostring(object64))
					end
				end
			end
		end
	else
		local ask
		if mode == "controllableresponses" then
			ask = C.GetAskToSignalForControllable(signalid, factionorcontrollable)
			C.SetDefaultResponseToSignalForControllable(newresponseid, ask, signalid, factionorcontrollable)
		else
			ask = C.GetAskToSignalForFaction(signalid, factionorcontrollable)
			C.SetDefaultResponseToSignalForFaction2(newresponseid, ask, signalid, factionorcontrollable, "")
		end
	end
	menu.refreshInfoFrame()
end

function menu.dropdownOrdersResupply(controllable, id)
	C.SetDefensibleLoadoutLevel(controllable, tonumber(id))
	menu.refreshInfoFrame()
end

function menu.dropdownOrdersCargoReservations(ship, id)
	C.SetShipTradeLoopCargoReservationOverride(ship, id == "on")
	menu.refreshInfoFrame()
end

function  menu.dropdownOrdersBlacklist(controllable, type, id)
	C.SetControllableBlacklist(controllable, tonumber(id), type, true)
	menu.refreshInfoFrame()
end

function  menu.dropdownOrdersFightRule(controllable, type, id)
	C.SetControllableFightRule(controllable, tonumber(id), type, true)
	menu.refreshInfoFrame()
end

function menu.dropdownHireRole(_, idstring)
	menu.noupdate = false
	if idstring ~= nil then
		local type, id = string.match(idstring, "(.+):(.+)")
		if type == "mission" then
			menu.contextMenuData.hireIsMission = true
			menu.contextMenuData.hireIsPost = nil
		else
			menu.contextMenuData.hireIsMission = nil
			menu.contextMenuData.hireIsPost = type == "post"
		end
		menu.contextMenuData.hireRole = id

		menu.refreshContextFrame()
	end
end

function menu.dropdownBehaviourFormation(_, shape)
	if shape ~= nil then
		local info = C.SetFormationShape(menu.infoSubmenuObject, shape)
		shape = ffi.string(info.shape)

		if (shape ~= "") then
			local subordinates = GetSubordinates(menu.infoSubmenuObject)
			for i = #subordinates, 1, -1 do
				local subordinate = ConvertIDTo64Bit(subordinates[i])

				local numorders = C.GetNumOrders(subordinate)
				local currentorders = ffi.new("Order[?]", numorders)
				numorders = C.GetOrders(currentorders, numorders, subordinate)
				local paramoffset = 0
				for j = 1, numorders do
					if (ffi.string(currentorders[0].orderdef) == "Escort") then
						paramoffset = 0
					elseif (ffi.string(currentorders[0].orderdef) == "SupplyFleet") then
						paramoffset = 1
					end
					if (ffi.string(currentorders[0].orderdef) == "Escort") or (ffi.string(currentorders[0].orderdef) == "SupplyFleet") then
						SetOrderParam(subordinate, j, paramoffset + 2, nil, shape) -- shape
						SetOrderParam(subordinate, j, paramoffset + 3, nil, info.radius) -- radius
						SetOrderParam(subordinate, j, paramoffset + 4, nil, info.rollMembers) -- rollmembers
						SetOrderParam(subordinate, j, paramoffset + 5, nil, info.rollFormation) -- rollformation
						SetOrderParam(subordinate, j, paramoffset + 6, nil, tonumber(info.maxShipsPerLine)) -- maxshipsperline
					end
				end

				local currentdefaultorder = ffi.new("Order")
				if C.GetDefaultOrder(currentdefaultorder, subordinate) then
					if (ffi.string(currentdefaultorder.orderdef) == "Escort") then
						paramoffset = 0
					elseif (ffi.string(currentdefaultorder.orderdef) == "SupplyFleet") then
						paramoffset = 1
					end
					if (ffi.string(currentdefaultorder.orderdef) == "Escort") or (ffi.string(currentdefaultorder.orderdef) == "SupplyFleet") then
						SetOrderParam(subordinate, "default", paramoffset + 2, nil, shape) -- shape
						SetOrderParam(subordinate, "default", paramoffset + 3, nil, info.radius) -- radius
						SetOrderParam(subordinate, "default", paramoffset + 4, nil, info.rollMembers) -- rollmembers
						SetOrderParam(subordinate, "default", paramoffset + 5, nil, info.rollFormation) -- rollformation
						SetOrderParam(subordinate, "default", paramoffset + 6, nil, tonumber(info.maxShipsPerLine)) -- maxshipsperline
					end
				end
			end
		end
		menu.refreshInfoFrame()
	end
end

function  menu.dropdownTradeRule(container, type, id, ware, refresh)
	if type == "trade" then
		C.SetContainerTradeRule(container, tonumber(id), "buy",  ware or "", true)
		C.SetContainerTradeRule(container, tonumber(id), "sell", ware or "", true)
	else
		C.SetContainerTradeRule(container, tonumber(id), type, ware or "", true)
	end

	if refresh then
		menu.refreshInfoFrame()
	end
end

function  menu.dropdownBuildRule(container, id)
	C.SetContainerBuildMethod(container, id)
end

function menu.checkboxSetWeaponConfig(system, value)
	if system == "default" then
		menu.contextMenuData.default = value
	end
	for i, entry in ipairs(menu.contextMenuData.weaponsystems) do
		if entry.id == system then
			menu.contextMenuData.weaponsystems[i].active = value
		end
	end
	menu.createContextFrame()
end

-- mode: "factionresponses", "controllableresponses"
function menu.checkboxOrdersSetAsk(factionorcontrollable, signalid, mode)
	if mode ~= "factionresponses" and mode ~= "controllableresponses" then
		DebugError("menu.checkboxOrdersSetAsk called with invalid mode set. only 'factionresponses' and 'controllableresponses' are supported at this time. mode: " .. tostring(mode))
		return
	elseif not factionorcontrollable then
		DebugError("menu.checkboxOrdersSetAsk called with invalid faction or controllable set. factionorcontrollable: " .. tostring(factionorcontrollable))
		return
	elseif not signalid then
		DebugError("menu.checkboxOrdersSetAsk called with invalid signal id set. signalid: " .. tostring(signalid))
		return
	end

	local ask
	local response
	if mode == "controllableresponses" then
		ask = not C.GetAskToSignalForControllable(signalid, factionorcontrollable)
		response = C.GetDefaultResponseToSignalForControllable(signalid, factionorcontrollable)
		C.SetDefaultResponseToSignalForControllable(response, ask, signalid, factionorcontrollable)
	else
		ask = not C.GetAskToSignalForFaction(signalid, factionorcontrollable)
		response = C.GetDefaultResponseToSignalForFaction2(signalid, factionorcontrollable, "")
		C.SetDefaultResponseToSignalForFaction2(response, ask, signalid, factionorcontrollable, "")
	end
	menu.refreshInfoFrame()
end

function menu.checkboxOrdersSetOverride(controllable, signalid, mode, checked)
	if mode ~= "controllableresponses" then
		DebugError("menu.checkboxOrdersSetOverride called with invalid mode set. only 'controllableresponses' is supported at this time. mode: " .. tostring(mode))
		return
	elseif not controllable then
		DebugError("menu.checkboxOrdersSetOverride called with invalid faction or controllable set. controllable: " .. tostring(controllable))
		return
	elseif not signalid then
		DebugError("menu.checkboxOrdersSetOverride called with invalid signal id set. signalid: " .. tostring(signalid))
		return
	end

	if checked then
		if not C.ResetResponseToSignalForControllable(signalid, controllable) then
			DebugError("Failed resetting response to signal " .. tostring(signalid) .. " for controllable " .. ffi.string(C.GetComponentName(controllable)) .. " " .. tostring(controllable))
		end
	else
		local faction, primarypurpose = GetComponentData(controllable, "owner", "primarypurpose")
		local deffactresponse = ffi.string(C.GetDefaultResponseToSignalForFaction2(signalid, faction, primarypurpose))
		local ask = C.GetAskToSignalForControllable(signalid, controllable)
		C.SetDefaultResponseToSignalForControllable(deffactresponse, ask, signalid, controllable)
	end

	menu.refreshInfoFrame()
end

function menu.checkboxOrdersSetResupplyOverride(controllable, checked)
	if checked then
		C.SetDefensibleLoadoutLevel(controllable, -1)
	else
		C.SetDefensibleLoadoutLevel(controllable, 0)
	end

	menu.refreshInfoFrame()
end

function menu.checkboxOrdersSetCargoReservations(ship, checked)
	if checked then
		C.RemoveShipTradeLoopCargoReservationOverride(ship)
	else
		C.SetShipTradeLoopCargoReservationOverride(ship, C.GetPlayerGlobalTradeLoopCargoReservationSetting())
	end

	menu.refreshInfoFrame()
end

function menu.checkboxStorageWarePriceOverride(container, ware, buysellswitch, price, checked)
	if checked then
		ClearContainerWarePriceOverride(container, ware, buysellswitch)
	else
		SetContainerWarePriceOverride(container, ware, buysellswitch, price)
	end

	menu.refreshInfoFrame()
end

function menu.checkboxOrdersSetBlacklistOverride(controllable, type, checked)
	if checked then
		C.SetControllableBlacklist(controllable, -1, type, false)
	else
		C.SetControllableBlacklist(controllable, -1, type, true)
	end

	menu.refreshInfoFrame()
end

function menu.checkboxOrdersSetFightRuleOverride(controllable, type, checked)
	if checked then
		C.SetControllableFightRule(controllable, -1, type, false)
	else
		C.SetControllableFightRule(controllable, -1, type, true)
	end

	menu.refreshInfoFrame()
end

function menu.checkboxSetWareList(ware, checked)
	menu.contextMenuData.selectedWares[ware] = checked or nil
end

function menu.checkboxSetSectorList(sector, checked)
	menu.contextMenuData.selectedSectors[tostring(sector)] = checked or nil
end

function menu.checkboxToggleWareList(checked)
	for _, ware in ipairs(menu.contextMenuData.wares) do
		menu.contextMenuData.selectedWares[ware] = checked or nil
	end
end

function menu.checkboxToggleSectorList(checked)
	for _, sector in ipairs(menu.contextMenuData.sectors) do
		menu.contextMenuData.selectedSectors[tostring(sector)] = checked or nil
	end
end

function menu.checkboxSetTradeRuleOverride(container, type, checked, ware)
	if type == "trade" then
		if checked then
			C.SetContainerTradeRule(container, -1, "buy",  ware or "", false)
			C.SetContainerTradeRule(container, -1, "sell", ware or "", false)
		else
			local currentid = C.GetContainerTradeRuleID(container, "buy", ware or "")
			C.SetContainerTradeRule(container, (currentid ~= 0) and currentid or -1, "buy",  ware or "", true)
			C.SetContainerTradeRule(container, (currentid ~= 0) and currentid or -1, "sell", ware or "", true)
		end
	else
		if checked then
			C.SetContainerTradeRule(container, -1, type, ware or "", false)
		else
			local currentid = C.GetContainerTradeRuleID(container, type, ware or "")
			C.SetContainerTradeRule(container, (currentid ~= 0) and currentid or -1, type, ware or "", true)
		end
	end

	menu.refreshInfoFrame()
end

function menu.checkboxSetBuildRuleOverride(container, checked, curglobal)
	if checked then
		C.SetContainerBuildMethod(container, "")
	else
		C.SetContainerBuildMethod(container, curglobal or "default")
	end

	menu.refreshInfoFrame()
end

function menu.storeCurrentPlots()
	menu.currentPlots = {}
	local playerobjects = GetContainedStationsByOwner("player", nil, true)
	for _, station in ipairs(playerobjects) do
		local station64 = ConvertStringTo64Bit(tostring(station))
		local rawsize = C.GetBuildPlotSize(station64)
		local plotcenter = C.GetBuildPlotCenterOffset(station64)
		menu.currentPlots[tostring(station64)] = {
			posX = math.ceil((rawsize.x / 2 + plotcenter.x) / 1000),
			negX = math.floor((rawsize.x / 2 - plotcenter.x) / 1000),
			posY = math.ceil((rawsize.y / 2 + plotcenter.y) / 1000),
			negY = math.floor((rawsize.y / 2 - plotcenter.y) / 1000),
			posZ = math.ceil((rawsize.z / 2 + plotcenter.z) / 1000),
			negZ = math.floor((rawsize.z / 2 - plotcenter.z) / 1000),
		}
	end
end

function menu.updatePlotData(station, donotrefresh)
	if not station then
		if not menu.plotData.component then
			DebugError("menu.updatePlotData(): no station passed in. station: " .. tostring(station) .. ", menu.plotData.component: " .. tostring(menu.plotData.component) .. ".")
			return
		end
		station = menu.plotData.component
	end

	if station ~= "plots_new" then
		local station64 = ConvertStringTo64Bit(tostring(station))
		local rawsize = C.GetBuildPlotSize(station)
		local plotcenter = C.GetBuildPlotCenterOffset(station)
		local sets = GetComponentData(station64, "modulesets")
		local sector = GetComponentData(station64, "sectorid")
		local owner = GetComponentData(station64, "owner")
		local boughtrawsize = C.GetPaidBuildPlotSize(station)
		local playermoney = GetPlayerMoney()
		local minimumrawsize = C.GetMinimumBuildPlotSize(station)
		local minimumcenter = C.GetMinimumBuildPlotCenterOffset(station)
		local pos = C.GetObjectPositionInSector(station)

		menu.plotData.name = ffi.string(C.GetComponentName(station))
		menu.plotData.component = station
		menu.plotData.position = pos
		menu.plotData.set = sets[1] or ""
		menu.plotData.placed = true
		menu.plotData.sector = ConvertIDTo64Bit(sector)
		menu.plotData.permanent = C.GetNumStationModules(station, true, true) > 0
		menu.plotData.isinownedspace = (GetComponentData(sector, "owner") ~= "ownerless") and (GetComponentData(sector, "owner") ~= "xenon")
		menu.plotData.paid = (not menu.plotData.isinownedspace) or (boughtrawsize.x > 0) or (boughtrawsize.y > 0) or (boughtrawsize.z > 0)
		local fullprice = tonumber(C.GetBuildPlotPrice(menu.plotData.sector, menu.plotData.position, rawsize.x, rawsize.y, rawsize.z, owner))
		local buf = ffi.new("bool[1]", 0)
		local plotpayment = tonumber(C.GetBuildPlotPayment(station, buf))
		local haspositionchanged = buf[0]
		menu.plotData.fullypaid = ((not menu.plotData.isinownedspace) or ((boughtrawsize.x >= rawsize.x) and (boughtrawsize.y >= rawsize.y) and (boughtrawsize.z >= rawsize.z))) and ((not haspositionchanged) or (plotpayment >= fullprice))
		menu.plotData.size = { x = rawsize.x / 1000, y = rawsize.y / 1000, z = rawsize.z / 1000 }
		menu.plotData.dimensions = {
			posX = math.ceil((rawsize.x / 2 + plotcenter.x) / 1000),
			negX = math.floor((rawsize.x / 2 - plotcenter.x) / 1000),
			posY = math.ceil((rawsize.y / 2 + plotcenter.y) / 1000),
			negY = math.floor((rawsize.y / 2 - plotcenter.y) / 1000),
			posZ = math.ceil((rawsize.z / 2 + plotcenter.z) / 1000),
			negZ = math.floor((rawsize.z / 2 - plotcenter.z) / 1000),
		}
		menu.plotData.minimumdimensions = {
			posX = math.ceil((minimumrawsize.x / 2 + minimumcenter.x) / 1000),
			negX = math.floor((minimumrawsize.x / 2 - minimumcenter.x) / 1000),
			posY = math.ceil((minimumrawsize.y / 2 + minimumcenter.y) / 1000),
			negY = math.floor((minimumrawsize.y / 2 - minimumcenter.y) / 1000),
			posZ = math.ceil((minimumrawsize.z / 2 + minimumcenter.z) / 1000),
			negZ = math.floor((minimumrawsize.z / 2 - minimumcenter.z) / 1000),
		}

		if ((not menu.plotData.isinownedspace) and (rawsize.x > boughtrawsize.x or rawsize.y > boughtrawsize.y or rawsize.z > boughtrawsize.z)) or GetComponentData(sector, "isplayerowned") then
			C.PayBuildPlotSize(station, rawsize, plotcenter)
			boughtrawsize = C.GetPaidBuildPlotSize(station)
			local found
			for _, plot in ipairs(menu.plots) do
				if plot.station == station then
					plot.boughtrawcenteroffset = plotcenter
					found = true
					break
				end
			end
			if not found then
				table.insert(menu.plots, { station = station, paid = true, fullypaid = true, permanent = C.GetNumStationModules(station, true, true) > 0, boughtrawcenteroffset = plotcenter, removed = nil })
			end
		end
		menu.plotData.boughtrawsize = { x = boughtrawsize.x, y = boughtrawsize.y, z = boughtrawsize.z }
		--print("fullypaid: " .. tostring(menu.plotData.fullypaid) .. ", boughtsize: " .. tostring(boughtrawsize.x) .. " x " .. tostring(boughtrawsize.y) .. " x " .. tostring(boughtrawsize.z) .. ", size: " .. tostring(rawsize.x) .. " x " .. tostring(rawsize.y) .. " x " .. tostring(rawsize.z))

		for _, plot in ipairs(menu.plots) do
			if station == plot.station then
				menu.plotData.boughtrawcenteroffset = plot.boughtrawcenteroffset
				break
			end
		end
		menu.plotData.price = tonumber(C.GetBuildPlotPrice(menu.plotData.sector, menu.plotData.position, rawsize.x, rawsize.y, rawsize.z, owner)) - plotpayment
		menu.plotData.affordable = playermoney >= menu.plotData.price
	else
		menu.plotData = {
			name = ReadText(1001, 9200),	-- New Plot
			set = "factory",
			active = false,
			placed = false,
			sector = menu.currentsector,
			permanent = false,
			isinownedspace = (GetComponentData(ConvertStringTo64Bit(tostring(menu.currentsector)), "owner") ~= "ownerless") and (GetComponentData(ConvertStringTo64Bit(tostring(menu.currentsector)), "owner") ~= "xenon"),
			paid = false,
			fullypaid = false,
			boughtrawsize = { x = 0, y = 0, z = 0 },
			size = { x = 4, y = 4, z = 4 },
			dimensions = { posX = 2, negX = 2, posY = 2, negY = 2, posZ = 2, negZ = 2 },
			minimumdimensions = { posX = 0, negX = 0, posY = 0, negY = 0, posZ = 0, negZ = 0 },
			affordable = false,
			removed = nil
		}
	end

	if menu.currentsector ~= menu.plotData.sector then
		menu.currentsector = menu.plotData.sector
		C.ShowBuildPlotPlacementMap(menu.holomap, menu.currentsector)
		menu.applyFilterSettings()
	end

	if not donotrefresh and menu.plotsliders then
		-- if slider setup (3-slider or 6-slider) and plotData don't match, refresh the menu at the next opportunity.
		if (menu.plotsliders[1].dimension == "x" and menu.plotData.placed) or (menu.plotsliders[1].dimension ~= "x" and not menu.plotData.placed) then
			menu.over = true
		else
			menu.updatePlotWidgets()
		end
	end
end

function menu.updatePlotSliders()
	for _, slider in ipairs(menu.plotsliders) do
		local locdimension = menu.plotData.dimensions[slider.dimension]
		local locpaireddimension = menu.plotData.dimensions[config.plotPairedDimension[slider.dimension]]

		local maxselect = (locpaireddimension > config.maxPlotSize) and locpaireddimension or (config.maxPlotSize - locpaireddimension)
		Helper.setSliderCellValue(slider.table.id, slider.row, slider.col, locdimension, maxselect)
	end
end

function menu.updatePlotWidgets()
	for _, slider in ipairs(menu.plotsliders) do
		local sliderproperties = { min = 0, minselect = 2, max = config.maxPlotSize, start = menu.plotData.size[slider.dimension], step = 2, suffix = ReadText(1001, 108) }
		local boughtdimensions = {}
		if menu.plotData.paid then
			boughtdimensions = {
				posX = math.ceil((menu.plotData.boughtrawsize.x / 2 + menu.plotData.boughtrawcenteroffset.x) / 1000),
				negX = math.floor((menu.plotData.boughtrawsize.x / 2 - menu.plotData.boughtrawcenteroffset.x) / 1000),
				posY = math.ceil((menu.plotData.boughtrawsize.y / 2 + menu.plotData.boughtrawcenteroffset.y) / 1000),
				negY = math.floor((menu.plotData.boughtrawsize.y / 2 - menu.plotData.boughtrawcenteroffset.y) / 1000),
				posZ = math.ceil((menu.plotData.boughtrawsize.z / 2 + menu.plotData.boughtrawcenteroffset.z) / 1000),
				negZ = math.floor((menu.plotData.boughtrawsize.z / 2 - menu.plotData.boughtrawcenteroffset.z) / 1000),
			}
		end
		if menu.plotData.placed then
			local locdimension = menu.plotData.dimensions[slider.dimension]
			local minimumdimension = menu.plotData.minimumdimensions[slider.dimension] or 0
			local boughtdimension = menu.plotData.paid and boughtdimensions[slider.dimension] or 0
			local locpaireddimension = menu.plotData.dimensions[config.plotPairedDimension[slider.dimension]]

			local minselect = math.max(menu.plotData.permanent and math.max(boughtdimension, minimumdimension) or boughtdimension, (locpaireddimension == 0 and 1 or 0))
			sliderproperties = {
				min = 0,
				minselect = minselect,
				max = (locpaireddimension > config.maxPlotSize) and locpaireddimension or config.maxPlotSize,
				maxselect = (locpaireddimension > config.maxPlotSize) and locpaireddimension or (config.maxPlotSize - locpaireddimension),
				start = locdimension,
				step = 1,
				suffix = ReadText(1001, 108)
			}
			if sliderproperties.minselect > sliderproperties.maxselect then
				print("menu.updatePlotWidgets(): minselect > maxselect [Florian]")
				sliderproperties.minselect = sliderproperties.maxselect
			end
			if sliderproperties.start < sliderproperties.minselect then
				print("menu.updatePlotWidgets(): start < minselect [Florian]")
				sliderproperties.start = sliderproperties.minselect
			end
		end
		--print("dimension: " .. tostring(slider.dimension) .. ", paired: " .. tostring(config.plotPairedDimension[slider.dimension]) .. ", row: " .. tostring(slider.row) .. ", value: " .. tostring(menu.plotData.dimensions[slider.dimension]) )
		--Helper.setSliderCellValue(slider.table.id, slider.row, slider.col, menu.plotData.dimensions[slider.dimension])

		-- NB: necessary at the moment to set max in addition to changing slider value.
		local color = Color["text_normal"]
		local desc = Helper.createSliderCell(
			Helper.createTextInfo(
				slider.cell.properties.text.text,
				"left",
				Helper.standardFont,
				slider.cell.properties.text.fontsize,
				color.r,
				color.g,
				color.b,
				color.a,
				0,
				0
			),
			nil,
			nil,
			nil,
			nil,
			config.mapRowHeight,
			slider.cell.properties.bgColor,
			nil,
			sliderproperties,
			ffi.string(C.GetDisplayedModifierKey("shift")) .. " - " .. ReadText(1026, 3279)
		)
		Helper.setCellContent(menu, slider.table.id, desc, slider.row, slider.col, nil, "slidercell", nil, function(_, val) return menu.slidercellPlotValue(_, val, slider.dimension, not menu.plotData.placed) end, function() menu.noupdate = true end, function() menu.noupdate = false end, nil, function() return menu.refreshInfoFrame() end)
	end

	-- NB: this is simply to reset the button's active attribute.
	for _, button in ipairs(menu.plotbuttons) do
		if button.rowdata == "createplot" then
			local activate
			if button.col == 2 then
				activate = (menu.plotData.placed and menu.plotData.paid and (menu.plotData.size.x * 1000 > menu.plotData.boughtrawsize.x or menu.plotData.size.y * 1000 > menu.plotData.boughtrawsize.y or menu.plotData.size.z * 1000 > menu.plotData.boughtrawsize.z) and not menu.plotData.permanent) and true or false
			elseif button.col == 3 then
				activate = not menu.plotData.placed
			end
			local color = Color["text_normal"]
			local desc = Helper.createButton(
				Helper.createTextInfo(
					button.cell.properties.text.text,
					"center",
					Helper.standardFont,
					button.cell.properties.text.fontsize,
					color.r,
					color.g,
					color.b,
					color.a,
					0,
					0
				),
				nil,
				false,
				activate
			)
			Helper.setCellContent(menu, button.table.id, desc, button.row, button.col, nil, "button", nil, button.script)
		elseif button.rowdata == "buyplot" then
			local activate
			if button.col == 2 then
				activate = false
			elseif button.col == 3 then
				activate = (menu.plotData.placed and not menu.plotData.fullypaid and menu.plotData.isinownedspace and menu.plotData.affordable) and true or false
			end
			local mouseovertext = ""
			if menu.plotData.placed and (not menu.plotData.fullypaid) and menu.plotData.isinownedspace and (not menu.plotData.affordable) then
				mouseovertext = ReadText(1026, 3222)
			end
			local color = Color["text_normal"]
			local desc = Helper.createButton(
				Helper.createTextInfo(
					button.cell.properties.text.text,
					"center",
					Helper.standardFont,
					button.cell.properties.text.fontsize,
					color.r,
					color.g,
					color.b,
					color.a,
					0,
					0
				),
				nil,
				false,
				activate,
				nil,
				nil,
				nil,
				nil,
				nil,
				nil,
				nil,
				mouseovertext
			)
			Helper.setCellContent(menu, button.table.id, desc, button.row, button.col, nil, "button", nil, button.script)
		elseif button.rowdata == "initiateconstruction" then
			local color = Color["text_normal"]
			local desc = Helper.createButton(
				Helper.createTextInfo(
					button.cell.properties.text.text,
					"center",
					Helper.standardFont,
					button.cell.properties.text.fontsize,
					color.r,
					color.g,
					color.b,
					color.a,
					0,
					0
				),
				nil,
				false,
				menu.plotData.placed
			)
			Helper.setCellContent(menu, button.table.id, desc, button.row, button.col, nil, "button", nil, button.script)
		end
	end
end

function menu.resetPlotSize()
	if not menu.plotData.placed then
		DebugError("menu.resetPlotSize: tried to resize a plot that has not yet been placed.")
		return
	end
	if menu.plotData.paid then
		local wantedcenteroffset = menu.plotData.boughtrawcenteroffset
		--print("wantedcenteroffset.x: " .. tostring(wantedcenteroffset.x) .. ", wantedcenteroffset.y: " .. tostring(wantedcenteroffset.y) .. ", wantedcenteroffset.z: " .. tostring(wantedcenteroffset.z))
		local boughtdimensions = {
			posX = math.ceil((menu.plotData.boughtrawsize.x / 2 + wantedcenteroffset.x) / 1000),
			negX = math.floor((menu.plotData.boughtrawsize.x / 2 - wantedcenteroffset.x) / 1000),
			posY = math.ceil((menu.plotData.boughtrawsize.y / 2 + wantedcenteroffset.y) / 1000),
			negY = math.floor((menu.plotData.boughtrawsize.y / 2 - wantedcenteroffset.y) / 1000),
			posZ = math.ceil((menu.plotData.boughtrawsize.z / 2 + wantedcenteroffset.z) / 1000),
			negZ = math.floor((menu.plotData.boughtrawsize.z / 2 - wantedcenteroffset.z) / 1000),
		}
		local posSizeChange = { x = (boughtdimensions.posX - menu.plotData.dimensions.posX) * 1000, y = (boughtdimensions.posY - menu.plotData.dimensions.posY) * 1000, z = (boughtdimensions.posZ - menu.plotData.dimensions.posZ) * 1000 }
		local negSizeChange = { x = (boughtdimensions.negX - menu.plotData.dimensions.negX) * 1000, y = (boughtdimensions.negY - menu.plotData.dimensions.negY) * 1000, z = (boughtdimensions.negZ - menu.plotData.dimensions.negZ) * 1000 }
		--print("poschangeX: " .. tostring(posSizeChange.x) .. ", possizechangeY: " .. tostring(posSizeChange.y) .. ", possizechangeZ: " .. tostring(posSizeChange.z) .. "\nnegchangeX: " .. tostring(negSizeChange.x) .. ", negsizechangeY: " .. tostring(negSizeChange.y) .. ", negsizechangeZ: " .. tostring(negSizeChange.z))
		if C.ExtendBuildPlot(menu.plotData.component, posSizeChange, negSizeChange, true) then
			local plotcenteroffset = C.GetBuildPlotCenterOffset(menu.plotData.component)
			menu.plotData.size = { x = menu.plotData.boughtrawsize.x / 1000, y = menu.plotData.boughtrawsize.y / 1000, z = menu.plotData.boughtrawsize.z / 1000 }
			menu.plotData.dimensions = {
				posX = math.ceil((menu.plotData.boughtrawsize.x / 2 + plotcenteroffset.x) / 1000),
				negX = math.floor((menu.plotData.boughtrawsize.x / 2 - plotcenteroffset.x) / 1000),
				posY = math.ceil((menu.plotData.boughtrawsize.y / 2 + plotcenteroffset.y) / 1000),
				negY = math.floor((menu.plotData.boughtrawsize.y / 2 - plotcenteroffset.y) / 1000),
				posZ = math.ceil((menu.plotData.boughtrawsize.z / 2 + plotcenteroffset.z) / 1000),
				negZ = math.floor((menu.plotData.boughtrawsize.z / 2 - plotcenteroffset.z) / 1000),
			}
			--print("menu.resetPlotSize: successfully reset build plot of station: " .. ffi.string(C.GetComponentName(menu.plotData.component)) .. ". posSizeChange.x: " .. tostring(posSizeChange.x) .. ", posSizeChange.y: " .. tostring(posSizeChange.y) .. ", posSizeChange.z: " .. tostring(posSizeChange.z) .. ", negSizeChange.x: " .. tostring(negSizeChange.x) .. ", negSizeChange.y: " .. tostring(negSizeChange.y) .. ", negSizeChange.z: " .. tostring(negSizeChange.z) .. ".")
			C.UpdateMapBuildPlot(menu.holomap)
		else
			DebugError("menu.resetPlotSize: failed to reset build plot of station: " .. ffi.string(C.GetComponentName(menu.plotData.component)) .. "\nposSizeChange.x: " .. tostring(posSizeChange.x) .. ", posSizeChange.y: " .. tostring(posSizeChange.y) .. ", posSizeChange.z: " .. tostring(posSizeChange.z) .. "\nnegSizeChange.x: " .. tostring(negSizeChange.x) .. ", negSizeChange.y: " .. tostring(negSizeChange.y) .. ", negSizeChange.z: " .. tostring(negSizeChange.z))
		end
		if not menu.plotData.fullypaid and menu.plotData.price <= 0 then
			menu.plotData.fullypaid = true
		end
		menu.updatePlotData(menu.plotData.component, true)
		menu.refreshInfoFrame()
	end
end

function menu.updatePlotSize(dimension, axis, valchange)
	if menu.plotData.active then
		C.ChangeMapBuildPlot(menu.holomap, menu.plotData.size.x * 1000, menu.plotData.size.y * 1000, menu.plotData.size.z * 1000)
	elseif menu.plotData.placed then
		local posSizeChange = { x = 0, y = 0, z = 0 }
		local negSizeChange = { x = 0, y = 0, z = 0 }
		if dimension == "posX" or dimension == "posY" or dimension == "posZ" then
			posSizeChange[axis] = valchange * 1000
		elseif dimension == "negX" or dimension == "negY" or dimension == "negZ" then
			negSizeChange[axis] = valchange * 1000
		else
			DebugError("menu.updatePlotSize: dimension passed in: " .. tostring(dimension) .. " indicates neither positive nor negative.")
			return
		end
		-- kuertee start: callback
		local canExtend = true
		if callbacks["updatePlotSize_on_before_extend"] then
			for _, callback in ipairs(callbacks["updatePlotSize_on_before_extend"]) do
				local result = callback(menu.plotData.component, posSizeChange, negSizeChange)
				if result == false then
					canExtend = false
					break
				end
			end
		end
		if not canExtend then return end
		-- kuertee end: callback
		if C.ExtendBuildPlot(menu.plotData.component, posSizeChange, negSizeChange, true) then
			--print("menu.updatePlotSize: successfully extended build plot of station: " .. ffi.string(C.GetComponentName(menu.plotData.component)) .. ". posSizeChange.x: " .. tostring(posSizeChange.x) .. ", posSizeChange.y: " .. tostring(posSizeChange.y) .. ", posSizeChange.z: " .. tostring(posSizeChange.z) .. ", negSizeChange.x: " .. tostring(negSizeChange.x) .. ", negSizeChange.y: " .. tostring(negSizeChange.y) .. ", negSizeChange.z: " .. tostring(negSizeChange.z) .. ".")
			C.UpdateMapBuildPlot(menu.holomap)
			if (not menu.plotData.isinownedspace) or GetComponentData(ConvertStringTo64Bit(tostring(menu.plotData.sector)), "isplayerowned") then
				local rawsize = C.GetBuildPlotSize(menu.plotData.component)
				local plotcenter = C.GetBuildPlotCenterOffset(menu.plotData.component)
				for _, plot in ipairs(menu.plots) do
					if plot.station == menu.plotData.component then
						plot.boughtrawcenteroffset = plotcenter
						break
					end
				end
				C.PayBuildPlotSize(menu.plotData.component, rawsize, plotcenter)
			end
		else
			DebugError("menu.updatePlotSize: failed to extend build plot of station: " .. ffi.string(C.GetComponentName(menu.plotData.component)) .. ". posSizeChange.x: " .. tostring(posSizeChange.x) .. ", posSizeChange.y: " .. tostring(posSizeChange.y) .. ", posSizeChange.z: " .. tostring(posSizeChange.z) .. ", negSizeChange.x: " .. tostring(negSizeChange.x) .. ", negSizeChange.y: " .. tostring(negSizeChange.y) .. ", negSizeChange.z: " .. tostring(negSizeChange.z) .. ".")
		end
	end
end

function menu.plotInitiateConstruction(station)
	if not station then
		DebugError("menu.plotInitiateConstruction(): no station passed in. station: " .. tostring(station))
		return
	end
	menu.setplotrow = Helper.currentTableRow[menu.infoTable]
	menu.setplottoprow = GetTopRow(menu.infoTable)
	for _, plot in ipairs(menu.plots) do
		if plot.station == station then
			plot.permanent = true
			break
		end
	end

	AddUITriggeredEvent(menu.name, "initiateconstruction_station", ConvertStringTo64Bit(tostring(station)))
	AddUITriggeredEvent(menu.name, "initiateconstruction_license", menu.plotData.fullypaid)

	Helper.closeMenuAndOpenNewMenu(menu, "StationConfigurationMenu", { 0, 0, station })
	menu.cleanup()
end

-- shortcuts
function menu.hotkey(action)
	local rowdata = Helper.getCurrentRowData(menu, menu.infoTable)
	local selectedcomponent
	if next(menu.selectedcomponents) then
		for id, _ in pairs(menu.selectedcomponents) do
			selectedcomponent = ConvertStringTo64Bit(id)
			if IsValidComponent(selectedcomponent) then
				break
			end
			selectedcomponent = nil
		end
	end

	if action == "INPUT_ACTION_ADDON_DETAILMONITOR_CLOSE_MAP" then
		if menu.showMultiverse then
			menu.buttonToggleMultiverseMap()
		else
			menu.onCloseElement("close")
		end
	elseif action == "INPUT_ACTION_ADDON_DETAILMONITOR_MISSIONS" then
		if menu.infoTableMode ~= "mission" then
			if menu.mode ~= "hire" then
				menu.infoTableMode = "mission"
				menu.refreshMainFrame = true
				menu.refreshInfoFrame()
			end
		end
	elseif action == "INPUT_ACTION_ADDON_DETAILMONITOR_ZONE_VIEW" then
		if menu.holomap and (menu.holomap ~= 0) then
			C.SetMapTargetDistance(menu.holomap, 20000)
			C.ResetMapPlayerRotation(menu.holomap)
			C.SetFocusMapComponent(menu.holomap, C.GetPlayerObjectID(), true)
			if menu.infoTableMode == "objectlist" then
				menu.refreshInfoFrame()
			end
		end
	elseif action == "INPUT_ACTION_ADDON_DETAILMONITOR_SECTOR_VIEW" then
		if menu.holomap and (menu.holomap ~= 0) then
			C.SetMapTargetDistance(menu.holomap, 2000000)
			C.ResetMapPlayerRotation(menu.holomap)
			C.SetFocusMapComponent(menu.holomap, C.GetPlayerObjectID(), true)
			if menu.infoTableMode == "objectlist" then
				menu.refreshInfoFrame()
			end
		end
	elseif action == "INPUT_ACTION_ADDON_DETAILMONITOR_F1" then
		C.SetPlayerCameraCockpitView(true)
	elseif action == "INPUT_ACTION_ADDON_DETAILMONITOR_T" then
		menu.target(nil, C.IsExternalTargetMode() or C.IsExternalViewActive(), selectedcomponent)
	elseif action == "INPUT_ACTION_ADDON_DETAILMONITOR_A_SHIFT" then
		C.ToggleAutoPilot(false)

		menu.settoprow = GetTopRow(menu.infoTable)
		menu.setrow = Helper.currentTableRow[menu.infoTable]
		if not menu.createInfoFrameRunning then
			menu.createInfoFrame()
		end
	elseif action == "INPUT_ACTION_ADDON_DETAILMONITOR_TRAVELMODE" then
		if GetPlayerActivity() == "travel" then
			C.StopPlayerActivity("travel")
			C.TriggerInputFeedback("action", "INPUT_ACTION_ADDON_DETAILMONITOR_TRAVELMODE", "inactive", "")
		else
			C.StartPlayerActivity("travel")
			C.TriggerInputFeedback("action", "INPUT_ACTION_ADDON_DETAILMONITOR_TRAVELMODE", "active", "")
		end
	elseif action == "INPUT_ACTION_ADDON_DETAILMONITOR_SETA" then
		if GetPlayerActivity() == "seta" then
			C.StopPlayerActivity("seta")
			C.TriggerInputFeedback("action", "INPUT_ACTION_ADDON_DETAILMONITOR_SETA", "inactive", "")
		else
			C.StartPlayerActivity("seta")
			C.TriggerInputFeedback("action", "INPUT_ACTION_ADDON_DETAILMONITOR_SETA", "active", "")
		end
	elseif action == "INPUT_ACTION_ADDON_DETAILMONITOR_MULTIVERSE" then
		if (menu.mode ~= "selectCV") and (menu.mode ~= "hire") and (menu.mode ~= "orderparam_object") and (menu.mode ~= "selectComponent") then
			if menu.showMultiverse then
				Helper.closeMenu(menu, dueToClose)
				menu.cleanup()
			else
				menu.buttonToggleMultiverseMap()
			end
		end
	elseif action == "INPUT_ACTION_ADDON_DETAILMONITOR_PROPERTY_OWNED" then
		menu.infoTableMode = "propertyowned"
		menu.closeContextMenu()
		menu.refreshMainFrame = true
		menu.refreshInfoFrame()
	elseif action == "INPUT_ACTION_ADDON_DETAILMONITOR_CURRENT_SHIP" then
		menu.openDetails(C.GetPlayerShipID())
	elseif action == "INPUT_ACTION_ADDON_DETAILMONITOR_CONTEXT_MENU" then
		if menu.picking then
			menu.rightdown = { time = getElapsedTime(), position = table.pack(GetLocalMousePosition()), dynpos = table.pack(GetLocalMousePosition()) }
			menu.onRenderTargetRightMouseUp(nil)
		else
			local row = Helper.currentTableRow[menu.infoTable]
			if row ~= nil then
				menu.onTableRightMouseClick(menu.infoTable, Helper.currentTableRow[menu.infoTable], 0, 0)
			end
		end
	elseif selectedcomponent then
		if action == "INPUT_ACTION_ADDON_DETAILMONITOR_C" then
			if (not menu.mode) and IsComponentOperational(selectedcomponent) and GetComponentData(selectedcomponent, "caninitiatecomm") then
				menu.openComm(selectedcomponent)
			else
				PlaySound("ui_target_set_fail")
			end
		elseif action == "INPUT_ACTION_ADDON_DETAILMONITOR_I" then
			if (not menu.mode) and IsInfoUnlockedForPlayer(selectedcomponent, "name") and CanViewLiveData(selectedcomponent) then
				menu.openDetails(selectedcomponent)
			else
				PlaySound("ui_target_set_fail")
			end
		elseif action == "INPUT_ACTION_ADDON_DETAILMONITOR_TELEPORT" then
			local isplayerowned, isally, isdeployable = GetComponentData(selectedcomponent, "isplayerowned", "isally", "isdeployable")
			if (isplayerowned or (C.IsComponentClass(selectedcomponent, "station") and isally)) and (not isdeployable) and not C.IsUnit(selectedcomponent) then
				if selectedcomponent ~= ConvertStringTo64Bit(tostring(C.GetPlayerOccupiedShipID())) then
					if ffi.string(C.CanTeleportPlayerTo(selectedcomponent, false, false)) == "granted" then
						C.TeleportPlayerTo(selectedcomponent, false, false, false)
						return
					end
				end
			end
			PlaySound("ui_target_set_fail")
		elseif action == "INPUT_ACTION_ADDON_DETAILMONITOR_P" then
			menu.plotCourse(selectedcomponent)
		elseif action == "INPUT_ACTION_ADDON_DETAILMONITOR_F3" then
			if not C.IsExternalViewDisabled() and C.IsPlayerCameraTargetViewPossible(selectedcomponent, true) then
				if menu.target(selectedcomponent, true) then
					C.SetPlayerCameraTargetView(selectedcomponent, true)
				else
					PlaySound("ui_target_set_fail")
				end
			else
				PlaySound("ui_target_set_fail")
			end
		elseif action == "INPUT_ACTION_ADDON_DETAILMONITOR_REMOVE_ORDER" then
			local lastorderidx = C.GetNumOrders(selectedcomponent)
			if lastorderidx > 0 then
				if GetComponentData(selectedcomponent, "isplayerowned") and C.RemoveOrder(selectedcomponent, lastorderidx, false, true) then
					if C.RemoveOrder(selectedcomponent, lastorderidx, false, false) then
						if (menu.infoTableMode == "info") and ((menu.infoMode.left == "orderqueue") or (menu.infoMode.left == "orderqueue_advanced")) then
							menu.removeExtendedOrder(selectedcomponent, lastorderidx, "left")
							if lastorderidx == #menu.infoTableData.left.orders then
								menu.infoTablePersistentData.left.selectedorder = (lastorderidx > 1) and { (lastorderidx - 1) } or nil
							end
							if menu.infoTablePersistentData.left.selectedorder and (type(menu.infoTablePersistentData.left.selectedorder[1]) == "number") then
								menu.infoTablePersistentData.left.selectedorder = { math.min(menu.infoTablePersistentData.left.selectedorder[1], #menu.infoTableData.left.orders - 1) }
							end
						end
						if (menu.searchTableMode == "info") and ((menu.infoMode.right == "orderqueue") or (menu.infoMode.right == "orderqueue_advanced")) then
							menu.removeExtendedOrder(selectedcomponent, lastorderidx, "right")
							if lastorderidx == #menu.infoTableData.right.orders then
								menu.infoTablePersistentData.right.selectedorder = (lastorderidx > 1) and { (lastorderidx - 1) } or nil
							end
							if menu.infoTablePersistentData.right.selectedorder and (type(menu.infoTablePersistentData.right.selectedorder[1]) == "number") then
								menu.infoTablePersistentData.right.selectedorder = { math.min(menu.infoTablePersistentData.right.selectedorder[1], #menu.infoTableData.right.orders - 1) }
							end
						end
					else
						PlaySound("ui_target_set_fail")
					end
				else
					PlaySound("ui_target_set_fail")
				end
			else
				PlaySound("ui_target_set_fail")
			end
		end
	else
		PlaySound("ui_target_set_fail")
	end
end

function menu.target(component, allowfirstperson, fallbackcomponent)
	local refresh = false
	if component == nil then
		component = C.GetPickedMapComponent(menu.holomap)
		if not C.IsComponentClass(component, "sector") then
			if C.IsComponentClass(component, "object") or C.IsComponentClass(component, "highway") then
				menu.addSelectedComponent(component, true, true)
				refresh = true
			end
		else
			component = fallbackcomponent
		end
	end
	if component == nil then
		PlaySound("ui_target_set_fail")
		return
	end
	local playersector = C.GetContextByClass(C.GetPlayerID(), "sector", false)
	local targetsector = C.GetContextByClass(component, "sector", true)
	if C.IsComponentClass(component, "highway") then
		targetsector = C.ConvertStringTo64Bit(GetComponentData(ConvertStringToLuaID(tostring(component)), "sourcesector"))
	end
	if (not menu.mode) and (component ~= C.GetPlayerControlledShipID()) and (allowfirstperson or (not IsFirstPerson())) and ((targetsector == 0) or (playersector == targetsector)) then
		local success = C.SetSofttarget(component, "")
		if success then
			PlaySound("ui_target_set")
			if not menu.createInfoFrameRunning then
				menu.createInfoFrame()
			end
			return true
		else
			PlaySound("ui_target_set_fail")
		end
	else
		PlaySound("ui_target_set_fail")
	end
	if refresh then
		menu.refreshInfoFrame()
	end
	return false
end

function menu.openComm(component)
	menu.closeContextMenu()
	local entities = Helper.getSuitableControlEntities(component, true, true)
	if #entities == 1 then
		if menu.conversationMenu then
			Helper.closeMenuForSubConversation(menu, "default", entities[1], component)
		else
			Helper.closeMenuForNewConversation(menu, "default", entities[1], component)
		end
	else
		Helper.closeMenuForNewConversation(menu, "gMain_propertyResult", ConvertStringToLuaID(tostring(C.GetPlayerComputerID())), component)
	end
	menu.cleanup()
end

function menu.openCommWithActor(actor)
	menu.closeContextMenu()
	if menu.conversationMenu then
		Helper.closeMenuForSubConversation(menu, "default", actor)
	else
		Helper.closeMenuForNewConversation(menu, "default", actor)
	end
	menu.cleanup()
end

function menu.openDetails(component)
	menu.infoTableMode = "info"
	menu.infoSubmenuObject = ConvertStringTo64Bit(tostring(component))
	if not menu.isInfoModeValidFor(menu.infoSubmenuObject, menu.infoMode.left) then
		menu.infoMode.left = "objectinfo"
	end
	menu.refreshMainFrame = true
	menu.refreshInfoFrame()
end

function menu.filterTradeStorage(setting)
	local count = 0
	for i, option in ipairs(setting) do
		if menu.getFilterOption(option.id, setting.savegame) then
			count = count + 1
		end
	end
	local transport = ffi.new("const char*[?]", count)
	local i = 0
	for _, option in ipairs(setting) do
		if menu.getFilterOption(option.id, setting.savegame) then
			transport[i] = Helper.ffiNewString(option.param)
			i = i + 1
		end
	end

	C.SetMapTradeFilterByWareTransport(menu.holomap, transport, count)
end

function menu.filterTradeRelation(setting, override)
	for _, option in ipairs(setting) do
		local value = override
		if value == nil then
			value = menu.getFilterOption(option.id, setting.savegame) or false
		end
		if option.param == "enemy" then
			if value then
				C.ClearMapTradeFilterByWillingToTradeWithPlayer(menu.holomap)
			else
				C.SetMapTradeFilterByWillingToTradeWithPlayer(menu.holomap)
			end
		end
	end
end

function menu.filterTradeWares(setting)
	local rawwarelist = menu.getFilterOption(setting.id, setting.savegame) or {}
	local warelist = ffi.new("const char*[?]", #rawwarelist)
	for i, ware in ipairs(rawwarelist) do
		warelist[i - 1] = Helper.ffiNewString(ware)
	end
	if #rawwarelist > 0 then
		C.SetMapTradeFilterByWare(menu.holomap, warelist, #rawwarelist)
	else
		C.ClearMapTradeFilterByWare(menu.holomap)
	end
	menu.refreshMainFrame = true
	menu.refreshInfoFrame()
end

function menu.filterTradePrice(setting)
	for _, option in ipairs(setting) do
		local value = menu.getFilterOption(option.id, setting.savegame) or false
		if option.param == "maxprice" then
			C.SetMapTradeFilterByMaxPrice(menu.holomap, value)
		end
	end
end

function menu.filterTradeOffer(setting)
	for _, option in ipairs(setting) do
		local value = menu.getFilterOption(option.id, setting.savegame) or false
		if option.param == "number" then
			C.SetMapTopTradesCount(menu.holomap, value)
		end
	end
end

function menu.filterTradeVolume(setting, override)
	for _, option in ipairs(setting) do
		if option.param == "volume" then
			local value = override
			if value == nil then
				value = menu.getFilterOption(option.id, setting.savegame) or false
			end
			if value == 0 then
				C.ClearMapTradeFilterByMinTotalVolume(menu.holomap)
			else
				C.SetMapTradeFilterByMinTotalVolume(menu.holomap, value)
			end
		end
	end
	menu.refreshIF = getElapsedTime()
end

function menu.filterTradePlayerOffer(setting, override)
	for _, option in ipairs(setting) do
		if option.param == "playeroffer_buy" then
			local value = override
			if value == nil then
				value = menu.getFilterOption(option.id, setting.savegame) or 0
			end
			if value == 0 then
				C.ClearMapTradeFilterByPlayerOffer(menu.holomap, true)
			elseif value == 1 then
				C.SetMapTradeFilterByPlayerOffer(menu.holomap, true, true)
			elseif value == 2 then
				C.SetMapTradeFilterByPlayerOffer(menu.holomap, true, false)
			end
		elseif option.param == "playeroffer_sell" then
			local value = override
			if value == nil then
				value = menu.getFilterOption(option.id, setting.savegame) or 0
			end
			if value == 0 then
				C.ClearMapTradeFilterByPlayerOffer(menu.holomap, false)
			elseif value == 1 then
				C.SetMapTradeFilterByPlayerOffer(menu.holomap, false, true)
			elseif value == 2 then
				C.SetMapTradeFilterByPlayerOffer(menu.holomap, false, false)
			end
		end
	end
	menu.refreshIF = getElapsedTime()
end

function menu.filterThinkAlert(setting, override)
	for _, option in ipairs(setting) do
		local value = override
		if value == nil then
			value = menu.getFilterOption(option.id, setting.savegame) or false
		end
		if option.param == "alert" then
			C.SetMapAlertFilter(menu.holomap, value)
		end
	end
	menu.refreshIF = getElapsedTime()
end

function menu.filterThinkDiplomacy(setting, override)
	for _, option in ipairs(setting) do
		local value = override
		if value == nil then
			value = menu.getFilterOption(option.id, setting.savegame) or false
		end
		if option.param == "factioncolor" then
			C.SetMapFactionRelationColorOption(menu.holomap, not value)
		elseif option.param == "highlightvisitors" then
			C.SetConfigSetting(option.param, value)
		end
	end
	menu.refreshIF = getElapsedTime()
end

function menu.filterMining(value)
	for _, setting in ipairs(config.layersettings["layer_mining"]) do
		if value then
			setting.callback(setting)
		else
			setting.callback(setting, false)
		end
	end
end

function menu.filterMiningResources(setting, override)
	for _, option in ipairs(setting) do
		local value = override
		if value == nil then
			value = menu.getFilterOption(option.id, setting.savegame) or false
		end
		if option.param == "display" then
			C.SetMapRenderResourceInfo(menu.holomap, value)
		end
	end
end

function menu.filterOther(value)
	for _, setting in ipairs(config.layersettings["layer_other"]) do
		if value then
			setting.callback(setting)
		else
			setting.callback(setting, false)
		end
	end
end

function menu.filterOtherStation(setting, override)
	for _, option in ipairs(setting) do
		local value = override
		if value == nil then
			value = menu.getFilterOption(option.id, setting.savegame) or false
		end
		if option.param == "missions" then
			C.SetMapRenderMissionOffers(menu.holomap, value)
		elseif option.param == "civilian" then
			C.SetMapRenderCivilianShips(menu.holomap, value)
		end
	end
end

function menu.filterOtherShip(setting, override)
	for _, option in ipairs(setting) do
		local value = override
		if value == nil then
			value = menu.getFilterOption(option.id, setting.savegame) or false
		end
		if option.param == "orderqueue" then
			C.SetMapRenderAllOrderQueues(menu.holomap, value)
		elseif option.param == "allyorderqueue" then
			C.SetMapRenderAllAllyOrderQueues(menu.holomap, value)
		end
	end
end

function menu.filterOtherMisc(setting, override)
	for _, option in ipairs(setting) do
		local value = override
		if value == nil then
			value = menu.getFilterOption(option.id, setting.savegame) or false
		end
		if option.param == "ecliptic" then
			C.SetMapRenderEclipticLines(menu.holomap, value)
		elseif option.param == "wrecks" then
			C.SetMapRenderWrecks(menu.holomap, value)
		elseif option.param == "selectionlines" then
			C.SetMapRenderSelectionLines(menu.holomap, value)
		elseif option.param == "gateconnections" then
			C.SetMapRenderAllGateConnections(menu.holomap, value)
		elseif option.param == "opacity" then
			menu.refreshMainFrame = true
		elseif option.param == "coveroverride" then
			C.SetUICoverOverride(value)
			menu.refreshIF = getElapsedTime()
		elseif option.param == "rendersatelliteradarrange" then
			C.SetMapRenderSatelliteRadarRange(menu.holomap, value)
		end
	end
end

-- menu display
function menu.onShowMenu(state)
	-- Restore settings
	C.SetUICoverOverride(false)
	__CORE_DETAILMONITOR_MAPFILTER["other_misc_coveroverride"] = false

	-- Init variables
	menu.selectedcomponents = {}
	menu.borderOffset = Helper.frameBorder
	menu.sellShipsWidth = Helper.scaleX(300)
	menu.selectWidth = Helper.scaleX(260)
	menu.searchtext = {}
	menu.syncMapFilterWithConfig()
	menu.createLegend()
	menu.orderloopskill = C.GetOrderLoopSkillLimit() * 3
	menu.showMultiverse = false
	menu.onlineModeHintWidth = Helper.scaleX(600)

	-- Handle menu parameters
	menu.importMenuParameters()
	if menu.mode == nil then
		if state or menu.state then
			menu.onRestoreState(state or menu.state, state ~= nil)
			menu.state = nil
		end
	end
	if menu.initMultiverse then
		if Helper.hasExtension("multiverse") then
			Helper.callExtensionFunction("multiverse", "getVentures")
		end
		Helper.updateVenturePlatforms()

		menu.showMultiverse = true
		if Helper.hasExtension("multiverse") then
			Helper.callExtensionFunction("multiverse", "registerOnlineEvents", menu)
		end
	else
		menu.showMultiverse = false
	end
	menu.initMultiverse = nil

	if (menu.infoTableMode ~= "plots") and (menu.mode ~= "selectCV") then
		menu.plotData = {}
	end

	-- main frame
	menu.editboxHeight = math.max(23, Helper.scaleY(Helper.standardTextHeight))

	menu.sideBarWidth = Helper.scaleX(Helper.sidebarWidth)
	menu.sideBarOffsetX = menu.borderOffset
	menu.sideBarOffsetY = Helper.playerInfoConfig.offsetY + Helper.playerInfoConfig.height + menu.borderOffset / 2 + menu.sideBarWidth + 2 * Helper.borderSize

	-- infoTable
	menu.infoTableWidth = Helper.playerInfoConfig.width - menu.sideBarWidth - 2 * Helper.borderSize
	menu.infoTableWidth = math.max(menu.infoTableWidth, 400)
	menu.infoTableOffsetX = menu.sideBarOffsetX + menu.sideBarWidth + 2 * Helper.borderSize
	menu.infoTableOffsetY = Helper.playerInfoConfig.offsetY + Helper.playerInfoConfig.height + menu.borderOffset / 2

	-- searchfield
	menu.searchFieldData = {
		width = Helper.playerInfoConfig.width - menu.sideBarWidth - 2 * Helper.borderSize,
		offsetX = Helper.viewWidth - Helper.playerInfoConfig.width - menu.borderOffset,
		offsetY = menu.borderOffset,
	}

	-- map
	menu.rendertargetWidth = Helper.viewWidth
	menu.rendertargetHeight = Helper.viewHeight

	-- selected ships
	menu.selectedShipsTableData = {
		height = Helper.scaleY(20),
		width = Helper.scaleX(50),
		singleObjectWidth = Helper.scaleX(600),
		maxCols = 6,
		fontsize = Helper.scaleFont(Helper.standardFont, Helper.standardFontSize),
		textHeight = Helper.scaleY(Helper.standardTextHeight),
	}

	-- trade rules
	Helper.updateTradeRules()

	-- Possible orders
	menu.orderdefs = {}
	menu.orderdefbyid = {}
	local orderdefs_skillsorted = {}
	local orderdefcategories_skillsorted = { mining = true }
	local orderdefs_forcedorderatfront = { "TradeRoutine_Basic", "TradeRoutine_Advanced" }

	local n = C.GetNumOrderDefinitions()
	local buf = ffi.new("OrderDefinition[?]", n)
	n = C.GetOrderDefinitions(buf, n)
	for i = 0, n - 1 do
		local entry = {}
		entry.id = ffi.string(buf[i].id)
		entry.name = ffi.string(buf[i].name)
		entry.description = ffi.string(buf[i].description)
		entry.category = ffi.string(buf[i].category)
		entry.categoryname = ffi.string(buf[i].categoryname)
		entry.infinite = buf[i].infinite
		entry.requiredSkill = buf[i].requiredSkill
		entry.loopable = C.IsOrderLoopable(entry.id)
		table.insert(menu.orderdefs, entry)
		menu.orderdefbyid[entry.id] = entry
		if (orderdefcategories_skillsorted[entry.category]) then
			table.insert(orderdefs_skillsorted, entry)
			--orderdefcategories_skillsorted[entry.category] = entry.categoryname
		end
	end
	table.sort(menu.orderdefs, Helper.sortName)
	table.sort(orderdefs_skillsorted, function (a, b) return a.requiredSkill < b.requiredSkill end)
	for i, orderid in ipairs(orderdefs_forcedorderatfront) do
		for j, entry in ipairs(menu.orderdefs) do
			if entry.id == orderid then
				table.insert(menu.orderdefs, i, entry)
				table.remove(menu.orderdefs, j + 1)
				break
			end
		end
	end

	menu.orderdefsbycategory = {}
	for _, orderdef in ipairs(menu.orderdefs) do
		if (not orderdefcategories_skillsorted[orderdef.category]) then
			if menu.orderdefsbycategory[orderdef.category] then
				table.insert(menu.orderdefsbycategory[orderdef.category], orderdef)
			else
				menu.orderdefsbycategory[orderdef.category] = { orderdef }
			end
		end
	end
	for _, orderdef in ipairs(orderdefs_skillsorted) do
		if menu.orderdefsbycategory[orderdef.category] then
			table.insert(menu.orderdefsbycategory[orderdef.category], orderdef)
		else
			menu.orderdefsbycategory[orderdef.category] = { orderdef }
		end
	end

	Helper.setTabScrollCallback(menu, menu.onTabScroll)
	registerForEvent("inputModeChanged", getElement("Scene.UIContract"), menu.onInputModeChanged)

	menu.sound_ambient = StartPlayingSound("ui_map_ambient")
	menu.displayMenu(true)

	Helper.setKeyBinding(menu, menu.hotkey)
end

function menu.onMinimizeMenu()
	UnregisterAddonBindings("ego_detailmonitor")
	UnregisterEvent("updateHolomap", menu.updateHolomap)
	UnregisterEvent("info_updatePeople", menu.infoUpdatePeople)
	unregisterForEvent("inputModeChanged", getElement("Scene.UIContract"), menu.onInputModeChanged)
	menu.state = menu.onSaveState()
end

function menu.onRestoreMenu()
	if not menu.sound_ambient then
		menu.sound_ambient = StartPlayingSound("ui_map_ambient")
	end
	registerForEvent("inputModeChanged", getElement("Scene.UIContract"), menu.onInputModeChanged)
	menu.selectedcomponents = {}
	menu.displayMenu()

	Helper.setKeyBinding(menu, menu.hotkey)
end

function menu.onSaveState()
	local state = {}

	if menu.holomap ~= 0 then
		if not menu.showMultiverse then
			local mapstate = ffi.new("HoloMapState")
			C.GetMapState(menu.holomap, mapstate)
			state.map = { offset = { x = mapstate.offset.x, y = mapstate.offset.y, z = mapstate.offset.z, yaw = mapstate.offset.yaw, pitch = mapstate.offset.pitch, roll = mapstate.offset.roll,}, cameradistance = mapstate.cameradistance }
		else
			state.map = menu.normalMapCameraState
		end
	end

	for _, key in ipairs(config.stateKeys) do
		state[key[1]] = menu[key[1]]
		if (key[1] == "focuscomponent") then
			if menu.holomap ~= 0 then
				local currentfocus = C.GetMapFocusComponent(menu.holomap)
				state[key[1]] = (currentfocus ~= 0) and currentfocus or nil
			end
		end
	end
	return state
end

function menu.onRestoreState(state, restorefromsubmenu)
	if (not menu.showMultiverse) and (not menu.initMultiverse) then
		if state.map then
			local offset = ffi.new("UIPosRot", {
				x = state.map.offset.x,
				y = state.map.offset.y,
				z = state.map.offset.z,
				yaw = state.map.offset.yaw,
				pitch = state.map.offset.pitch,
				roll = state.map.offset.roll
			})
			menu.mapstate = ffi.new("HoloMapState", {
				offset = offset,
				cameradistance = state.map.cameradistance
			})
		end
	else
		menu.normalMapCameraState = state.map
	end

	local focuscomponent = menu.focuscomponent
	local focusoffset = menu.focusoffset
	menu.focusoffset = nil

	for _, key in ipairs(config.stateKeys) do
		if key[2] == "UniverseID" then
			menu[key[1]] = ConvertStringTo64Bit(tostring(state[key[1]]))
			if menu[key[1]] == 0 then
				menu[key[1]] = nil
			end
		elseif key[2] == "bool" then
			if type(state[key[1]]) == "number" then
				menu[key[1]] = state[key[1]] ~= 0
			else
				menu[key[1]] = state[key[1]]
			end
		else
			menu[key[1]] = state[key[1]]
		end
	end

	-- check if stored focuscomponent still makes sense
	if menu.focuscomponent then
		if not IsValidComponent(menu.focuscomponent) then
			-- component is not valid anymore, keep default value
			menu.focuscomponent = focuscomponent
		elseif not CanViewLiveData(menu.focuscomponent) then
			-- component is not in view anymore, keep default value
			menu.focuscomponent = focuscomponent
		end
	end
	if (not restorefromsubmenu) and menu.param[4] then
		-- we are not restoring from a submenu but opened the map with this explizit parameter, keep the parameter
		menu.focuscomponent = focuscomponent
		menu.focusoffset = focusoffset
		menu.mapstate = nil
	end
	-- check if stored infoSubmenuObject still makes sense
	if menu.infoSubmenuObject then
		if not IsValidComponent(menu.infoSubmenuObject) then
			-- component is not valid anymore, keep default value
			menu.infoSubmenuObject = nil
		end
	end
	-- check selectedcomponents
	local remove = {}
	for id, _ in pairs(menu.selectedcomponents) do
		local selectedcomponent = ConvertStringTo64Bit(id)
		if not (IsValidComponent(selectedcomponent) and CanViewLiveData(selectedcomponent)) then
			table.insert(remove, id)
		end
	end
	for _, id in ipairs(remove) do
		menu.selectedcomponents[id] = nil
	end
	-- update venture platforms
	Helper.updateVenturePlatforms()
	-- set plot mode if necessary (only if we are restoring from a submenu now, see mail "#Observations# March 18th 2023 X4KE")
	if menu.infoTableMode == "plots" then
		if not restorefromsubmenu then
			menu.infoTableMode = "objectlist"
		else
			menu.updatePlotData("plots_new", true)
			menu.storeCurrentPlots()
			menu.mode = "selectbuildlocation"
		end
	end
	if menu.mode == "selectbuildlocation" then
		if not restorefromsubmenu then
			menu.mode = nil
		end
	end
end

function menu.displayMenu(firsttime)
	-- register lua events
	RegisterEvent("updateHolomap", menu.updateHolomap)
	RegisterEvent("info_updatePeople", menu.infoUpdatePeople)

	-- Register bindings
	RegisterAddonBindings("ego_detailmonitor", "map")
	RegisterAddonBindings("ego_detailmonitor", "context")
	RegisterAddonBindings("ego_detailmonitor", "comm")
	RegisterAddonBindings("ego_detailmonitor", "autopilot")
	RegisterAddonBindings("ego_detailmonitor", "undo")
	RegisterAddonBindings("ego_detailmonitor", "modes")

	menu.renderedComponents = {}

	menu.holomapcolor = Helper.getHoloMapColors()
	menu.prepareEconomyWares()
	if firsttime then
		menu.prepareKnownSectors()
	end

	-- create frames
	menu.topRows = {}
	menu.selectedRows = {}
	menu.selectedCols = {}
	menu.activatemap = nil
	local curtime = getElapsedTime()
	menu.lastrefresh = curtime
	menu.lastHighlightCheck = curtime

	if menu.mode == "infomode" then
		menu.infoTableMode = menu.modeparam[1]

		if menu.infoTableMode == "info" then
			menu.infoSubmenuObject = ConvertStringTo64Bit(tostring(menu.modeparam[2]))
			menu.focuscomponent = menu.infoSubmenuObject
			if not menu.isInfoModeValidFor(menu.infoSubmenuObject, menu.infoMode.left) then
				menu.infoMode.left = "objectinfo"
			end
			if menu.modeparam[3] then
				menu.extendedinfo = {}
				for _, loccategory in ipairs(menu.modeparam[3]) do
					menu.extendedinfo[loccategory .. "left"] = true
				end
			end
		elseif menu.infoTableMode == "objectlist" then
			if menu.modeparam[2] then
				menu.objectMode = menu.modeparam[2]
			end
		elseif menu.infoTableMode == "propertyowned" then
			if menu.modeparam[2] then
				menu.propertyMode = menu.modeparam[2]
			end
		elseif menu.infoTableMode == "mission" then
			if menu.modeparam[2] then
				menu.missionMode = menu.modeparam[2]
			end
			if menu.modeparam[3] then
				menu.missionModeCurrent = menu.modeparam[3]
			end
			if menu.modeparam[4] and (menu.modeparam[4] ~= 0) then
				menu.expandedMissionGroups[menu.modeparam[3]] = true
			end
		end

		menu.mode = nil
		menu.modeparam = {}

		if menu.infoTableMode == "plots" then
			menu.initPlotList()
			local station = "plots_new"
			if C.IsRealComponentClass(menu.focuscomponent, "station") then
				station = menu.focuscomponent
			end
			menu.updatePlotData(station, true)
			menu.storeCurrentPlots()
			menu.mode = "selectbuildlocation"
		end
	elseif menu.mode == "hire" then
		menu.infoTableMode = "propertyowned"
		menu.searchTableMode = "hire"
	elseif menu.mode == "sellships" then
		C.SetTrackedMenuFullscreen(menu.name, false)
		local ships = {}
		for _, ship in ipairs(menu.modeparam[2]) do
			table.insert(ships, ConvertIDTo64Bit(ship))
		end
		menu.contextMenuData = { shipyard = ConvertIDTo64Bit(menu.modeparam[1]), ships = ships, xoffset = menu.modeparam[3], yoffset = menu.modeparam[4] }
		menu.contextMenuMode = "sellships"
		menu.createContextFrame(menu.sellShipsWidth)
	elseif menu.mode == "selectCV" then
		menu.infoTableMode = "objectlist"
		menu.objectMode = "objectall"
		menu.propertyMode = "propertyall"
		table.insert(menu.searchtext, { text = ReadText(1014, 803), blockRemove = true })
		menu.focuscomponent = ConvertIDTo64Bit(menu.modeparam[1])
		menu.focusoffset = nil
		menu.layerBackup = {}
		for _, entry in ipairs(config.layers) do
			local oldvalue = __CORE_DETAILMONITOR_MAPFILTER[entry.mode]
			__CORE_DETAILMONITOR_MAPFILTER[entry.mode] = false
			menu.layerBackup[entry.mode] = oldvalue
		end
		menu.layerBackup["think_diplomacy_highlightvisitor"] = __CORE_DETAILMONITOR_MAPFILTER["think_diplomacy_highlightvisitor"]
	elseif menu.mode == "selectComponent" then
		menu.infoTableMode = "objectlist"

		if menu.modeparam[3] == "deployables" then
			menu.objectMode = "deployables"
			menu.propertyMode = "deployables"
		end
	elseif menu.mode == "ventureconsole" then
		if C.AreVenturesCompatible() and (C.IsVentureSeasonSupported() or C.WasSessionOnline()) then
			if Helper.hasExtension("multiverse") then
				Helper.callExtensionFunction("multiverse", "getVentures")
			end
			Helper.updateVenturePlatforms()

			menu.showMultiverse = true
			if Helper.hasExtension("multiverse") then
				Helper.callExtensionFunction("multiverse", "registerOnlineEvents", menu)
			end

			menu.mode = nil
			menu.modeparam = {}

			local isonline = Helper.isOnlineGame()
			if isonline then
				local operation = OnlineGetCurrentOperation()
				local currentteam = OnlineGetCurrentTeam()
				if operation.isvalid and currentteam.isvalid then
					menu.ventureMode = "ventureoperation"
				else
					menu.ventureMode = "ventureseason"
					menu.seasonMode.left = "currentseason"
				end
			end
		else
			menu.mode = nil
			menu.modeparam = {}
		end
	end

	if menu.mode == "tradecontext" then
		local shadyOnly = false
		if menu.modeparam[4] then
			shadyOnly = menu.modeparam[4] ~= 0
		end

		local loop = false
		if menu.modeparam[5] then
			loop = menu.modeparam[5]
		end

		local width, height
		if loop then
			menu.contextMenuMode = "tradeloop"
			menu.contextMenuData = { component = ConvertIDTo64Bit(menu.modeparam[1]), currentShip = ConvertIDTo64Bit(menu.modeparam[6]), orders = {}, xoffset = Helper.viewWidth / 2 - config.tradeLoopWidth / 2, yoffset = Helper.frameBorder, tradeModeHeight = config.tradeLoopWidth, loop = loop, reservecargo = true }

			width = config.tradeLoopWidth
		else
			menu.contextMenuMode = "trade"
			menu.contextMenuData = { component = ConvertIDTo64Bit(menu.modeparam[1]), currentShip = ConvertIDTo64Bit(menu.modeparam[2]), shadyOnly = shadyOnly, orders = {}, xoffset = Helper.viewWidth / 2 - config.tradeContextMenuWidth / 2, yoffset = Helper.frameBorder, wareexchange = menu.modeparam[3] ~= 0 }

			local numwarerows, numinforows = menu.initTradeContextData()
			menu.updateTradeContextDimensions(numwarerows, numinforows)

			if menu.contextMenuData.xoffset + menu.tradeContext.width > Helper.viewWidth - Helper.frameBorder then
				menu.contextMenuData.xoffset = Helper.viewWidth - menu.tradeContext.width - Helper.frameBorder
			end
			menu.contextMenuData.tradeModeHeight = menu.tradeContext.shipheight + menu.tradeContext.buttonheight + 1 * Helper.borderSize
			if menu.contextMenuData.yoffset + menu.contextMenuData.tradeModeHeight > Helper.viewHeight - Helper.frameBorder then
				menu.contextMenuData.yoffset = Helper.viewHeight - menu.contextMenuData.tradeModeHeight - Helper.frameBorder
			end
			width = menu.tradeContext.width
			height = menu.contextMenuData.tradeModeHeight
		end

		menu.createMainFrame(nil, menu.contextMenuData.tradeModeHeight)

		menu.contextMenuData.yoffset = menu.contextMenuData.yoffset + menu.topLevelHeight
		menu.createContextFrame(width, height, menu.contextMenuData.xoffset, menu.contextMenuData.yoffset)
	elseif menu.mode == "boardingcontext" then
		-- accessing boarding menu from outside the map
		local width = Helper.viewWidth * 0.6
		local height = Helper.viewHeight * 0.7
		local xoffset = Helper.viewWidth * 0.2
		local yoffset = Helper.viewHeight * 0.15
		menu.closemapwithmenu = true
		menu.contextMenuMode = "boardingcontext"
		menu.contextMenuData = { target = menu.modeparam[1], boarders = menu.modeparam[2] }
		menu.createContextFrame(width, height, xoffset, yoffset)
	elseif menu.mode == "crewtransfercontext" then
		local mousepos = C.GetCenteredMousePos()
		menu.contextMenuMode = "crewtransfer"
		menu.contextMenuData = { leftShip = menu.modeparam[1], rightShip = menu.modeparam[2], extendedTier = {}, xoffset = mousepos.x + Helper.viewWidth / 2, yoffset = mousepos.y + Helper.viewHeight / 2 }

		local width = Helper.scaleX(config.crewTransferWidth)
		if menu.contextMenuData.xoffset + width > Helper.viewWidth then
			menu.contextMenuData.xoffset = Helper.viewWidth - width - Helper.frameBorder
		end

		menu.createContextFrame(width, nil, menu.contextMenuData.xoffset, menu.contextMenuData.yoffset)
	elseif menu.mode == "dropwarescontext" then
		C.SetTrackedMenuFullscreen(menu.name, false)
		local x, y = GetLocalMousePosition()

		menu.contextMenuMode = "dropwares"
		menu.contextMenuData = { mode = menu.modeparam[1], entity = ConvertStringTo64Bit(tostring(menu.modeparam[2])), xoffset = x + Helper.viewWidth / 2, yoffset = Helper.viewHeight / 2 - y, wares = {} }

		if menu.contextMenuData.mode == "inventory" then
			local inventory = GetInventory(menu.contextMenuData.entity)
			local onlineitems = OnlineGetUserItems()

			for ware, entry in pairs(inventory) do
				local ispersonalupgrade = GetWareData(ware, "ispersonalupgrade")
				if (not ispersonalupgrade) and (not onlineitems[ware]) then
					table.insert(menu.contextMenuData.wares, { ware = ware, name = entry.name, amount = entry.amount })
				end
			end
			table.sort(menu.contextMenuData.wares, Helper.sortName)
		end

		local height = (#menu.contextMenuData.wares + 5) * (Helper.scaleY(config.mapRowHeight) + Helper.borderSize)
		if menu.contextMenuData.yoffset + height > Helper.viewHeight then
			menu.contextMenuData.yoffset = Helper.viewHeight - height - Helper.frameBorder
		end
		if menu.contextMenuData.xoffset + config.dropInventoryWidth > Helper.viewWidth then
			menu.contextMenuData.xoffset = Helper.viewWidth - config.dropInventoryWidth - Helper.frameBorder
		end

		menu.createContextFrame(config.dropInventoryWidth, nil, menu.contextMenuData.xoffset, menu.contextMenuData.yoffset)
	elseif menu.mode == "renamecontext" then
		local x, y = GetLocalMousePosition()

		menu.contextMenuMode = "rename"

		-- kuertee start: multi-rename
		-- menu.contextMenuData = { component = menu.modeparam[1], fleetrename = menu.modeparam[2] ~= 0, xoffset = x + Helper.viewWidth / 2, yoffset = Helper.viewHeight / 2 - y }
		menu.contextMenuData = {
			component = menu.modeparam[1],
			fleetrename = menu.modeparam[2] ~= 0,
			uix_multiRename_objects = menu.modeparam[3],
			xoffset = x + Helper.viewWidth / 2,
			yoffset = Helper.viewHeight / 2 - y
		}
		-- kuertee end: multi-rename

		local width = Helper.scaleX(config.renameWidth)
		if menu.contextMenuData.xoffset + width > Helper.viewWidth then
			menu.contextMenuData.xoffset = Helper.viewWidth - width - Helper.frameBorder
		end

		menu.createContextFrame(width, nil, menu.contextMenuData.xoffset, menu.contextMenuData.yoffset)
	elseif menu.mode == "changelogocontext" then
		local x, y = GetLocalMousePosition()

		menu.contextMenuMode = "changelogo"
		menu.contextMenuData = { component = menu.modeparam[1], origlogo = {}, currentlogo = {}, xoffset = x + Helper.viewWidth / 2, yoffset = Helper.viewHeight / 2 - y }

		local buf = C.GetCurrentFleetLogo(menu.contextMenuData.component)
		menu.contextMenuData.origlogo = { file = ffi.string(buf.file), icon = ffi.string(buf.icon), ispersonal = buf.ispersonal }
		menu.contextMenuData.currentlogo = menu.contextMenuData.origlogo

		local width = Helper.scaleX(config.changeLogoWidth)
		if menu.contextMenuData.xoffset + width > Helper.viewWidth then
			menu.contextMenuData.xoffset = Helper.viewWidth - width - Helper.frameBorder
		end

		menu.createContextFrame(width, nil, menu.contextMenuData.xoffset, menu.contextMenuData.yoffset)
	elseif menu.mode == "venturepatroninfo" then
		local x, y = GetLocalMousePosition()

		menu.contextMenuMode = "venturepatron"
		menu.contextMenuData = { component = menu.modeparam[1], xoffset = x + Helper.viewWidth / 2, yoffset = Helper.viewHeight / 2 - y }

		local width = Helper.scaleX(config.venturePatronWidth)
		if menu.contextMenuData.xoffset + width > Helper.viewWidth then
			menu.contextMenuData.xoffset = Helper.viewWidth - width - Helper.frameBorder
		end

		menu.createContextFrame(width, nil, menu.contextMenuData.xoffset, menu.contextMenuData.yoffset)
	elseif menu.mode == "venturereport" then
		local x, y = GetLocalMousePosition()

		menu.contextMenuMode = "venturereport"
		menu.contextMenuData = { mode = "venturereport", submode = menu.modeparam[1], reason = menu.modeparam[2], timestamp = menu.modeparam[3], author = menu.modeparam[4], transactionid = menu.modeparam[5], userid = menu.modeparam[6], xoffset = x + Helper.viewWidth / 2, yoffset = Helper.viewHeight / 2 - y }

		local width = Helper.scaleX(config.venturePatronWidth)
		if menu.contextMenuData.xoffset + width > Helper.viewWidth then
			menu.contextMenuData.xoffset = Helper.viewWidth - width - Helper.frameBorder
		end

		menu.createContextFrame(width, nil, menu.contextMenuData.xoffset, menu.contextMenuData.yoffset, nil, false)
	else
		menu.createMainFrame(firsttime)

		if firsttime then
			if menu.infoTableMode then
				AddUITriggeredEvent(menu.name, menu.infoTableMode)
				local tab
				if menu.infoTableMode == "objectlist" then
					tab = menu.objectMode
				elseif menu.infoTableMode == "propertyowned" then
					tab = menu.propertyMode
				elseif menu.infoTableMode == "info" then
					tab = menu.infoMode
				elseif menu.infoTableMode == "missionoffer" then
					tab = menu.missionOfferMode
				elseif menu.infoTableMode == "mission" then
					tab = menu.missionMode
				end
				if tab then
					AddUITriggeredEvent(menu.name, "infoTableTab", tab)
				end
			end
		end
		menu.createInfoFrame()

		if menu.showMultiverse then
			local isonline = Helper.isOnlineGame()
			local operationRewardPending = Helper.hasVentureRewards()
			if C.IsVentureSeasonSupported() and (not isonline) then
				menu.contextMenuMode = "onlinemode"
				menu.contextMenuData = { xoffset = 0, yoffset = menu.topLevelHeight, instance = instance, width = Helper.viewWidth, height = Helper.viewHeight - 2 * menu.topLevelHeight }
				menu.createContextFrame(nil, nil, nil, nil, 0)
			elseif operationRewardPending then
				menu.contextMenuMode = "onlinereward"
				menu.contextMenuData = { xoffset = 0, yoffset = menu.topLevelHeight, instance = instance, width = Helper.viewWidth, height = Helper.viewHeight - 2 * menu.topLevelHeight, rewardentries = OnlineGetLogbookRewards() }
				menu.createContextFrame(nil, nil, nil, nil, 0)
			end
		end
	end
end

-- create main frame (sideBar, navBar, map)
function menu.createMainFrame(firsttime, height, refresh)
	menu.createMainFrameRunning = true
	-- remove old data
	Helper.removeAllWidgetScripts(menu, config.mainFrameLayer)

	menu.mainFrame = Helper.createFrameHandle(menu, {
		layer = config.mainFrameLayer,
		standardButtons = { back = true, close = true, help = true },
		standardButtonHelpOverlays = { help = "map_standardbutton_help" },
		width = Helper.viewWidth,
		height = Helper.viewHeight,
		x = 0,
		y = 0,
	})

	-- player info
	menu.createPlayerInfo(menu.mainFrame, Helper.playerInfoConfig.width, Helper.playerInfoConfig.height, Helper.playerInfoConfig.offsetX, Helper.playerInfoConfig.offsetY)
	if menu.mode ~= "tradecontext" then
		if not menu.showMultiverse then
			-- search field
			menu.createSearchField(menu.mainFrame, menu.searchFieldData.width, 0, menu.searchFieldData.offsetX, menu.searchFieldData.offsetY, refresh)
		else
			Helper.clearTableConnectionColumn(menu, 3)
		end
		-- sideBar
		menu.createSideBar(firsttime, menu.mainFrame, menu.sideBarWidth, 0, menu.sideBarOffsetX, menu.sideBarOffsetY)
		if not menu.showMultiverse then
			-- rightBar
			menu.createRightBar(menu.mainFrame, menu.sideBarWidth, 0, Helper.viewWidth - menu.sideBarWidth - menu.borderOffset, menu.searchFieldData.offsetY)
			-- selected ships
			menu.createSelectedShips(menu.mainFrame)
		else
			Helper.clearTableConnectionColumn(menu, 4)
		end
	end
	-- top level
	menu.createTopLevel(menu.mainFrame)
	if menu.mode ~= "tradecontext" then
		-- map
		local alpha = 98
		if __CORE_DETAILMONITOR_MAPFILTER["other_misc_opacity"] then
			alpha = 100
		end
		menu.mainFrame:addRenderTarget({width = menu.rendertargetWidth, height = menu.rendertargetHeight, x = 0, y = 0, scaling = false, alpha = alpha, clear = false })
	end

	if menu.mode == "tradecontext" then
		menu.mainFrame.properties.background.icon = "solid"
		menu.mainFrame.properties.background.color = Color["frame_background_semitransparent"]
		if height then
			menu.mainFrame.properties.height = height + menu.topLevelHeight + 2 * Helper.frameBorder
		end
	end

	menu.mainFrame:display()
end

-- (re)create info frame (infoTable)
function menu.createInfoFrame()
	menu.createInfoFrameRunning = true
	menu.refreshed = true
	menu.noupdate = false

	-- remove old data
	Helper.clearDataForRefresh(menu, config.infoFrameLayer)

	-- infoTable
	local infoTableHeight = Helper.viewHeight - menu.infoTableOffsetY - menu.borderOffset

	menu.infoFrame = Helper.createFrameHandle(menu, {
		x = menu.infoTableOffsetX,
		y = menu.infoTableOffsetY,
		width = menu.infoTableWidth,
		height = infoTableHeight,
		layer = config.infoFrameLayer,
		standardButtons = {},
		autoFrameHeight = true,
		helpOverlayID = "map_infoframe",
	})
	menu.infoFrame:setBackground("solid", { color = Color["frame_background_semitransparent"] })

	menu.autopilottarget = GetAutoPilotTarget()
	menu.softtarget = C.GetSofttarget2().softtargetID
	menu.populateUpkeepMissionData()

	if (menu.infoTableMode ~= "info") and (menu.mode ~= "orderparam_object") then
		menu.infoTablePersistentData.left.cashtransferdetails = {}
		menu.infoTablePersistentData.left.drops = {}
		menu.infoTablePersistentData.left.crew.object = nil
		menu.infoTablePersistentData.left.macrostolaunch = {}
	end

	if menu.holomap ~= 0 then
		if menu.infoTableMode then
			C.SetMapStationInfoBoxMargin(menu.holomap, "left", menu.infoTableOffsetX + menu.infoTableWidth + config.contextBorder)
		else
			C.SetMapStationInfoBoxMargin(menu.holomap, "left", 0)
		end
	end

	Helper.clearTableConnectionColumn(menu, 2)

	local helpOverlayText = ""

	local infotabledesc, infotabledesc2
	menu.infoTableData = menu.infoTableData or {}
	menu.infoTableData.left = {}
	if menu.showMultiverse then
		if menu.ventureMode == "ventureseason" then
			if menu.seasonMode.left == "currentseason" then
				menu.createVentureSeason(menu.infoFrame, "left")
			elseif menu.seasonMode.left == "coalition" then
				Helper.callExtensionFunction("multiverse", "createVentureCoalition", menu, menu.infoFrame, "left")
			elseif menu.seasonMode.left == "ventureteam" then
				Helper.callExtensionFunction("multiverse", "createVentureTeam", menu, menu.infoFrame, "left")
			elseif menu.seasonMode.left == "pastseasons" then
				Helper.callExtensionFunction("multiverse", "createVenturePastSeasons", menu, menu.infoFrame, "left")
			end
		elseif menu.ventureMode == "ventureoperation" then
			Helper.callExtensionFunction("multiverse", "createVentureOperation", menu, menu.infoFrame, "left")
		elseif menu.ventureMode == "venturelogbook" then
			Helper.callExtensionFunction("multiverse", "createVentureLogbook", menu, menu.infoFrame, "left")
		elseif menu.ventureMode == "ventureinventory" then
			Helper.callExtensionFunction("multiverse", "createVentureInventory", menu, menu.infoFrame, "left")
		elseif menu.ventureMode == "venturecontacts" then
			Helper.createVentureContacts(menu, menu.infoFrame, "left", menu.infoTableWidth, nil, nil, menu.infoTableOffsetX, menu.infoTableOffsetY)
		else
			-- empty
			menu.infoFrame.properties.background.icon = ""
			menu.infoFrame.properties.autoFrameHeight = false
			menu.infoFrame:addTable(0)
		end
	else
		if menu.infoTableMode == "objectlist" then
			infotabledesc, infotabledesc2 = menu.createObjectList(menu.infoFrame, "left")
		elseif menu.infoTableMode == "propertyowned" then
			infotabledesc = menu.createPropertyOwned(menu.infoFrame, "left")
		elseif menu.infoTableMode == "plots" then
			menu.createPlotMode(menu.infoFrame)
		elseif menu.infoTableMode == "info" then
			if menu.infoMode.left == "objectinfo" then
				menu.infoFrame.properties.autoFrameHeight = false
				menu.createInfoSubmenu(menu.infoFrame, "left")
			elseif menu.infoMode.left == "objectcrew" then
				menu.createCrewInfoSubmenu(menu.infoFrame, "left")
			elseif menu.infoMode.left == "objectloadout" then
				menu.createLoadoutInfoSubmenu(menu.infoFrame, "left")
			elseif menu.infoMode.left == "objectlogbook" then
				menu.createLogbookInfoSubmenu(menu.infoFrame, "left")
			elseif menu.infoMode.left == "orderqueue" then
				menu.createOrderQueue(menu.infoFrame, menu.infoMode.left, "left")
			elseif menu.infoMode.left == "orderqueue_advanced" then
				menu.createOrderQueue(menu.infoFrame, menu.infoMode.left, "left")
			elseif menu.infoMode.left == "standingorders" then
				menu.createStandingOrdersMenu(menu.infoFrame, "left")
			end
		elseif menu.infoTableMode == "missionoffer" then
			menu.createMissionMode(menu.infoFrame)
		elseif menu.infoTableMode == "mission" then
			menu.createMissionMode(menu.infoFrame)
		elseif menu.infoTableMode == "cheats" then
			menu.createCheats(menu.infoFrame)
		else
			-- empty
			-- kuertee start: callback
			-- menu.infoFrame.properties.background.icon = ""
			-- menu.infoFrame.properties.autoFrameHeight = false
			-- menu.infoFrame:addTable(0)
			local isCreated = false
			if callbacks ["createInfoFrame_on_menu_infoTableMode"] then
				for _, callback in ipairs (callbacks ["createInfoFrame_on_menu_infoTableMode"]) do
					if callback (menu.infoFrame) then
						isCreated = true
					end
				end
			end
			if isCreated ~= true then
				menu.infoFrame.properties.background.icon = ""
				menu.infoFrame.properties.autoFrameHeight = false
				menu.infoFrame:addTable(0)
			end
			-- kuertee end: callback

			-- start Forleyor_infoCenter callback:
			local isCreated = false
			if callbacks ["ic_createInfoFrame"] then
				for _, callback in ipairs (callbacks ["ic_createInfoFrame"]) do
					if callback (menu.infoFrame) then
						isCreated = true
					end
				end
			end
			if isCreated ~= true then
				menu.infoFrame:addTable(0)
			end
			-- end Forleyor_infoCenter callback:

		end

	end
	menu.infoFrame.properties.helpOverlayText = helpOverlayText
	menu.infoFrame:display()

	if menu.holomap and (menu.holomap ~= 0) then
		menu.setSelectedMapComponents()
	end
end

-- create context frame
function menu.createContextFrame(width, height, xoffset, yoffset, noborder, startanimation)
	PlaySound("ui_positive_click")
	Helper.removeAllWidgetScripts(menu, config.contextFrameLayer)

	menu.contextMenuData = menu.contextMenuData or {}
	if width then
		menu.contextMenuData.width = width
	end
	if height then
		menu.contextMenuData.height = height
	end
	if xoffset then
		menu.contextMenuData.xoffset = xoffset
	end
	if yoffset then
		menu.contextMenuData.yoffset = yoffset
	end

	if menu.contextMenuData.xoffset + menu.contextMenuData.width + Helper.borderSize > Helper.viewWidth then
		menu.contextMenuData.width = Helper.viewWidth - menu.contextMenuData.xoffset - Helper.borderSize
	end

	local closeOnUnhandledClick = true
	if menu.contextMenuMode == "boardingcontext" then
		closeOnUnhandledClick = false
	elseif menu.contextMenuMode == "onlinemode" then
		closeOnUnhandledClick = false
	elseif menu.contextMenuMode == "onlinereward" then
		closeOnUnhandledClick = false
	end
	if menu.contextMenuData.mode == "discardplanneddefaultbehaviour" then
		closeOnUnhandledClick = false
	end
	if menu.mode == "tradecontext" then
		closeOnUnhandledClick = false
	end

	menu.contextFrame = Helper.createFrameHandle(menu, {
		x = menu.contextMenuData.xoffset - (noborder and 0 or 2 * Helper.borderSize),
		y = menu.contextMenuData.yoffset,
		width = menu.contextMenuData.width + (noborder and 0 or 2 * Helper.borderSize),
		layer = config.contextFrameLayer,
		standardButtons = { close = true },
		closeOnUnhandledClick = closeOnUnhandledClick,
		startAnimation = startanimation,
	})
	menu.contextFrame:setBackground("solid", { color = Color["frame_background_semitransparent"] })

	local adjustFrameHeight = true
	if menu.contextMenuMode == "neworder" then
		menu.createNewOrderContext(menu.contextFrame, menu.contextMenuData.instance)
	elseif menu.contextMenuMode == "set_orderparam_ware" then
		menu.createOrderparamWareContext(menu.contextFrame, menu.contextMenuData.instance)
	elseif menu.contextMenuMode == "set_orderparam_sector" then
		menu.createOrderparamSectorContext(menu.contextFrame, menu.contextMenuData.instance)
	elseif menu.contextMenuMode == "filter_multiselectlist" then
		menu.createFilterparamWareContext(menu.contextFrame)
	elseif menu.contextMenuMode == "set_orderparam_formationshape" then
		menu.createOrderparamFormationShapeContext(menu.contextFrame, menu.contextMenuData.instance)
	elseif menu.contextMenuMode == "trade" then
		menu.createTradeContext(menu.contextFrame)
	elseif menu.contextMenuMode == "tradeloop" then
		menu.createTradeLoopContext(menu.contextFrame)
	elseif menu.contextMenuMode == "mission" then
		menu.createMissionContext(menu.contextFrame)
	elseif menu.contextMenuMode == "boardingcontext" then
		menu.oldmode = menu.mode
		menu.mode = "boardingcontext"
		menu.oldInfoTableMode = menu.infoTableMode
		menu.infoTableMode = nil
		menu.refreshInfoFrame()
		menu.createBoardingContext(menu.contextFrame, menu.contextMenuData.target, menu.contextMenuData.boarders)
	elseif menu.contextMenuMode == "weaponconfig" then
		menu.createWeaponConfigContext(menu.contextFrame, menu.contextMenuData.instance)
	elseif menu.contextMenuMode == "sellships" then
		menu.createSellShipsContext(menu.contextFrame)
	elseif menu.contextMenuMode == "select" then
		menu.createSelectContext(menu.contextFrame)
	elseif menu.contextMenuMode == "info_context" then
		menu.createInfoContext(menu.contextFrame)
	elseif menu.contextMenuMode == "dropwares" then
		Helper.createDropWaresContext(menu, menu.contextFrame, menu.contextMenuData.instance)
	elseif menu.contextMenuMode == "crewtransfer" then
		menu.initCrewTransferData()
		menu.createCrewTransferContext(menu.contextFrame)
	elseif menu.contextMenuMode == "rename" then
		menu.createRenameContext(menu.contextFrame)
	elseif menu.contextMenuMode == "changelogo" then
		menu.createChangeLogoContext(menu.contextFrame)
	elseif menu.contextMenuMode == "userquestion" then
		menu.createUserQuestionContext(menu.contextFrame)
	elseif menu.contextMenuMode == "userquestion_multiverse" then
		Helper.callExtensionFunction("multiverse", "createUserQuestionContext", menu, menu.contextFrame)
	elseif menu.contextMenuMode == "onlinemode" then
		local contexttable = menu.createOnlineModeContext(menu.contextFrame)
		menu.contextFrame:setBackground("gradient_alpha_02", {  })
		menu.contextFrame:setBackground2("tut_gradient_hint_01", { color = Color["frame_background2_notification"], width = menu.onlineModeHintWidth + 3 * Helper.borderSize, height = contexttable:getFullHeight() + 4 * Helper.borderSize, rotationStart = 135 })
		menu.contextFrame.properties.standardButtons = {}
		menu.contextFrame.properties.height = menu.contextMenuData.height
		adjustFrameHeight = false
	elseif menu.contextMenuMode == "ventureconfig" then
		Helper.callExtensionFunction("multiverse", "showVentureConfigurationContext", menu, menu.contextFrame, menu.contextMenuData.instance)
	elseif menu.contextMenuMode == "venturecreateparty" then
		Helper.callExtensionFunction("multiverse", "createVentureCreatePartyContext", menu, menu.contextFrame, menu.contextMenuData.instance)
	elseif menu.contextMenuMode == "venturepatron" then
		Helper.callExtensionFunction("multiverse", "createVenturePatronContext", menu, menu.contextFrame, menu.contextMenuData.instance)
	elseif menu.contextMenuMode == "venturereport" then
		Helper.callExtensionFunction("multiverse", "createUserQuestionContext", menu, menu.contextFrame)
	elseif menu.contextMenuMode == "ventureteammembercontext" then
		Helper.callExtensionFunction("multiverse", "createVentureTeamMemberContext", menu, menu.contextFrame)
	elseif menu.contextMenuMode == "venturecontactcontext" then
		Helper.createVentureContactContext(menu, menu.contextFrame)
	elseif menu.contextMenuMode == "venturefriendlist" then
		Helper.showVentureFriendListContext(menu, menu.contextFrame)
	elseif menu.contextMenuMode == "hire" then
		menu.createHireContext(menu.contextFrame)
	elseif menu.contextMenuMode == "ventureoutcome" then
		Helper.callExtensionFunction("multiverse", "createVentureOutcomeContext", menu, menu.contextFrame, menu.contextMenuData.instance)
	elseif menu.contextMenuMode == "onlinereward" then
		local contexttable
		contexttable, menu.contextMenuData.allowClose = Helper.callExtensionFunction("multiverse", "createVentureRewardContext", menu, menu.contextFrame, menu.contextMenuData.instance)
		menu.contextFrame:setBackground("gradient_alpha_02", {  })
		if not menu.contextMenuData.allowClose then
			menu.contextFrame:setBackground2("tut_gradient_hint_01", { color = Color["frame_background2_notification"], width = menu.onlineModeHintWidth + 3 * Helper.borderSize, height = contexttable:getFullHeight() + 4 * Helper.borderSize, rotationRate = 360, rotationStart = 135, rotationDuration = 4, rotationInterval = 10 })
			menu.contextFrame.properties.standardButtons = {}
		else
			menu.contextFrame:setBackground2("tut_gradient_hint_01", { color = Color["frame_background2_notification"], width = menu.onlineModeHintWidth + 3 * Helper.borderSize, height = contexttable:getFullHeight() + 4 * Helper.borderSize, rotationStart = 135 })
			menu.contextFrame.properties.standardButtonX = Helper.viewWidth - contexttable.properties.x - menu.onlineModeHintWidth - Helper.borderSize
			menu.contextFrame.properties.standardButtonY = contexttable.properties.y
		end
		menu.contextFrame.properties.height = menu.contextMenuData.height
		adjustFrameHeight = false
	elseif menu.contextMenuMode == "searchfield" then
		menu.createSearchFieldContext(menu.contextFrame)
		menu.contextFrame.properties.standardButtons = {}
	end

	-- only add one border as the table y offset already is part of frame:getUsedHeight()
	if adjustFrameHeight then
		menu.contextFrame.properties.height = math.min(Helper.viewHeight - menu.contextFrame.properties.y, menu.contextFrame:getUsedHeight() + Helper.borderSize)
	end
	menu.contextFrame:display()
end

-- handle created frames
function menu.viewCreated(layer, ...)
	if layer == config.mainFrameLayer then
		if menu.mode ~= "tradecontext" then
			if menu.showMultiverse then
				menu.playerInfoTable, menu.sideBar, menu.topLevel, menu.map = ...
			else
				menu.playerInfoTable, menu.searchField, menu.sideBar, menu.rightBar, menu.selectedShipsTable, menu.topLevel, menu.map = ...
			end

			if menu.activatemap == nil then
				menu.activatemap = true
			end
		else
			menu.playerInfoTable, menu.topLevel = ...
		end
		menu.createMainFrameRunning = false
	elseif layer == config.infoFrameLayer then
		menu.infoTable, menu.infoTable2, menu.infoTable3 = ...

		menu.createInfoFrameRunning = false
	elseif layer == config.infoFrameLayer2 then
		menu.infoTableRight, menu.infoTableRight2, menu.infoTableRight3 = ...

		menu.createInfoFrame2Running = false
	elseif layer == config.contextFrameLayer then
		if menu.contextMenuMode == "neworder" then
			menu.contexttable = ...
		elseif menu.contextMenuMode == "set_orderparam_ware" then
			menu.contexttable = ...
		elseif menu.contextMenuMode == "set_orderparam_sector" then
			menu.contexttable = ...
		elseif menu.contextMenuMode == "set_orderparam_formationshape" then
			menu.contexttable = ...
		elseif menu.contextMenuMode == "trade" then
			menu.contextshiptable, menu.contextbuttontable = ...
		elseif menu.contextMenuMode == "tradeloop" then
			menu.contextshiptable, menu.contextbuttontable = ...
		elseif menu.contextMenuMode == "mission" then
			menu.contextdesctable, menu.contextobjectivetable, menu.contextbottomtable = ...

			if menu.contextMenuData.isoffer then
				RegisterEvent("missionofferremoved", menu.onMissionOfferRemoved)
			else
				RegisterEvent("missionremoved", menu.onMissionRemoved)
			end
		elseif menu.contextMenuMode == "weaponconfig" then
			menu.contexttable = ...
		elseif menu.contextMenuMode == "sellships" then
			menu.contexttable = ...
		elseif menu.contextMenuMode == "select" then
			menu.contexttable = ...
		elseif menu.contextMenuMode == "crewtransfer" then
			menu.contextbuttontable, menu.contexttable = ...
		elseif menu.contextMenuMode == "ventureconfig" then
			menu.contexttitletable, menu.contextmissiontable, menu.contextinfotable, menu.contextbuttontable, menu.contextrewardtable, menu.contextdescriptiontable = ...
		elseif menu.contextMenuMode == "hire" then
			menu.contexttable = ...
		end
	end
end

function menu.refreshContextFrame(setrow, setcol, noborder)
	Helper.removeAllWidgetScripts(menu, config.contextFrameLayer)

	local closeOnUnhandledClick = true
	if menu.contextMenuMode == "boardingcontext" then
		closeOnUnhandledClick = false
	elseif menu.contextMenuMode == "onlinemode" then
		closeOnUnhandledClick = false
	elseif menu.contextMenuMode == "onlinereward" then
		closeOnUnhandledClick = false
	end
	if menu.contextMenuData.mode == "discardplanneddefaultbehaviour" then
		closeOnUnhandledClick = false
	end
	if menu.mode == "tradecontext" then
		closeOnUnhandledClick = false
	end

	menu.contextFrame = Helper.createFrameHandle(menu, {
		x = menu.contextMenuData.xoffset - (noborder and 0 or 2 * Helper.borderSize),
		y = menu.contextMenuData.yoffset,
		width = menu.contextMenuData.width + (noborder and 0 or 2 * Helper.borderSize),
		layer = config.contextFrameLayer,
		standardButtons = { close = true },
		closeOnUnhandledClick = closeOnUnhandledClick,
	})
	menu.contextFrame:setBackground("solid", { color = Color["frame_background_semitransparent"] })

	local adjustFrameHeight = true
	if menu.contextMenuMode == "boardingcontext" then
		menu.contexttoprow = GetTopRow(menu.boardingtable_shipselection.id)
		menu.contextselectedrow = Helper.currentTableRow[menu.boardingtable_shipselection.id]

		menu.createBoardingContext(menu.contextFrame, menu.contextMenuData.target, menu.contextMenuData.boarders)
	elseif menu.contextMenuMode == "crewtransfer" then
		menu.contexttoprow = GetTopRow(menu.contexttable)
		menu.contextselectedrow = Helper.currentTableRow[menu.contexttable]

		menu.createCrewTransferContext(menu.contextFrame)
	elseif menu.contextMenuMode == "tradeloop" then
		menu.contextselectedrow = Helper.currentTableRow[menu.contextbuttontable]

		menu.createTradeLoopContext(menu.contextFrame)
	elseif menu.contextMenuMode == "ventureconfig" then
		menu.topRows.contextdescriptiontable = GetTopRow(menu.contextdescriptiontable)
		menu.selectedRows.contextdescriptiontable = setrow or Helper.currentTableRow[menu.contextdescriptiontable]
		menu.selectedCols.contextdescriptiontable = setcol or Helper.currentTableCol[menu.contextdescriptiontable]

		menu.topRows.contextinfotable = GetTopRow(menu.contextinfotable)
		menu.selectedRows.contextinfotable = setrow or Helper.currentTableRow[menu.contextinfotable]
		menu.selectedCols.contextinfotable = setcol or Helper.currentTableCol[menu.contextinfotable]

		menu.topRows.contextbuttontable = GetTopRow(menu.contextbuttontable)
		menu.selectedRows.contextbuttontable = Helper.currentTableRow[menu.contextbuttontable]
		menu.selectedCols.contextbuttontable = Helper.currentTableCol[menu.contextbuttontable]

		Helper.callExtensionFunction("multiverse", "showVentureConfigurationContext", menu, menu.contextFrame, menu.contextMenuData.instance)
	elseif menu.contextMenuMode == "venturecreateparty" then
		Helper.callExtensionFunction("multiverse", "createVentureCreatePartyContext", menu, menu.contextFrame, menu.contextMenuData.instance)
	elseif menu.contextMenuMode == "hire" then
		menu.createHireContext(menu.contextFrame)
	elseif menu.contextMenuMode == "dropwares" then
		Helper.createDropWaresContext(menu, menu.contextFrame, menu.contextMenuData.instance)
	elseif menu.contextMenuMode == "ventureoutcome" then
		Helper.callExtensionFunction("multiverse", "createVentureOutcomeContext", menu, menu.contextFrame, menu.contextMenuData.instance)
	elseif menu.contextMenuMode == "onlinereward" then
		local contexttable
		contexttable, menu.contextMenuData.allowClose = Helper.callExtensionFunction("multiverse", "createVentureRewardContext", menu, menu.contextFrame, menu.contextMenuData.instance)
		menu.contextFrame:setBackground("gradient_alpha_02", {  })
		if not menu.contextMenuData.allowClose then
			menu.contextFrame:setBackground2("tut_gradient_hint_01", { color = Color["hint_background_orange"], width = menu.onlineModeHintWidth + 3 * Helper.borderSize, height = contexttable:getFullHeight() + 4 * Helper.borderSize, rotationRate = 360, rotationStart = 135, rotationDuration = 4, rotationInterval = 10 })
			menu.contextFrame.properties.standardButtons = {}
		else
			menu.contextFrame:setBackground2("tut_gradient_hint_01", { color = Color["hint_background_azure"], width = menu.onlineModeHintWidth + 3 * Helper.borderSize, height = contexttable:getFullHeight() + 4 * Helper.borderSize, rotationStart = 135 })
			menu.contextFrame.properties.standardButtonX = Helper.viewWidth - contexttable.properties.x - menu.onlineModeHintWidth - Helper.borderSize
			menu.contextFrame.properties.standardButtonY = contexttable.properties.y
		end
		menu.contextFrame.properties.height = menu.contextMenuData.height
		adjustFrameHeight = false
	elseif menu.contextMenuMode == "searchfield" then
		menu.createSearchFieldContext(menu.contextFrame)
		menu.contextFrame.properties.standardButtons = {}
	end

	-- only add one border as the table y offset already is part of frame:getUsedHeight()
	if adjustFrameHeight then
		menu.contextFrame.properties.height = math.min(Helper.viewHeight - menu.contextFrame.properties.y, menu.contextFrame:getUsedHeight() + Helper.borderSize)
	end
	menu.contextFrame:display()
end

function menu.refreshInfoFrame(setrow, setcol, setrow2, setcol2)
	if (menu.mode == "tradecontext") or (menu.mode == "dropwarescontext") or (menu.mode == "renamecontext") or (menu.mode == "changelogocontext") or (menu.mode == "crewtransfercontext") or (menu.mode == "venturepatroninfo") or (menu.mode == "venturereport") then
		return
	end
	if not menu.createInfoFrameRunning then
		menu.settoprow = menu.settoprow or GetTopRow(menu.infoTable)
		menu.topRows.infotableleft = menu.settoprow
		if menu.setplottoprow then
			menu.settoprow = menu.setplottoprow
			menu.setplottoprow = nil
		end
		local storerowinfo = true
		if not menu.showMultiverse then
			if (menu.infoTableMode ~= "objectlist") and (menu.infoTableMode ~= "propertyowned") and ((menu.infoTableMode ~= "missionoffer") or (menu.missionOfferMode ~= "operation")) then
				storerowinfo = false
			end
		end
		if storerowinfo then
			menu.setrow = setrow or Helper.currentTableRow[menu.infoTable]
			menu.selectedRows.infotableleft = menu.setrow
			if menu.setplotrow then
				menu.setrow = menu.setplotrow
				menu.setplotrow = nil
			end
			menu.setcol = setcol or Helper.currentTableCol[menu.infoTable]
			menu.selectedCols.infotableleft = menu.setcol
		end

		menu.selectedRows.infotable2 = nil
		menu.selectedCols.infotable2 = nil
		if menu.infoTable2 then
			menu.selectedRows.infotable2 = setrow2 or Helper.currentTableRow[menu.infoTable2]
			menu.selectedCols.infotable2 = setcol2 or Helper.currentTableCol[menu.infoTable2]
		end
		if menu.infoTable3 then
			menu.topRows.infotable3left = GetTopRow(menu.infoTable3)
			menu.selectedRows.infotable3left = Helper.currentTableRow[menu.infoTable3]
		end
		if menu.orderHeaderTable and menu.lastactivetable == menu.orderHeaderTable.id then
			menu.selectedRows.orderHeaderTableleft = menu.selectedRows.orderHeaderTableleft or Helper.currentTableRow[menu.orderHeaderTable.id] or 1
			menu.selectedCols.orderHeaderTableleft = menu.selectedCols.orderHeaderTableleft or Helper.currentTableCol[menu.orderHeaderTable.id]
		end
		if menu.ventureSeasonHeaderTableLeft and menu.lastactivetable == menu.ventureSeasonHeaderTableLeft.id then
			menu.selectedRows.ventureSeasonHeaderTableleft = menu.selectedRows.ventureSeasonHeaderTableleft or Helper.currentTableRow[menu.ventureSeasonHeaderTableLeft.id] or 1
			menu.selectedCols.ventureSeasonHeaderTableleft = menu.selectedCols.ventureSeasonHeaderTableleft or Helper.currentTableCol[menu.ventureSeasonHeaderTableLeft.id]
		end
		if menu.ventureInventoryHeaderTableLeft and menu.lastactivetable == menu.ventureInventoryHeaderTableLeft.id then
			menu.selectedRows.ventureInventoryHeaderTableleft = menu.selectedRows.ventureInventoryHeaderTableleft or Helper.currentTableRow[menu.ventureInventoryHeaderTableLeft.id] or 1
			menu.selectedCols.ventureInventoryHeaderTableleft = menu.selectedCols.ventureInventoryHeaderTableleft or Helper.currentTableCol[menu.ventureInventoryHeaderTableLeft.id]
		end
		if menu.ventureContactsHeaderTableLeft and menu.lastactivetable == menu.ventureContactsHeaderTableLeft.id then
			menu.selectedRows.ventureContactsHeaderTableleft = menu.selectedRows.ventureContactsHeaderTableleft or Helper.currentTableRow[menu.ventureContactsHeaderTableLeft.id] or 1
			menu.selectedCols.ventureContactsHeaderTableleft = menu.selectedCols.ventureContactsHeaderTableleft or Helper.currentTableCol[menu.ventureContactsHeaderTableLeft.id]
		end
		if menu.missionModeHeaderTableLeft and menu.lastactivetable == menu.missionModeHeaderTableLeft.id then
			menu.selectedRows.missionModeHeaderTableleft = menu.selectedRows.missionModeHeaderTableleft or Helper.currentTableRow[menu.missionModeHeaderTableLeft.id] or 1
			menu.selectedCols.missionModeHeaderTableleft = menu.selectedCols.missionModeHeaderTableleft or Helper.currentTableCol[menu.missionModeHeaderTableLeft.id]
		end
		menu.createInfoFrame()
	end
	menu.refreshInfoFrame2()
end

function menu.refreshInfoFrame2(setrow, setcol)
	-- kuertee start: callback
	local isCreated = false
	if callbacks ["refreshInfoFrame2_on_start"] then
		for _, callback in ipairs (callbacks ["refreshInfoFrame2_on_start"]) do
			if callback () then
				isCreated = true
			end
		end
	end
	-- kuertee end: callback

	if (menu.mode == "tradecontext") or (menu.mode == "dropwarescontext") or (menu.mode == "renamecontext") or (menu.mode == "changelogocontext") or (menu.mode == "crewtransfercontext") or (menu.mode == "venturepatroninfo") or (menu.mode == "venturereport") then
		return
	end
	if not menu.createInfoFrame2Running then
		menu.topRows.infotableright = menu.topRows.infotableright or GetTopRow(menu.infoTableRight)
		menu.selectedRows.infotableright = setrow or Helper.currentTableRow[menu.infoTableRight]
		menu.selectedCols.infotableright = setcol or Helper.currentTableCol[menu.infoTableRight]

		if menu.infoTableRight3 then
			menu.topRows.infotable3right = GetTopRow(menu.infoTableRight3)
			menu.selectedRows.infotable3right = Helper.currentTableRow[menu.infoTableRight3]
		end
		if menu.orderHeaderTableRight and menu.lastactivetable == menu.orderHeaderTableRight.id then
			menu.selectedRows.orderHeaderTableright = menu.selectedRows.orderHeaderTableright or Helper.currentTableRow[menu.orderHeaderTableRight.id] or 1
			menu.selectedCols.orderHeaderTableright = menu.selectedCols.orderHeaderTableright or Helper.currentTableCol[menu.orderHeaderTableRight.id]
		end
		if menu.ventureSeasonHeaderTableRight and menu.lastactivetable == menu.ventureSeasonHeaderTableRight.id then
			menu.selectedRows.ventureSeasonHeaderTableright = menu.selectedRows.ventureSeasonHeaderTableright or Helper.currentTableRow[menu.ventureSeasonHeaderTableRight.id] or 1
			menu.selectedCols.ventureSeasonHeaderTableright = menu.selectedCols.ventureSeasonHeaderTableright or Helper.currentTableCol[menu.ventureSeasonHeaderTableRight.id]
		end
		if menu.ventureInventoryHeaderTableRight and menu.lastactivetable == menu.ventureInventoryHeaderTableRight.id then
			menu.selectedRows.ventureInventoryHeaderTableright = menu.selectedRows.ventureInventoryHeaderTableright or Helper.currentTableRow[menu.ventureInventoryHeaderTableRight.id] or 1
			menu.selectedCols.ventureInventoryHeaderTableright = menu.selectedCols.ventureInventoryHeaderTableright or Helper.currentTableCol[menu.ventureInventoryHeaderTableRight.id]
		end
		if menu.ventureContactsHeaderTableRight and menu.lastactivetable == menu.ventureContactsHeaderTableRight.id then
			menu.selectedRows.ventureContactsHeaderTableright = menu.selectedRows.ventureContactsHeaderTableright or Helper.currentTableRow[menu.ventureContactsHeaderTableRight.id] or 1
			menu.selectedCols.ventureContactsHeaderTableright = menu.selectedCols.ventureContactsHeaderTableright or Helper.currentTableCol[menu.ventureContactsHeaderTableRight.id]
		end
		if menu.missionModeHeaderTableRight and menu.lastactivetable == menu.missionModeHeaderTableRight.id then
			menu.selectedRows.missionModeHeaderTableright = menu.selectedRows.missionModeHeaderTableright or Helper.currentTableRow[menu.missionModeHeaderTableRight.id] or 1
			menu.selectedCols.missionModeHeaderTableright = menu.selectedCols.missionModeHeaderTableright or Helper.currentTableCol[menu.missionModeHeaderTableRight.id]
		end
		menu.createInfoFrame2()
	end
end

function menu.extendSectionAndRefresh(rowdata)
	menu.extendModuleType(rowdata[2], rowdata[3])
	menu.settoprow = GetTopRow(menu.infoTable)
	menu.updateMapAndInfoFrame()
end

function menu.getContainerNameAndColors(container, iteration, issquadleader, showScanLevel)
	local convertedContainer = ConvertIDTo64Bit(container)
	local isplayer, revealpercent, name, faction, icon, ismissiontarget, isonlineobject, isenemy, ishostile = GetComponentData(container, "isplayerowned", "revealpercent", "name", "owner", "icon", "ismissiontarget", "isonlineobject", "isenemy", "ishostile")
	local unlocked = IsInfoUnlockedForPlayer(container, "name")
	local usefactioncolor = false
	local highlightvisitors = false
	if menu.getFilterOption("layer_other", false) then
		usefactioncolor = menu.getFilterOption("think_diplomacy_factioncolor", false)
		highlightvisitors = menu.getFilterOption("think_diplomacy_highlightvisitor", false)
	end

	local name = Helper.unlockInfo(unlocked, name .. " (" .. ffi.string(C.GetObjectIDCode(convertedContainer)) .. ")") .. (((not showScanLevel) or isplayer) and "" or " (" .. revealpercent .. " %)")
	local font = Helper.standardFont
	local color = Color["text_normal"]

	if faction == nil then
		if C.IsComponentClass(convertedContainer, "controllable") then
			DebugError("Found a controllable without a faction: " .. name)
		end
		usefactioncolor = false
	end

	local bgcolor = issquadleader and Color["row_background_blue"] or Color["row_background"]
	if (menu.mode == "orderparam_object") and (not menu.checkForOrderParamObject(convertedContainer)) then
		bgcolor = Color["row_background_unselectable"]
	elseif (menu.mode == "selectCV") and C.IsBuilderBusy(convertedContainer) then
		name = ColorText["text_error"] .. ReadText(1001, 7943) .. "\27X - " .. name
		color = Color["text_inactive"]
	elseif (menu.mode == "selectComponent") and (not menu.checkForSelectComponent(convertedContainer)) then
		bgcolor = Color["row_background_unselectable"]
	end

    -- mycu start: callback
    if callbacks ["getContainerNameAndColors_on_name_construct"] then
        for _, callback in ipairs (callbacks ["getContainerNameAndColors_on_name_construct"]) do
            local result = callback (container, name)
            if result then
                name = result.name
            end
        end
    end
    -- mycu end: callback

	if not menu.mode then
		if convertedContainer == menu.softtarget then
			name = config.softtargetmarker_l .. name
			font = Helper.standardFontBold
		end
		if IsSameComponent(menu.autopilottarget, container) then
			name = config.autopilotmarker .. name
		end
	end

	if ismissiontarget then
		color = menu.holomapcolor.missioncolor
	elseif isonlineobject and highlightvisitors then
		color = menu.holomapcolor.visitorcolor
	elseif not unlocked then
		color = Color["text_inactive"]
	elseif isplayer then
		if convertedContainer == C.GetPlayerObjectID() then
			color = menu.holomapcolor.currentplayershipcolor
		else
			color = menu.holomapcolor.playercolor
		end
	elseif ishostile then
		color = menu.holomapcolor.hostilecolor
	elseif isenemy then
		color = menu.holomapcolor.enemycolor
	end

	local factioncolor = ""
	if usefactioncolor then
		factioncolor = Helper.convertColorToText(GetFactionData(faction, "color"))
	end

	if IsComponentClass(container, "ship") or C.IsRealComponentClass(convertedContainer, "station") or IsComponentClass(container, "buildstorage") then
		local iconid = icon
		if iconid and iconid ~= "" then
			if usefactioncolor then
				name = string.format("%s\027[%s]%s %s", factioncolor, iconid, Helper.convertColorToText(color), name)
			else
				name = string.format("\027[%s] %s", iconid, name)
			end
		end
	end
	local mouseover = "" --name
	for i = 1, iteration do
		name = "    " .. name
	end

	return name, color, bgcolor, font, mouseover, factioncolor
end

function menu.getFleetName(object64)
	if C.IsComponentClass(object64, "controllable") then
		local fleetname = ffi.string(C.GetFleetName(object64))
		if fleetname ~= "" then
			return fleetname
		end
	end
end

function menu.updateRenderedComponents()
	menu.renderedComponents = {}
	menu.renderedComponentsRef = {}
	if menu.holomap and (menu.holomap ~= 0) then
		Helper.ffiVLA(menu.renderedComponents, "UniverseID", C.GetNumMapRenderedComponents, C.GetMapRenderedComponents, menu.holomap)
		for i = #menu.renderedComponents, 1, -1 do
			local id = ConvertStringTo64Bit(tostring(menu.renderedComponents[i]))
			if IsValidComponent(id) then
				local ismasstraffic, isenemy, hull, purpose, ismodule, uirelation = GetComponentData(id, "ismasstraffic", "isenemy", "hullpercent", "primarypurpose", "ismodule", "uirelation")
				if ismasstraffic and (not isenemy) then
					table.remove(menu.renderedComponents, i)
				else
					menu.renderedComponents[i] = { id = id, name = ffi.string(C.GetComponentName(id)), fleetname = menu.getFleetName(id), objectid = ismodule and "" or ffi.string(C.GetObjectIDCode(id)), class = ffi.string(C.GetComponentClass(id)), hull = hull, purpose = purpose, relation = uirelation }
					menu.renderedComponentsRef[ConvertStringTo64Bit(tostring(id))] = true
				end
			else
				table.remove(menu.renderedComponents, i)
			end
		end

		-- make sure the holomap is up before using the focuscomponent to init selectedcomponents
		if #menu.renderedComponents > 0 then
			if menu.focuscomponent then
				menu.infoTable = nil
				menu.highlightedbordercomponent = nil
				menu.highlightedbordermoduletype = nil
				menu.highlightedplannedmodule = nil
				menu.highlightedbordersection = nil
				menu.highlightedborderstationcategory = nil
				menu.selectedstationcategory = nil
				menu.highlightedconstruction = nil
				menu.selectedconstruction = nil
				menu.selectedfleetcommander = nil
				if menu.selectfocuscomponent then
					menu.addSelectedComponent(menu.focuscomponent)
					menu.selectfocuscomponent = nil
				end
				menu.focuscomponent = nil
			end
		end
	end

	-- Always show target component
	local softtarget = ConvertStringTo64Bit(tostring(C.GetSofttarget2().softtargetID))
	if softtarget ~= 0 then
		if not menu.renderedComponentsRef[softtarget] then
			local hull, purpose, uirelation, sector = GetComponentData(softtarget, "hullpercent", "primarypurpose", "uirelation", "sector")
			table.insert(menu.renderedComponents, { id = softtarget, name = ffi.string(C.GetComponentName(softtarget)), fleetname = menu.getFleetName(softtarget), objectid = C.IsComponentClass(softtarget, "object") and ffi.string(C.GetObjectIDCode(softtarget)) or "", class = ffi.string(C.GetComponentClass(softtarget)), hull = hull, purpose = purpose, relation = uirelation, sector = sector })
			menu.renderedComponentsRef[softtarget] = true
		end
	end

	-- Always show selected components
	for id, _ in pairs(menu.selectedcomponents) do
		local selectedcomponent = ConvertStringTo64Bit(id)
		if IsValidComponent(selectedcomponent) then
			if not menu.renderedComponentsRef[selectedcomponent] then
				local hull, purpose, uirelation, sector = GetComponentData(selectedcomponent, "hullpercent", "primarypurpose", "uirelation", "sector")
				table.insert(menu.renderedComponents, { id = selectedcomponent, name = ffi.string(C.GetComponentName(selectedcomponent)), fleetname = menu.getFleetName(selectedcomponent), objectid = C.IsComponentClass(selectedcomponent, "object") and ffi.string(C.GetObjectIDCode(selectedcomponent)) or "", class = ffi.string(C.GetComponentClass(selectedcomponent)), hull = hull, purpose = purpose, relation = uirelation, sector = sector })
				menu.renderedComponentsRef[selectedcomponent] = true
			end
		end
	end

	table.sort(menu.renderedComponents, menu.componentSorter(menu.objectSorterType))
end

function menu.componentSorter(sorttype)
	local sorter = Helper.sortNameAndObjectID
	if sorttype == "nameinverse" then
		sorter = function (a, b) return Helper.sortNameAndObjectID(a, b, true) end
	elseif sorttype == "class" then
		sorter = Helper.sortShipsByClassAndPurpose
	elseif sorttype == "classinverse" then
		sorter = function (a, b) return Helper.sortShipsByClassAndPurpose(a, b, true) end
	elseif sorttype == "hull" then
		sorter = Helper.sortHullAndName
	elseif sorttype == "hullinverse" then
		sorter = function (a, b) return Helper.sortHullAndName(a, b, true) end
	elseif sorttype == "relation" then
		sorter = Helper.sortRelationAndName
	elseif sorttype == "relationinverse" then
		sorter = function (a, b) return Helper.sortRelationAndName(a, b, true) end
	elseif sorttype == "sector" then
		sorter = Helper.sortNameSectorAndObjectID
	elseif sorttype == "sectorinverse" then
		sorter = function (a, b) return Helper.sortNameSectorAndObjectID(a, b, true) end

	-- kuertee start: add sort by distance
	elseif sorttype == "distance_from_player" then
		sorter = menu.sortDistanceFromPlayer
	elseif sorttype == "distance_from_playerinverse" then
		sorter = function (a, b) return menu.sortDistanceFromPlayer (a, b, true) end
	elseif sorttype == "distance_from_object" then
		sorter = menu.sortDistanceFromObject
	elseif sorttype == "distance_from_objectinverse" then
		sorter = function (a, b) return menu.sortDistanceFromObject (a, b, true) end
	-- kuertee end: add sort by distance

	end
	return sorter
end

function menu.sortComponentListHelper(components, sorter)
	local sortedComponents = {}
	for _, component in ipairs(components) do
		local component64 = ConvertStringTo64Bit(tostring(component))
		local hull, purpose, uirelation, sector = GetComponentData(component64, "hullpercent", "primarypurpose", "uirelation", "sector")
		table.insert(sortedComponents, { id = component64, name = ffi.string(C.GetComponentName(component64)), fleetname = menu.getFleetName(component64), objectid = C.IsComponentClass(component64, "object") and ffi.string(C.GetObjectIDCode(component64)) or "", class = ffi.string(C.GetComponentClass(component64)), hull = hull, purpose = purpose, relation = uirelation, sector = sector })
	end
	table.sort(sortedComponents, menu.componentSorter(sorter))
	local returnvalue = {}
	for _, entry in ipairs(sortedComponents) do
		table.insert(returnvalue, ConvertStringToLuaID(tostring(entry.id)))
	end
	return returnvalue
end

function menu.isObjectValid(object)
	local isdeployable, isradarvisible, isorphaned, isattachedaslimpet = GetComponentData(object, "isdeployable", "isradarvisible", "isorphaned", "isattachedaslimpet")
	local isship = C.IsComponentClass(object, "ship")
	if not isship and not (C.IsRealComponentClass(object, "station") and (not C.IsComponentWrecked(object))) and not isdeployable and not C.IsComponentClass(object, "lockbox") and not (C.IsComponentClass(object, "buildstorage") and isorphaned) then
		return false
	elseif C.IsComponentClass(object, "controllable") and C.IsUnit(object) then
		return false
	elseif (not C.IsObjectKnown(object)) or (not isradarvisible) then
		return false
	elseif isship and isattachedaslimpet then
		return false
	end
	return true
end

function menu.getShipIconWidth()
	local numbertext = "99"
	local minWidthPercent = 0.028

	local textheight = math.ceil(C.GetTextHeight("99", Helper.standardFont, Helper.scaleFont(Helper.standardFont, config.mapFontSize), Helper.viewWidth))
	local textwidth = math.ceil(C.GetTextWidth("99", Helper.standardFont, Helper.scaleFont(Helper.standardFont, config.mapFontSize)))

	return math.max(minWidthPercent * menu.infoTableWidth, math.max(textheight, textwidth))
end

-- Object List

function menu.createObjectList(frame, instance)
	local infoTableData = menu.infoTableData[instance]

	-- TODO: Move to config table?
	infoTableData.maxIcons = 5
	infoTableData.shipIconWidth = menu.getShipIconWidth()
	local maxicons = infoTableData.maxIcons

	local objecttable = frame:addTable(5 + maxicons, { tabOrder = 1, multiSelect = true })
	objecttable:setDefaultCellProperties("text", { minRowHeight = config.mapRowHeight, fontsize = config.mapFontSize })
	objecttable:setDefaultCellProperties("button", { height = config.mapRowHeight })
	objecttable:setDefaultCellProperties("icon",   { height = config.mapRowHeight })
	objecttable:setDefaultComplexCellProperties("button", "text", { fontsize = config.mapFontSize })
	--  [+/-] [Object Name] [Location] [Sub_1] [Sub_2] [Sub_3] ... [Sub_N] [Shield/Hull Bar]
	objecttable:setColWidth(1, Helper.scaleY(config.mapRowHeight), false)
	objecttable:setColWidthMinPercent(2, 20)
	objecttable:setColWidthMinPercent(4, 10)
	for i = 1, maxicons do
		objecttable:setColWidth(5 + i - 1, infoTableData.shipIconWidth, false)
	end
	objecttable:setColWidth(5 + maxicons, infoTableData.shipIconWidth, false)
	objecttable:setDefaultBackgroundColSpan(2, 4 + maxicons)

	-- title section
	local onlysectorallowed
	if menu.currentsector and (menu.currentsector ~= 0) then
		-- title
		menu.title = ReadText(20001, 201) .. ReadText(1001, 120) .. " " .. ffi.string(C.GetComponentName(menu.currentsector))
		infoTableData.ownerDetails = C.GetOwnerDetails(menu.currentsector)

		if menu.mode == "orderparam_object" then
			local sectorallowed = false
			if menu.modeparam[2].inputparams.class then
				if type(menu.modeparam[2].inputparams.class) == "table" then
					for _, class in ipairs(menu.modeparam[2].inputparams.class) do
						if class == "sector" then
							sectorallowed = menu.checkForOrderParamObject(menu.currentsector)
							onlysectorallowed = #menu.modeparam[2].inputparams.class == 1
							break
						end
					end
				else
					DebugError("Order parameter '" .. menu.modeparam[2].name .. "' - input parameter class is not a list. [Florian]")
				end
			end

			local row = objecttable:addRow(sectorallowed, { fixed = true, bgColor = Color["row_title_background"] })
			row[1]:setColSpan(4):createText(menu.title, Helper.headerRowCenteredProperties)
			row[5]:setColSpan(1 + maxicons):createButton({ active = sectorallowed, height = Helper.headerRow1Height, mouseOverText = ReadText(1001, 3228) }):setText(ReadText(1001, 3102), { halign = "center" })
			row[5].handlers.onClick = menu.buttonSelectSector
		else
			local row = objecttable:addRow(false, { fixed = true, bgColor = Color["row_title_background"] })
			row[1]:setColSpan(5 + maxicons):createText(menu.title, Helper.headerRowCenteredProperties)
		end

		-- owner
		if ffi.string(infoTableData.ownerDetails.factionIcon) ~= "" then
			local locsectorname = ffi.string(infoTableData.ownerDetails.factionName)
			if C.IsContestedSector(menu.currentsector) then
				locsectorname = locsectorname .. " " .. ReadText(1001, 3247)
			end

			local row = objecttable:addRow(false, { fixed = true, bgColor = Color["row_background_unselectable"] })
			local sector64 = ConvertStringTo64Bit(tostring(menu.currentsector))
			row[1]:createIcon(function () return GetComponentData(sector64, "ownericon") end)
			row[2]:setColSpan(4 + maxicons):createText(locsectorname)
		end
	end

	-- object section
	infoTableData.playerStations = { }
	infoTableData.npcStations = { }
	infoTableData.moduledata = { }
	infoTableData.playerShips = { }
	infoTableData.npcShips = { }
	infoTableData.deployables = { }
	infoTableData.subordinates = { }
	infoTableData.dockedships = { }
	infoTableData.constructions = { }

	menu.updateRenderedComponents()
	local numdisplayed = 0
	local maxvisibleheight

	if not onlysectorallowed then
		for _, entry in ipairs(menu.renderedComponents) do
			local id = entry.id
			local convertedID = ConvertStringToLuaID(tostring(id))
			if menu.isObjectValid(id) then
				if menu.mode == "selectCV" then
					if C.IsComponentClass(id, "ship") and GetComponentData(convertedID, "primarypurpose") == "build" then
						if GetComponentData(convertedID, "isplayerowned") then
							table.insert(infoTableData.playerShips, convertedID)
						else
							table.insert(infoTableData.npcShips, convertedID)
						end
					end
				else
					if GetComponentData(convertedID, "isdeployable") or C.IsComponentClass(id, "lockbox") then
						table.insert(infoTableData.deployables, convertedID)
					elseif C.IsComponentClass(id, "ship") or C.IsRealComponentClass(id, "station") then
						-- Determine subordinates that may appear in the menu
						local subordinates = {}
						if C.IsComponentClass(id, "controllable") then
							subordinates = GetSubordinates(convertedID)
						end
						for i = #subordinates, 1, -1 do
							local subordinate = ConvertIDTo64Bit(subordinates[i])
							if not menu.isObjectValid(subordinate) then
								table.remove(subordinates, i)
							elseif menu.renderedComponentsRef[subordinate] then
								subordinates.hasRendered = true
							end
						end
						infoTableData.subordinates[tostring(convertedID)] = subordinates

						local dockedships = {}
						if C.IsComponentClass(id, "container") then
							Helper.ffiVLA(dockedships, "UniverseID", C.GetNumDockedShips, C.GetDockedShips, id, nil)
						end
						for i = #dockedships, 1, -1 do
							local convertedID = ConvertStringToLuaID(tostring(dockedships[i]))
							local commander = GetCommander(convertedID)
							if (not commander) or (not menu.renderedComponentsRef[ConvertIDTo64Bit(commander)]) then
								dockedships[i] = convertedID
							else
								table.remove(dockedships, i)
							end
						end
						infoTableData.dockedships[tostring(convertedID)] = dockedships

						if C.IsComponentClass(id, "ship") then
							local commander = GetCommander(convertedID)
							local isdocked = GetComponentData(convertedID, "isdocked")
							local dockcontainer = C.GetContextByClass(id, "container", false)
							if (not commander) or (not menu.renderedComponentsRef[ConvertIDTo64Bit(commander)]) then
								if (not isdocked) or (not menu.renderedComponentsRef[ConvertStringTo64Bit(tostring(dockcontainer))]) then
									if GetComponentData(convertedID, "isplayerowned") then
										table.insert(infoTableData.playerShips, convertedID)
									else
										table.insert(infoTableData.npcShips, convertedID)
									end
								end
							end
						elseif C.IsRealComponentClass(id, "station") then
							local isplayerowned = GetComponentData(convertedID, "isplayerowned")
							if isplayerowned then
								table.insert(infoTableData.playerStations, convertedID)
							else
								table.insert(infoTableData.npcStations, convertedID)
							end

							local constructions = {}
							local constructionshipsbymacro = {}
							-- builds in progress
							local n = C.GetNumBuildTasks(id, 0, true, false)
							local buf = ffi.new("BuildTaskInfo[?]", n)
							n = C.GetBuildTasks(buf, n, id, 0, true, false)
							for i = 0, n - 1 do
								table.insert(constructions, { id = buf[i].id, buildingcontainer = buf[i].buildingcontainer, component = buf[i].component, macro = ffi.string(buf[i].macro), factionid = ffi.string(buf[i].factionid), buildercomponent = buf[i].buildercomponent, price = buf[i].price, ismissingresources = buf[i].ismissingresources, queueposition = buf[i].queueposition, inprogress = true })
							end
							if #constructions > 0 then
								table.insert(constructions, { empty = true })
							end
							-- other builds
							local n = C.GetNumBuildTasks(id, 0, false, false)
							local buf = ffi.new("BuildTaskInfo[?]", n)
							n = C.GetBuildTasks(buf, n, id, 0, false, false)
							for i = 0, n - 1 do
								local component = buf[i].component
								local macro = ffi.string(buf[i].macro)
								if (component == 0) and (macro ~= "") then
									if constructionshipsbymacro[macro] then
										constructions[constructionshipsbymacro[macro]].amount = constructions[constructionshipsbymacro[macro]].amount + 1
										table.insert(constructions[constructionshipsbymacro[macro]].ids, buf[i].id)
									else
										table.insert(constructions, { id = buf[i].id, buildingcontainer = buf[i].buildingcontainer, component = component, macro = macro, factionid = ffi.string(buf[i].factionid), buildercomponent = buf[i].buildercomponent, price = buf[i].price, ismissingresources = buf[i].ismissingresources, queueposition = buf[i].queueposition, inprogress = false, amount = 1, ids = { buf[i].id } })
										constructionshipsbymacro[macro] = #constructions
									end
								else
									table.insert(constructions, { id = buf[i].id, buildingcontainer = buf[i].buildingcontainer, component = buf[i].component, macro = ffi.string(buf[i].macro), factionid = ffi.string(buf[i].factionid), buildercomponent = buf[i].buildercomponent, price = buf[i].price, ismissingresources = buf[i].ismissingresources, queueposition = buf[i].queueposition, inprogress = false })
								end
							end
							infoTableData.constructions[tostring(convertedID)] = constructions
						end
					elseif C.IsComponentClass(id, "buildstorage") then
						local isplayerowned = GetComponentData(convertedID, "isplayerowned")
						if isplayerowned then
							table.insert(infoTableData.playerStations, convertedID)
						else
							table.insert(infoTableData.npcStations, convertedID)
						end
					end
				end
			end
		end

		maxvisibleheight = objecttable:getFullHeight()
		if menu.mode ~= "selectCV" then
			if (menu.objectMode == "stations") or (menu.objectMode == "objectall") then
				numdisplayed = menu.createPropertySection(instance, "ownedstations", objecttable, ReadText(1001, 3276), infoTableData.playerStations, "-- " .. ReadText(1001, 33) .. " --", true, numdisplayed, nil, menu.objectSorterType)
			end
		end
		if (menu.objectMode == "ships") or (menu.objectMode == "objectall") then
			numdisplayed = menu.createPropertySection(instance, "ownedships", objecttable, ReadText(1001, 8301), infoTableData.playerShips, "-- " .. ReadText(1001, 34) .. " --", nil, numdisplayed, nil, menu.objectSorterType)
		end
		if menu.mode ~= "selectCV" then
			if (menu.objectMode == "stations") or (menu.objectMode == "objectall") then
				numdisplayed = menu.createPropertySection(instance, "npcstations", objecttable, ReadText(1001,8302), infoTableData.npcStations, "-- " .. ReadText(1001, 33) .. " --", true, numdisplayed, nil, menu.objectSorterType)
			end
		end
		if (menu.objectMode == "ships") or (menu.objectMode == "objectall") then
			numdisplayed = menu.createPropertySection(instance, "npcships", objecttable, ReadText(1001,8303), infoTableData.npcShips, "-- " .. ReadText(1001, 34) .. " --", nil, numdisplayed, nil, menu.objectSorterType)
		end
		if menu.mode ~= "selectCV" then
			if menu.objectMode == "deployables" then
				numdisplayed = menu.createPropertySection(instance, "deployables", objecttable, ReadText(1001, 1332), infoTableData.deployables, "-- " .. ReadText(1001, 34) .. " --", nil, numdisplayed, nil, menu.objectSorterType)
			end
		end
	end

	if numdisplayed > 50 then
		objecttable.properties.maxVisibleHeight = maxvisibleheight + 50 * (Helper.scaleY(config.mapRowHeight) + Helper.borderSize)
	end

	menu.numFixedRows = objecttable.numfixedrows

	if menu.selectedRows["objectlist"] then
		objecttable:setSelectedRow(menu.selectedRows["objectlist"])
		menu.selectedRows["objectlist"] = nil
		if menu.topRows["objectlist"] then
			objecttable:setTopRow(menu.topRows["objectlist"])
			menu.topRows["objectlist"] = nil
		end
		if menu.selectedCols["objectlist"] then
			objecttable:setSelectedCol(menu.selectedCols["objectlist"])
			menu.selectedCols["objectlist"] = nil
		end
	else
		menu.settoprow = ((not menu.settoprow) or (menu.settoprow == 0)) and ((menu.setrow and menu.setrow > 21) and (menu.setrow - 17) or 3) or menu.settoprow
		objecttable:setTopRow(menu.settoprow)
		local highlightborderrow = menu.sethighlightborderrow or menu.setrow
		if menu.infoTable then
			local result = GetShiftStartEndRow(menu.infoTable)
			if result then
				if highlightborderrow then
					local shiftstart, shiftend = table.unpack(result)
					local ismultiselected = objecttable.rows[highlightborderrow].properties.multiSelected
					if (not ismultiselected) or (((not shiftstart) or (shiftstart <= highlightborderrow)) and ((not shiftend) or (shiftend >= highlightborderrow))) then
						objecttable:setShiftStartEnd(table.unpack(result))
					end
				end
			end
		end
		objecttable:setSelectedRow(highlightborderrow)
	end
	menu.setrow = nil
	menu.settoprow = nil
	menu.setcol = nil
	menu.sethighlightborderrow = nil

	local tabtable
	local maxNumCategoryColumns =  math.floor(menu.infoTableWidth / (menu.sideBarWidth + Helper.borderSize))
	if maxNumCategoryColumns > Helper.maxTableCols then
		maxNumCategoryColumns = Helper.maxTableCols
	end
	local numOfSorterColumns = 4 -- "sort by", "size", "name", "hull"
	local colSpanPerSorterColumn = math.floor(maxNumCategoryColumns / numOfSorterColumns)
	tabtable = frame:addTable(maxNumCategoryColumns, { tabOrder = 2, reserveScrollBar = false })
	if maxNumCategoryColumns > 0 then
		for i = 1, maxNumCategoryColumns do
			tabtable:setColWidth(i, menu.sideBarWidth, false)
		end
		local diff = menu.infoTableWidth - maxNumCategoryColumns * (menu.sideBarWidth + Helper.borderSize)
		tabtable:setColWidth(maxNumCategoryColumns, menu.sideBarWidth + diff, false)
		-- object list categories row
		local row = tabtable:addRow("property_tabs", { fixed = true })
		local rowCount = 1
		if #config.objectCategories > 0 then
			for i, entry in ipairs(config.objectCategories) do
				if i / maxNumCategoryColumns > rowCount then
					row = tabtable:addRow("property_tabs", { fixed = true })
					rowCount = rowCount + 1
				end
				local bgcolor = Color["row_title_background"]
				local color = Color["icon_normal"]
				if entry.category == menu.objectMode then
					bgcolor = Color["row_background_selected"]
				end
				local active = true
				if menu.mode == "selectCV" then
					active = entry.category == "objectall"
				elseif (menu.mode == "selectComponent") and (menu.modeparam[3] == "deployables") then
					active = entry.category == "deployables"
					if active and (menu.selectedCols.propertytabs == nil) then
						menu.selectedCols.propertytabs = i
					end
				end
				row[i - math.floor((i - 1) / maxNumCategoryColumns) * maxNumCategoryColumns]:createButton({ height = menu.sideBarWidth, width = menu.sideBarWidth, bgColor = bgcolor, mouseOverText = entry.name, scaling = false, helpOverlayID = entry.helpOverlayID, helpOverlayText = entry.helpOverlayText, active = active }):setIcon(entry.icon, { color = color})
				row[i - math.floor((i - 1) / maxNumCategoryColumns) * maxNumCategoryColumns].handlers.onClick = function () return menu.buttonObjectSubMode(entry.category, i) end
			end
		end
		local row = tabtable:addRow(true, { fixed = true })
		-- sorter row
		-- "sort by"
		row[1]:setColSpan(colSpanPerSorterColumn):createText(ReadText(1001, 2906) .. ReadText(1001, 120))
		local buttonheight = Helper.scaleY(config.mapRowHeight)
		-- "size"
		local sorterColumn = 2
		local tableColumn = (sorterColumn - 1) * colSpanPerSorterColumn + 1
		local button = row[tableColumn]:setColSpan(colSpanPerSorterColumn):createButton({ scaling = false, height = buttonheight }):setText(ReadText(1001, 8026), { halign = "center", scaling = true })
		if menu.objectSorterType == "class" then
			button:setIcon("table_arrow_inv_down", { width = buttonheight, height = buttonheight, x = button:getColSpanWidth() - buttonheight })
		elseif menu.objectSorterType == "classinverse" then
			button:setIcon("table_arrow_inv_up", { width = buttonheight, height = buttonheight, x = button:getColSpanWidth() - buttonheight })
		end
		row[tableColumn].handlers.onClick = function () return menu.buttonObjectSorter("class") end
		-- "name"
		sorterColumn = 3
		tableColumn = (sorterColumn - 1) * colSpanPerSorterColumn + 1
		local button = row[tableColumn]:setColSpan(colSpanPerSorterColumn):createButton({ scaling = false, height = buttonheight }):setText(ReadText(1001, 2809), { halign = "center", scaling = true })
		if menu.objectSorterType == "name" then
			button:setIcon("table_arrow_inv_down", { width = buttonheight, height = buttonheight, x = button:getColSpanWidth() - buttonheight })
		elseif menu.objectSorterType == "nameinverse" then
			button:setIcon("table_arrow_inv_up", { width = buttonheight, height = buttonheight, x = button:getColSpanWidth() - buttonheight })
		end
		row[tableColumn].handlers.onClick = function () return menu.buttonObjectSorter("name") end
		-- "hull"
		sorterColumn = 4
		tableColumn = (sorterColumn - 1) * colSpanPerSorterColumn + 1
		local button = row[tableColumn]:setColSpan(colSpanPerSorterColumn):createButton({ scaling = false, height = buttonheight }):setText(ReadText(1001, 1), { halign = "center", scaling = true })
		if menu.objectSorterType == "hull" then
			button:setIcon("table_arrow_inv_down", { width = buttonheight, height = buttonheight, x = button:getColSpanWidth() - buttonheight })
		elseif menu.objectSorterType == "hullinverse" then
			button:setIcon("table_arrow_inv_up", { width = buttonheight, height = buttonheight, x = button:getColSpanWidth() - buttonheight })
		end
		row[tableColumn].handlers.onClick = function () return menu.buttonObjectSorter("hull") end
		-- "relation"
		local row = tabtable:addRow(true, { fixed = true })
		sorterColumn = 2
		tableColumn = (sorterColumn - 1) * colSpanPerSorterColumn + 1
		button = row[tableColumn]:setColSpan(colSpanPerSorterColumn):createButton({ scaling = false, height = buttonheight }):setText(ReadText(1001, 7749), { halign = "center", scaling = true })
		if menu.objectSorterType == "relation" then
			button:setIcon("table_arrow_inv_down", { width = buttonheight, height = buttonheight, x = button:getColSpanWidth() - buttonheight })
		elseif menu.objectSorterType == "relationinverse" then
			button:setIcon("table_arrow_inv_up", { width = buttonheight, height = buttonheight, x = button:getColSpanWidth() - buttonheight })
		end
		row[tableColumn].handlers.onClick = function () return menu.buttonObjectSorter("relation") end
	end

	tabtable:setSelectedRow(menu.selectedRows.propertytabs or menu.selectedRows.infotable2 or 0)
	tabtable:setSelectedCol(menu.selectedCols.propertytabs or Helper.currentTableCol[menu.infoTable2] or 0)
	menu.selectedRows.propertytabs = nil
	menu.selectedCols.propertytabs = nil

	objecttable.properties.y = tabtable.properties.y + tabtable:getFullHeight() + Helper.borderSize

	tabtable:addConnection(1, 2, true)
	objecttable:addConnection(2, 2)
end

-- Property Owned

function menu.createPropertyOwned(frame, instance)
	-- kuertee start: callback
	if callbacks ["createPropertyOwned_on_start"] then
		for _, callback in ipairs (callbacks ["createPropertyOwned_on_start"]) do
			callback (config)
		end
	end
	-- kuertee end: callback

	local infoTableData = menu.infoTableData[instance]

	-- TODO: Move to config table?
	infoTableData.maxIcons = 5
	infoTableData.shipIconWidth = menu.getShipIconWidth()
	local maxicons = infoTableData.maxIcons

	local ftable = frame:addTable(5 + maxicons, { tabOrder = 1, multiSelect = true })
	ftable:setDefaultCellProperties("text", { minRowHeight = config.mapRowHeight, fontsize = config.mapFontSize })
	ftable:setDefaultCellProperties("button", { height = config.mapRowHeight })
	ftable:setDefaultComplexCellProperties("button", "text", { fontsize = config.mapFontSize })

	--  [+/-] [Object Name][Location] [Sub_1] [Sub_2] [Sub_3] ... [Sub_N] [Shield/Hull Bar]
	ftable:setColWidth(1, Helper.scaleY(config.mapRowHeight), false)
	ftable:setDefaultBackgroundColSpan(2, 4 + maxicons)
	ftable:setColWidthMinPercent(2, 14)
	ftable:setColWidthMinPercent(4, 5)
	for i = 1, maxicons do
		ftable:setColWidth(5 + i - 1, infoTableData.shipIconWidth, false)
	end
	ftable:setColWidth(5 + maxicons, infoTableData.shipIconWidth, false)

	local row = ftable:addRow(false, { fixed = true, bgColor = Color["row_title_background"] })
	row[1]:setColSpan(5 + maxicons):createText(ReadText(1001, 1000), Helper.headerRowCenteredProperties)

	infoTableData.stations = { }
	infoTableData.fleetLeaderShips = { }
	infoTableData.unassignedShips = { }
	infoTableData.constructionShips = { }
	infoTableData.inventoryShips = { }
	infoTableData.deployables = { }
	infoTableData.subordinates = { }
	infoTableData.dockedships = { }
	infoTableData.constructions = { }
	infoTableData.moduledata = { }

	-- kuertee start: callback
	if callbacks ["createPropertyOwned_on_init_infoTableData"] then
		for _, callback in ipairs (callbacks ["createPropertyOwned_on_init_infoTableData"]) do
			callback (infoTableData)
		end
	end
	-- kuertee end: callback

	local onlineitems = {}
	if menu.propertyMode == "inventoryships" then
		onlineitems = OnlineGetUserItems()
	end

	local playerobjects = {}
	if Helper.isPlayerCovered() and (not C.IsUICoverOverridden()) then
		playerobjects[1] = ConvertStringTo64Bit(tostring(C.GetPlayerOccupiedShipID()))
	else
		playerobjects = GetContainedObjectsByOwner("player")
	end
	for i = #playerobjects, 1, -1 do
		local object = playerobjects[i]
		local object64 = ConvertIDTo64Bit(object)
		if menu.isObjectValid(object64) then
			local hull, purpose, uirelation, sector = GetComponentData(object, "hullpercent", "primarypurpose", "uirelation", "sector")
			playerobjects[i] = { id = object, name = ffi.string(C.GetComponentName(object64)), fleetname = menu.getFleetName(object64), objectid = ffi.string(C.GetObjectIDCode(object64)), class = ffi.string(C.GetComponentClass(object64)), hull = hull, purpose = purpose, relation = uirelation, sector = sector }
		else
			table.remove(playerobjects, i)
		end
	end

	table.sort(playerobjects, menu.componentSorter(menu.propertySorterType))

	for _, entry in ipairs(playerobjects) do
		local object = entry.id
		local object64 = ConvertIDTo64Bit(object)
		-- Determine subordinates that may appear in the menu
		local subordinates = {}
		if C.IsComponentClass(object64, "controllable") then
			subordinates = GetSubordinates(object)
		end
		for i = #subordinates, 1, -1 do
			local subordinate = subordinates[i]
			if not menu.isObjectValid(ConvertIDTo64Bit(subordinate)) then
				table.remove(subordinates, i)
			end
		end
		subordinates.hasRendered = #subordinates > 0
		infoTableData.subordinates[tostring(object)] = subordinates
		-- Find docked ships
		local dockedships = {}
		if C.IsComponentClass(object64, "container") then
			Helper.ffiVLA(dockedships, "UniverseID", C.GetNumDockedShips, C.GetDockedShips, object64, nil)
		end
		for i = #dockedships, 1, -1 do
			local convertedID = ConvertStringToLuaID(tostring(dockedships[i]))
			local loccommander = GetCommander(convertedID)
			if not loccommander then
				dockedships[i] = convertedID
			else
				table.remove(dockedships, i)
			end
		end
		infoTableData.dockedships[tostring(object)] = dockedships
		-- Check if object is station, fleet leader or unassigned
		local commander
		if C.IsComponentClass(object64, "controllable") then
			commander = GetCommander(object)
		end
		if not commander then
			if C.IsRealComponentClass(object64, "station") then
				table.insert(infoTableData.stations, object)
			elseif C.IsComponentClass(object64, "buildstorage") then
				local basestation = GetComponentData(object64, "basestation")
				if not basestation then
					table.insert(infoTableData.stations, object)
				end
			elseif GetComponentData(object, "isdeployable") or C.IsComponentClass(object64, "lockbox") then
				table.insert(infoTableData.deployables, object)
			elseif #subordinates > 0 then
				table.insert(infoTableData.fleetLeaderShips, object)
			else
				table.insert(infoTableData.unassignedShips, object)
			end
		end

		if C.IsRealComponentClass(object64, "station") then
			local constructions = {}
			local constructionshipsbymacro = {}
			-- builds in progress
			local n = C.GetNumBuildTasks(object64, 0, true, false)
			local buf = ffi.new("BuildTaskInfo[?]", n)
			n = C.GetBuildTasks(buf, n, object64, 0, true, false)
			for i = 0, n - 1 do
				table.insert(constructions, { id = buf[i].id, buildingcontainer = buf[i].buildingcontainer, component = buf[i].component, macro = ffi.string(buf[i].macro), factionid = ffi.string(buf[i].factionid), buildercomponent = buf[i].buildercomponent, price = buf[i].price, ismissingresources = buf[i].ismissingresources, queueposition = buf[i].queueposition, inprogress = true })
			end
			if #constructions > 0 then
				table.insert(constructions, { empty = true })
			end
			-- other builds
			local n = C.GetNumBuildTasks(object64, 0, false, false)
			local buf = ffi.new("BuildTaskInfo[?]", n)
			n = C.GetBuildTasks(buf, n, object64, 0, false, false)
			for i = 0, n - 1 do
				local component = buf[i].component
				local macro = ffi.string(buf[i].macro)
				if (component == 0) and (macro ~= "") then
					if constructionshipsbymacro[macro] then
						constructions[constructionshipsbymacro[macro]].amount = constructions[constructionshipsbymacro[macro]].amount + 1
						table.insert(constructions[constructionshipsbymacro[macro]].ids, buf[i].id)
					else
						table.insert(constructions, { id = buf[i].id, buildingcontainer = buf[i].buildingcontainer, component = component, macro = macro, factionid = ffi.string(buf[i].factionid), buildercomponent = buf[i].buildercomponent, price = buf[i].price, ismissingresources = buf[i].ismissingresources, queueposition = buf[i].queueposition, inprogress = false, amount = 1, ids = { buf[i].id } })
						constructionshipsbymacro[macro] = #constructions
					end
				else
					table.insert(constructions, { id = buf[i].id, buildingcontainer = buf[i].buildingcontainer, component = component, macro = macro, factionid = ffi.string(buf[i].factionid), buildercomponent = buf[i].buildercomponent, price = buf[i].price, ismissingresources = buf[i].ismissingresources, queueposition = buf[i].queueposition, inprogress = false })
				end
			end
			infoTableData.constructions[tostring(object)] = constructions
		elseif C.IsComponentClass(object64, "ship") then
			if menu.propertyMode == "inventoryships" then
				local pilot = ConvertIDTo64Bit(GetComponentData(object, "assignedpilot"))
				if pilot and (pilot ~= C.GetPlayerID()) then
					local inventory = GetInventory(pilot)
					if next(inventory) then
						local sortedWares = {}
						for ware, entry in pairs(inventory) do
							local ispersonalupgrade = GetWareData(ware, "ispersonalupgrade")
							if (not ispersonalupgrade) and (not onlineitems[ware]) then
								table.insert(infoTableData.inventoryShips, object)
								break
							end
						end
					end
				end
			end

			-- kuertee start: callback
			if callbacks ["createPropertyOwned_on_add_ship_infoTableData"] then
				for _, callback in ipairs (callbacks ["createPropertyOwned_on_add_ship_infoTableData"]) do
					callback (infoTableData, object)
				end
			end
			-- kuertee end: callback

		end
	end

	-- kuertee start: callback
	if callbacks ["createPropertyOwned_on_add_other_objects_infoTableData"] then
		for _, callback in ipairs (callbacks ["createPropertyOwned_on_add_other_objects_infoTableData"]) do
			result = callback (infoTableData)
			if result then
				infoTableData = result.infoTableData
			end
		end
	end
	-- kuertee end: callback

	local constructionshipsbymacro = {}
	local n = C.GetNumPlayerShipBuildTasks(true, false)
	local buf = ffi.new("BuildTaskInfo[?]", n)
	n = C.GetPlayerShipBuildTasks(buf, n, true, false)
	for i = 0, n - 1 do
		local factionid = ffi.string(buf[i].factionid)
		if factionid == "player" then
			table.insert(infoTableData.constructionShips, { id = buf[i].id, buildingcontainer = buf[i].buildingcontainer, component = buf[i].component, macro = ffi.string(buf[i].macro), factionid = factionid, buildercomponent = buf[i].buildercomponent, price = buf[i].price, ismissingresources = buf[i].ismissingresources, queueposition = buf[i].queueposition, inprogress = true })
		end
	end
	if #infoTableData.constructionShips > 0 then
		table.insert(infoTableData.constructionShips, { empty = true })
	end
	local n = C.GetNumPlayerShipBuildTasks(false, false)
	local buf = ffi.new("BuildTaskInfo[?]", n)
	n = C.GetPlayerShipBuildTasks(buf, n, false, false)
	for i = 0, n - 1 do
		local factionid = ffi.string(buf[i].factionid)
		if factionid == "player" then
			local component = buf[i].component
			local macro = ffi.string(buf[i].macro)
			if (component == 0) and (macro ~= "") then
				if constructionshipsbymacro[macro] then
					infoTableData.constructionShips[constructionshipsbymacro[macro]].amount = infoTableData.constructionShips[constructionshipsbymacro[macro]].amount + 1
					table.insert(infoTableData.constructionShips[constructionshipsbymacro[macro]].ids, buf[i].id)
				else
					table.insert(infoTableData.constructionShips, { id = buf[i].id, buildingcontainer = buf[i].buildingcontainer, component = component, macro = macro, factionid = factionid, buildercomponent = buf[i].buildercomponent, price = buf[i].price, ismissingresources = buf[i].ismissingresources, queueposition = buf[i].queueposition, inprogress = false, amount = 1, ids = { buf[i].id } })
					constructionshipsbymacro[macro] = #infoTableData.constructionShips
				end
			else
				table.insert(infoTableData.constructionShips, { id = buf[i].id, buildingcontainer = buf[i].buildingcontainer, component = component, macro = macro, factionid = factionid, buildercomponent = buf[i].buildercomponent, price = buf[i].price, ismissingresources = buf[i].ismissingresources, queueposition = buf[i].queueposition, inprogress = false })
			end
		end
	end

	local numdisplayed = 0
	local maxvisibleheight = ftable:getFullHeight()
	if menu.mode ~= "selectCV" then
		if (menu.propertyMode == "stations") or (menu.propertyMode == "propertyall") then
			numdisplayed = menu.createPropertySection(instance, "ownedstations", ftable, ReadText(1001, 8379), infoTableData.stations, "-- " .. ReadText(1001, 33) .. " --", menu.mode ~= "hire", numdisplayed, nil, menu.propertySorterType)
		end
	end
	if (menu.propertyMode == "fleets") or (menu.propertyMode == "propertyall") then
		numdisplayed = menu.createPropertySection(instance, "ownedfleets", ftable, ReadText(1001, 8326), infoTableData.fleetLeaderShips, "-- " .. ReadText(1001, 34) .. " --", nil, numdisplayed, nil, menu.propertySorterType)			-- {1001,8326} = Fleets
	end
	if (menu.propertyMode == "unassignedships") or (menu.propertyMode == "propertyall") then
		numdisplayed = menu.createPropertySection(instance, "ownedships", ftable, ReadText(1001, 8327), infoTableData.unassignedShips, "-- " .. ReadText(1001, 34) .. " --", nil, numdisplayed, nil, menu.propertySorterType)	-- {1001,8327} = Unassigned Ships
	end
	if menu.propertyMode == "inventoryships" then
		numdisplayed = menu.createPropertySection(instance, "inventoryships", ftable, ReadText(1001, 8381), infoTableData.inventoryShips, "-- " .. ReadText(1001, 34) .. " --", nil, numdisplayed, true, menu.propertySorterType)	-- {1001,8327} = Ships with Inventory
	end
	if (menu.propertyMode == "unassignedships") or (menu.propertyMode == "propertyall") then
		-- construction rows do not use the shield/hull bar widget
		menu.createConstructionSection(instance, "constructionships", ftable, ReadText(1001, 8328), infoTableData.constructionShips)
	end
	if menu.mode ~= "selectCV" then
		if menu.propertyMode == "deployables" then
			numdisplayed = menu.createPropertySection(instance, "owneddeployables", ftable, ReadText(1001, 1332), infoTableData.deployables, "-- " .. ReadText(1001, 34) .. " --", nil, numdisplayed, nil, menu.propertySorterType)
		end
	end

	-- kuertee start: callback
	if callbacks ["createPropertyOwned_on_createPropertySection_unassignedships"] then
		local result
		for _, callback in ipairs (callbacks ["createPropertyOwned_on_createPropertySection_unassignedships"]) do
			result = callback (numdisplayed, instance, ftable, infoTableData)
			if result and result.numdisplayed > numdisplayed then
				numdisplayed = result.numdisplayed
			end
		end
	end
	-- kuertee end: callback

	if numdisplayed > 50 then
		ftable.properties.maxVisibleHeight = maxvisibleheight + 50 * (Helper.scaleY(config.mapRowHeight) + Helper.borderSize)
	end

	menu.numFixedRows = ftable.numfixedrows

	if menu.selectedRows["propertyowned"] then
		ftable:setSelectedRow(menu.selectedRows["propertyowned"])
		menu.selectedRows["propertyowned"] = nil
		if menu.topRows["propertyowned"] then
			ftable:setTopRow(menu.topRows["propertyowned"])
			menu.topRows["propertyowned"] = nil
		end
		if menu.selectedCols["propertyowned"] then
			ftable:setSelectedCol(menu.selectedCols["propertyowned"])
			menu.selectedCols["propertyowned"] = nil
		end
	else
		menu.settoprow = ((not menu.settoprow) or (menu.settoprow == 0)) and ((menu.setrow and menu.setrow > 21) and (menu.setrow - 17) or 3) or menu.settoprow
		ftable:setTopRow(menu.settoprow)
		local highlightborderrow = menu.sethighlightborderrow or menu.setrow
		if menu.infoTable then
			local result = GetShiftStartEndRow(menu.infoTable)
			if result then
				if highlightborderrow then
					local shiftstart, shiftend = table.unpack(result)
					local ismultiselected = ftable.rows[highlightborderrow].properties.multiSelected
					if (not ismultiselected) or (((not shiftstart) or (shiftstart <= highlightborderrow)) and ((not shiftend) or (shiftend >= highlightborderrow))) then
						ftable:setShiftStartEnd(shiftstart, shiftend)
					end
				end
			end
		end
		ftable:setSelectedRow(highlightborderrow)
	end
	menu.setrow = nil
	menu.settoprow = nil
	menu.setcol = nil
	menu.sethighlightborderrow = nil

	local tabtable
	local maxNumCategoryColumns =  math.floor(menu.infoTableWidth / (menu.sideBarWidth + Helper.borderSize))
	if maxNumCategoryColumns > Helper.maxTableCols then
		maxNumCategoryColumns = Helper.maxTableCols
	end
	local numOfSorterColumns = 4 -- "sort by", "size", "name", "hull"
	local colSpanPerSorterColumn = math.floor(maxNumCategoryColumns / numOfSorterColumns)
	tabtable = frame:addTable(maxNumCategoryColumns, { tabOrder = 2, reserveScrollBar = false })
	if maxNumCategoryColumns > 0 then
		for i = 1, maxNumCategoryColumns do
			tabtable:setColWidth(i, menu.sideBarWidth, false)
		end
		local diff = menu.infoTableWidth - maxNumCategoryColumns * (menu.sideBarWidth + Helper.borderSize)
		tabtable:setColWidth(maxNumCategoryColumns, menu.sideBarWidth + diff, false)
		-- product categories row
		local row = tabtable:addRow("property_tabs", { fixed = true })
		local rowCount = 1
		if #config.propertyCategories > 0 then
			for i, entry in ipairs(config.propertyCategories) do
				if i / maxNumCategoryColumns > rowCount then
					row = tabtable:addRow("property_tabs", { fixed = true })
					rowCount = rowCount + 1
				end
				local bgcolor = Color["row_title_background"]
				local color = Color["icon_normal"]
				if entry.category == menu.propertyMode then
					bgcolor = Color["row_background_selected"]
				end
				local active = true
				if menu.mode == "hire" then
					active = entry.category ~= "deployables"
				elseif menu.mode == "selectCV" then
					active = entry.category == "propertyall"
                    -- start: mycu callback
                    if callbacks ["onSetActiveStateForCVMode_on_createPropertyOwned"] then
                        for _, callback in ipairs (callbacks ["onSetActiveStateForCVMode_on_createPropertyOwned"]) do
                            active = callback (entry)
                        end
                    end
                    -- end: mycu callback
				elseif (menu.mode == "selectComponent") and (menu.modeparam[3] == "deployables") then
					active = entry.category == "deployables"
					if active and (menu.selectedCols.propertytabs == nil) then
						menu.selectedCols.propertytabs = i
					end
				end
				row[i - math.floor((i - 1) / maxNumCategoryColumns) * maxNumCategoryColumns]:createButton({ height = menu.sideBarWidth, width = menu.sideBarWidth, bgColor = bgcolor, mouseOverText = entry.name, scaling = false, helpOverlayID = entry.helpOverlayID, helpOverlayText = entry.helpOverlayText, active = active }):setIcon(entry.icon, { color = color})
				row[i - math.floor((i - 1) / maxNumCategoryColumns) * maxNumCategoryColumns].handlers.onClick = function () return menu.buttonPropertySubMode(entry.category, i) end
			end
		end
		local row = tabtable:addRow(true, { fixed = true })
		-- sorter row
		-- "sort by"
		row[1]:setColSpan(colSpanPerSorterColumn):createText(ReadText(1001, 2906) .. ReadText(1001, 120))
		local buttonheight = Helper.scaleY(config.mapRowHeight)
		-- "size"
		local sorterColumn = 2
		local tableColumn = (sorterColumn - 1) * colSpanPerSorterColumn + 1
		local button = row[tableColumn]:setColSpan(colSpanPerSorterColumn):createButton({ scaling = false, height = buttonheight }):setText(ReadText(1001, 8026), { halign = "center", scaling = true })
		if menu.propertySorterType == "class" then
			button:setIcon("table_arrow_inv_down", { width = buttonheight, height = buttonheight, x = button:getColSpanWidth() - buttonheight })
		elseif menu.propertySorterType == "classinverse" then
			button:setIcon("table_arrow_inv_up", { width = buttonheight, height = buttonheight, x = button:getColSpanWidth() - buttonheight })
		end
		row[tableColumn].handlers.onClick = function () return menu.buttonPropertySorter("class") end
		-- "name"
		sorterColumn = 3
		tableColumn = (sorterColumn - 1) * colSpanPerSorterColumn + 1
		local button = row[tableColumn]:setColSpan(colSpanPerSorterColumn):createButton({ scaling = false, height = buttonheight }):setText(ReadText(1001, 2809), { halign = "center", scaling = true })
		if menu.propertySorterType == "name" then
			button:setIcon("table_arrow_inv_down", { width = buttonheight, height = buttonheight, x = button:getColSpanWidth() - buttonheight })
		elseif menu.propertySorterType == "nameinverse" then
			button:setIcon("table_arrow_inv_up", { width = buttonheight, height = buttonheight, x = button:getColSpanWidth() - buttonheight })
		end
		row[tableColumn].handlers.onClick = function () return menu.buttonPropertySorter("name") end
		-- "hull"
		sorterColumn = 4
		tableColumn = (sorterColumn - 1) * colSpanPerSorterColumn + 1
		local button = row[tableColumn]:setColSpan(colSpanPerSorterColumn):createButton({ scaling = false, height = buttonheight }):setText(ReadText(1001, 1), { halign = "center", scaling = true })
		if menu.propertySorterType == "hull" then
			button:setIcon("table_arrow_inv_down", { width = buttonheight, height = buttonheight, x = button:getColSpanWidth() - buttonheight })
		elseif menu.propertySorterType == "hullinverse" then
			button:setIcon("table_arrow_inv_up", { width = buttonheight, height = buttonheight, x = button:getColSpanWidth() - buttonheight })
		end
		row[tableColumn].handlers.onClick = function () return menu.buttonPropertySorter("hull") end
		-- "sector"
		local row = tabtable:addRow(true, { fixed = true })
		sorterColumn = 2
		tableColumn = (sorterColumn - 1) * colSpanPerSorterColumn + 1
		button = row[tableColumn]:setColSpan(colSpanPerSorterColumn):createButton({ scaling = false, height = buttonheight }):setText(ReadText(1001, 11284), { halign = "center", scaling = true })
		if menu.propertySorterType == "sector" then
			button:setIcon("table_arrow_inv_down", { width = buttonheight, height = buttonheight, x = button:getColSpanWidth() - buttonheight })
		elseif menu.propertySorterType == "sectorinverse" then
			button:setIcon("table_arrow_inv_up", { width = buttonheight, height = buttonheight, x = button:getColSpanWidth() - buttonheight })
		end
		row[tableColumn].handlers.onClick = function () return menu.buttonPropertySorter("sector") end

		--kuertee start: add distance sorters
		-- "distance from player"
		local buttonLabel = ffi.string (C.GetPlayerName ())
		sorterColumn = 3
		tableColumn = (sorterColumn - 1) * colSpanPerSorterColumn + 1
		local button = row[tableColumn]:setColSpan(colSpanPerSorterColumn):createButton({ scaling = false, height = buttonheight }):setText(buttonLabel, { halign = "center", scaling = true })
		if menu.propertySorterType == "distance_from_player" then
			button:setIcon("table_arrow_inv_down", { width = buttonheight, height = buttonheight, x = button:getColSpanWidth() - buttonheight })
		elseif menu.propertySorterType == "distance_from_playerinverse" then
			button:setIcon("table_arrow_inv_up", { width = buttonheight, height = buttonheight, x = button:getColSpanWidth() - buttonheight })
		end
		row[tableColumn].handlers.onClick = function () return menu.buttonPropertySorter("distance_from_player") end
		-- "distance from object"
		if menu.infoSubmenuObject then
			buttonLabel = ffi.string (C.GetObjectIDCode (menu.infoSubmenuObject))
			if buttonLabel == "" then
				buttonLabel = ffi.string (C.GetComponentName (menu.infoSubmenuObject))
			end
			sorterColumn = 4
			tableColumn = (sorterColumn - 1) * colSpanPerSorterColumn + 1
			local button = row[tableColumn]:setColSpan(colSpanPerSorterColumn):createButton({ scaling = false, height = buttonheight }):setText(buttonLabel, { halign = "center", scaling = true })
			if menu.propertySorterType == "distance_from_object" then
				button:setIcon("table_arrow_inv_down", { width = buttonheight, height = buttonheight, x = button:getColSpanWidth() - buttonheight })
			elseif menu.propertySorterType == "distance_from_objectinverse" then
				button:setIcon("table_arrow_inv_up", { width = buttonheight, height = buttonheight, x = button:getColSpanWidth() - buttonheight })
			end
			row[tableColumn].handlers.onClick = function () return menu.buttonPropertySorter("distance_from_object") end
		end
		--kuertee end: add distance sorters
	end

	tabtable:setSelectedRow(menu.selectedRows.propertytabs or menu.selectedRows.infotable2 or 0)
	tabtable:setSelectedCol(menu.selectedCols.propertytabs or Helper.currentTableCol[menu.infoTable2] or 0)
	menu.selectedRows.propertytabs = nil
	menu.selectedCols.propertytabs = nil

	ftable.properties.y = tabtable.properties.y + tabtable:getFullHeight() + Helper.borderSize

	tabtable:addConnection(1, 2, true)
	ftable:addConnection(2, 2)
end

function menu.createPropertySection(instance, id, ftable, name, array, nonetext, showmodules, numdisplayed, hidesubordinates, sorter)
	local maxicons = menu.infoTableData[instance].maxIcons

	local row = ftable:addRow(false, { bgColor = Color["row_background_blue"] })
	row[1]:setColSpan(5 + maxicons):createText(name, Helper.headerRowCenteredProperties)

	if id == menu.highlightedbordersection then
		menu.sethighlightborderrow = row.index + 1
	end

	local prevnumdisplayed = numdisplayed
	if #array > 0 then
		for _, component in ipairs(array) do
			numdisplayed = menu.createPropertyRow(instance, ftable, component, 0, nil, showmodules, hidesubordinates, numdisplayed, sorter)
		end
	end
	if numdisplayed == prevnumdisplayed then
		row = ftable:addRow(id, { interactive = false })
		row[2]:setColSpan(4 + maxicons):createText(nonetext)
	end

	return numdisplayed
end

function menu.getOrderInfo(ship, gettargetname)
	local isplayerowned, assignment, assignedpilot = GetComponentData(ship, "isplayerowned", "assignment", "assignedpilot")
	if not isplayerowned then
		return "", "", nil, "", false, nil, "", "", ""
	end

	local waiticon = ""
	local orderdefinition = ffi.new("OrderDefinition")
	if C.GetOrderDefinition(orderdefinition, "Wait") then
		waiticon = ffi.string(orderdefinition.icon)
	end

	local orders, defaultorder = {}, {}
	local n = C.GetNumOrders(ship)
	local buf = ffi.new("Order2[?]", n)
	n = C.GetOrders2(buf, n, ship)
	for i = 0, n - 1 do
		local order = {}
		order.state = ffi.string(buf[i].state)
		order.statename = ffi.string(buf[i].statename)
		order.orderdef = ffi.string(buf[i].orderdef)
		order.actualparams = tonumber(buf[i].actualparams)
		order.enabled = buf[i].enabled
		order.isinfinite = buf[i].isinfinite
		order.issyncpointreached = buf[i].issyncpointreached
		order.istemporder = buf[i].istemporder
		order.isoverride = buf[i].isoverride

		local orderdefinition = ffi.new("OrderDefinition")
		if order.orderdef ~= nil and C.GetOrderDefinition(orderdefinition, order.orderdef) then
			order.orderdef = {}
			order.orderdef.id = ffi.string(orderdefinition.id)
			order.orderdef.icon = ffi.string(orderdefinition.icon)
			order.orderdef.name = ffi.string(orderdefinition.name)
			order.orderdef.description = ffi.string(orderdefinition.description)
		else
			order.orderdef = { id = "", icon = "", name = "", description = "" }
		end

		table.insert(orders, order)
	end

	local hasrealorders = false
	for _, order in ipairs(orders) do
		if order.enabled and (not order.istemporder) then
			hasrealorders = true
			break
		end
	end

	local buf = ffi.new("Order")
	if C.GetDefaultOrder(buf, ship) then
		defaultorder.state = ffi.string(buf.state)
		defaultorder.statename = ffi.string(buf.statename)
		defaultorder.orderdef = ffi.string(buf.orderdef)
		defaultorder.actualparams = tonumber(buf.actualparams)
		defaultorder.enabled = buf.enabled
		defaultorder.issyncpointreached = buf.issyncpointreached
		defaultorder.istemporder = buf.istemporder

		local orderdefinition = ffi.new("OrderDefinition")
		if defaultorder.orderdef ~= nil and C.GetOrderDefinition(orderdefinition, defaultorder.orderdef) then
			defaultorder.orderdef = {}
			defaultorder.orderdef.id = ffi.string(orderdefinition.id)
			defaultorder.orderdef.icon = ffi.string(orderdefinition.icon)
			defaultorder.orderdef.name = ffi.string(orderdefinition.name)
			defaultorder.orderdef.description = ffi.string(orderdefinition.description)
		else
			defaultorder.orderdef = { id = "", icon = "", name = "", description = "" }
		end
	end

	local icon, name, description, color, isoverride, mouseovertext, targetname, behaviouricon, behaviourname, behaviourdescription = "", "", "", nil, false, nil, "", "", "", ""
	if #orders > 0 then
		-- there is an order
		local curindex = tonumber(C.GetOrderQueueCurrentIdx(ship))
		local order = orders[curindex]
		name = order.orderdef.name
		description = order.orderdef.description
		icon = order.orderdef.icon
		isoverride = order.isoverride
		-- change icon to wait if the order is in the wait part
		if (order.orderdef.id == "MoveWait") or (order.orderdef.id == "MoveToObject") or (order.orderdef.id == "DockAndWait") then
			if order.issyncpointreached then
				icon = waiticon
			end
		end
		-- if all orders are temp they were spawned by a defaultorder
		if not hasrealorders then
			color = Color["order_temp"]
		end
		if gettargetname then
			local targets = {}
			Helper.ffiVLA(targets, "UniverseID", C.GetNumOrderLocationData, C.GetOrderLocationData, ship, curindex, false)
			if #targets == 1 then
				local target = targets[1]
				targetname = ffi.string(C.GetComponentName(target))
				if C.IsComponentClass(target, "ship") then
					targetname = targetname .. " (" .. ffi.string(C.GetObjectIDCode(target)) .. ")"
				end
			elseif #targets > 0 then
				targetname = ReadText(1001, 3424)
			end
		end
		-- if there are normal orders also return information about the default order
		if next(defaultorder) then
			-- there is a defaultorder
			behaviourname = defaultorder.orderdef.name
			behaviourdescription = defaultorder.orderdef.description
			behaviouricon = defaultorder.orderdef.icon
			if (defaultorder.orderdef.id == "Wait") then
				-- do not show Wait default order
				behaviouricon = ""
			elseif (defaultorder.orderdef.id == "MoveWait") or (defaultorder.orderdef.id == "MoveToObject") or (defaultorder.orderdef.id == "DockAndWait") then
				if defaultorder.issyncpointreached then
					-- do not show these default orders if they reached the wait part
					behaviouricon = ""
				end
			elseif defaultorder.orderdef.id == "TradeRoutine" then
				local params = GetOrderParams(ship, "default")
				local overridewares = ""
				for i, entry in ipairs(params) do
					if entry.name == "warebasket_override" then
						local sortedwares = {}
						for _, ware in ipairs(entry.value) do
							table.insert(sortedwares, ware)
						end
						table.sort(sortedwares, Helper.sortWareName)

						for j, ware in ipairs(sortedwares) do
							if j == 1 then
								overridewares = overridewares .. "\n\n" .. ReadText(1001, 11651) .. ReadText(1001, 120)
							elseif j > 5 then
								overridewares = overridewares .. "\n· " .. ((#entry.value == 6) and GetWareData(ware, "name") or string.format(ReadText(1001, 11633), #entry.value - 5))
								break
							end
							overridewares = overridewares .. "\n· " .. GetWareData(ware, "name")
						end
						break
					end
				end

				behaviourdescription = behaviourdescription .. overridewares
			end
		end
	elseif next(defaultorder) then
		-- there is a defaultorder
		name = defaultorder.orderdef.name
		description = defaultorder.orderdef.description
		icon = defaultorder.orderdef.icon
		-- change icon to wait if the order is in the wait part
		if (defaultorder.orderdef.id == "MoveWait") or (defaultorder.orderdef.id == "MoveToObject") or (defaultorder.orderdef.id == "DockAndWait") then
			if defaultorder.issyncpointreached then
				icon = waiticon
			end
		elseif defaultorder.orderdef.id == "TradeRoutine" then
			local params = GetOrderParams(ship, "default")
			local overridewares = ""
			for i, entry in ipairs(params) do
				if entry.name == "warebasket_override" then
					local sortedwares = {}
					for _, ware in ipairs(entry.value) do
						table.insert(sortedwares, ware)
					end
					table.sort(sortedwares, Helper.sortWareName)

					for j, ware in ipairs(sortedwares) do
						if j == 1 then
							overridewares = overridewares .. "\n\n" .. ReadText(1001, 11651) .. ReadText(1001, 120)
						elseif j > 5 then
							overridewares = overridewares .. "\n· " .. ((#entry.value == 6) and GetWareData(ware, "name") or string.format(ReadText(1001, 11633), #entry.value - 5))
							break
						end
						overridewares = overridewares .. "\n· " .. GetWareData(ware, "name")
					end
					break
				end
			end

			description = description .. overridewares
		end
		color = Color["order_temp"]
		if gettargetname then
			local targets = {}
			Helper.ffiVLA(targets, "UniverseID", C.GetNumOrderLocationData, C.GetOrderLocationData, ship, 0, true)
			if #targets == 1 then
				local target = targets[1]
				targetname = ffi.string(C.GetComponentName(target))
				if C.IsComponentClass(target, "ship") then
					targetname = targetname .. " (" .. ffi.string(C.GetObjectIDCode(target)) .. ")"
				end
			elseif #targets > 0 then
				targetname = ReadText(1001, 3424)
			end
		end
	end

	if assignedpilot and (assignment == "assist") then
		-- if the ship is trying to mimic, but failed, mark the icon red
		local aicommandactionraw = GetComponentData(assignedpilot, "aicommandactionraw")
		if aicommandactionraw == "orderfailed" then
			color = Color["text_failure"]
			mouseovertext = ReadText(1026, 3268)
		end
	elseif C.HasControllableAnyOrderFailures(ship) then
		-- if the ship had any order failure, mark the icon orange
		color = Color["text_warning"]
	end

	local texticon = ""
	if icon ~= "" then
		texticon = (color and Helper.convertColorToText(color) or "") .. "\27[" .. icon .. "]\27X"
	end
	local behaviourtexticon = ""
	if behaviouricon ~= "" then
		behaviourtexticon = ColorText["order_temp"] .. "\27[" .. behaviouricon .. "]\27X"
	end
	return texticon, icon, color, name, description, isoverride, mouseovertext, targetname, behaviourtexticon, behaviouricon, behaviourname, behaviourdescription
end

function menu.overrideOrderIcon(normalcolor, usetext, icon, prefix, postfix)
	-- number between 0 and 1, duration 1s
	local x = getElapsedTime() % 1

	normalcolor = normalcolor or Color["icon_normal"]
	overridecolor = Color["order_override"]
	local color = {
		r = (1 - x) * overridecolor.r + x * normalcolor.r,
		g = (1 - x) * overridecolor.g + x * normalcolor.g,
		b = (1 - x) * overridecolor.b + x * normalcolor.b,
		a = (1 - x) * overridecolor.a + x * normalcolor.a,
	}
	if usetext then
		local colortext = Helper.convertColorToText(color) .. "\27[" .. icon .. "]\27X"
		return prefix .. colortext .. postfix
	else
		return color
	end
end

function menu.getModuleData(object64)
	local modules = {}
	local modulesByID = {}
	local n = C.GetNumStationModules(object64, false, false)
	local buf = ffi.new("UniverseID[?]", n)
	n = C.GetStationModules(buf, n, object64, false, false)
	for i = 0, n - 1 do
		local module = ConvertStringTo64Bit(tostring(buf[i]))
		local type = GetModuleType(module)
		modulesByID[tostring(module)] = true
		if modules[type] then
			table.insert(modules[type], module)
		else
			modules[type] = { module }
		end
	end
	local n = C.GetNumPlannedStationModules(object64, false)
	local buf = ffi.new("UIConstructionPlanEntry[?]", n)
	n = C.GetPlannedStationModules(buf, n, object64, false)
	for i = 0, tonumber(n) - 1 do
		local module, type
		if buf[i].componentid ~= 0 then
			module = ConvertStringTo64Bit(tostring(buf[i].componentid))
			type = GetModuleType(module)
			if modulesByID[tostring(module)] then
				module = nil
				type = nil
			end
		else
			module = ffi.string(buf[i].macroid)
			type = GetModuleType(nil, module)
		end
		if module then
			if modules[type] then
				table.insert(modules[type], module)
			else
				modules[type] = { module }
			end
		end
	end
	return modules
end

function menu.createPropertyRow(instance, ftable, component, iteration, commanderlocation, showmodules, hidesubordinates, numdisplayed, sorter)
	local maxicons = menu.infoTableData[instance].maxIcons

	local subordinates = menu.infoTableData[instance].subordinates[tostring(component)] or {}
	local dockedships = menu.infoTableData[instance].dockedships[tostring(component)] or {}
	local constructions = menu.infoTableData[instance].constructions[tostring(component)] or {}
	local convertedComponent = ConvertStringTo64Bit(tostring(component))

	-- kuertee start: callback
	if callbacks ["createPropertyRow_on_init_vars"] then
		local result
		for _, callback in ipairs (callbacks ["createPropertyRow_on_init_vars"]) do
			result = callback (maxicons, subordinates, dockedships, constructions, convertedComponent, iteration)
			if result then
				maxicons = result.maxicons
				subordinates = result.subordinates
				dockedships = result.dockedships
				constructions = result.constructions
				convertedComponent = result.convertedComponent
				iteration = result.iteration
			end
		end
	end
	-- kuertee end: callback

	if (#menu.searchtext == 0) or Helper.textArrayHelper(menu.searchtext, function (numtexts, texts) return C.FilterComponentByText(convertedComponent, numtexts, texts, true) end, "text") then
		if (menu.mode == "orderparam_object") and (not menu.checkForOrderParamObject(convertedComponent)) then
			return numdisplayed
		elseif (menu.mode == "selectComponent") and (not menu.checkForSelectComponent(convertedComponent)) then
			return numdisplayed
		end

		numdisplayed = numdisplayed + 1

		if (not menu.isPropertyExtended(tostring(component))) and (menu.isCommander(component) or menu.isConstructionContext(convertedComponent)) then
			menu.extendedproperty[tostring(component)] = true
		end
		if (not menu.isPropertyExtended(tostring(component))) and menu.isDockContext(convertedComponent) then

			-- if menu.infoTableMode ~= "propertyowned" then
			-- kuertee start: callback
			if not string.find (menu.infoTableMode, "propertyowned") then
				-- kuertee end: callback

				menu.extendedproperty[tostring(component)] = true
			end
		end

		local isstation = C.IsRealComponentClass(convertedComponent, "station")
		local isdoublerow = (iteration == 0 and (isstation or #subordinates > 0))
		local name, color, bgcolor, font, mouseover, factioncolor = menu.getContainerNameAndColors(component, iteration, isdoublerow, false)
		local alertString = ""
		local alertMouseOver = ""
		if menu.getFilterOption("layer_other", false) then
			local alertStatus, missionlist = menu.getContainerAlertLevel(component)
			local minAlertLevel = menu.getFilterOption("think_alert", false)
			if (minAlertLevel ~= 0) and alertStatus >= minAlertLevel then
				local color = Color["text_normal"]
				if alertStatus == 1 then
					color = menu.holomapcolor.lowalertcolor
				elseif alertStatus == 2 then
					color = menu.holomapcolor.mediumalertcolor
				else
					color = menu.holomapcolor.highalertcolor
				end
				alertString = Helper.convertColorToText(color) .. "\027[workshop_error]\027X"
				alertMouseOver = ReadText(1001, 3305) .. ReadText(1001, 120) .. "\n" .. missionlist
			end
		end
		local location, locationtext, isdocked, aipilot, isplayerowned, isonlineobject, iscovered, isenemy, macro, isally = GetComponentData(component, "sectorid", "sector", "isdocked", "assignedaipilot", "isplayerowned", "isonlineobject", "iscovered", "isenemy", "macro", "isally")
		if isplayerowned and iscovered then
			alertString = alertString .. factioncolor .. "\27[menu_hidden]\27X"
		end

		if menu.mode == "selectCV" then
			if isenemy then
				mouseover = ColorText["text_error"] .. ReadText(1026, 8014) .. "\027X"
			elseif C.IsBuilderBusy(convertedComponent) then
				mouseover = ColorText["text_error"] .. ReadText(1001, 7939) .. "\027X"
			elseif not isplayerowned then
				local fee = tonumber(C.GetBuilderHiringFee())
				mouseover = ((fee > GetPlayerMoney()) and ColorText["text_error"] or ColorText["text_success"]) .. ReadText(1001, 7940) .. ReadText(1001, 120) .. " " .. ConvertMoneyString(fee, false, true, nil, true) .. " " .. ReadText(1001, 101) .. "\027X"
			end
		end

		local row = ftable:addRow({"property", component, nil, iteration}, { bgColor = bgcolor, multiSelected = menu.isSelectedComponent(component) })
		if (menu.getNumSelectedComponents() == 1) and menu.isSelectedComponent(component) then
			menu.setrow = row.index
		end
		if IsSameComponent(component, menu.highlightedbordercomponent) then
			menu.sethighlightborderrow = row.index
		end

		-- Set up columns
		--  [+/-] [Object Name] [Top Level Shield/Hull Bar] [Location] [Sub_1] [Sub_2] [Sub_3] ... [Sub_N or Shield/Hull Bar]
		local isconstruction = IsComponentConstruction(component)
		local isstationexpandable = showmodules and isstation and (not isconstruction)
		if showmodules and isstation and isconstruction then
			isstationexpandable = C.GetNumStationModules(convertedComponent, true, false) > 0
		end
		if isstationexpandable or (subordinates.hasRendered and (not hidesubordinates)) or (#dockedships > 0) or (isstation and (#constructions > 0)) then
			row[1]:createButton({ scaling = false }):setText(menu.isPropertyExtended(tostring(component)) and "-" or "+", { scaling = true, halign = "center" })
			row[1].handlers.onClick = function () return menu.buttonExtendProperty(tostring(component)) end
		end

		local displaylocation = location and not (commanderlocation and IsSameComponent(location, commanderlocation))
		local currentordericon, currentorderrawicon, currentordercolor, currentordername, currentorderdescription, currentorderisoverride, currentordermouseovertext, behaviouricon, behaviourrawicon, behaviourname, behaviourdescription = "", "", nil, "", "", false, nil, "", "", "", ""
		if IsComponentClass(component, "ship") then
			currentordericon, currentorderrawicon, currentordercolor, currentordername, currentorderdescription, currentorderisoverride, currentordermouseovertext, _, behaviouricon, behaviourrawicon, behaviourname, behaviourdescription = menu.getOrderInfo(convertedComponent)
		end
		local fleettypes = IsComponentClass(component, "controllable") and menu.getPropertyOwnedFleetData(instance, component, maxicons) or {}

		if isplayerowned and isonlineobject then
			locationtext = Helper.convertColorToText(menu.holomapcolor.visitorcolor) .. ReadText(1001, 11231) .. "\27X"
			currentordericon = Helper.convertColorToText(menu.holomapcolor.visitorcolor) .. "\27[order_venture]\27X"
			currentorderrawicon = "order_waitforventure"
			currentordercolor = menu.holomapcolor.visitorcolor
			currentordername = ReadText(1001, 7868)
			currentordermouseovertext = nil
			isdocked = false
		end

		-- kuertee start: callback
		if callbacks ["createPropertyRow_on_set_locationtext"] then
			local result
			for i, callback in ipairs (callbacks ["createPropertyRow_on_set_locationtext"]) do
				result = callback (locationtext, component)
				if result.locationtext then
					locationtext = result.locationtext
				end
			end
		end
		-- kuertee end: callback

		local namecolspan = 1
		if menu.infoTableMode == "objectlist" then
			displaylocation = false
		end
		if not displaylocation then
			if (currentordericon ~= "") or isdocked then
				namecolspan = namecolspan + maxicons - 3
			else
				namecolspan = namecolspan + maxicons
			end
		end

		if isdoublerow then
			if isstation then
				-- station case
				local secondline = ""
				if displaylocation then
					secondline = locationtext
				end
				row[2]:setColSpan(4 + maxicons - #fleettypes - 1)
				local stationname = alertString .. Helper.convertColorToText(color) .. name .. "\27X"
				if isconstruction then
					stationname = stationname .. ColorText["text_inactive"] .. " (" .. ReadText(1001, 3217) .. ")\27X"
				end
				if alertMouseOver ~= "" then
					if mouseover ~= "" then
						mouseover = mouseover .. "\n\n"
					end
					mouseover = mouseover .. alertMouseOver
				end
				row[2]:createText(stationname .. "\n" .. secondline, { font = font, mouseOverText = mouseover })
			else
				-- fleet case
				local textheight = C.GetTextHeight(" \n ", font, Helper.scaleFont(font, config.mapFontSize), Helper.viewWidth)
				local icon = row[2]:setColSpan(4 + maxicons - #fleettypes - 1):createIcon("solid", { scaling = false, color = Color["icon_transparent"], height = textheight })

				local secondtext1 = ""
				local secondtext2 = ""
				if displaylocation or (currentordericon ~= "") or isdocked then
					if displaylocation then
						secondtext1 = locationtext
					end
					secondtext2 = (currentordericon ~= "") and currentordericon or ""
					if isdocked then
						secondtext2 = secondtext2 .. " \27[order_dockat]"
					end
					if behaviouricon ~= "" then
						secondtext2 = ColorText["order_temp"] .. behaviouricon .. "\27X" .. secondtext2
					end
				end
				local secondtext1truncated = TruncateText(secondtext1, font, Helper.scaleFont(font, config.mapFontSize), icon:getColSpanWidth() - Helper.scaleX(Helper.standardTextOffsetx))
				local secondtext1width = C.GetTextWidth(secondtext1truncated, font, Helper.scaleFont(font, config.mapFontSize))
				local secondtext2width = C.GetTextWidth(secondtext2, font, Helper.scaleFont(font, config.mapFontSize))

				local fleetname = ffi.string(C.GetFleetName(convertedComponent))
				local shipname = alertString .. name
				local fleetnametruncated = TruncateText(fleetname, font, Helper.scaleFont(font, config.mapFontSize), icon:getColSpanWidth() - Helper.scaleX(Helper.standardTextOffsetx) - secondtext1width - Helper.scaleX(10))
				local shipnametruncated = TruncateText(shipname, font, Helper.scaleFont(font, config.mapFontSize), icon:getColSpanWidth() - Helper.scaleX(Helper.standardTextOffsetx) - secondtext2width - Helper.scaleX(10))

				local mouseovertext = ""
				if fleetnametruncated ~= fleetname then
					mouseovertext = mouseovertext .. fleetname
				end
				if shipnametruncated ~= shipname then
					if mouseovertext ~= "" then
						mouseovertext = mouseovertext .. "\n"
					end
					mouseovertext = mouseovertext .. alertString .. Helper.convertColorToText(color) .. name .. "\27X"
				end
				if secondtext1truncated ~= secondtext1 then
					if mouseovertext ~= "" then
						mouseovertext = mouseovertext .. "\n"
					end
					mouseovertext = mouseovertext .. secondtext1
				end
				-- skip adding when behaviouricon was ignored (case: behaviour == HoldPosition AND order ~= null)
				if behaviouricon ~= "" and behaviourname and behaviourname ~= "" then
					if mouseovertext ~= "" then
						mouseovertext = mouseovertext .. "\n"
					end
					mouseovertext = mouseovertext .. behaviourname
				end
				-- skip adding when behaviouricon was ignored (case: behaviour == HoldPosition AND order ~= null)
				if behaviouricon ~= "" and behaviourdescription and behaviourdescription ~= "" then
					if mouseovertext ~= "" then
						mouseovertext = mouseovertext .. "\n"
					end
					mouseovertext = mouseovertext .. Helper.indentText(behaviourdescription, "  ", GetCurrentMouseOverWidth(), GetCurrentMouseOverFont())
				end
				if currentordername ~= "" then
					if mouseovertext ~= "" then
						mouseovertext = mouseovertext .. "\n"
					end
					mouseovertext = mouseovertext .. currentordername .. (currentordermouseovertext and ("\n" .. ColorText["text_error"] .. currentordermouseovertext .. "\27X") or "")
				end
				if currentorderdescription and currentorderdescription ~= "" then
					if mouseovertext ~= "" then
						mouseovertext = mouseovertext .. "\n"
					end
					mouseovertext = mouseovertext .. Helper.indentText(currentorderdescription, "  ", GetCurrentMouseOverWidth(), GetCurrentMouseOverFont())
				end
				if isdocked then
					if mouseovertext ~= "" then
						mouseovertext = mouseovertext .. "\n"
					end
					mouseovertext = mouseovertext .. ReadText(1001, 3249)
				end
				if alertMouseOver ~= "" then
					if mouseovertext ~= "" then
						mouseovertext = mouseovertext .. "\n\n"
					end
					mouseovertext = mouseovertext .. alertMouseOver
				end
				icon.properties.mouseOverText = mouseovertext

				icon:setText(string.format("%s\n%s%s", fleetnametruncated, Helper.convertColorToText(color), shipnametruncated), { scaling = true, font = font, x = Helper.standardTextOffsetx })
				icon:setText2(currentorderisoverride and function () return menu.overrideOrderIcon(currentordercolor, true, currentorderrawicon, secondtext1truncated .. "\n", isdocked and "\27[order_dockat]" or "") end or (secondtext1truncated .. "\n" .. secondtext2), { scaling = true, font = font, halign = "right", x = Helper.standardTextOffsetx })
			end
			-- fleet info
			for i, fleetdata in ipairs(fleettypes) do
				local colidx = 5 + maxicons - #fleettypes + i - 1
				if fleetdata.icon then
					row[colidx]:createText(string.format("\027[%s]\n%d", fleetdata.icon, fleetdata.count), { halign = "center", x = 0, color = fleetdata.color })
				else
					row[colidx]:createText(string.format("...\n%d", fleetdata.count), { halign = "center", x = 0 })
				end
			end
			-- shieldhullbar
			row[5 + maxicons]:createObjectShieldHullBar(component, { y = isstation and Helper.standardTextHeight / 2 or 1.5 * Helper.standardTextHeight })
		else
			-- unassigned ship case
			row[2]:setColSpan(namecolspan + 1)
			local indentation, actualname = string.match(name, "([ ]*)(.*)")
			local shipname = indentation .. alertString .. actualname
			if alertMouseOver ~= "" then
				if mouseover ~= "" then
					mouseover = mouseover .. "\n\n"
				end
				mouseover = mouseover .. alertMouseOver
			end

			-- kuertee start: callback
			-- row[2]:createText(shipname, { font = font, color = color, mouseOverText = mouseover })
			if not callbacks ["createPropertyRow_override_row_shipname_createText"] then
				row[2]:createText(shipname, { font = font, color = color, mouseOverText = mouseover })
			else
				local result
				for _, callback in ipairs (callbacks ["createPropertyRow_override_row_shipname_createText"]) do
					result = callback (shipname, { font = font, color = color, mouseOverText = mouseover }, component)
					if result then
						row[2]:createText(result.shipname, result.properties)
					end
				end
				if not result then
					row[2]:createText(shipname, { font = font, color = color, mouseOverText = mouseover })
				end
			end
			-- kuertee end: callback

			-- location / order
			if displaylocation then
				local colspan = 5 + maxicons - 3 - namecolspan
				if currentordericon ~= "" then
					colspan = colspan - 1
				end
				if isdocked then
					colspan = colspan - 1
				end
				if behaviouricon ~= "" then
					colspan = colspan - 1
				end
				-- kuertee start: callback
				-- row[3 + namecolspan]:setColSpan(colspan):createText(locationtext, { halign = "right", font = font, x = 0 })
				if not callbacks ["createPropertyRow_override_row_location_createText"] then
					row[3 + namecolspan]:setColSpan(colspan):createText(locationtext, { halign = "right", font = font, x = 0 })
				else
					local result
					for _, callback in ipairs (callbacks ["createPropertyRow_override_row_location_createText"]) do
						result = callback (locationtext, {halign = "right", font = font, mouseOverText = mouseovertext, x = 0}, component)
						if result then
							row[3 + namecolspan]:createText(result.locationtext, result.properties)
						end
					end
					if not result then
						row[3 + namecolspan]:setColSpan(colspan):createText(locationtext, { halign = "right", font = font, x = 0 })
					end
				end
				-- kuertee end: callback

			end
			if (currentordericon ~= "") or isdocked then
				local col = 4 + maxicons
				if isdocked then
					row[col]:createIcon("order_dockat", { width = config.mapRowHeight, height = config.mapRowHeight, mouseOverText = ReadText(1001, 3249) })
					col = col - 1
				end
				if currentordericon ~= "" then
					row[col]:createIcon(currentorderrawicon, { color = currentorderisoverride and function () return menu.overrideOrderIcon(currentordercolor, false) end or currentordercolor, width = config.mapRowHeight, height = config.mapRowHeight, mouseOverText = currentordername .. "\n" .. Helper.indentText(currentorderdescription .. (currentordermouseovertext and ("\n" .. ColorText["text_error"] .. currentordermouseovertext .. "\27X") or ""), "  ", GetCurrentMouseOverWidth(), GetCurrentMouseOverFont()) })
					col = col - 1
				end
				if behaviouricon ~= "" then
					row[col]:createIcon(behaviourrawicon, { color = Color["order_temp"], width = config.mapRowHeight, height = config.mapRowHeight, mouseOverText = behaviourname .. "\n" .. Helper.indentText(behaviourdescription, "  ", GetCurrentMouseOverWidth(), GetCurrentMouseOverFont()) })
					col = col - 1
				end
			end
			-- shieldhullbar
			row[5 + maxicons]:createObjectShieldHullBar(component)
		end

		if row[1].type == "button" then
			if isdoublerow and (not isstation) then
				row[1].properties.height = row[2]:getHeight()
			else
				row[1].properties.height = row[2]:getMinTextHeight(true)
			end
		end

		if isstation then
			AddKnownItem("stationtypes", macro)
		elseif IsComponentClass(component, "ship_xl") then
			AddKnownItem("shiptypes_xl", macro)
		elseif IsComponentClass(component, "ship_l") then
			AddKnownItem("shiptypes_l", macro)
		elseif IsComponentClass(component, "ship_m") then
			AddKnownItem("shiptypes_m", macro)
		elseif GetMacroData(macro, "islasertower") then
			AddKnownItem("lasertowers", macro)
		elseif IsComponentClass(component, "ship_s") then
			AddKnownItem("shiptypes_s", macro)
		elseif IsComponentClass(component, "ship_xs") then
			AddKnownItem("shiptypes_xs", macro)
		end

		if menu.isPropertyExtended(tostring(component)) then
			-- modules
			if showmodules and isstation then
				menu.createModuleSection(instance, ftable, component, iteration)
			end
			-- subordinates
			if subordinates.hasRendered and (not hidesubordinates) then
				numdisplayed = menu.createSubordinateSection(instance, ftable, component, isstation, iteration, location or commanderlocation, numdisplayed, sorter, isplayerowned, isally)
			end
			-- dockedships
			if #dockedships > 0 then
				local isdockedshipsextended = menu.isDockedShipsExtended(tostring(component), isstation)
				if (not isdockedshipsextended) and menu.isDockContext(convertedComponent) then

					-- kuertee start: callback
					-- if menu.infoTableMode ~= "propertyowned" then
					if not string.find (menu.infoTableMode, "propertyowned") then
						-- kuertee end: callback

						menu.extendeddockedships[tostring(component)] = true
						isdockedshipsextended = true
					end
				end

				local row = ftable:addRow({"dockedships", component}, {  })
				row[1]:createButton():setText(isdockedshipsextended and "-" or "+", { halign = "center" })
				row[1].handlers.onClick = function () return menu.buttonExtendDockedShips(tostring(component), isstation) end
				local text = ReadText(1001, 3265)
				for i = 1, iteration + 1 do
					text = "    " .. text
				end
				row[2]:setColSpan(3):createText(text)
				local numdockedplayerships = 0
				for _, dockedship in ipairs(dockedships) do
					local isplayerowned = GetComponentData(dockedship, "isplayerowned")
					if isplayerowned then
						numdockedplayerships = numdockedplayerships + 1
					end
				end
				if numdockedplayerships > 0 then
					row[5]:setColSpan(1 + maxicons):createText("\27[order_dockat] " .. numdockedplayerships, { halign = "right", color = menu.holomapcolor.playercolor })
				end
				if IsSameComponent(component, menu.highlightedbordercomponent) and (menu.highlightedborderstationcategory == "dockedships") then
					menu.sethighlightborderrow = row.index
				end
				if isdockedshipsextended then
					dockedships = menu.sortComponentListHelper(dockedships, sorter)
					for _, dockedship in ipairs(dockedships) do
						numdisplayed = menu.createPropertyRow(instance, ftable, dockedship, iteration + 2, location or commanderlocation, nil, true, numdisplayed, sorter)
					end
				end
			end
			if isstation then
				-- construction
				if #constructions > 0 then
					menu.createConstructionSubSection(ftable, component, constructions)
				end
			end
		end
	end

	return numdisplayed
end

function menu.createSubordinateSection(instance, ftable, component, isstation, iteration, location, numdisplayed, sorter, isplayerowned, isally)
	local maxicons = menu.infoTableData[instance].maxIcons
	local subordinates = menu.infoTableData[instance].subordinates[tostring(component)] or {}
	subordinates = menu.sortComponentListHelper(subordinates, sorter)
	-- setup groups
	local groups = {}
	for _, subordinate in ipairs(subordinates) do
		local group = GetComponentData(subordinate, "subordinategroup")
		if group and group > 0 then
			if groups[group] then
				if (not groups[group].hasrendered) and (menu.infoTableMode == "objectlist") then
					groups[group].hasrendered = menu.renderedComponentsRef[ConvertIDTo64Bit(subordinate)]
				end
				table.insert(groups[group].subordinates, subordinate)
			else
				local isrendered = true
				if menu.infoTableMode == "objectlist" then
					isrendered = menu.renderedComponentsRef[ConvertIDTo64Bit(subordinate)]
				end
				groups[group] = { assignment = ffi.string(C.GetSubordinateGroupAssignment(ConvertIDTo64Bit(component), group)), subordinates = { subordinate }, hasrendered = isrendered }
			end
		end
	end

	for group = 1, 10 do
		if groups[group] and groups[group].hasrendered then
			local issubordinateextended = menu.isSubordinateExtended(tostring(component), group)
			if (not issubordinateextended) and menu.isCommander(component, group) then
				menu.extendedsubordinates[tostring(component) .. group] = true
				issubordinateextended = true
			end

			local row = ftable:addRow({"subordinates" .. tostring(component) .. group, component, group}, {  })
			row[1]:createButton():setText(issubordinateextended and "-" or "+", { halign = "center" })
			row[1].handlers.onClick = function () return menu.buttonExtendSubordinate(tostring(component), group) end
			local text = string.format(ReadText(1001, 8398), ReadText(20401, group))
			for i = 1, iteration + 1 do
				text = "    " .. text
			end
			row[2]:setColSpan(2):createText(text)

			local assignmenttext = config.assignments[groups[group].assignment] and config.assignments[groups[group].assignment].name or ""
			local groupiconstext = ""
			local groupmouseovertext = ""

			if isplayerowned or isally then
				groupmouseovertext = ReadText(1001, 5903) .. ReadText(1001, 120) .. " " .. assignmenttext -- Assignment: X
				local idlingshipstext = ReadText(1026, 3271) -- "%d ships waiting for orders."
				local idlingshipstext_singular = ReadText(1026, 3272) -- "1 ship waiting for orders."
				local awayshipstext = ReadText(1026, 3273) -- "%d ships in a different sector."
				local awayshipstext_singular = ReadText(1026, 3274) -- "1 ship in a different sector."

				-- group icons
				local shipstates = menu.getPropertyOwnedGroupIcons(instance, component, groups[group].subordinates)
				for i, shipstatedata in ipairs(shipstates) do
					if shipstatedata.icon and shipstatedata.count > 0 then
						groupiconstext = groupiconstext .. string.format("\027[%s]%d  ", shipstatedata.icon, shipstatedata.count)
						if (shipstatedata.name == "shipstate_idling") then
							if shipstatedata.count == 1 then
								groupmouseovertext = groupmouseovertext .. "\n" .. idlingshipstext_singular
							elseif shipstatedata.count > 1 then
								groupmouseovertext = groupmouseovertext .. "\n" .. string.format(idlingshipstext, shipstatedata.count)
							end
						elseif (shipstatedata.name == "shipstate_away") then
							if shipstatedata.count == 1 then
								groupmouseovertext = groupmouseovertext .. "\n" .. awayshipstext_singular
							elseif shipstatedata.count > 1 then
								groupmouseovertext = groupmouseovertext .. "\n" .. string.format(awayshipstext, shipstatedata.count)
							end
						end
					end
				end
				groupiconstext = groupiconstext .. assignmenttext
			else
				groupiconstext = assignmenttext
			end

			row[4]:setColSpan(maxicons + 2):createText(groupiconstext, { halign = "right", mouseOverText = groupmouseovertext })
			if menu.highlightedborderstationcategory == "subordinates" .. tostring(component) .. group then
				menu.sethighlightborderrow = row.index
			end
			if issubordinateextended then
				for _, subordinate in ipairs(groups[group].subordinates) do
					local isdocked, subordinategroup = GetComponentData(subordinate, "isdocked", "subordinategroup")
					local isexternaldock, parent
					if isdocked then
						isexternaldock = C.IsShipAtExternalDock(ConvertIDTo64Bit(subordinate))
						parent = C.GetContextByClass(ConvertIDTo64Bit(subordinate), "container", false)
					end

					if (menu.infoTableMode ~= "objectlist") or menu.renderedComponentsRef[ConvertIDTo64Bit(subordinate)] or (isdocked and (not isexternaldock) and menu.renderedComponentsRef[ConvertStringTo64Bit(tostring(parent))]) then
						numdisplayed = menu.createPropertyRow(instance, ftable, subordinate, iteration + 2, location, nil, nil, numdisplayed, sorter)
					end
				end
			end
		end
	end

	return numdisplayed
end

function menu.createModuleSection(instance, ftable, component, iteration)
	local moduledata = menu.getModuleData(ConvertStringTo64Bit(tostring(component)))
	local maxicons = menu.infoTableData[instance].maxIcons

	for _, moduletype in ipairs(config.moduletypes) do
		local modules = moduledata[moduletype.type] or {}
		if next(modules) then
			if (not menu.isModuleTypeExtended(component, moduletype.type)) then
				for _, module in ipairs(modules) do
					if menu.isSelectedComponent(module) then
						menu.extendModuleType(component, moduletype.type, true)
						break
					end
				end
			end

			local istypeextended = menu.isModuleTypeExtended(component, moduletype.type)

			local bgcolor
			if (menu.mode == "orderparam_object") then
				bgcolor = Color["row_background_unselectable"]
			end

			local row = ftable:addRow({"moduletype", component, moduletype.type, iteration}, { bgColor = bgcolor })
			if IsSameComponent(component, menu.highlightedbordercomponent) and (moduletype.type == menu.highlightedbordermoduletype) then
				menu.sethighlightborderrow = row.index
			end

			row[1]:createButton():setText(istypeextended and "-" or "+", { halign = "center" })
			row[1].handlers.onClick = function () return menu.buttonExtendModuleType(component, moduletype.type) end
			local moduleUnderConstruction
			for _, module in ipairs(modules) do
				if type(module) ~= "string" then
					if IsComponentConstruction(module) then
						moduleUnderConstruction = module
						break
					end
				end
			end

			if moduleUnderConstruction then
				row[2]:setColSpan(3):createText(function () return menu.getBuildProgress(component, "    " .. moduletype.name, moduleUnderConstruction) end)
				local buildingprocessor = GetComponentData(component, "buildingprocessor")
				local ismissingresources = GetComponentData(buildingprocessor, "ismissingresources")
				row[5]:setColSpan(1 + maxicons):createText(function () return menu.getBuildTime(ConvertIDTo64Bit(buildingprocessor), moduleUnderConstruction, ismissingresources) end, { halign = "right", mouseOverText = ismissingresources and ReadText(1026, 3223) or "" })
			else
				row[2]:setColSpan(3):createText("    " .. moduletype.name)
			end

			if istypeextended then
				for _, module in ipairs(modules) do
					if type(module) == "string" then
						local name = GetMacroData(module, "name")
						local bgcolor
						if menu.mode == "orderparam_object" then
							bgcolor = Color["row_background_unselectable"]
						end
						local row = ftable:addRow({"module", nil, moduletype.type, iteration, component, module}, { bgColor = bgcolor })

						if IsSameComponent(component, menu.highlightedbordercomponent) and (moduletype.type == menu.highlightedbordermoduletype) and (module == menu.highlightedplannedmodule) then
							menu.sethighlightborderrow = row.index
						end

						row[2]:setColSpan(3):createText(function () return menu.getBuildProgress(component, "        " .. name, 0) end, { color = color })
					else
						local moduleunlocked = isplayer or IsInfoUnlockedForPlayer(module, "name")

						local color = (not moduleunlocked) and Color["text_inactive"] or nil
						local bgcolor
						if (menu.mode == "orderparam_object") and (not menu.checkForOrderParamObject(module)) then
							bgcolor = Color["row_background_unselectable"]
						end

						local row = ftable:addRow({"module", ConvertStringToLuaID(tostring(module)), moduletype.type, iteration, component}, { bgColor = bgcolor, multiSelected = menu.isSelectedComponent(module) })
						if IsSameComponent(module, menu.highlightedbordercomponent) then
							menu.sethighlightborderrow = row.index
						end
						local name = moduleunlocked and ffi.string(C.GetComponentName(module)) or ReadText(1001, 3210)
						row[2]:setColSpan(3):createText(function () return menu.getBuildProgress(component, "        " .. name, module) end, { color = color })

						local isfunctional, ishacked = GetComponentData(module, "isfunctional", "ishacked")
						if IsComponentConstruction(module) then
							local buildingprocessor = GetComponentData(component, "buildingprocessor")
							local ismissingresources = GetComponentData(buildingprocessor, "ismissingresources")
							row[5]:setColSpan(1 + maxicons):createText(function () return menu.getBuildTime(ConvertIDTo64Bit(buildingprocessor), module, ismissingresources) end, { halign = "right", color = color, mouseOverText = ismissingresources and ReadText(1026, 3223) or "" })
						else
							if not isfunctional then
								row[5]:setColSpan(maxicons):createText(ishacked and ("[" .. ReadText(1001, 4770) .. "]") or ("[" .. ReadText(1001, 11606) .. "]"), { halign = "right", color = Color["text_warning"] })
							end
							row[5 + maxicons]:createObjectShieldHullBar(module)
						end
					end
				end
			end
		end
	end
end

function menu.createConstructionSubSection(ftable, component, constructions)
	for i, construction in ipairs(constructions) do
		if menu.isSelectedComponent(construction.component) then
			menu.extendedconstruction[tostring(component)] = true
		end
	end
	local isconstructionextended = menu.isConstructionExtended(tostring(component))
	local row = ftable:addRow({"constructions", component}, {  })
	row[1]:createButton():setText(isconstructionextended and "-" or "+", { halign = "center" })
	row[1].handlers.onClick = function () return menu.buttonExtendConstruction(tostring(component)) end
	row[2]:setColSpan(3):createText("    " .. ReadText(1001, 3266))
	if IsSameComponent(component, menu.highlightedbordercomponent) and (menu.highlightedborderstationcategory == "constructions") then
		menu.sethighlightborderrow = row.index
	end
	if isconstructionextended then
		for i, construction in ipairs(constructions) do
			if construction.empty then
				ftable:addEmptyRow(config.mapRowHeight / 2)
			else
				menu.createConstructionRow(ftable, component, construction, 2)
			end
		end
	end
end

function menu.createConstructionSection(instance, id, ftable, name, constructions)
	if #constructions > 0 then
		local maxicons = menu.infoTableData[instance].maxIcons

		local row = ftable:addRow(false, { bgColor = Color["row_background_blue"] })
		row[1]:setColSpan(5 + maxicons):createText(name, Helper.headerRowCenteredProperties)

		if id == menu.highlightedbordersection then
			menu.sethighlightborderrow = row.index + 1
		end

		for i, construction in ipairs(constructions) do
			if construction.empty then
				ftable:addEmptyRow(config.mapRowHeight / 2)
			else
				local component = ConvertStringTo64Bit(tostring(construction.buildingcontainer))
				menu.createConstructionRow(ftable, component, construction, 1)
			end
		end
	end
end

function menu.createConstructionRow(ftable, component, construction, iteration)
	local name = ReadText(20109, 5101)
	if construction.component ~= 0 then
		name = ffi.string(C.GetComponentName(construction.component))
	elseif construction.macro ~= "" then
		name = GetMacroData(construction.macro, "name")
		if construction.amount then
			name = construction.amount .. ReadText(1001, 42) .. " " .. name
		end
	end
	for i = 1, iteration do
		name = "    " .. name
	end
	local color = (construction.factionid == "player") and menu.holomapcolor.playercolor or Color["text_normal"]
	local bgcolor
	if menu.mode == "orderparam_object" then
		bgcolor = Color["row_background_unselectable"]
	end

	local row = ftable:addRow({ "construction", component, construction }, { bgColor = bgcolor, multiSelected = menu.isSelectedComponent(construction.component) })
	if menu.highlightedconstruction and (construction.id == menu.highlightedconstruction.id) then
		menu.sethighlightborderrow = row.index
	end
	if (construction.component ~= 0) and IsSameComponent(ConvertStringTo64Bit(tostring(construction.component)), menu.highlightedbordercomponent) then
		menu.sethighlightborderrow = row.index
	end

	if construction.inprogress then
		row[2]:setColSpan(4):createText(function () return menu.getShipBuildProgress(construction.component, name .. " (" .. ffi.string(C.GetObjectIDCode(construction.component)) .. ")") end, { color = color, mouseOverText = construction.ismissingresources and ReadText(1026, 3223) or "" })
		row[6]:setColSpan(5):createText(function () return (construction.ismissingresources and (ColorText["text_warning"] .. "\27[warning] ") or "") .. Helper.formatTimeLeft(C.GetBuildProcessorEstimatedTimeLeft(construction.buildercomponent)) end, { halign = "right", color = color, mouseOverText = construction.ismissingresources and ReadText(1026, 3223) or "" })
	else
		local duration = C.GetBuildTaskDuration(construction.buildingcontainer, construction.id)
		row[2]:setColSpan(3):createText(name, { color = color })
		if construction.amount then
			row[5]:setColSpan(6):createText(string.format(ReadText(1001, 11608), Helper.formatTimeLeft(duration)), { halign = "right", color = color })
		else
			row[5]:setColSpan(6):createText("#" .. construction.queueposition .. " - " .. Helper.formatTimeLeft(duration), { halign = "right", color = color })
		end
	end
end

function menu.getPropertyOwnedFleetData(instance, component, maxentries)
	local shiptyperanks = { }
	local shiptypedata = { }
	menu.getPropertyOwnedFleetDataInternal(instance, component, shiptyperanks, shiptypedata)
	table.sort(shiptyperanks)
	local result = { }
	for _, shiptyperank in ipairs(shiptyperanks) do
		-- insert at front
		table.insert(result, 1, shiptypedata[shiptyperank])
	end

	local dockedships = menu.infoTableData[instance].dockedships[tostring(component)] or {}
	local numdockedplayerships = 0
	for _, dockedship in ipairs(dockedships) do
		local isplayerowned = GetComponentData(dockedship, "isplayerowned")
		if isplayerowned then
			local iscommander = false
			local commanderlist = GetAllCommanders(dockedship)
			for i, entry in ipairs(commanderlist) do
				if IsSameComponent(entry, component) then
					iscommander = true
					break
				end
			end
			if not iscommander then
				numdockedplayerships = numdockedplayerships + 1
			end
		end
	end
	if numdockedplayerships > 0 then
		table.insert(result, 1, { icon = "order_dockat", count = numdockedplayerships, color = menu.holomapcolor.playercolor })
	end

	-- If there are too many entries, accumulate counts in last entry and invalidate icon
	while maxentries and #result > maxentries do
		local removed = table.remove(result)
		result[maxentries].count = result[maxentries].count + removed.count
		result[maxentries].icon = nil
	end
	return result
end

function menu.getPropertyOwnedFleetDataInternal(instance, component, shiptyperanks, shiptypedata)
	local shiptyperank
	local shipclass = "xs"
	if IsComponentClass(component, "ship_xl") then
		shiptyperank = 50
		shipclass = "xl"
	elseif IsComponentClass(component, "ship_l") then
		shiptyperank = 40
		shipclass = "l"
	elseif IsComponentClass(component, "ship_m") then
		shiptyperank = 30
		shipclass = "m"
	elseif IsComponentClass(component, "ship_s") then
		shiptyperank = 20
		shipclass = "s"
	elseif IsComponentClass(component, "ship_xs") then
		shiptyperank = 10
		shipclass = "xs"
	end
	if shiptyperank then
		local purpose, icon, primarypurposeicon = GetComponentData(component, "primarypurpose", "icon", "primarypurposeicon")
		if purpose == "fight" then
			shiptyperank = shiptyperank + 5
		elseif purpose == "auxiliary" then
			shiptyperank = shiptyperank + 4
		elseif purpose == "trade" then
			shiptyperank = shiptyperank + 3
		elseif purpose == "mine" then
			shiptyperank = shiptyperank + 2
		elseif purpose == "build" then
			shiptyperank = shiptyperank + 1
		else
			purpose = "neutral"
		end
		if primarypurposeicon ~= "" then
			icon = primarypurposeicon
		end
		if not shiptypedata[shiptyperank] then
			table.insert(shiptyperanks, shiptyperank)
			shiptypedata[shiptyperank] = { icon = icon, count = 0 }
		end
		shiptypedata[shiptyperank].count = shiptypedata[shiptyperank].count + 1
	end

	-- kuertee start: callback
	if callbacks ["getPropertyOwnedFleetDataInternal_addToFleetIcons"] then
		for _, callback in ipairs (callbacks ["getPropertyOwnedFleetDataInternal_addToFleetIcons"]) do
			callback (component, shiptyperanks, shiptypedata)
		end
	end
	-- kuertee end: callback

	local subordinates = menu.infoTableData[instance].subordinates[tostring(component)]
	if subordinates == nil then
		-- component is not rendered but we still need the subordinates for accurate fleet counts
		subordinates = GetSubordinates(component)
		for i = #subordinates, 1, -1 do
			local subordinate = subordinates[i]
			if not menu.isObjectValid(ConvertIDTo64Bit(subordinate)) then
				table.remove(subordinates, i)
			end
		end
	end
	menu.infoTableData[instance].subordinates[tostring(component)] = subordinates
	for _, subordinate in ipairs(subordinates) do
		menu.getPropertyOwnedFleetDataInternal(instance, subordinate, shiptyperanks, shiptypedata)
	end
end

function menu.getPropertyOwnedGroupIcons(instance, component, subordinates)
	local shipstates = {}
	local shipstatesdata = {}
	local sectorbase = GetComponentData(ConvertStringTo64Bit(tostring(component)), "sector")
	for _, subordinate in ipairs(subordinates) do
		if menu.isObjectValid(ConvertIDTo64Bit(subordinate)) then
			menu.getPropertyOwnedGroupIcons_getData(instance, subordinate, shipstates, shipstatesdata, sectorbase)
		end
	end
	table.sort(shipstates)
	local result = {}
	for _, shipstate in ipairs(shipstates) do
		table.insert(result, 1, shipstatesdata[shipstate])
	end
	return result
end

function menu.getPropertyOwnedGroupIcons_getData(instance, component, shipstates, shipstatesdata, sectorbase)
	local shipstate_idling = 10
	local shipstate_name = "shipstate_idling"
	local shipstate_idling_icon = "ships_idling_01"
	local purpose = GetComponentData(component, "primarypurpose")
	if not shipstatesdata[shipstate_idling] then
		table.insert(shipstates, shipstate_idling)
		shipstatesdata[shipstate_idling] = {name = shipstate_name, icon = shipstate_idling_icon, count = 0 }
	end
	local numOrders = C.GetNumOrders(ConvertStringTo64Bit(tostring(component)))
	if numOrders == 0 then
		shipstatesdata[shipstate_idling].count = shipstatesdata[shipstate_idling].count + 1
	end
	local shipstate_away = 20
	local shipstate_name = "shipstate_away"
	local shipstate_away_icon = "ships_away_01"
	local sector = GetComponentData(ConvertStringTo64Bit(tostring(component)), "sector")
	if not shipstatesdata[shipstate_away] then
		table.insert(shipstates, shipstate_away)
		shipstatesdata[shipstate_away] = {name = shipstate_name, icon = shipstate_away_icon, count = 0}
	end
	if sector ~= sectorbase then
		shipstatesdata[shipstate_away].count = shipstatesdata[shipstate_away].count + 1
	end
end

function menu.populateUpkeepMissionData()
	menu.upkeepMissionData = {}

	local numMissions = GetNumMissions()
	for i = 1, numMissions do
		local missionID, name, description, difficulty, threadtype, maintype, subtype, subtypename, faction, reward, rewardtext, _, _, _, _, _, missiontime, _, abortable, disableguidance, associatedcomponent, alertLevel = GetMissionDetails(i)

		if maintype == "upkeep" then
			if associatedcomponent then
				local rawcontainer = C.GetContextByRealClass(ConvertIDTo64Bit(associatedcomponent), "container", true)
				if rawcontainer ~= 0 then
					local container = ConvertStringTo64Bit(tostring(rawcontainer))

					if menu.upkeepMissionData[tostring(container)] then
						table.insert(menu.upkeepMissionData[tostring(container)], { missionID = missionID, alertLevel = alertLevel, name = name })
					else
						menu.upkeepMissionData[tostring(container)] = { { missionID = missionID, alertLevel = alertLevel, name = name } }
					end
				end
			end
		end
	end
end

function menu.getContainerAlertLevel(component)
	component = ConvertStringTo64Bit(tostring(component))
	local highestAlertLevel = 0
	local upkeepMissions = {}
	if menu.upkeepMissionData[tostring(component)] then
		for _, entry in ipairs(menu.upkeepMissionData[tostring(component)]) do
			highestAlertLevel = math.max(highestAlertLevel, entry.alertLevel)
			table.insert(upkeepMissions, { alertLevel = entry.alertLevel, name = entry.name })
		end
	end

	table.sort(upkeepMissions, function (a, b) return a.alertLevel > b.alertLevel end)
	local missionlist = ""
	for i, entry in ipairs(upkeepMissions) do
		if i ~= 1 then
			missionlist = missionlist .. "\n"
		end
		local color = Color["text_normal"]
		if entry.alertLevel == 1 then
			color = menu.holomapcolor.lowalertcolor
		elseif entry.alertLevel == 2 then
			color = menu.holomapcolor.mediumalertcolor
		else
			color = menu.holomapcolor.highalertcolor
		end
		missionlist = missionlist .. Helper.convertColorToText(color) .. entry.name
	end

	return highestAlertLevel, missionlist
end

function menu.getBuildProgress(station, name, component)
	local buildprogress = 100
	if IsComponentConstruction(ConvertStringTo64Bit(tostring(component))) then
		buildprogress = math.floor(C.GetCurrentBuildProgress(ConvertIDTo64Bit(station)))
	elseif component == 0 then
		buildprogress = "-"
	end

	if buildprogress == 100 then
		return name
	else
		return name .. " (" .. buildprogress .. " %)"
	end
end

function menu.getBuildTime(buildingprocessor, component, ismissingresources)
	if IsComponentConstruction(ConvertStringTo64Bit(tostring(component))) then
		return (ismissingresources and (ColorText["text_warning"] .. "\27[warning] ") or "") .. ConvertTimeString(C.GetBuildProcessorEstimatedTimeLeft(buildingprocessor), "%h:%M:%S")
	else
		return ""
	end
end

function menu.getShipBuildProgress(ship, name)
	local buildprogress = 100
	if IsComponentConstruction(ConvertStringTo64Bit(tostring(ship))) then
		buildprogress = math.floor(C.GetCurrentBuildProgress(ship))
	elseif ship == 0 then
		buildprogress = "-"
	end

	if buildprogress == 100 then
		return name
	else
		return name .. " (" .. buildprogress .. " %)"
	end
end

-- Order Queue

function menu.displayOrderParam(ftable, orderidx, order, paramidx, param, listidx, instance)
	local value = param.value
	local ismissing = value == nil
	local playeroccupiedship64 = C.GetPlayerOccupiedShipID()
	local isplayeroccupiedship = menu.infoSubmenuObject == playeroccupiedship64
	local paramactive = true
	if orderidx == "default" then
		paramactive = (menu.infoTableData[instance].commander == nil) and (not isplayeroccupiedship)
	end
	if paramactive and ((param.inputparams and param.inputparams.playerreadonly) or param.playerreadonly) then
		if param.inputparams and param.inputparams.playerreadonly then
			paramactive = (param.inputparams.playerreadonly ~= 1)
		elseif param.playerreadonly then
			paramactive = (param.playerreadonly ~= 1)
		end
	end
	if instance == nil then
		print(TraceBack())
	end
	local selectedorder = menu.infoTablePersistentData[instance].selectedorder

	local numValues = 0
	if not ismissing then
		if listidx then
			numValues = #order.params[paramidx].value
		end
		value = menu.getParamValue(param.type, value, param.inputparams)
	end

	local paramcolor = Color["text_normal"]
	if ismissing then
		paramcolor = Color["text_error"]
	elseif order.state == "setup" then
		paramcolor = Color["text_success"]
	end

	local paramtext = (param.text ~= "") and ("  " .. param.text .. ReadText(1001, 120)) or ""

	if listidx then
		local row = ftable:addRow({ orderidx, paramidx, listidx }, {  })
		if selectedorder and (selectedorder[1] == orderidx) and (selectedorder[2] == paramidx) and (selectedorder[3] == listidx) then
			menu.selectedRows["infotable" .. instance] = row.index
			menu.selectedCols["infotable" .. instance] = nil
		end

		if param.canplayeroverride then
			local checked = (#param.canplayeroverride.param.value == 0) or (param.canplayeroverride.values[param.value] ~= nil)
			local active = #param.canplayeroverride.param.value > 1
			local mouseovertext = ""

			if #param.canplayeroverride.param.value > 0 then
				if not checked then
					active = true
				elseif not active then
					mouseovertext = ReadText(1026, 3283)
				end
			end

			row[5]:setColSpan(1)
			row[6]:createCheckBox(checked, { active = active, width = config.mapRowHeight, height = config.mapRowHeight, mouseOverText = mouseovertext })
			row[6].handlers.onClick = function () menu.checkboxOrderPlayerOverrideValue(orderidx, param.canplayeroverride.paramidx, param.canplayeroverride.values[param.value], param.value) end

			local suffix = ""
			local mouseovertext = ""
			if param.canplayeroverride.criticalwares[param.value] then
				suffix = " " .. ColorText["text_warning"] .. "\27[menu_ware_critical]"
				mouseovertext = ReadText(1026, 3284)
			end
			row[7]:createText(value and (tostring(value) .. suffix) or "", { mouseOverText = mouseovertext })
		else
			row[menu.infoTableData[instance].hasloop and 4 or 2]:setColSpan(menu.infoTableData[instance].hasloop and 1 or 3):createText(paramtext)
			local active = paramactive and (not isplayeroccupiedship) and (((order.state == "setup") and (paramidx <= (order.actualparams + 1))) or ((order.state ~= "setup") and param.editable))
			row[5]:setColSpan(7):createButton({ active = active }):setText(value and tostring(value) or "", { halign = "center", color = paramcolor })
			row[5].handlers.onClick = function () return menu.buttonSetOrderParam(orderidx, paramidx, listidx, nil, instance) end
			row[12]:createButton({ active = active and ((not order.params[paramidx].required) or (numValues > 1)) }):setText("x", { halign = "center", color = paramcolor })
			row[12].handlers.onClick = function () return menu.buttonRemoveListParam(orderidx, paramidx, listidx, instance) end
		end
	elseif config.complexOrderParams[param.type] then
		local data = config.complexOrderParams[param.type].data(param.value)
		local playerreadonly = param.inputparams and param.inputparams.playerreadonly
		if next(data) then
			for _, subparam in ipairs(config.complexOrderParams[param.type]) do
				if subparam.value(data) then
					local subparam2 = { name = subparam.id, text = subparam.name, value = subparam.value(data), type = subparam.type, editable = param.editable, playerreadonly = playerreadonly }
					menu.displayOrderParam(ftable, orderidx, order, paramidx, subparam2, nil, instance)
				end
			end
		end
	elseif param.inputparams and (param.type == "number" or param.type == "length" or param.type == "time" or param.type == "money") then
		local defaultmax = 50000
		local minselect = math.max(0, param.inputparams.min or 0)
		local maxselect = math.max(0, param.inputparams.max or defaultmax)
		local curvalue = tonumber(param.value)
		local startvalue = param.inputparams.startvalue
		local step = (param.inputparams.step and (param.inputparams.step >= 1)) and param.inputparams.step or 1
		local usetimeformat = false

		local suffix = ""
		if param.type == "length" then
			if param.inputparams.step >= 1000 then
				suffix = ReadText(1001, 108)
				minselect = math.floor(minselect / 1000)
				maxselect = math.floor(maxselect / 1000)
				curvalue = curvalue and math.floor(curvalue / 1000)
				startvalue = startvalue and math.floor(startvalue / 1000)
				step = math.ceil(step / 1000)
			else
				suffix = ReadText(1001, 107)
			end
		elseif param.type == "time" then
			suffix = ReadText(1001, 103)
			usetimeformat = true
			minselect = math.floor(minselect / 60)
			maxselect = math.floor(maxselect / 60)
			curvalue = curvalue and math.floor(curvalue / 60)
			startvalue = startvalue and math.floor(startvalue / 60)
			step = math.ceil(step / 60)
		elseif param.type == "money" then
			suffix = ReadText(1001, 101)
		end

		local useinfinite = false
		if param.hasinfinitevalue then
			useinfinite = true
			infinitevalue = param.infinitevalue
		end

		local slidercellProperties = {
			height = config.mapRowHeight,
			bgColor = Color["slider_background_transparent"],
			valueColor = paramactive and Color["slider_value"] or Color["slider_value_inactive"],
			min       = minselect,
			max       = maxselect,
			start     = math.max(minselect, math.min(maxselect, curvalue or startvalue or minselect)),
			step      = step,
			suffix    = suffix,
			exceedMaxValue = false,
			readOnly = (not paramactive) or isplayeroccupiedship or (((order.state ~= "setup") or (paramidx > (order.actualparams + 1))) and ((order.state == "setup") and (not param.editable))),
			hideMaxValue = param.hasinfinitevalue,
			useInfiniteValue = useinfinite,
			infiniteValue = infinitevalue,
			useTimeFormat = usetimeformat,
		}

		local row = ftable:addRow({ orderidx, paramidx, listidx }, {  })
		if selectedorder and (selectedorder[1] == orderidx) and (selectedorder[2] == paramidx) and (selectedorder[3] == listidx) then
			menu.selectedRows["infotable" .. instance] = row.index
			menu.selectedCols["infotable" .. instance] = nil
		end
		row[menu.infoTableData[instance].hasloop and 4 or 2]:setColSpan(menu.infoTableData[instance].hasloop and 1 or 3)
		row[menu.infoTableData[instance].hasloop and 4 or 2]:createText(paramtext)
		row[5]:setColSpan(8):createSliderCell(slidercellProperties):setText("", { fontsize = config.mapFontSize, color = paramcolor })
		row[5].handlers.onSliderCellConfirm = function (_, value) return menu.slidercellSetOrderParam(orderidx, paramidx, listidx, value, instance) end
		row[5].handlers.onSliderCellActivated = function() menu.noupdate = true end
		row[5].handlers.onSliderCellDeactivated = function() menu.noupdate = false end
	elseif param.type == "bool" then
		local row = ftable:addRow({ orderidx, paramidx, listidx }, {  })
		if selectedorder and (selectedorder[1] == orderidx) and (selectedorder[2] == paramidx) and (selectedorder[3] == listidx) then
			menu.selectedRows["infotable" .. instance] = row.index
			menu.selectedCols["infotable" .. instance] = nil
		end
		row[menu.infoTableData[instance].hasloop and 4 or 2]:setColSpan(menu.infoTableData[instance].hasloop and 1 or 3):createText(paramtext)
		local active = paramactive and (not isplayeroccupiedship) and (((order.state == "setup") and (paramidx <= (order.actualparams + 1))) or ((order.state ~= "setup") and param.editable))
		local rawvalue = param.value ~= 0
		if ismissing then
			rawvalue = false
		end
		row[5]:createCheckBox(rawvalue, { active = active, width = config.mapRowHeight })
		row[5].handlers.onClick = function () return menu.buttonSetOrderParam(orderidx, paramidx, listidx, nil, instance) end
	else
		local row = ftable:addRow({ orderidx, paramidx, listidx }, {  })
		if selectedorder and (selectedorder[1] == orderidx) and (selectedorder[2] == paramidx) and (selectedorder[3] == listidx) then
			menu.selectedRows["infotable" .. instance] = row.index
			menu.selectedCols["infotable" .. instance] = nil
		end
		row[menu.infoTableData[instance].hasloop and 4 or 2]:setColSpan(menu.infoTableData[instance].hasloop and 1 or 3):createText(paramtext)
		row[5]:setColSpan(8)
		local active = paramactive and (not isplayeroccupiedship) and (((order.state == "setup") and (paramidx <= (order.actualparams + 1))) or ((order.state ~= "setup") and param.editable))
		local text = value and tostring(value) or ""
		local height = math.max(config.mapRowHeight, math.ceil(C.GetTextHeight(text, Helper.standardFont, Helper.standardFontSize, row[5]:getWidth())) + Helper.borderSize)
		row[5]:createButton({ active = active, height = height, helpOverlayID = "orderparam_" .. param.name, helpOverlayText = " ", helpOverlayHighlightOnly = true }):setText(text, { halign = "center", color = paramcolor, y = (height - config.mapRowHeight) / 2 })
		row[5].handlers.onClick = function () return menu.buttonSetOrderParam(orderidx, paramidx, listidx, nil, instance) end
		row[5].properties.uiTriggerID = "orderparam_" .. param.name
	end
end

function menu.displayFailureParam(ftable, failureidx, paramidx, param, listidx, instance)
	if instance == nil then
		print(TraceBack())
	end
	local selectedorder = menu.infoTablePersistentData[instance].selectedorder

	local value = menu.getParamValue(param.type, param.value, param.inputparams)

	local paramtext = (param.text ~= "") and ("  " .. param.text .. ReadText(1001, 120)) or ""

	if listidx then
		local row = ftable:addRow({ "failure", failureidx, paramidx, listidx }, { interactive = false })
		if selectedorder and (selectedorder[1] == "failure") and (selectedorder[2] == failureidx) and (selectedorder[3] == paramidx) and (selectedorder[4] == listidx) then
			menu.selectedRows["infotable" .. instance] = row.index
			menu.selectedCols["infotable" .. instance] = nil
		end
		row[menu.infoTableData[instance].hasloop and 4 or 2]:setColSpan(menu.infoTableData[instance].hasloop and 1 or 3):createText(paramtext)
		row[5]:setColSpan(8):createButton({ active = false }):setText(value and tostring(value) or "", { halign = "center" })
	elseif config.complexOrderParams[param.type] then
		local data = config.complexOrderParams[param.type].data(param.value)
		if next(data) then
			for _, subparam in ipairs(config.complexOrderParams[param.type]) do
				if subparam.value(data) then
					local subparam2 = { text = subparam.name, value = subparam.value(data), type = subparam.type, editable = param.editable }
					menu.displayFailureParam(ftable, failureidx, paramidx, subparam2, nil, instance)
				end
			end
		end
	elseif param.inputparams and (param.type == "number" or param.type == "length" or param.type == "time" or param.type == "money") then
		local defaultmax = 50000
		local minselect = math.max(0, param.inputparams.min or 0)
		local maxselect = math.max(0, param.inputparams.max or defaultmax)
		local curvalue = tonumber(param.value)
		local startvalue = param.inputparams.startvalue
		local step = (param.inputparams.step and (param.inputparams.step >= 1)) and param.inputparams.step or 1
		local usetimeformat = false

		local suffix = ""
		if param.type == "length" then
			if param.inputparams.step and (param.inputparams.step >= 1000) then
				suffix = ReadText(1001, 108)
				minselect = math.floor(minselect / 1000)
				maxselect = math.floor(maxselect / 1000)
				curvalue = curvalue and math.floor(curvalue / 1000)
				startvalue = startvalue and math.floor(startvalue / 1000)
				step = math.ceil(step / 1000)
			else
				suffix = ReadText(1001, 107)
			end
		elseif param.type == "time" then
			suffix = ReadText(1001, 103)
			usetimeformat = true
			minselect = math.floor(minselect / 60)
			maxselect = math.floor(maxselect / 60)
			curvalue = curvalue and math.floor(curvalue / 60)
			startvalue = startvalue and math.floor(startvalue / 60)
			step = math.ceil(step / 60)
		elseif param.type == "money" then
			suffix = ReadText(1001, 101)
		end

		local useinfinite = false
		if param.hasinfinitevalue then
			useinfinite = true
			infinitevalue = param.infinitevalue
		end

		local slidercellProperties = {
			height = config.mapRowHeight,
			bgColor = Color["slider_background_transparent"],
			readOnly = true,
			min       = minselect,
			max       = maxselect,
			start     = math.max(minselect, math.min(maxselect, curvalue or startvalue or minselect)),
			step      = step,
			suffix    = suffix,
			exceedMaxValue = false,
			hideMaxValue = param.hasinfinitevalue,
			useInfiniteValue = useinfinite,
			infiniteValue = infinitevalue,
			useTimeFormat = usetimeformat,
		}

		local row = ftable:addRow({ "failure", failureidx, paramidx, listidx }, { interactive = false })
		if selectedorder and (selectedorder[1] == "failure") and (selectedorder[2] == failureidx) and (selectedorder[3] == paramidx) and (selectedorder[4] == listidx) then
			menu.selectedRows["infotable" .. instance] = row.index
			menu.selectedCols["infotable" .. instance] = nil
		end
		row[menu.infoTableData[instance].hasloop and 4 or 2]:setColSpan(menu.infoTableData[instance].hasloop and 1 or 3)
		row[menu.infoTableData[instance].hasloop and 4 or 2]:createText(paramtext)
		row[5]:setColSpan(8):createSliderCell(slidercellProperties):setText("", { fontsize = config.mapFontSize })
	elseif param.type == "bool" then
		local row = ftable:addRow({ "failure", failureidx, paramidx, listidx }, { interactive = false })
		if selectedorder and (selectedorder[1] == "failure") and (selectedorder[2] == failureidx) and (selectedorder[3] == paramidx) and (selectedorder[4] == listidx) then
			menu.selectedRows["infotable" .. instance] = row.index
			menu.selectedCols["infotable" .. instance] = nil
		end
		row[menu.infoTableData[instance].hasloop and 4 or 2]:setColSpan(menu.infoTableData[instance].hasloop and 1 or 3):createText(paramtext)
		local rawvalue = param.value ~= 0
		if ismissing then
			rawvalue = false
		end
		row[5]:createCheckBox(rawvalue, { active = false, width = config.mapRowHeight })
	else
		local row = ftable:addRow({ "failure", failureidx, paramidx, listidx }, { interactive = false })
		if selectedorder and (selectedorder[1] == "failure") and (selectedorder[2] == failureidx) and (selectedorder[3] == paramidx) and (selectedorder[4] == listidx) then
			menu.selectedRows["infotable" .. instance] = row.index
			menu.selectedCols["infotable" .. instance] = nil
		end
		row[menu.infoTableData[instance].hasloop and 4 or 2]:setColSpan(menu.infoTableData[instance].hasloop and 1 or 3):createText(paramtext)
		row[5]:setColSpan(8)
		local text = value and tostring(value) or ""
		local height = math.max(config.mapRowHeight, math.ceil(C.GetTextHeight(text, Helper.standardFont, Helper.standardFontSize, row[5]:getWidth())) + Helper.borderSize)
		row[5]:createButton({ active = false, height = height }):setText(text, { halign = "center", y = (height - config.mapRowHeight) / 2 })
	end
end

function menu.copyDefaultOrderForPlanning(instance)
	if menu.isInfoModeValidFor(menu.infoSubmenuObject, "orderqueue") then
		C.CreateOrder(menu.infoSubmenuObject, menu.infoTableData[instance].defaultorder.orderdef, true)
		local buf = ffi.new("Order")
		if C.GetPlannedDefaultOrder(buf, menu.infoSubmenuObject) then
			menu.infoTableData[instance].planneddefaultorder.state = ffi.string(buf.state)
			menu.infoTableData[instance].planneddefaultorder.statename = ffi.string(buf.statename)
			menu.infoTableData[instance].planneddefaultorder.orderdef = ffi.string(buf.orderdef)
			menu.infoTableData[instance].planneddefaultorder.actualparams = tonumber(buf.actualparams)
			menu.infoTableData[instance].planneddefaultorder.enabled = buf.enabled
			menu.infoTablePersistentData[instance].planneddefaultorderiscopy = true

			local found = false
			for _, orderdef in ipairs(menu.orderdefs) do
				if (orderdef.id == menu.infoTableData[instance].planneddefaultorder.orderdef) then
					menu.infoTableData[instance].planneddefaultorder.orderdefref = orderdef
					found = true
					break
				end
			end
			if not found then
				DebugError("Planned default order of '" .. tostring(menu.infoSubmenuObject) .. "' is of unknown definition '" .. ffi.string(buf.orderdef) .. "' [Florian]")
			end
		end

		menu.closeContextMenu()
		menu.infoTablePersistentData[instance].orderqueuemode = { mode = "plandefaultorder", curobject = menu.infoSubmenuObject }
	else
		DebugError("menu.copyDefaultOrderForPlanning: function called with invalid object: " .. ffi.string(C.GetComponentName(menu.infoSubmenuObject)) .. " " .. tostring(menu.infoSubmenuObject))
	end

	CopyDefaultOrderParamsForPlanning(menu.infoSubmenuObject)
	menu.refreshInfoFrame()
end

function menu.createOrdersMenuHeader(frame, instance)
	-- sync with tab table in menu.createOrderQueue()
	local orderHeaderTable
	if instance == "left" then
		menu.orderHeaderTable = frame:addTable(#config.infoCategories + 1, { tabOrder = 1 })
		orderHeaderTable = menu.orderHeaderTable
	elseif instance == "right" then
		menu.orderHeaderTableRight = frame:addTable(#config.infoCategories + 1, { tabOrder = 1 })
		orderHeaderTable = menu.orderHeaderTableRight
	end

	local count = 0
	for i, entry in ipairs(config.infoCategories) do
		if entry.empty then
			count = count + 0.5
		else
			count = count + 1
		end
	end

	local sideBarWidth = menu.sideBarWidth
	if (count * menu.sideBarWidth + (#config.infoCategories - 1) * Helper.borderSize) > frame.properties.width then
		sideBarWidth = math.floor((frame.properties.width - (#config.infoCategories - 1) * Helper.borderSize) / count)
	end

	for i, entry in ipairs(config.infoCategories) do
		if entry.empty then
			orderHeaderTable:setColWidth(i, sideBarWidth / 2, false)
		else
			orderHeaderTable:setColWidth(i, sideBarWidth, false)
		end
	end

	local row = orderHeaderTable:addRow("orders_tabs", { fixed = true })
	local count = 1
	for _, entry in ipairs(config.infoCategories) do
		if not entry.empty then
			local bgcolor = Color["row_title_background"]
			local color = Color["icon_normal"]
			if entry.category == menu.infoMode[instance] then
				bgcolor = Color["row_background_selected"]
			end

			local shown = true
			if entry.category == "orderqueue_advanced" then
				if C.IsMasterVersion() and (C.GetConfigSetting("advancedorderqueue") <= 0) then
					shown = false
				end
			end

			if shown then
				local loccount = count
				row[loccount]:createButton({ active = menu.isInfoModeValidFor(menu.infoSubmenuObject, entry.category), height = sideBarWidth, bgColor = bgcolor, mouseOverText = entry.name, scaling = false, helpOverlayID = entry.helpOverlayID, helpOverlayText = entry.helpOverlayText }):setIcon(entry.icon, { color = color})
				row[loccount].handlers.onClick = function () return menu.buttonInfoSubMode(entry.category, loccount, instance) end
				count = count + 1
			end
		else
			count = count + 1
		end
	end

	if menu.selectedRows["orderHeaderTable" .. instance] then
		orderHeaderTable.properties.defaultInteractiveObject = true
		orderHeaderTable:setSelectedRow(menu.selectedRows["orderHeaderTable" .. instance])
		if menu.isInfoModeValidFor(menu.infoSubmenuObject, menu.infoMode[instance]) then
			orderHeaderTable:setSelectedCol(menu.selectedCols["orderHeaderTable" .. instance] or 0)
		end
		menu.selectedRows["orderHeaderTable" .. instance] = nil
		menu.selectedCols["orderHeaderTable" .. instance] = nil
	end

	return orderHeaderTable
end

function menu.createResponsesForControllable(ftable, controllable, textproperties, mode, yoffset, instance)
	local selectedorder = menu.infoTablePersistentData[instance].selectedorder

	local isvalid = menu.isInfoModeValidFor(controllable, "standingorders")
	local faction, primarypurpose = GetComponentData(controllable, "owner", "primarypurpose")
	if C.IsComponentClass(controllable, "ship") then
		local row = ftable:addRow(false, { bgColor = Color["row_title_background"] })
		row[1]:setColSpan(8):createText(ReadText(1001, 8362), Helper.headerRowCenteredProperties)

		for _, signalentry in ipairs(menu.signals) do
			local signalid = signalentry.id
			local defask = false
			local defresponse = ""
			local deffactresponse = ""
			local hasownresponse = false
			if isvalid then
				defask = C.GetAskToSignalForControllable(signalid, controllable)
				defresponse = ffi.string(C.GetDefaultResponseToSignalForControllable(signalid, controllable))
				deffactresponse = ffi.string(C.GetDefaultResponseToSignalForFaction2(signalid, faction, primarypurpose))
				hasownresponse = C.HasControllableOwnResponse(controllable, signalid)
			end
			local deffactresponsename = ""

			local locresponses = {}
			for _, responseentry in ipairs(signalentry.responses) do
				if responseentry.id == deffactresponse then
					deffactresponsename = responseentry.name
					break
				end
			end
			for _, responseentry in ipairs(signalentry.responses) do
				table.insert(locresponses, { id = responseentry.id, text = responseentry.name, text2 = (deffactresponse ~= responseentry.id) and ("[" .. ReadText(1001, 8366) .. ReadText(1001, 120) .. " " .. deffactresponsename .. "]") or "", icon = "", displayremoveoption = false })
			end
			--table.insert(locresponses, { id = "reset", text = ReadText(1001, 9311), icon = "", displayremoveoption = false })	-- Reset standing orders of this ship for this scenario

			row = ftable:addRow(false, {  })
			row[1]:setColSpan(8):createText(ReadText(1001, 9321) .. " " .. tostring(signalentry.name) .. ReadText(1001, 120), textproperties)	-- Default response to, :

			local rowdata = "orders_" .. tostring(signalid) .. "_global"
			row = ftable:addRow({ rowdata }, {  })
			if selectedorder and (selectedorder[1] == rowdata) then
				menu.setrow = row.index
				menu.setcol = nil
			end
			row[1]:createCheckBox(not hasownresponse, { width = config.mapRowHeight, height = config.mapRowHeight, active = isvalid })
			row[1].handlers.onClick = function(_, checked) return menu.checkboxOrdersSetOverride(controllable, signalid, mode, checked) end
			row[2]:setColSpan(7):createText(ReadText(1001, 8367), textproperties)

			local rowdata = "orders_" .. tostring(signalid) .. "_response"
			row = ftable:addRow({ rowdata }, {  })
			if selectedorder and (selectedorder[1] == rowdata) then
				menu.setrow = row.index
				menu.setcol = nil
			end
			row[1]:setColSpan(8):createDropDown(locresponses, { height = config.mapRowHeight, startOption = defresponse, active = isvalid and hasownresponse }):setTextProperties({fontsize = config.mapFontSize}):setText2Properties({ fontsize = config.mapFontSize, halign = "right" })
			row[1].handlers.onDropDownConfirmed = function(_, newresponseid) return menu.dropdownOrdersSetResponse(_, newresponseid, controllable, signalid, mode) end
			row[1].handlers.onDropDownActivated = function () menu.noupdate = true end

			local rowdata = "orders_" .. tostring(signalid) .. "_ask"
			row = ftable:addRow({ rowdata }, {  })
			if selectedorder and (selectedorder[1] == rowdata) then
				menu.setrow = row.index
				menu.setcol = nil
			end
			row[1]:createCheckBox(defask, { width = config.mapRowHeight, height = config.mapRowHeight, active = isvalid and hasownresponse })
			row[1].handlers.onClick = function() return menu.checkboxOrdersSetAsk(controllable, signalid, mode) end
			row[2]:setColSpan(7):createText(ReadText(1001, 9330), textproperties)	-- Notify me if incident occurs
			row[2].properties.color = hasownresponse and Color["text_normal"] or Color["text_inactive"]

			ftable:addEmptyRow()
		end
	end

	if C.IsComponentClass(controllable, "ship") or C.IsComponentClass(controllable, "station") then
		-- resupply
		local row = ftable:addRow(false, { bgColor = Color["row_title_background"] })
		row[1]:setColSpan(8):createText(C.IsComponentClass(controllable, "ship") and ReadText(1001, 7722) or ReadText(1001, 7724), Helper.headerRowCenteredProperties)

		local curOption = Helper.round(C.GetDefensibleLoadoutLevel(controllable), 1)
		local hasownresponse = isvalid and (curOption ~= -1)
		local component = controllable
		while curOption == -1 do
			component = GetCommander(component)
			if component then
				curOption = Helper.round(C.GetDefensibleLoadoutLevel(ConvertIDTo64Bit(component)), 1)
			else
				curOption = Helper.round(C.GetPlayerGlobalLoadoutLevel(), 1)
				break
			end
		end

		local rowdata = "orders_resupply_global"
		local row = ftable:addRow({ rowdata }, {  })
		if selectedorder and (selectedorder[1] == rowdata) then
			menu.setrow = row.index
			menu.setcol = nil
		end
		row[1]:createCheckBox(not hasownresponse, { width = config.mapRowHeight, height = config.mapRowHeight, active = isvalid })
		row[1].handlers.onClick = function(_, checked) return menu.checkboxOrdersSetResupplyOverride(controllable, checked) end
		row[2]:setColSpan(7):createText(GetCommander(controllable) and ReadText(1001, 7723) or ReadText(1001, 8367), textproperties)

		local locresponses = {
			{ id = 0,   text = ReadText(1001, 7726), icon = "", displayremoveoption = false },
			{ id = 0.1, text = ReadText(1001, 7736), icon = "", displayremoveoption = false },
			{ id = 0.5, text = ReadText(1001, 7737), icon = "", displayremoveoption = false },
			{ id = 1.0, text = ReadText(1001, 7738), icon = "", displayremoveoption = false },
		}
		local row = ftable:addRow("orders_resupply", {})
		row[1]:setColSpan(8):createDropDown(locresponses, { height = Helper.standardTextHeight, startOption = curOption, active = isvalid and hasownresponse }):setTextProperties({ fontsize = config.mapFontSize })
		row[1].handlers.onDropDownConfirmed = function (_, id) return menu.dropdownOrdersResupply(controllable, id) end
		row[1].handlers.onDropDownActivated = function () menu.noupdate = true end

		ftable:addEmptyRow()

		-- blacklists
		local row = ftable:addRow(false, { bgColor = Color["row_title_background"] })
		row[1]:setColSpan(8):createText(C.IsComponentClass(controllable, "ship") and ReadText(1001, 9143) or ReadText(1001, 9178), Helper.headerRowCenteredProperties)

		local blacklists = Helper.getBlackLists()

		local purpose = GetComponentData(controllable, "primarypurpose")
		local group = ((purpose == "fight") or (purpose == "auxiliary")) and "military" or "civilian"
		local types = {
			{ type = "sectortravel",	name = ReadText(1001, 9165) },
			{ type = "sectoractivity",	name = ReadText(1001, 9166) },
			{ type = "objectactivity",	name = ReadText(1001, 9167) },
		}
		for i, entry in ipairs(types) do
			row = ftable:addRow(false, {  })
			row[1]:setColSpan(8):createText(entry.name .. ReadText(1001, 120), textproperties)

			local hasownlist = isvalid and C.HasControllableOwnBlacklist(controllable, entry.type)
			local blacklistid = C.GetControllableBlacklistID(controllable, entry.type, group)

			local rowdata = "orders_blacklist_" .. entry.type .. "_global"
			local row = ftable:addRow({ rowdata }, {  })
			if selectedorder and (selectedorder[1] == rowdata) then
				menu.setrow = row.index
				menu.setcol = nil
			end
			row[1]:createCheckBox(not hasownlist, { width = config.mapRowHeight, height = config.mapRowHeight, active = isvalid })
			row[1].handlers.onClick = function(_, checked) return menu.checkboxOrdersSetBlacklistOverride(controllable, entry.type, checked) end
			row[2]:setColSpan(7):createText(GetCommander(controllable) and ReadText(1001, 7723) or ReadText(1001, 8367), textproperties)

			local locresponses = {
				{ id = -1, text = ReadText(1001, 7726), icon = "", displayremoveoption = false },
			}
			for _, blacklist in ipairs(blacklists) do
				if blacklist.type == entry.type then
					table.insert(locresponses, { id = blacklist.id, text = blacklist.name, icon = "", displayremoveoption = false })
				end
			end
			local row = ftable:addRow("orders_resupply", {})
			row[1]:setColSpan(7):createDropDown(locresponses, { startOption = (blacklistid ~= 0) and blacklistid or -1, active = isvalid and hasownlist }):setTextProperties({ fontsize = config.mapFontSize })
			row[1].handlers.onDropDownConfirmed = function (_, id) return menu.dropdownOrdersBlacklist(controllable, entry.type, id) end
			row[1].handlers.onDropDownActivated = function () menu.noupdate = true end
			row[8]:createButton({ mouseOverText = ReadText(1026, 8413) }):setIcon("menu_edit")
			row[8].handlers.onClick = menu.buttonEditBlacklist

			ftable:addEmptyRow()
		end

		-- fight rules
		local row = ftable:addRow(false, { bgColor = Color["row_title_background"] })
		row[1]:setColSpan(8):createText(ReadText(1001, 7753), Helper.headerRowCenteredProperties)

		local fightrules = Helper.getFightRules()

		local hasownrule = isvalid and C.HasControllableOwnFightRule(controllable, "attack")
		local fightruleid = C.GetControllableFightRuleID(controllable, "attack")

		local rowdata = "orders_fightrule_attack_global"
		local row = ftable:addRow({ rowdata }, {  })
		if selectedorder and (selectedorder[1] == rowdata) then
			menu.setrow = row.index
			menu.setcol = nil
		end
		row[1]:createCheckBox(not hasownrule, { width = config.mapRowHeight, height = config.mapRowHeight, active = isvalid })
		row[1].handlers.onClick = function(_, checked) return menu.checkboxOrdersSetFightRuleOverride(controllable, "attack", checked) end
		row[2]:setColSpan(7):createText(GetCommander(controllable) and ReadText(1001, 7723) or ReadText(1001, 8367), textproperties)

		local locresponses = {
			{ id = -1, text = ReadText(1001, 7726), icon = "", displayremoveoption = false },
		}
		for _, fightrule in ipairs(fightrules) do
			table.insert(locresponses, { id = fightrule.id, text = fightrule.name, icon = "", displayremoveoption = false })
		end
		local row = ftable:addRow("orders_resupply", {})
		row[1]:setColSpan(7):createDropDown(locresponses, { startOption = (fightruleid ~= 0) and fightruleid or -1, active = isvalid and hasownrule }):setTextProperties({ fontsize = config.mapFontSize })
		row[1].handlers.onDropDownConfirmed = function (_, id) return menu.dropdownOrdersFightRule(controllable, "attack", id) end
		row[1].handlers.onDropDownActivated = function () menu.noupdate = true end
		row[8]:createButton({ mouseOverText = ReadText(1026, 8414) }):setIcon("menu_edit")
		row[8].handlers.onClick = menu.buttonEditFightRule
	end

	-- ship trade prices & restrictions
	if C.IsComponentClass(controllable, "ship") then
		ftable:addEmptyRow()

		-- trade loop cargo reservations
		local row = ftable:addRow(false, { bgColor = Color["row_title_background"] })
		row[1]:setColSpan(8):createText(ReadText(1001, 11642), Helper.headerRowCenteredProperties)

		local rowdata = "orders_cargoreservations_global"
		local row = ftable:addRow({ rowdata }, {  })
		if selectedorder and (selectedorder[1] == rowdata) then
			menu.setrow = row.index
			menu.setcol = nil
		end
		local hasownresponse = C.HasShipTradeLoopCargoReservationOverride(controllable)
		local curOption = C.GetShipTradeLoopCargoReservationSetting(controllable) and "on" or "off"
		row[1]:createCheckBox(not hasownresponse, { width = config.mapRowHeight, height = config.mapRowHeight, active = isvalid })
		row[1].handlers.onClick = function(_, checked) return menu.checkboxOrdersSetCargoReservations(controllable, checked) end
		row[2]:setColSpan(7):createText(ReadText(1001, 8367), textproperties)

		local locresponses = {
			{ id = "off",   text = ReadText(1001, 7726),  icon = "", displayremoveoption = false, mouseovertext = ReadText(1026, 3276) },
			{ id = "on",    text = ReadText(1001, 11643), icon = "", displayremoveoption = false },
		}
		local row = ftable:addRow("orders_cargoreservations", {  })
		row[1]:setColSpan(8):createDropDown(locresponses, { height = Helper.standardTextHeight, startOption = curOption, active = isvalid and hasownresponse }):setTextProperties({ fontsize = config.mapFontSize })
		row[1].handlers.onDropDownConfirmed = function (_, id) return menu.dropdownOrdersCargoReservations(controllable, id) end
		row[1].handlers.onDropDownActivated = function () menu.noupdate = true end

		if GetComponentData(controllable, "issupplyship") then
			ftable:addEmptyRow()

			-- preferred build method
			local row = ftable:addRow(false, { bgColor = Color["row_title_background"] })
			row[1]:setColSpan(8):createText(ReadText(1001, 11298), Helper.headerRowCenteredProperties)

			local cursetting = ffi.string(C.GetContainerBuildMethod(controllable))
			local curglobalsetting = ffi.string(C.GetPlayerBuildMethod())
			local foundcursetting = false
			local locresponses = {}
			local n = C.GetNumPlayerBuildMethods()
			if n > 0 then
				local buf = ffi.new("ProductionMethodInfo[?]", n)
				n = C.GetPlayerBuildMethods(buf, n)
				for i = 0, n - 1 do
					local id = ffi.string(buf[i].id)
					-- check if the curglobalsetting (which can be the method of the player's race) is in the list of options
					if id == curglobalsetting then
						foundcursetting = true
					end
					table.insert(locresponses, { id = id, text = ffi.string(buf[i].name), icon = "", displayremoveoption = false })
				end
			end
			-- if the setting is not in the list, default to default (if the race method is not in the list, there is no ware that has this method and it will always use default)
			if not foundcursetting then
				curglobalsetting = "default"
			end
			local hasownsetting = cursetting ~= ""

			local rowdata = "info_buildrule_global"
			local row = ftable:addRow({ rowdata }, {  })
			row[1]:createCheckBox(not hasownsetting, { width = config.mapRowHeight, height = config.mapRowHeight })
			row[1].handlers.onClick = function(_, checked) return menu.checkboxSetBuildRuleOverride(controllable, checked, curglobalsetting) end
			row[2]:setColSpan(7):createText(ReadText(1001, 8367))

			local row = ftable:addRow("info_buildrule", {  })
			row[1]:setColSpan(8):createDropDown(locresponses, { height = Helper.standardTextHeight, startOption = hasownsetting and cursetting or curglobalsetting, active = hasownsetting }):setTextProperties({ fontsize = config.mapFontSize })
			row[1].handlers.onDropDownConfirmed = function (_, id) return menu.dropdownBuildRule(controllable, id) end
			row[1].handlers.onDropDownActivated = function () menu.noupdate = true end

			ftable:addEmptyRow()

			local row = ftable:addRow(false, { bgColor = Color["row_title_background"] })
			row[1]:setColSpan(8):createText(ReadText(1001, 7725), Helper.headerRowCenteredProperties)

			-- trade rule
			local hasownlist = C.HasContainerOwnTradeRule(controllable, "buy", "") or C.HasContainerOwnTradeRule(controllable, "sell", "")
			local traderuleid = C.GetContainerTradeRuleID(controllable, "buy", "")
			if traderuleid ~= C.GetContainerTradeRuleID(controllable, "sell", "") then
				DebugError("menu.createResponsesForControllable(): Mismatch between buy and sell trade rule on supply ship: " .. tostring(traderuleid) .. " vs " .. tostring(C.GetContainerTradeRuleID(controllable, "sell", "")))
			end
			local row = ftable:addRow(nil, {  })
			row[1]:setColSpan(8):createText(ReadText(1001, 11013) .. ReadText(1001, 120), textproperties)
			-- global
			local row = ftable:addRow("order_wares_global", {  })
			row[1]:setColSpan(7):createText(ReadText(1001, 8367) .. ReadText(1001, 120), textproperties)
			row[8]:createCheckBox(not hasownlist, { height = config.mapRowHeight })
			row[8].handlers.onClick = function(_, checked) return menu.checkboxSetTradeRuleOverride(controllable, "trade", checked) end
			-- current
			local row = ftable:addRow("order_wares_current", {  })
			row[1]:setColSpan(7):createDropDown(Helper.traderuleOptions, { startOption = (traderuleid ~= 0) and traderuleid or -1, active = hasownlist }):setTextProperties({ fontsize = config.mapFontSize })
			row[1].handlers.onDropDownConfirmed = function (_, id) return menu.dropdownTradeRule(controllable, "trade", id, "", true) end
			row[1].handlers.onDropDownActivated = function () menu.noupdate = true end
			row[8]:createButton({ mouseOverText = ReadText(1026, 8407) }):setIcon("menu_edit")
			row[8].handlers.onClick = menu.buttonEditTradeRule

			local row = ftable:addRow(false, {})
			row[1]:setColSpan(8):createText("")

			local wares = {}
			local n = C.GetNumMaxProductionStorage(controllable)
			local buf = ffi.new("UIWareAmount[?]", n)
			n = C.GetMaxProductionStorage(buf, n, controllable)
			for i = 0, n - 1 do
				table.insert(wares, ffi.string(buf[i].wareid))
			end
			table.sort(wares, Helper.sortWareName)

			local reservations = {}
			local n = C.GetNumContainerWareReservations2(controllable, false, false, true)
			local buf = ffi.new("WareReservationInfo2[?]", n)
			n = C.GetContainerWareReservations2(buf, n, controllable, false, false, true)
			for i = 0, n - 1 do
				local ware = ffi.string(buf[i].ware)
				local buyflag = buf[i].isbuyreservation and "selloffer" or "buyoffer" -- sic! Reservation to buy -> container is selling
				local invbuyflag = buf[i].isbuyreservation and "buyoffer" or "selloffer"
				if reservations[ware] then
					table.insert(reservations[ware][buyflag], { reserver = buf[i].reserverid, amount = buf[i].amount, eta = buf[i].eta })
				else
					reservations[ware] = { [buyflag] = { { reserver = buf[i].reserverid, amount = buf[i].amount, eta = buf[i].eta } }, [invbuyflag] = {} }
				end
			end
			for _, data in pairs(reservations) do
				table.sort(data.buyoffer, menu.etaSorter)
				table.sort(data.selloffer, menu.etaSorter)
			end

			for _, ware in ipairs(wares) do
				local name, minprice, maxprice = GetWareData(ware, "name", "minprice", "maxprice")
				local isextended = menu.isOrderExtended(controllable, ware, instance)

				-- ware
				local rowdata = "orders_wares_" .. ware .. "_header"
				local row = ftable:addRow({ rowdata }, {  })
				if selectedorder and (selectedorder[1] == rowdata) then
					menu.setrow = row.index
					menu.setcol = nil
				end
				row[1]:createButton({  }):setText(isextended and "-" or "+", { halign = "center" })
				row[1].handlers.onClick = function () return menu.buttonExtendOrder(controllable, ware, instance, row.index, 1) end
				row[2]:setColSpan(5):createText(name)
				if (C.GetContainerTradeRuleID(controllable, "buy", ware) > 0) or (C.GetContainerTradeRuleID(controllable, "sell", ware) > 0) then
					row[7]:setColSpan(2):createText("\27[lso_error]", { halign = "right", color = Color["text_warning"] })
				end

				if isextended then
					-- trade rule
					local hasownlist = C.HasContainerOwnTradeRule(controllable, "buy", ware) or C.HasContainerOwnTradeRule(controllable, "sell", ware)
					local traderuleid = C.GetContainerTradeRuleID(controllable, "buy", ware)
					if traderuleid ~= C.GetContainerTradeRuleID(controllable, "sell", ware) then
						DebugError("menu.createResponsesForControllable(): Mismatch between buy and sell trade rule on supply ship: " .. tostring(traderuleid) .. " vs " .. tostring(C.GetContainerTradeRuleID(controllable, "sell", ware)))
					end
					local row = ftable:addRow(nil, {  })
					row[2]:setColSpan(7):createText(ReadText(1001, 11013) .. ReadText(1001, 120), textproperties)
					-- global
					local row = ftable:addRow("orders_wares_" .. ware .. "_tradeglobal", {  })
					row[2]:setColSpan(6):createText(ReadText(1001, 11031) .. ReadText(1001, 120), textproperties)
					row[8]:createCheckBox(not hasownlist, { height = config.mapRowHeight })
					row[8].handlers.onClick = function(_, checked) return menu.checkboxSetTradeRuleOverride(controllable, "trade", checked, ware) end
					-- current
					local row = ftable:addRow("orders_wares_" .. ware .. "_tradecurrent", {  })
					row[2]:setColSpan(6):createDropDown(Helper.traderuleOptions, { startOption = (traderuleid ~= 0) and traderuleid or -1, active = hasownlist }):setTextProperties({ fontsize = config.mapFontSize })
					row[2].handlers.onDropDownConfirmed = function (_, id) return menu.dropdownTradeRule(controllable, "trade", id, ware, true) end
					row[2].handlers.onDropDownActivated = function () menu.noupdate = true end
					row[8]:createButton({ mouseOverText = ReadText(1026, 8407) }):setIcon("menu_edit")
					row[8].handlers.onClick = menu.buttonEditTradeRule

					ftable:addEmptyRow(config.mapRowHeight / 2)

					local currentprice = math.max(minprice, math.min(maxprice, RoundTotalTradePrice(GetContainerWarePrice(controllable, ware, true))))
					local haspriceoverride = HasContainerWarePriceOverride(controllable, ware, true)
					-- automatic pricing
					local rowdata = "orders_wares_" .. ware .. "_autoprice"
					local row = ftable:addRow({ rowdata }, {  })
					if selectedorder and (selectedorder[1] == rowdata) then
						menu.setrow = row.index
						menu.setcol = nil
					end
					row[2]:setColSpan(6):createText(ReadText(1001, 8402) .. ReadText(1001, 120))
					row[8]:createCheckBox(not haspriceoverride, { height = config.mapRowHeight })
					row[8].handlers.onClick = function (_, checked) return menu.checkboxStorageWarePriceOverride(controllable, ware, true, currentprice, checked) end
					-- price
					local rowdata = "orders_wares_" .. ware .. "_price"
					local row = ftable:addRow({ rowdata }, {  })
					if selectedorder and (selectedorder[1] == rowdata) then
						menu.setrow = row.index
						menu.setcol = nil
					end
					row[2]:setColSpan(7):createSliderCell({
						height = Helper.standardTextHeight,
						valueColor = haspriceoverride and Color["slider_value"] or Color["slider_value_inactive"],
						min = minprice,
						max = maxprice,
						start = currentprice,
						hideMaxValue = true,
						suffix = ReadText(1001, 101),
						readOnly = not haspriceoverride,
					})
					row[2].handlers.onSliderCellChanged = function(_, value) return menu.slidercellStorageWarePriceOverride(controllable, ware, true, value) end
					-- reservations
					if reservations[ware] and (#reservations[ware].buyoffer > 0) then
						-- title
						local row = ftable:addRow(nil, {  })
						row[2]:setColSpan(7):createText(ReadText(1001, 7946) .. ReadText(1001, 120))
						for _, reservation in ipairs(reservations[ware].buyoffer) do
							local row = ftable:addRow(false, {  })
							local name = ffi.string(C.GetComponentName(reservation.reserver)) .. " (" .. ffi.string(C.GetObjectIDCode(reservation.reserver)) .. ")"
							row[2]:setColSpan(5):createText(function () return "   " .. Helper.getETAString(name, reservation.eta) end, { font = Helper.standardFontMono })
							row[7]:setColSpan(2):createText(ConvertIntegerString(reservation.amount, true, 0, false), { halign = "right" })
						end
					end
				end
			end
		end
	end
end

function menu.createOrderQueue(frame, mode, instance)
	local infoTableData = menu.infoTableData[instance]
	local selectedorder = menu.infoTablePersistentData[instance].selectedorder

	infoTableData.ships = menu.getShipList(true, true)
	if not menu.infoSubmenuObject then
		for id, _ in pairs(menu.selectedcomponents) do
			local selectedcomponent = ConvertStringTo64Bit(id)
			if GetComponentData(selectedcomponent, "isplayerowned") and C.IsComponentClass(selectedcomponent, "ship") then
				menu.infoSubmenuObject = selectedcomponent
				break
			end
		end
		if not menu.infoSubmenuObject then
			if #infoTableData.ships > 0 then
				menu.infoSubmenuObject = ConvertIDTo64Bit(infoTableData.ships[1].shipid)
			else
				menu.infoSubmenuObject = 0
			end
		end
	end

	if menu.infoTablePersistentData[instance].planneddefaultorderloop and (menu.infoTablePersistentData[instance].planneddefaultorderloop.curobject ~= menu.infoSubmenuObject) then
		menu.infoTablePersistentData[instance].planneddefaultorderloop = nil
	end
	if menu.infoTablePersistentData[instance].orderqueuemode and (menu.infoTablePersistentData[instance].orderqueuemode.curobject ~= menu.infoSubmenuObject) then
		C.RemovePlannedDefaultOrder(menu.infoTablePersistentData[instance].orderqueuemode.curobject)
		menu.infoTablePersistentData[instance].planneddefaultorderiscopy = nil
		menu.infoTablePersistentData[instance].orderqueuemode = nil
	end

	-- Current orders
	infoTableData.orders = {}
	infoTableData.defaultorder = {}
	infoTableData.planneddefaultorder = {}

	if menu.isInfoModeValidFor(menu.infoSubmenuObject, mode) then
		local n = C.GetNumOrders(menu.infoSubmenuObject)
		local buf = ffi.new("Order2[?]", n)
		n = C.GetOrders2(buf, n, menu.infoSubmenuObject)
		for i = 0, n - 1 do
			local entry = {}
			entry.state = ffi.string(buf[i].state)
			entry.statename = ffi.string(buf[i].statename)
			entry.orderdef = ffi.string(buf[i].orderdef)
			entry.actualparams = tonumber(buf[i].actualparams)
			entry.enabled = buf[i].enabled
			entry.isinfinite = buf[i].isinfinite
			entry.isoverride = buf[i].isoverride
			entry.istemporder = buf[i].istemporder
			table.insert(infoTableData.orders, entry)
		end

		local buf = ffi.new("Order")
		if C.GetDefaultOrder(buf, menu.infoSubmenuObject) then
			infoTableData.defaultorder.state = ffi.string(buf.state)
			infoTableData.defaultorder.statename = ffi.string(buf.statename)
			infoTableData.defaultorder.orderdef = ffi.string(buf.orderdef)
			infoTableData.defaultorder.actualparams = tonumber(buf.actualparams)
			infoTableData.defaultorder.enabled = buf.enabled

			local found = false
			for _, orderdef in ipairs(menu.orderdefs) do
				if (orderdef.id == infoTableData.defaultorder.orderdef) then
					infoTableData.defaultorder.orderdefref = orderdef
					found = true
					break
				end
			end
			if not found then
				DebugError("Default order of '" .. tostring(menu.infoSubmenuObject) .. "' is of unknown definition '" .. ffi.string(buf.orderdef) .. "' [Florian]")
			end
		end

		local buf = ffi.new("Order")
		if C.GetPlannedDefaultOrder(buf, menu.infoSubmenuObject) then
			infoTableData.planneddefaultorder.state = ffi.string(buf.state)
			infoTableData.planneddefaultorder.statename = ffi.string(buf.statename)
			infoTableData.planneddefaultorder.orderdef = ffi.string(buf.orderdef)
			infoTableData.planneddefaultorder.actualparams = tonumber(buf.actualparams)
			infoTableData.planneddefaultorder.enabled = buf.enabled

			local found = false
			for _, orderdef in ipairs(menu.orderdefs) do
				if (orderdef.id == infoTableData.planneddefaultorder.orderdef) then
					infoTableData.planneddefaultorder.orderdefref = orderdef
					found = true
					break
				end
			end
			if not found then
				DebugError("Planned default order of '" .. tostring(menu.infoSubmenuObject) .. "' is of unknown definition '" .. ffi.string(buf.orderdef) .. "' [Florian]")
			end
		elseif (not menu.infoTablePersistentData[instance].planneddefaultorderloop) and menu.infoTablePersistentData[instance].orderqueuemode and (menu.infoTablePersistentData[instance].orderqueuemode.mode == "plandefaultorder") then
			menu.infoTablePersistentData[instance].planneddefaultorderiscopy = nil
			menu.infoTablePersistentData[instance].orderqueuemode = nil
		end

		infoTableData.commander = GetCommander(menu.infoSubmenuObject)

		local hasloop = ffi.new("bool[1]", 0)
		C.GetOrderQueueFirstLoopIdx(menu.infoSubmenuObject, hasloop)
		infoTableData.hasloop = hasloop[0]
		infoTableData.currentIdx = tonumber(C.GetOrderQueueCurrentIdx(menu.infoSubmenuObject))
	end

	if not selectedorder then
		menu.setcol = nil
	else
		if selectedorder.object ~= menu.infoSubmenuObject then
			selectedorder = nil
			menu.setrow = nil
			menu.setcol = nil
			menu.topRows["infotable" .. instance] = nil
			menu.selectedRows["infotable" .. instance] = nil
			menu.selectedCols["infotable" .. instance] = nil
		end
	end

	local numcols = 12
	local ftable = frame:addTable(numcols, { tabOrder = 1 })
	ftable:setColWidth(1, Helper.standardTextHeight)
	ftable:setColWidth(2, Helper.standardTextHeight)
	ftable:setColWidth(3, 2 * Helper.standardTextHeight)
	ftable:setColWidth(4, frame.properties.width / 3 - 4 * Helper.scaleY(Helper.standardTextHeight) - 3 * Helper.borderSize, false)
	ftable:setColWidth(5, Helper.standardTextHeight)
	ftable:setColWidth(6, Helper.standardTextHeight)
	ftable:setColWidth(7, frame.properties.width / 3 - 2 * Helper.scaleY(Helper.standardTextHeight) - Helper.borderSize, false)
	ftable:setColWidth(9, Helper.standardTextHeight)
	ftable:setColWidth(10, Helper.standardTextHeight)
	ftable:setColWidth(11, Helper.standardTextHeight)
	ftable:setColWidth(12, Helper.standardTextHeight)

	ftable:setDefaultCellProperties("button", { height = config.mapRowHeight })
	ftable:setDefaultBackgroundColSpan(1, 10)
	ftable:setDefaultColSpan(5, 3)

	-- isvalid == controllable.isclass.ship and controllable.isplayerowned
	local isvalid = menu.isInfoModeValidFor(menu.infoSubmenuObject, mode)
	local playeroccupiedship64 = C.GetPlayerOccupiedShipID()
	local isplayeroccupiedship = menu.infoSubmenuObject == playeroccupiedship64

	local color = Color["text_normal"]
	local isplayerowned, isonlineobject, isenemy, ishostile = GetComponentData(menu.infoSubmenuObject, "isplayerowned", "isonlineobject", "isenemy", "ishostile")
	if isplayerowned then
		color = menu.holomapcolor.playercolor
		if menu.infoSubmenuObject == C.GetPlayerObjectID() then
			color = menu.holomapcolor.currentplayershipcolor
		end
	elseif isonlineobject and menu.getFilterOption("layer_other", false) and menu.getFilterOption("think_diplomacy_highlightvisitor", false) then
		color = menu.holomapcolor.visitorcolor
	elseif ishostile then
		color = menu.holomapcolor.hostilecolor
	elseif isenemy then
		color = menu.holomapcolor.enemycolor
	end

	--- title ---
	local row = ftable:addRow(false, { fixed = true, bgColor = Color["row_title_background"] })
	row[1]:setColSpan(numcols):createText(ReadText(1001, 2427), Helper.headerRowCenteredProperties)
	local row = ftable:addRow(false, { fixed = true, bgColor = Color["row_title_background"] })
	row[1]:setColSpan(numcols):createText((mode == "orderqueue") and ReadText(1001, 8360) or ReadText(1001, 8361), Helper.headerRowCenteredProperties)
	--- name ---
	local row = ftable:addRow({ "info_focus" }, { fixed = true, bgColor = Color["row_title_background"] })
	row[numcols]:createButton({ height = Helper.headerRow1Height, width = config.mapRowHeight, cellBGColor = Color["row_background"] }):setIcon("menu_center_selection", { width = Helper.standardTextHeight, height = Helper.standardTextHeight, y = (Helper.headerRow1Height - Helper.standardTextHeight) / 2 })
	row[numcols].handlers.onClick = function () return C.SetFocusMapComponent(menu.holomap, menu.infoSubmenuObject, true) end
	if C.IsComponentClass(menu.infoSubmenuObject, "object") then
		row[1]:setBackgroundColSpan(numcols - 1):setColSpan(7):createText(ffi.string(C.GetComponentName(menu.infoSubmenuObject)), Helper.headerRow1Properties)
		row[1].properties.color = color
		row[8]:setColSpan(4):createText(ffi.string(C.GetObjectIDCode(menu.infoSubmenuObject)), Helper.headerRow1Properties)
		row[8].properties.color = color
		row[8].properties.halign = "right"
	else
		row[1]:setBackgroundColSpan(numcols - 1):setColSpan(numcols - 1):createText(ffi.string(C.GetComponentName(menu.infoSubmenuObject)), Helper.headerRow1Properties)
		row[1].properties.color = color
	end

	local maxvisibleheight

	if C.IsComponentClass(menu.infoSubmenuObject, "ship") then
		---- pilot info ----
		local pilot, formation, isplayerowned = GetComponentData(menu.infoSubmenuObject, "assignedpilot", "formation", "isplayerowned")
		local pilot64 = ConvertIDTo64Bit(pilot)
		local isplayer = pilot64 == C.GetPlayerID()
		local commandername, commandercolor = "-", Color["text_normal"]
		if infoTableData.commander then
			commandername, commandercolor = menu.getContainerNameAndColors(infoTableData.commander, 0, false, false)
		end
		if isvalid and isplayerowned then
			local name, postname, aicommandstack, aicommand, aicommandparam, aicommandaction, aicommandactionparam = "-", ReadText(1001, 4847), {}
			if pilot and IsValidComponent(pilot) then
				name, postname, aicommandstack, aicommand, aicommandparam, aicommandaction, aicommandactionparam = GetComponentData(pilot, "name", "postname", "aicommandstack", "aicommand", "aicommandparam", "aicommandaction", "aicommandactionparam")
			end
			--- name ---
			local row = ftable:addRow(false, { bgColor = Color["row_background_unselectable"] })
			row[1]:setColSpan(4):createText(postname .. ReadText(1001, 120))
			row[5]:setColSpan(8):createText(name)
			--- skills ---
			local adjustedskill = pilot and math.floor(C.GetEntityCombinedSkill(pilot64, nil, isplayer and "playerpilot" or "aipilot") * 15 / 100) or 0
			local row = ftable:addRow(false, { bgColor = Color["row_background_unselectable"] })
			row[1]:setColSpan(4):createText(ReadText(1001, 9124) .. ReadText(1001, 120), { mouseOverText = ReadText(1026, 2) })
			row[5]:setColSpan(8):createText(pilot and Helper.displaySkill(adjustedskill) or "-", { color = pilot and Color["text_skills"] or nil, mouseOverText = ReadText(1026, 2) })
			--- commander ---
			local row = ftable:addRow({ infoTableData.commander }, {  })
			row[1]:setColSpan(4):createText(ReadText(1001, 1112) .. ReadText(1001, 120))
			if infoTableData.commander then
				row[5]:setColSpan(7):createText(commandername, { color = commandercolor })
				row[12]:createButton():setIcon("menu_center_selection", { width = Helper.standardTextHeight, height = Helper.standardTextHeight })
				row[12].handlers.onClick = function () return C.SetFocusMapComponent(menu.holomap, ConvertIDTo64Bit(infoTableData.commander), true) end
			else
				row[5]:setColSpan(8):createText(commandername, { color = commandercolor })
			end
			--- current ai command ---
			if pilot and IsValidComponent(pilot) then
				local row = ftable:addRow(false, { bgColor = Color["row_background_unselectable"] })
				row[1]:setColSpan(4):createText(ReadText(1001, 78) .. ReadText(1001, 120))
				local unlocked_operator_commands = IsInfoUnlockedForPlayer(menu.infoSubmenuObject, "operator_commands")
				if #aicommandstack > 0 then
					aicommand = aicommandstack[1].command
					aicommandparam = aicommandstack[1].param
				end
				row[5]:setColSpan(8):createText(Helper.unlockInfo(unlocked_operator_commands, string.format(aicommand, IsComponentClass(aicommandparam, "component") and GetComponentData(aicommandparam, "name") or nil)))
				local row = ftable:addRow(false, { bgColor = Color["row_background_unselectable"] })
				local numaicommands = #aicommandstack
				if numaicommands > 1 then
					aicommandaction = aicommandstack[numaicommands].command
					aicommandactionparam = aicommandstack[numaicommands].param
				end
				row[3]:setColSpan(8):createText(Helper.unlockInfo(unlocked_operator_commands, string.format(aicommandaction, IsComponentClass(aicommandactionparam, "component") and GetComponentData(aicommandactionparam, "name") or nil)))
			end
			--- subordinates ---
			local subordinates = GetSubordinates(menu.infoSubmenuObject, nil, true)
			local row = ftable:addRow(false, { bgColor = Color["row_background_unselectable"] })
			row[1]:setColSpan(4):createText(ReadText(1001, 1503) .. ReadText(1001, 120))
			row[5]:setColSpan(8):createText(#subordinates)
			--- formation ---
			local n = C.GetNumFormationShapes()
			local buf = ffi.new("UIFormationInfo[?]", n)
			n = C.GetFormationShapes(buf, n)
			local formationshapes = {}
			for i = 0, n - 1 do
				-- skill range from 0-5 -> 0-15
				table.insert(formationshapes, { name = ffi.string(buf[i].name), shape = ffi.string(buf[i].shape), requiredSkill = buf[i].requiredSkill * 3 })
			end
			table.sort(formationshapes, Helper.sortName)
			local formationOptions = {}
			for _, data in ipairs(formationshapes) do
				table.insert(formationOptions, { id = data.shape, text = data.name, text2 = Helper.displaySkill(data.requiredSkill), icon = "", displayremoveoption = false, active = data.requiredSkill <= adjustedskill })
			end
			local row = ftable:addRow({ "formation" }, {  })
			if selectedorder and (selectedorder[1] == "formation") then
				menu.selectedRows["infotable" .. instance] = row.index
				menu.selectedCols["infotable" .. instance] = nil
			end
			row[1]:setColSpan(4):createText(ReadText(1001, 8307) .. ReadText(1001, 120))
			row[5]:setColSpan(8):createDropDown(formationOptions, { height = config.mapRowHeight, startOption = formation, active = isvalid and (#subordinates > 0), textOverride = (#subordinates == 0) and ReadText(20223, 11) or nil }):setTextProperties({ fontsize = config.mapFontSize }):setText2Properties({ fontsize = config.mapFontSize, color = Color["text_skills"], halign = "right" })
			row[5].handlers.onDropDownConfirmed = menu.dropdownBehaviourFormation
			row[5].handlers.onDropDownActivated = function () menu.noupdate = true end
		end

		local row = ftable:addRow(false, {  })
		row[1]:setColSpan(numcols):createText(" ")

		---- actual order queue ----
		--- title ---
		local titlerow = ftable:addRow(false, { bgColor = Color["row_title_background"] })
		titlerow[1]:setColSpan(numcols):createText((infoTableData.hasloop and (utf8.char(8734) .. " ") or "") .. ((mode == "orderqueue") and ReadText(1001, 3225) or ReadText(1001, 8318)) .. (infoTableData.hasloop and (" [" .. ReadText(1001, 11270) .. "]") or ""), Helper.headerRowCenteredProperties)
		titlerow[1].properties.helpOverlayID = "map_orderqueue"
		titlerow[1].properties.helpOverlayText = " "
		titlerow[1].properties.helpOverlayHeight = titlerow:getHeight()
		titlerow[1].properties.helpOverlayHighlightOnly = true
		titlerow[1].properties.helpOverlayScaling = false

		menu.displayOrderFailureSection(ftable, instance)

		if infoTableData.hasloop then
			local row = ftable:addRow(false, { bgColor = Color["row_background_unselectable"] })
			if #infoTableData.orders > 0 then
				local nontempcounter = 0
				for _, order in ipairs(infoTableData.orders) do
					if not order.istemporder then
						nontempcounter = nontempcounter + 1
					end
				end
				row[1]:setColSpan(numcols):createText(string.format(ReadText(1001, 11271), nontempcounter) .. ReadText(1001, 120), { font = Helper.standardFontBold })
			else
				row[1]:setColSpan(numcols):createText(ReadText(1001, 11272), { font = Helper.standardFontBold })
			end
			titlerow[1].properties.helpOverlayHeight = titlerow[1].properties.helpOverlayHeight + row:getHeight() + Helper.borderSize
		end

		local row = ftable:addEmptyRow(1)
		titlerow[1].properties.helpOverlayHeight = titlerow[1].properties.helpOverlayHeight + row:getHeight() + Helper.borderSize

		if #infoTableData.orders > 15 then
			maxvisibleheight = ftable:getFullHeight() + 15 * (Helper.scaleY(config.mapRowHeight) + Helper.borderSize)
		end

		--- orders ---
		infoTableData.disabledmarker = nil
		local firstoverride = true
		local nontempcounter = 0
		for i, order in ipairs(infoTableData.orders) do
			local nextorder = infoTableData.orders[i + 1]
			if i == 1 and ((order.state == "setup") or (order.state == "disabled")) then
				infoTableData.disabledmarker = 1
			elseif (not infoTableData.disabledmarker) and ((nextorder and ((nextorder.state == "setup") or (nextorder.state == "disabled"))) or (i == #infoTableData.orders)) then
				infoTableData.disabledmarker = i + 1
			end
			-- red line
			if infoTableData.disabledmarker == i then
				if next(infoTableData.defaultorder) and (not infoTableData.hasloop) then
					local row = ftable:addRow(false, { bgColor = Color["row_background_unselectable"] })
					row[2]:setColSpan(numcols - 1):createText(ReadText(1001, 8320) .. ReadText(1001, 120) .. " " .. infoTableData.defaultorder.orderdefref.name, { font = Helper.standardFontBold })
				end

				local row = ftable:addRow(false, {  })
				row[1]:setColSpan(numcols):createText(ReadText(1001, 8319), { halign = "center", titleColor = Color["text_negative"] })
			end

			-- orderdef
			local found = false
			for _, orderdef in ipairs(menu.orderdefs) do
				if (orderdef.id == order.orderdef) then
					order.orderdefref = orderdef
					found = true
					break
				end
			end
			if not found then
				break
			end

			-- params
			order.params = GetOrderParams(menu.infoSubmenuObject, i)

			-- hasrequiredparams
			order.hasrequiredparams = false
			for _, param in ipairs(order.params) do
				if param.type ~= "internal" then
					order.hasrequiredparams = true
					break
				end
			end

			-- sync point
			order.syncPointInfo = ffi.new("SyncPointInfo2")
			order.hasSyncPoint = C.GetSyncPointInfo2(menu.infoSubmenuObject, i, order.syncPointInfo)

			local isextended = menu.isOrderExtended(menu.infoSubmenuObject, i, instance)

			-- sort out parameters for AdjustOrder()
			local oldidx, newupidx, newdownidx, enableup, enabledown
			oldidx = i
			if infoTableData.disabledmarker == i + 1 then
				newupidx = i - 1
				newdownidx = i
				enableup = true
				enabledown = false
			elseif infoTableData.disabledmarker == i then
				newupidx = i
				newdownidx = i + 1
				enableup = true
				enabledown = false
			else
				newupidx = i - 1
				newdownidx = i + 1
				enableup = order.enabled
				enabledown = order.enabled
			end

			-- state color
			local statecolor = "\27X"
			if order.state == "setup" then
				statecolor = ColorText["text_negative"]
			elseif order.state == "disabled" then
				statecolor = ColorText["text_warning"]
			end

			local row = ftable:addRow({ i }, {  })
			if selectedorder and (selectedorder[1] == i) then
				menu.selectedRows["infotable" .. instance] = row.index
			end
			-- loop indicator
			if infoTableData.hasloop then
				if i == infoTableData.currentIdx then
					row[1]:createIcon("widget_arrow_right_01", { height = config.mapRowHeight, width = config.mapRowHeight })
				end
			end
			-- extend
			row[infoTableData.hasloop and 2 or 1]:createButton({ active = order.hasrequiredparams }):setText(isextended and "-" or "+", { halign = "center" })
			row[infoTableData.hasloop and 2 or 1].handlers.onClick = function () return menu.buttonExtendOrder(menu.infoSubmenuObject, i, instance, row.index, infoTableData.hasloop and 2 or 1) end
			-- loop counter
			if infoTableData.hasloop then
				if not order.istemporder then
					nontempcounter = nontempcounter + 1
					row[3]:createText(nontempcounter, { halign = "right" })
				end
			end
			-- name
			local colspan = (firstoverride and order.isoverride) and 1 or 2
			if not infoTableData.hasloop then
				colspan = colspan + 2
			end
			local name = order.orderdefref.name
			local mouseovertext
			if order.isoverride then
				name = name .. " " .. ColorText["text_error"] .. "[" .. ReadText(1001, 11219) .. "]"
			elseif order.istemporder then
				name = name .. " " .. ColorText["text_inactive"] .. "[" .. ReadText(1001, 11283) .. "]"
				mouseovertext = ReadText(1026, 3261)
			end
			local id = C.GetOrderID(menu.infoSubmenuObject, i)
			local failure = infoTableData.looporderfailures[tostring(id)]
			if failure then
				menu.cachedOrderFailures[tostring(id)] = failure
			elseif (order.state ~= "started") and (order.state ~= "critical") then
				menu.cachedOrderFailures[tostring(id)] = nil
			end
			row[infoTableData.hasloop and 4 or 2]:setColSpan(colspan):createText((failure and (ColorText["text_warning"] .. "\27[warning]\27X ") or "") .. name, { x = infoTableData.hasloop and 0 or nil, mouseOverText = failure and (ColorText["text_warning"] .. failure.message) or mouseovertext })
			-- override
			if firstoverride and order.isoverride then
				local attacker
				if order.orderdefref.id == "Flee" then
					if order.params[6] and order.params[6].value then
						local value = ConvertIDTo64Bit(order.params[6].value)
						if value ~= 0 then
							attacker = value
						end
					end
				elseif order.orderdefref.id == "Attack" then
					if order.params[1] and order.params[1].value and (order.params[1].type == "object") and (order.params[1].value ~= 0) then
						attacker = order.params[1].value
					end
				elseif order.orderdefref.id == "Wait" then
					if order.params[5] and order.params[5].value then
						local value = ConvertIDTo64Bit(order.params[5].value)
						if value ~= 0 then
							attacker = value
						end
					end
				end

				local overrideOrderOptions = {}
				if order.orderdefref.id ~= "Attack" then
					table.insert(overrideOrderOptions, { id = "Attack", text = ReadText(1001, 11228), icon = "", displayremoveoption = false, mouseovertext = ReadText(1026, 3234), active = attacker ~= nil })
				end
				if order.orderdefref.id ~= "Flee" then
					table.insert(overrideOrderOptions, { id = "Flee", text = ReadText(1001, 11220), icon = "", displayremoveoption = false, mouseovertext = ReadText(1026, 3232), active = attacker ~= nil })
				end
				if order.orderdefref.id ~= "Wait" then
					table.insert(overrideOrderOptions, { id = "Wait", text = ReadText(1001, 11247), icon = "", displayremoveoption = false, mouseovertext = ReadText(1026, 3245), active = attacker ~= nil })
				end

				row[5]:createDropDown(overrideOrderOptions, { height = config.mapRowHeight, startOption = "", active = isvalid and (not isplayeroccupiedship), textOverride = ReadText(1001, 11248) }):setTextProperties({ fontsize = config.mapFontSize, halign = "center" })
				row[5].handlers.onDropDownConfirmed = function (_, id) return menu.dropdownChangeOverrideOrder(id, attacker, instance) end
				row[5].handlers.onDropDownActivated = function () menu.noupdate = true end

				firstoverride = false
			end
			-- state
			row[8]:createText(statecolor .. " [" .. order.statename .. "]", { halign = "right" })
			-- weapon config
			row[9]:createButton({ active = isvalid and not isplayeroccupiedship, mouseOverText = ReadText(1001, 1105) }):setText("*", { halign = "center" })
			row[9].handlers.onClick = function () return menu.buttonWeaponConfig(menu.infoSubmenuObject, i, false, instance) end
			-- up
			row[10]:createButton({ active = isvalid and (not isplayeroccupiedship) and C.AdjustOrder(menu.infoSubmenuObject, oldidx, newupidx, enableup, false, true), mouseOverText = ReadText(1026, 3264) .. "\n".. ffi.string(C.GetDisplayedModifierKey("ctrl")) .. " - " .. ReadText(1026, 3277) }):setIcon("table_arrow_inv_up")
			row[10].handlers.onClick = function (_, _, modified) return menu.buttonOrderUp(i, instance, modified) end
			row[10].properties.uiTriggerID = "moveorderup"
			-- down
			row[11]:createButton({ active = isvalid and (not isplayeroccupiedship) and C.AdjustOrder(menu.infoSubmenuObject, oldidx, newdownidx, enabledown, false, true), mouseOverText = ReadText(1026, 3265) .. "\n" .. ffi.string(C.GetDisplayedModifierKey("ctrl")) .. " - " .. ReadText(1026, 3278) }):setIcon("table_arrow_inv_down")
			row[11].handlers.onClick = function (_, _, modified) return menu.buttonOrderDown(i, instance, modified) end
			row[11].properties.uiTriggerID = "moveorderdown"
			-- remove
			row[12]:createButton({ active = C.RemoveOrder(menu.infoSubmenuObject, i, false, true), helpOverlayID = "map_ordercancel", helpOverlayText = " ", helpOverlayHighlightOnly = true, mouseOverText = ReadText(1026, 3263) }):setText("x", { halign = "center" })
			row[12].handlers.onClick = function () return menu.buttonRemoveOrder(i, instance) end
			row[12].properties.uiTriggerID = "deleteorder"
			titlerow[1].properties.helpOverlayHeight = titlerow[1].properties.helpOverlayHeight + row:getHeight() + Helper.borderSize

			if isextended then
				if failure then
					local row = ftable:addRow(nil, { bgColor = Color["row_background_unselectable"] })
					row[infoTableData.hasloop and 4 or 2]:setColSpan(infoTableData.hasloop and 9 or 11):createText("  " .. Helper.getPassedTime(failure.timestamp) .. " - " .. failure.message, { color = Color["text_warning"] })
				elseif menu.cachedOrderFailures[tostring(id)] then
					local row = ftable:addRow(nil, { bgColor = Color["row_background_unselectable"] })
					row[infoTableData.hasloop and 4 or 2]:setColSpan(infoTableData.hasloop and 9 or 11):createText("  " .. Helper.getPassedTime(menu.cachedOrderFailures[tostring(id)].timestamp) .. " - " .. menu.cachedOrderFailures[tostring(id)].message, { color = Color["text_warning"] })
				end
				for j, param in ipairs(order.params) do
					if (not param.advanced) or (mode == "orderqueue_advanced") then
						if param.type == "list" then
							local playerreadonly = param.inputparams and param.inputparams.playerreadonly
							if param.value then
								for k, entry in ipairs(param.value) do
									local param2 = { text = (k == 1) and param.text or "", value = entry, type = param.inputparams.type, editable = param.editable, playerreadonly = playerreadonly }
									menu.displayOrderParam(ftable, i, order, j, param2, k, instance)
								end
							end

							if playerreadonly ~= 1 then
								local row = ftable:addRow({ i, j, "new" }, {  })
								if selectedorder and (selectedorder[1] == i) and (selectedorder[2] == j) and (selectedorder[3] == "new") then
									menu.selectedRows["infotable" .. instance] = row.index
									menu.selectedCols["infotable" .. instance] = nil
								end
								local active = isvalid and (not isplayeroccupiedship) and (((order.state == "setup") and (j <= (order.actualparams + 1))) or ((order.state ~= "setup") and param.editable))
								row[2]:setColSpan(numcols - 1):createButton({ active = active }):setText("  " .. string.format(ReadText(1001, 3235), param.text), { halign = "center" })
								row[2].handlers.onClick = function () return menu.buttonSetOrderParam(i, j, nil, nil, instance) end
							end
						elseif (param.type ~= "internal") then
							menu.displayOrderParam(ftable, i, order, j, param, nil, instance)
						end
					end
				end
				-- sync point option
				if (not order.hasSyncPoint) or (order.syncPointInfo.owningcontrollable == 0) then
					if (order.orderdefref.id == "MoveWait") or (order.orderdefref.id == "Wait") or (order.orderdefref.id == "DockAndWait") then
						local syncPointOptions = { [1] = { id = 0, text = ReadText(1001, 3236), icon = "", displayremoveoption = false } }
						for i = 1, 10 do
							table.insert(syncPointOptions, { id = i, text = Helper.getSyncPointName(i), icon = "", displayremoveoption = false })
						end

						local row = ftable:addRow({ i, nil, "syncoption" }, {  })
						if selectedorder and (selectedorder[1] == i) and (selectedorder[3] == "syncoption") then
							menu.selectedRows["infotable" .. instance] = row.index
							menu.selectedCols["infotable" .. instance] = nil
						end
						row[2]:setColSpan(3):createText("  " .. ReadText(1001, 3237))
						row[5]:setColSpan(8):createDropDown(syncPointOptions, { height = config.mapRowHeight, startOption = order.syncPointInfo.id, active = isvalid and (not isplayeroccupiedship) and order.isinfinite }):setTextProperties({ fontsize = config.mapFontSize, halign = "center" })
						row[5].handlers.onDropDownConfirmed = function (_, id) return menu.dropdownNewSyncPoint(i, id) end
						row[5].handlers.onDropDownActivated = function () menu.noupdate = true end
					end
				end
			end

			-- sync point info
			if order.hasSyncPoint then
				local color = Color["text_failure"]
				if order.syncPointInfo.reached then
					color = Color["text_success"]
				end

				local row = ftable:addRow({ i, nil, "syncinfo" }, {  })
				if selectedorder and (selectedorder[1] == i) and (selectedorder[3] == "syncinfo") then
					menu.selectedRows["infotable" .. instance] = row.index
					menu.selectedCols["infotable" .. instance] = nil
				end

				local isextended = menu.isOrderExtended(menu.infoSubmenuObject, i .. "syncpoint", instance)
				row[infoTableData.hasloop and 2 or 1]:createButton({ active = order.hasrequiredparams }):setText(isextended and "-" or "+", { halign = "center" })
				row[infoTableData.hasloop and 2 or 1].handlers.onClick = function () return menu.buttonExtendOrder(menu.infoSubmenuObject, i .. "syncpoint", instance, row.index, infoTableData.hasloop and 2 or 1) end

				if order.syncPointInfo.id > 0 then
					row[infoTableData.hasloop and 3 or 2]:setColSpan(infoTableData.hasloop and 9 or 10):createText(ReadText(1001, 3237) .. ReadText(1001, 120) .. " " .. Helper.getSyncPointName(order.syncPointInfo.id), { titleColor = color })
					row[numcols]:createButton({ active = isvalid and not isplayeroccupiedship }):setText("x", { halign = "center" })
					row[numcols].handlers.onClick = function () return menu.buttonRemoveOrderSyncPoint(i, instance) end
				else
					row[infoTableData.hasloop and 3 or 2]:setColSpan(infoTableData.hasloop and 10 or 11):createText(ReadText(1001, 3237) .. ReadText(1001, 120) .. " " .. ffi.string(C.GetComponentName(order.syncPointInfo.owningcontrollable)) .. " (" .. ffi.string(C.GetObjectIDCode(order.syncPointInfo.owningcontrollable)) .. ")", { titleColor = color })
				end

				if isextended then
					local row = ftable:addRow({ i, nil, "syncpointreleasesetting" }, {  })
					if selectedorder and (selectedorder[1] == i) and (selectedorder[3] == "syncpointreleasesetting") then
						menu.selectedRows["infotable" .. instance] = row.index
						menu.selectedCols["infotable" .. instance] = nil
					end
					row[infoTableData.hasloop and 3 or 2]:setColSpan(infoTableData.hasloop and 9 or 10):createText("  " .. ReadText(1001, 11297) .. ReadText(1001, 120))
					if order.syncPointInfo.id > 0 then
						row[numcols]:createCheckBox(function () return C.GetSyncPointAutoRelease(order.syncPointInfo.id, true) end, { width = config.mapRowHeight, height = config.mapRowHeight })
						row[numcols].handlers.onClick = function(_, checked) return C.SetSyncPointAutoRelease(order.syncPointInfo.id, checked, false) end
					else
						row[numcols]:createCheckBox(function () return C.GetSyncPointAutoReleaseFromOrder(order.syncPointInfo.owningcontrollable, order.syncPointInfo.owningorderidx, true) end, { width = config.mapRowHeight, height = config.mapRowHeight })
						row[numcols].handlers.onClick = function(_, checked) return C.SetSyncPointAutoReleaseFromOrder(order.syncPointInfo.owningcontrollable, order.syncPointInfo.owningorderidx, checked, false) end
					end

					local totalobjects, reachedobjects
					if order.syncPointInfo.id > 0 then
						totalobjects = C.GetNumObjectsWithSyncPoint(order.syncPointInfo.id, false)
						reachedobjects = C.GetNumObjectsWithSyncPoint(order.syncPointInfo.id, true)
					else
						totalobjects = C.GetNumObjectsWithSyncPointFromOrder(order.syncPointInfo.owningcontrollable, order.syncPointInfo.owningorderidx, false)
						reachedobjects = C.GetNumObjectsWithSyncPointFromOrder(order.syncPointInfo.owningcontrollable, order.syncPointInfo.owningorderidx, true)
					end

					local row = ftable:addRow({ i, nil, "syncpointtrigger" }, {  })
					if selectedorder and (selectedorder[1] == i) and (selectedorder[3] == "syncpointtrigger") then
						menu.selectedRows["infotable" .. instance] = row.index
						menu.selectedCols["infotable" .. instance] = nil
					end
					row[infoTableData.hasloop and 3 or 2]:setColSpan(infoTableData.hasloop and 2 or 3):createText("  " .. string.format(ReadText(1001, 3229), reachedobjects, totalobjects))
					row[5]:setColSpan(8):createButton({ active = (reachedobjects > 0) }):setText(ReadText(1001, 8324), { halign = "center" })
					row[5].handlers.onClick = function () return menu.buttonReleaseSyncPoint(order.syncPointInfo) end
				end
			end
		end

		-- red line
		if (infoTableData.disabledmarker == nil) or (infoTableData.disabledmarker == (#infoTableData.orders + 1)) then
			if next(infoTableData.defaultorder) and (not infoTableData.hasloop) then
				local row = ftable:addRow(false, { bgColor = Color["row_background_unselectable"] })
				row[2]:setColSpan(numcols - 1):createText(ReadText(1001, 8320) .. ReadText(1001, 120) .. " " .. infoTableData.defaultorder.orderdefref.name, { font = Helper.standardFontBold })
			end

			local row = ftable:addRow(false, {  })
			row[1]:setColSpan(numcols):createText(ReadText(1001, 8319), { halign = "center", titleColor = Color["text_negative"] })
		end

		local hasstartableorders = false
		local hasremoveableorders = false
		for i, order in ipairs(infoTableData.orders) do
			if C.RemoveOrder(menu.infoSubmenuObject, i, false, true) then
				hasremoveableorders = true
			end
			if order.state == "disabled" then
				hasstartableorders = true
				break;
			end
			if order.state == "setup" then
				break;
			end
		end

		if mode == "orderqueue_advanced" then
			local row = ftable:addRow({ "neworder" }, {  })
			if selectedorder and (selectedorder[1] == "neworder") then
				menu.selectedRows["infotable" .. instance] = row.index
				menu.selectedCols["infotable" .. instance] = nil
			end
			row[1]:setColSpan(numcols):createButton({ active = isvalid and (not isplayeroccupiedship) and ((pilot64 ~= nil) and (pilot64 ~= 0)), mouseOverText = isplayeroccupiedship and ReadText(1026, 3224) or (((pilot64 == nil) or (pilot64 == 0)) and ReadText(1026, 3225) or "") }):setText(ReadText(1001, 3238), { halign = "center" })
			row[1].handlers.onClick = function () return menu.buttonNewOrder(nil, false, instance) end
		end

		local row = ftable:addRow({ "buttons" }, {  })
		if selectedorder and (selectedorder[1] == "buttons") then
			menu.selectedRows["infotable" .. instance] = row.index
		end
		row[1]:setColSpan(4):createButton({ active = isvalid and hasremoveableorders }):setText(ReadText(1001, 3239), { halign = "center" })
		row[1].handlers.onClick = function () return menu.buttonDeleteAllOrders(instance) end
		row[1].properties.uiTriggerID = "deleteallorders"
		row[8]:setColSpan(5):createButton({ active = isvalid and (not isplayeroccupiedship) and hasstartableorders }):setText(ReadText(1001, 3240), { halign = "center" })
		row[8].handlers.onClick = function () return menu.buttonStartOrders(instance) end
		row[8].properties.uiTriggerID = "startorderqueue"

		-- syncpoint overview
		local first = true
		for i = 1, 10 do
			local totalobjects = C.GetNumObjectsWithSyncPoint(i, false)
			local reachedobjects = C.GetNumObjectsWithSyncPoint(i, true)

			if totalobjects > 0 then
				if first then
					ftable:addEmptyRow(1)
					--- title ---
					local row = ftable:addRow(false, { bgColor = Color["row_title_background"] })
					row[1]:setColSpan(numcols):createText(ReadText(1001, 8323), Helper.headerRowCenteredProperties)
					first = false
				end
				local row = ftable:addRow({"sync", i}, {  })
				if selectedorder and (selectedorder[1] == "sync") and (selectedorder[2] == i) then
					menu.selectedRows["infotable" .. instance] = row.index
					menu.selectedCols["infotable" .. instance] = nil
				end
				row[1]:setColSpan(4):createText(Helper.getSyncPointName(i) .. " (" .. string.format(ReadText(1001, 3229), reachedobjects, totalobjects) .. ")")
				row[5]:setColSpan(8):createButton({ active = (reachedobjects > 0) }):setText(ReadText(1001, 8324), { halign = "center" })
				local syncpointinfo = { id = i }
				row[5].handlers.onClick = function () return menu.buttonReleaseSyncPoint(syncpointinfo) end

				local row = ftable:addRow({"syncrelease", i}, {  })
				if selectedorder and (selectedorder[1] == "syncrelease") and (selectedorder[2] == i) then
					menu.selectedRows["infotable" .. instance] = row.index
					menu.selectedCols["infotable" .. instance] = nil
				end
				row[3]:setColSpan(9):createText(ReadText(1001, 11297) .. ReadText(1001, 120))
				row[numcols]:createCheckBox(function () return C.GetSyncPointAutoRelease(i, true) end, { width = config.mapRowHeight, height = config.mapRowHeight })
				row[numcols].handlers.onClick = function(_, checked) return C.SetSyncPointAutoRelease(i, checked, false) end
			end
		end

		local row = ftable:addRow(false, {  })
		row[1]:setColSpan(numcols):createText(" ")

		---- assignment ----
		if infoTableData.commander and isvalid and (not isplayeroccupiedship) then
			--- title ---
			local row = ftable:addRow({ infoTableData.commander }, { bgColor = Color["row_title_background"] })
			row[1]:setColSpan(numcols - 1):createText(string.format(ReadText(1001, 7803), Helper.convertColorToText(commandercolor) .. commandername), Helper.headerRowCenteredProperties)
			row[numcols]:createButton({ height = Helper.headerRow1Height, width = config.mapRowHeight, cellBGColor = Color["row_background"] }):setIcon("menu_center_selection", { width = Helper.standardTextHeight, height = Helper.standardTextHeight, y = (Helper.headerRow1Height - Helper.standardTextHeight) / 2 })
			row[numcols].handlers.onClick = function () return C.SetFocusMapComponent(menu.holomap, ConvertIDTo64Bit(infoTableData.commander), true) end

			local row = ftable:addRow({ "assignment" }, {  })
			if selectedorder and (selectedorder[1] == "assignment") then
				menu.selectedRows["infotable" .. instance] = row.index
				menu.selectedCols["infotable" .. instance] = nil
			end
			row[1]:setColSpan(4):createText(ReadText(1001, 8373) .. ReadText(1001, 120))

			local isstation = IsComponentClass(infoTableData.commander, "station")
			local isship = IsComponentClass(infoTableData.commander, "ship")
			local shiptype = GetComponentData(infoTableData.commander, "shiptype")
			local currentassignment, primarypurpose = GetComponentData(menu.infoSubmenuObject, "assignment", "primarypurpose")
			local asssignmentOptions = {}
			-- defence
			table.insert(asssignmentOptions, { id = "defence", text = ReadText(20208, 40301), icon = "", displayremoveoption = false })
			-- supplyfleet
			if isship and (primarypurpose == "auxiliary") and GetComponentData(menu.infoSubmenuObject, "cansupplyships") then
				table.insert(asssignmentOptions, { id = "supplyfleet", text = ReadText(20208, 40701), icon = "", displayremoveoption = false })
			end
			if isstation then
				-- trade
				table.insert(asssignmentOptions, { id = "trade", text = ReadText(20208, 40101), icon = "", displayremoveoption = false, mouseovertext = (primarypurpose == "mine") and (ColorText["text_warning"] .. ReadText(1026, 8608)) or "" })
				if primarypurpose == "mine" then
					-- mining
					table.insert(asssignmentOptions, { id = "mining", text = ReadText(20208, 40201), icon = "", displayremoveoption = false })
				else
					-- trade for build storage
					table.insert(asssignmentOptions, { id = "tradeforbuildstorage", text = ReadText(20208, 40801), icon = "", displayremoveoption = false })
				end
				if primarypurpose == "salvage" then
					table.insert(asssignmentOptions, { id = "salvage", text = ReadText(20208, 41401), icon = "", displayremoveoption = false })
				end
			elseif isship then
				-- position defence
				local parentcommander = ConvertIDTo64Bit(GetCommander(infoTableData.commander))
				local subordinates = GetSubordinates(infoTableData.commander)
				local isfleetcommander = (not parentcommander) and (#subordinates > 0)
				if (shiptype == "carrier") and isfleetcommander then
					local hasintersectorgroup = C.HasSubordinateAssignment(ConvertIDTo64Bit(infoTableData.commander), "positiondefence")
					table.insert(asssignmentOptions, { id = "positiondefence", text = ReadText(20208, 41501), icon = "", displayremoveoption = false, active = hasintersectorgroup, mouseovertext = hasintersectorgroup and "" or ReadText(1026, 3270) })
				end
				-- attack and intercept
				table.insert(asssignmentOptions, { id = "attack", text = ReadText(20208, 40901), icon = "", displayremoveoption = false })
				table.insert(asssignmentOptions, { id = "interception", text = ReadText(20208, 41001), icon = "", displayremoveoption = false })
				table.insert(asssignmentOptions, { id = "bombardment", text = ReadText(20208, 41601), icon = "", displayremoveoption = false })
				table.insert(asssignmentOptions, { id = "follow", text = ReadText(20208, 41301), icon = "", displayremoveoption = false })
				local active = true
				local mouseovertext = ""
				local buf = ffi.new("Order")
				if not C.GetDefaultOrder(buf, ConvertIDTo64Bit(infoTableData.commander)) then
					active = false
					mouseovertext = ReadText(1026, 8606)
				end
				table.insert(asssignmentOptions, { id = "assist", text = ReadText(20208, 41201), icon = "", displayremoveoption = false, active = active, mouseovertext = mouseovertext })
				
				-- start: aegs call-back
				if callbacks ["map_ship_assignments_insert"] then
					local data_o
					for _, callback in ipairs (callbacks ["map_ship_assignments_insert"]) do
						data_o = callback (GetComponentData(infoTableData.commander, "macro"),primarypurpose)
						if data_o then
							table.insert(asssignmentOptions, data_o)
						end
					end
				end
				-- end: aegs call-back

				-- trade
				if shiptype == "resupplier" then
					table.insert(asssignmentOptions, { id = "trade", text = ReadText(20208, 40101), icon = "", displayremoveoption = false })
				end
			end

			row[5]:setColSpan(8):createDropDown(asssignmentOptions, { height = config.mapRowHeight, startOption = currentassignment }):setTextProperties({ fontsize = config.mapFontSize, halign = "center" })
			row[5].handlers.onDropDownConfirmed = function(_, newassignment) Helper.dropdownAssignment(_, menu.infoSubmenuObject, nil, nil, newassignment) end
			row[5].handlers.onDropDownActivated = function () menu.noupdate = true end

			local row = ftable:addRow({ "removeassignment" }, {  })
			if selectedorder and (selectedorder[1] == "removeassignment") then
				menu.selectedRows["infotable" .. instance] = row.index
				menu.selectedCols["infotable" .. instance] = nil
			end
			row[1]:setColSpan(numcols):createButton({ active = true }):setText(ReadText(1001, 7810), { halign = "center" })
			row[1].handlers.onClick = menu.buttonRemoveAssignment

			local row = ftable:addRow(false, {  })
			row[1]:setColSpan(numcols):createText(" ")
		end

		---- default order ----
		local hasloop = infoTableData.hasloop or menu.infoTablePersistentData[instance].planneddefaultorderloop

		--- title ---
		local titlerow = ftable:addRow(false, { bgColor = Color["row_title_background"] })
		titlerow[1]:setColSpan(numcols):createText((hasloop and (utf8.char(8734) .. " ") or "") .. ReadText(1001, 8320), Helper.headerRowCenteredProperties)
		titlerow[1].properties.helpOverlayID = "map_defaultorder"
		titlerow[1].properties.helpOverlayText = " "
		titlerow[1].properties.helpOverlayHeight = titlerow:getHeight()
		titlerow[1].properties.helpOverlayHighlightOnly = true
		titlerow[1].properties.helpOverlayScaling = false

		if menu.infoTablePersistentData[instance].orderqueuemode and (menu.infoTablePersistentData[instance].orderqueuemode.mode == "plandefaultorder") then
			menu.displayPlannedDefaultBehaviour(ftable, mode, titlerow, instance)
		else
			menu.displayDefaultBehaviour(ftable, mode, titlerow, instance)
		end
	else
		local row = ftable:addRow(nil, {  })
		row[1]:setColSpan(numcols):createText(ReadText(1001, 11226), { wordwrap = true })
	end

	if maxvisibleheight then
		ftable.properties.maxVisibleHeight = maxvisibleheight
	end

	if menu.selectedRows["infotable" .. instance] then
		ftable:setSelectedRow(menu.selectedRows["infotable" .. instance])
		menu.selectedRows["infotable" .. instance] = nil
		if menu.selectedCols["infotable" .. instance] then
			ftable:setSelectedCol(menu.selectedCols["infotable" .. instance])
			menu.selectedCols["infotable" .. instance] = nil
		end
	end
	if menu.topRows["infotable" .. instance] then
		ftable:setTopRow(menu.topRows["infotable" .. instance])
		menu.topRows["infotable" .. instance] = nil
	end
	menu.setrow = nil
	menu.settoprow = nil
	menu.setcol = nil

	--- tabs ---
	local tabtable = menu.createOrdersMenuHeader(frame, instance)

	ftable.properties.y = tabtable.properties.y + tabtable:getVisibleHeight() + Helper.borderSize

	tabtable:addConnection(1, (instance == "left") and 2 or 3, true)
	ftable:addConnection(2, (instance == "left") and 2 or 3)
end

function menu.displayOrderFailureSection(ftable, instance)
	local infoTableData = menu.infoTableData[instance]
	local selectedorder = menu.infoTablePersistentData[instance].selectedorder
	infoTableData.looporderfailures = {}

	local numcols = 12
	local found = false
	local n = C.GetNumOrderFailures(menu.infoSubmenuObject, infoTableData.hasloop == true)
	if n > 0 then
		local buf = ffi.new("OrderFailure[?]", n)
		n = C.GetOrderFailures(buf, n, menu.infoSubmenuObject, infoTableData.hasloop == true)
		for i = 0, n - 1 do
			local failure = buf[i]

			if failure.wasinloop then
				local entry = {}
				entry.message = ffi.string(failure.message)
				entry.timestamp = failure.timestamp
				infoTableData.looporderfailures[tostring(buf[i].orderid)] = entry
			else
				if not found then
					found = true
					-- failed behaviour
					local row = ftable:addRow(nil, { bgColor = Color["row_title_background"] })
					row[1]:setColSpan(numcols):createText(ReadText(1001, 11621), Helper.subHeaderTextProperties)
				end

				local orderdefid = ffi.string(failure.orderdef)
				local orderfailuredef
				local found = false
				for _, orderdef in ipairs(menu.orderdefs) do
					if orderdef.id == orderdefid then
						orderfailuredef = orderdef
						found = true
						break
					end
				end
				if not found then
					DebugError("Order failure of '" .. tostring(menu.infoSubmenuObject) .. "' is of unknown definition '" .. orderdefid .. "' [Florian]")
				end

				local isextended = menu.isOrderExtended(menu.infoSubmenuObject, i .. "failure", instance, true)
				local message = ffi.string(failure.message)
				-- name
				local row = ftable:addRow({ "failure", i }, {  })
				if selectedorder and (selectedorder[1] == "failure") and (selectedorder[2] == i) then
					menu.selectedRows["infotable" .. instance] = row.index
					menu.selectedCols["infotable" .. instance] = nil
				end
				row[1]:createButton({  }):setText(isextended and "-" or "+", { halign = "center" })
				row[1].handlers.onClick = function () return menu.buttonExtendOrder(menu.infoSubmenuObject, i .. "failure", instance, row.index, 1) end
				row[2]:setColSpan(3):createText(orderfailuredef and orderfailuredef.name or "", { mouseOverText = ColorText["text_warning"] .. message })
				row[5]:setColSpan(7):createText("[" .. ReadText(1001, 8837) .. "]", { halign = "right", color = Color["text_warning"], mouseOverText = ColorText["text_warning"] .. message })
				row[12]:createButton({  }):setText("X", { halign = "center" })
				row[12].handlers.onClick = function () C.RemoveOrderFailure(menu.infoSubmenuObject, buf[i].id); menu.refreshInfoFrame(nil, 0) end
				if isextended then
					-- message
					local row = ftable:addRow(nil, { bgColor = Color["row_background_unselectable"] })
					row[2]:setColSpan(9):createText("  " .. Helper.getPassedTime(failure.timestamp) .. " - " .. message, { color = Color["text_warning"] })
					-- params
					local params = GetOrderFailureParams(menu.infoSubmenuObject, tonumber(failure.id))
					for j, param in ipairs(params) do
						if (not param.hasinfinitevalue) and ((not param.advanced) or (mode == "orderqueue_advanced")) then
							if param.type == "list" then
								if param.value then
									for k, entry in ipairs(param.value) do
										local param2 = { text = (k == 1) and param.text or "", value = entry, type = param.inputparams.type, editable = param.editable }
										menu.displayFailureParam(ftable, i, j, param2, k, instance)
									end
								end
							elseif (param.type ~= "internal") then
								menu.displayFailureParam(ftable, i, j, param, nil, instance)
							end
						end
					end
				end
			end
		end
		if found then
			-- empty line
			local row = ftable:addEmptyRow()
			-- current behaviour
			local row = ftable:addRow(nil, { bgColor = Color["row_title_background"] })
			row[1]:setColSpan(numcols):createText(ReadText(1001, 11622), Helper.subHeaderTextProperties)
		end
	end
end

function menu.createStandingOrdersMenu(frame, instance)
	local infoTableData = menu.infoTableData[instance]

	infoTableData.ships = menu.getShipList(true, true)
	if not menu.infoSubmenuObject then
		for id, _ in pairs(menu.selectedcomponents) do
			local selectedcomponent = ConvertStringTo64Bit(id)
			if GetComponentData(selectedcomponent, "isplayerowned") and C.IsComponentClass(selectedcomponent, "ship") then
				menu.infoSubmenuObject = selectedcomponent
				break
			end
		end
		if not menu.infoSubmenuObject then
			if #infoTableData.ships > 0 then
				menu.infoSubmenuObject = ConvertIDTo64Bit(infoTableData.ships[1].shipid)
			else
				menu.infoSubmenuObject = 0
			end
		end
	end

	if not menu.infoTablePersistentData[instance].selectedorder then
		menu.setcol = nil
	else
		if menu.infoTablePersistentData[instance].selectedorder.object ~= menu.infoSubmenuObject then
			menu.infoTablePersistentData[instance].selectedorder = nil
			menu.setrow = nil
			menu.setcol = nil
		end
	end

	local ftable = frame:addTable(8, { tabOrder = 1 })
	ftable:setColWidth(1, Helper.standardTextHeight)
	ftable:setColWidth(2, frame.properties.width / 3 - Helper.scaleY(Helper.standardTextHeight) - Helper.borderSize, false)
	ftable:setColWidthPercent(3, 33)
	ftable:setColWidth(5, Helper.standardTextHeight)
	ftable:setColWidth(6, Helper.standardTextHeight)
	ftable:setColWidth(7, Helper.standardTextHeight)
	ftable:setColWidth(8, Helper.standardTextHeight)

	ftable:setDefaultCellProperties("button", { height = config.mapRowHeight })
	ftable:setDefaultBackgroundColSpan(1, 8)

	local color = Color["text_normal"]
	local isplayerowned, isonlineobject, isenemy, ishostile = GetComponentData(menu.infoSubmenuObject, "isplayerowned", "isonlineobject", "isenemy", "ishostile")
	if isplayerowned then
		color = menu.holomapcolor.playercolor
		if menu.infoSubmenuObject == C.GetPlayerObjectID() then
			color = menu.holomapcolor.currentplayershipcolor
		end
	elseif isonlineobject and menu.getFilterOption("layer_other", false) and menu.getFilterOption("think_diplomacy_highlightvisitor", false) then
		color = menu.holomapcolor.visitorcolor
	elseif ishostile then
		color = menu.holomapcolor.hostilecolor
	elseif isenemy then
		color = menu.holomapcolor.enemycolor
	end

	--- title ---
	local row = ftable:addRow(false, { fixed = true, bgColor = Color["row_title_background"] })
	row[1]:setColSpan(8):createText(ReadText(1001, 2427), Helper.headerRowCenteredProperties)
	local row = ftable:addRow(false, { fixed = true, bgColor = Color["row_title_background"] })
	row[1]:setColSpan(8):createText(ReadText(1001, 8396), Helper.headerRowCenteredProperties)
	--- name ---
	local row = ftable:addRow({ "info_focus" }, { fixed = true, bgColor = Color["row_title_background"] })
	row[8]:createButton({ height = Helper.headerRow1Height, width = config.mapRowHeight, cellBGColor = Color["row_background"] }):setIcon("menu_center_selection", { width = Helper.standardTextHeight, height = Helper.standardTextHeight, y = (Helper.headerRow1Height - Helper.standardTextHeight) / 2 })
	row[8].handlers.onClick = function () return C.SetFocusMapComponent(menu.holomap, menu.infoSubmenuObject, true) end
	if C.IsComponentClass(menu.infoSubmenuObject, "object") then
		row[1]:setBackgroundColSpan(7):setColSpan(3):createText(ffi.string(C.GetComponentName(menu.infoSubmenuObject)), Helper.headerRow1Properties)
		row[1].properties.color = color
		row[4]:setColSpan(4):createText(ffi.string(C.GetObjectIDCode(menu.infoSubmenuObject)), Helper.headerRow1Properties)
		row[4].properties.color = color
		row[4].properties.halign = "right"
	else
		row[1]:setBackgroundColSpan(7):setColSpan(7):createText(ffi.string(C.GetComponentName(menu.infoSubmenuObject)), Helper.headerRow1Properties)
		row[1].properties.color = color
	end

	---- current override order ----
	infoTableData.orders = {}
	if menu.isInfoModeValidFor(menu.infoSubmenuObject, "standingorders") then
		local n = C.GetNumOrders(menu.infoSubmenuObject)
		local buf = ffi.new("Order2[?]", n)
		n = C.GetOrders2(buf, n, menu.infoSubmenuObject)
		for i = 0, n - 1 do
			local entry = {}
			entry.state = ffi.string(buf[i].state)
			entry.statename = ffi.string(buf[i].statename)
			entry.orderdef = ffi.string(buf[i].orderdef)
			entry.actualparams = tonumber(buf[i].actualparams)
			entry.enabled = buf[i].enabled
			entry.isinfinite = buf[i].isinfinite
			entry.isoverride = buf[i].isoverride
			table.insert(infoTableData.orders, entry)
		end
	end

	if (#infoTableData.orders > 0) and infoTableData.orders[1].isoverride then
		local order = infoTableData.orders[1]
		local orderdefinition = ffi.new("OrderDefinition")
		local ordername = ""
		local orderrefid
		if order.orderdef ~= nil and C.GetOrderDefinition(orderdefinition, order.orderdef) then
			ordername = ffi.string(orderdefinition.name)
			orderrefid = ffi.string(orderdefinition.id)
		end
		order.params = GetOrderParams(menu.infoSubmenuObject, 1)

		local row = ftable:addRow(false, { bgColor = Color["row_title_background"] })
		row[1]:setColSpan(8):createText(ReadText(1001, 11221), Helper.headerRowCenteredProperties)

		local row = ftable:addRow(false, {  })
		row[1]:setColSpan(8):createText(ordername .. " " .. ColorText["text_error"] .. "[" .. ReadText(1001, 11219) .. "]")

		local row = ftable:addRow({ "current_override_order" }, {  })

		local attacker
		if orderrefid == "Flee" then
			if order.params[6] and order.params[6].value then
				local value = ConvertIDTo64Bit(order.params[6].value)
				if value ~= 0 then
					attacker = value
				end
			end
		elseif orderrefid == "Attack" then
			if order.params[1] and order.params[1].value and (order.params[1].type == "object") and (order.params[1].value ~= 0) then
				attacker = order.params[1].value
			end
		elseif orderrefid == "Wait" then
			if order.params[5] and order.params[5].value then
				local value = ConvertIDTo64Bit(order.params[5].value)
				if value ~= 0 then
					attacker = value
				end
			end
		end

		local overrideOrderOptions = {}
		if orderrefid ~= "Attack" then
			table.insert(overrideOrderOptions, { id = "Attack", text = ReadText(1001, 11228), icon = "", displayremoveoption = false, mouseovertext = ReadText(1026, 3234), active = attacker ~= nil })
		end
		if orderrefid ~= "Flee" then
			table.insert(overrideOrderOptions, { id = "Flee", text = ReadText(1001, 11220), icon = "", displayremoveoption = false, mouseovertext = ReadText(1026, 3232), active = attacker ~= nil })
		end
		if orderrefid ~= "Wait" then
			table.insert(overrideOrderOptions, { id = "Wait", text = ReadText(1001, 11247), icon = "", displayremoveoption = false, mouseovertext = ReadText(1026, 3245), active = attacker ~= nil })
		end

		row[3]:createDropDown(overrideOrderOptions, { height = config.mapRowHeight, startOption = "", active = isvalid and (not isplayeroccupiedship), textOverride = ReadText(1001, 11248) }):setTextProperties({ fontsize = config.mapFontSize, halign = "center" })
		row[3].handlers.onDropDownConfirmed = function (_, id) return menu.dropdownChangeOverrideOrder(id, attacker, instance) end
		row[3].handlers.onDropDownActivated = function () menu.noupdate = true end

		row[4]:setColSpan(5):createButton({ active = C.RemoveOrder(menu.infoSubmenuObject, 1, false, true), mouseOverText = ReadText(1026, 3233) }):setText(ReadText(1001, 11222), { halign = "center" })
		row[4].handlers.onClick = function () return menu.buttonRemoveOrder(1, instance) end

		local row = ftable:addRow(false, {  })
		row[1]:createText(" ")
	end

	---- standing orders ----
	menu.signals = {}
	local numsignals = C.GetNumAllSignals()
	local allsignals = ffi.new("SignalInfo[?]", numsignals)
	numsignals = C.GetAllSignals(allsignals, numsignals)
	for i = 0, numsignals - 1 do
		local signalid = ffi.string(allsignals[i].id)
		table.insert(menu.signals, {id = signalid, name = ffi.string(allsignals[i].name), description = ffi.string(allsignals[i].description), responses = {}})

		local numresponses = C.GetNumAllResponsesToSignal(signalid)
		local allresponses = ffi.new("ResponseInfo[?]", numresponses)
		numresponses = C.GetAllResponsesToSignal(allresponses, numresponses, signalid)
		for j = 0, numresponses - 1 do
			table.insert(menu.signals[#menu.signals].responses, {id = ffi.string(allresponses[j].id), name = ffi.string(allresponses[j].name), description = ffi.string(allresponses[j].description)})
		end
	end

	if C.IsComponentClass(menu.infoSubmenuObject, "ship") or C.IsComponentClass(menu.infoSubmenuObject, "station") then
		menu.createResponsesForControllable(ftable, menu.infoSubmenuObject, { height = config.mapRowHeight, fontsize = config.mapFontSize }, "controllableresponses", nil, instance)
	else
		local row = ftable:addRow(nil, {  })
		row[1]:setColSpan(8):createText(ReadText(1001, 11227), { wordwrap = true })
	end

	if menu.selectedRows["infotable" .. instance] then
		ftable:setSelectedRow(menu.selectedRows["infotable" .. instance])
		menu.selectedRows["infotable" .. instance] = nil
		if menu.selectedCols["infotable" .. instance] then
			ftable:setSelectedCol(menu.selectedCols["infotable" .. instance])
			menu.selectedCols["infotable" .. instance] = nil
		end
	end
	if menu.topRows["infotable" .. instance] then
		ftable:setTopRow(menu.topRows["infotable" .. instance])
		menu.topRows["infotable" .. instance] = nil
	end
	menu.setrow = nil
	menu.settoprow = nil
	menu.setcol = nil

	--- tabs ---
	local tabtable = menu.createOrdersMenuHeader(frame, instance)

	ftable.properties.y = tabtable.properties.y + tabtable:getVisibleHeight() + Helper.borderSize

	tabtable:addConnection(1, (instance == "left") and 2 or 3, true)
	ftable:addConnection(2, (instance == "left") and 2 or 3)
end

function menu.displayDefaultBehaviourFailure(ftable, mode, titlerow, instance, planned)
	local infoTableData = menu.infoTableData[instance]
	local selectedorder = menu.infoTablePersistentData[instance].selectedorder
	local numcols = 12
	if not infoTableData.hasloop then
		local failure = ffi.new("OrderFailure")
		if C.GetDefaultOrderFailure(failure, menu.infoSubmenuObject) then
			-- failed behaviour
			local row = ftable:addRow({ "defaultorderfailure" }, { bgColor = Color["row_title_background"] })
			if selectedorder and (selectedorder[1] == "defaultorderfailure") then
				menu.selectedRows["infotable" .. instance] = row.index
				menu.selectedCols["infotable" .. instance] = nil
			end
			row[1]:setColSpan(numcols - 1):setBackgroundColSpan(9):createText(ReadText(1001, 11618), Helper.subHeaderTextProperties)
			row[numcols]:createButton({ height = Helper.subHeaderHeight }):setText("X", { halign = "center" })
			row[numcols].handlers.onClick = function () C.RemoveDefaultOrderFailure(menu.infoSubmenuObject); menu.refreshInfoFrame() end
			titlerow[1].properties.helpOverlayHeight = titlerow[1].properties.helpOverlayHeight + row:getHeight() + Helper.borderSize

			local orderdefid = ffi.string(failure.orderdef)
			local orderfailuredef
			local found = false
			for _, orderdef in ipairs(menu.orderdefs) do
				if orderdef.id == orderdefid then
					orderfailuredef = orderdef
					found = true
					break
				end
			end
			if not found then
				DebugError("Default order failure of '" .. tostring(menu.infoSubmenuObject) .. "' is of unknown definition '" .. orderdefid .. "' [Florian]")
			end

			-- name
			local row = ftable:addRow(nil, {  })
			row[1]:setColSpan(4):createText(ReadText(1001, 8320) .. ReadText(1001, 120))
			row[5]:setColSpan(8):createButton({ active = false }):setText(orderfailuredef and orderfailuredef.name or ""):setText2(orderfailuredef and Helper.displaySkill(math.floor(orderfailuredef.requiredSkill * 15 / 100)) or "", { halign = "right", color = Color["text_skills"] })
			titlerow[1].properties.helpOverlayHeight = titlerow[1].properties.helpOverlayHeight + row:getHeight() + Helper.borderSize
			-- params
			local params = GetOrderFailureParams(menu.infoSubmenuObject, tonumber(failure.id))
			for j, param in ipairs(params) do
				if (not param.hasinfinitevalue) and ((not param.advanced) or (mode == "orderqueue_advanced")) then
					if param.type == "list" then
						if param.value then
							for k, entry in ipairs(param.value) do
								local param2 = { text = (k == 1) and param.text or "", value = entry, type = param.inputparams.type, editable = param.editable }
								menu.displayFailureParam(ftable, "defaultorderfailure", j, param2, k, instance)
							end
						end
					elseif (param.type ~= "internal") then
						menu.displayFailureParam(ftable, "defaultorderfailure", j, param, nil, instance)
					end
				end
			end
			-- message
			local row = ftable:addRow(nil, { bgColor = Color["row_background_unselectable"] })
			row[1]:setColSpan(numcols):createText(Helper.getPassedTime(failure.timestamp) .. " - " .. ffi.string(failure.message), { color = Color["text_warning"] })
			titlerow[1].properties.helpOverlayHeight = titlerow[1].properties.helpOverlayHeight + row:getHeight() + Helper.borderSize
			if orderdefid ~= infoTableData.defaultorder.orderdefref.id then
				-- changed default
				local row = ftable:addRow(nil, { bgColor = Color["row_background_unselectable"] })
				row[1]:setColSpan(numcols):createText(ReadText(1001, 11619), { color = Color["text_warning"] })
				titlerow[1].properties.helpOverlayHeight = titlerow[1].properties.helpOverlayHeight + row:getHeight() + Helper.borderSize
			end
			-- empty line
			local row = ftable:addEmptyRow()
			titlerow[1].properties.helpOverlayHeight = titlerow[1].properties.helpOverlayHeight + row:getHeight() + Helper.borderSize
			-- current behaviour
			local row = ftable:addRow(nil, { bgColor = Color["row_title_background"] })
			row[1]:setColSpan(numcols):createText(planned and ReadText(1001, 11620) or ReadText(1001, 11617), Helper.subHeaderTextProperties)
			titlerow[1].properties.helpOverlayHeight = titlerow[1].properties.helpOverlayHeight + row:getHeight() + Helper.borderSize
		end
	end
end

function menu.displayDefaultBehaviour(ftable, mode, titlerow, instance)
	local infoTableData = menu.infoTableData[instance]
	local selectedorder = menu.infoTablePersistentData[instance].selectedorder

	local isvalid = menu.isInfoModeValidFor(menu.infoSubmenuObject, mode)
	local playeroccupiedship64 = C.GetPlayerOccupiedShipID()
	local isplayeroccupiedship = menu.infoSubmenuObject == playeroccupiedship64

	local haspilot = GetComponentData(menu.infoSubmenuObject, "assignedpilot") ~= nil
	local behaviouractive = (infoTableData.commander == nil) and isvalid and (not isplayeroccupiedship) and haspilot
	local mouseovertext = isplayeroccupiedship and ReadText(1026, 3226) or ((not haspilot) and ReadText(1026, 3227) or "")

	menu.displayDefaultBehaviourFailure(ftable, mode, titlerow, instance)

	local numcols = 12
	local order = infoTableData.defaultorder
	if infoTableData.hasloop then
		-- name
		local row = ftable:addRow({ "default2" }, {  })
		if selectedorder and (selectedorder[1] == "default2") then
			menu.setrow = row.index
			menu.setcol = nil
		end
		row[1]:setColSpan(4):createText(ReadText(1001, 8320) .. ReadText(1001, 120))
		row[5]:setColSpan(8):createButton({ active = behaviouractive, mouseOverText = (mouseovertext == "") and ReadText(1026, 3269) or mouseovertext }):setText(ReadText(1001, 11267)):setText2(Helper.displaySkill(menu.orderloopskill), { halign = "right", color = Color["text_skills"] })
		row[5].handlers.onClick = function () return menu.buttonNewOrder(nil, true, instance) end
		titlerow[1].properties.helpOverlayHeight = titlerow[1].properties.helpOverlayHeight + row:getHeight() + Helper.borderSize
	elseif next(order) then
		order.params = GetOrderParams(menu.infoSubmenuObject, "default")
		-- commander
		if infoTableData.commander then
			local row = ftable:addRow(nil, {  })
			row[1]:setColSpan(numcols):createText(ReadText(1001, 11230), { wordwrap = true })
			titlerow[1].properties.helpOverlayHeight = titlerow[1].properties.helpOverlayHeight + row:getHeight() + Helper.borderSize
		end
		-- note
		local row = ftable:addRow(nil, {  })
		row[1]:setColSpan(numcols):createText(ReadText(1001, 8363) .. ReadText(1001, 120))
		titlerow[1].properties.helpOverlayHeight = titlerow[1].properties.helpOverlayHeight + row:getHeight() + Helper.borderSize
		-- name
		local row = ftable:addRow({ "default2" }, {  })
		if selectedorder and (selectedorder[1] == "default2") then
			menu.setrow = row.index
			menu.setcol = nil
		end
		local printedSkillReq = math.floor(order.orderdefref.requiredSkill * 15 / 100)
		row[1]:setColSpan(4):createText(ReadText(1001, 8364) .. ReadText(1001, 120))
		row[5]:setColSpan(8):createButton({helpOverlayID = "map_behaviourassignement", helpOverlayText = " ", helpOverlayHighlightOnly = true, active = behaviouractive, mouseOverText = (mouseovertext == "") and order.orderdefref.description or mouseovertext }):setText(order.orderdefref.name):setText2(Helper.displaySkill(printedSkillReq), { halign = "right", color = Color["text_skills"] })
		row[5].handlers.onClick = function () return menu.buttonNewOrder(nil, true, instance) end
		row[5].properties.uiTriggerID = "DefaultBehaviour"
		titlerow[1].properties.helpOverlayHeight = titlerow[1].properties.helpOverlayHeight + row:getHeight() + Helper.borderSize
		-- weapon config - TODO
		--row[7]:createButton({ active = isvalid and not isplayeroccupiedship }):setText("*", { halign = "center" })
		--row[7].handlers.onClick = function () return menu.buttonWeaponConfig(menu.infoSubmenuObject, nil, true) end

		for j, param in ipairs(order.params) do
			if (not param.hasinfinitevalue) and ((not param.advanced) or (mode == "orderqueue_advanced")) then
				if param.type == "list" then
					local playerreadonly = param.inputparams and param.inputparams.playerreadonly
					local canplayeroverride = (param.inputparams.canplayeroverride == 1) and infoTableData.commander

					if param.value then
						local overridedata
						if canplayeroverride then
							overridedata = {}

							local overrideparamname = param.name .. "_override"
							for i, entry in ipairs(order.params) do
								if entry.name == overrideparamname then
									overridedata.paramidx = i
									overridedata.param = entry
									break
								end
							end
							if not overridedata.paramidx then
								DebugError("Missing override order parameter '" .. overrideparamname .."' although canplayeroverride is set.")
								return
							end

							local row = ftable:addRow({ j, "manual" })
							if selectedorder and (selectedorder[1] == j) and (selectedorder[2] == "manual") then
								menu.setrow = row.index
								menu.setcol = nil
							end
							row[2]:setColSpan(3):createText("  " .. param.text .. ReadText(1001, 120))
							row[5]:setColSpan(1):createCheckBox(#overridedata.param.value == 0, { width = config.mapRowHeight, height = config.mapRowHeight, mouseOverText = ReadText(1026, 3282) })
							row[5].handlers.onClick = function (_, checked) return menu.checkboxOrderPlayerOverride("default", j, param, overridedata.paramidx, overridedata.param, checked) end
							row[6]:setColSpan(7):createText(ReadText(1001, 11650), { mouseOverText = ReadText(1026, 3282) })

							ftable:addEmptyRow()

							overridedata.values = {}
							for k, entry in ipairs(overridedata.param.value) do
								overridedata.values[entry] = k
							end

							overridedata.criticalwares = {}
							local commander = infoTableData.commander
							if GetComponentData(menu.infoSubmenuObject, "assignment") == "tradeforbuildstorage" then
								commander = GetComponentData(commander, "buildstorage")
							end
							local commander64 = C.ConvertStringTo64Bit(tostring(commander))
							local n = C.GetNumContainerCriticalWares(commander64)
							if n > 0 then
								local buf = ffi.new("const char*[?]", n)
								n = C.GetContainerCriticalWares(buf, n, commander64)
								for i = 0, n - 1 do
									overridedata.criticalwares[ffi.string(buf[i])] = true
								end
							end
						end

						if overridedata and (#overridedata.param.value > 0) and overridedata.param.inputparams.optionsource then
							if overridedata.param.inputparams.optionsource == "commanderwarebasket" then
								if overridedata.param.inputparams.type == "ware" then
									local warebasket = {}
									local found = {}
									local commander = infoTableData.commander
									if GetComponentData(menu.infoSubmenuObject, "assignment") == "tradeforbuildstorage" then
										commander = GetComponentData(commander, "buildstorage")
									end
									local allresources, allproducts, rawtradewares = GetComponentData(commander, "allresources", "products", "tradewares")
									for _, ware in ipairs(allresources) do
										if not found[ware] then
											found[ware] = true
											table.insert(warebasket, ware)
										end
									end
									for _, ware in ipairs(allproducts) do
										if not found[ware] then
											found[ware] = true
											table.insert(warebasket, ware)
										end
									end
									for _, ware in ipairs(rawtradewares) do
										if not found[ware] then
											found[ware] = true
											table.insert(warebasket, ware)
										end
									end

									for i = #warebasket, 1, -1 do
										if GetWareCapacity(overridedata.param.inputparams.cancarry, warebasket[i], true) == 0 then
											table.remove(warebasket, i)
										end
									end
									table.sort(warebasket, Helper.sortWareName)

									for k, ware in ipairs(warebasket) do
										local param2 = { text = ((k == 1) and (not canplayeroverride)) and param.text or "", value = ware, type = param.inputparams.type, editable = param.editable, playerreadonly = playerreadonly, canplayeroverride = overridedata }
										menu.displayOrderParam(ftable, "default", order, j, param2, k, instance)
									end
								end
							end
						else
							for k, entry in ipairs(param.value) do
								local param2 = { text = ((k == 1) and (not canplayeroverride)) and param.text or "", value = entry, type = param.inputparams.type, editable = param.editable, playerreadonly = playerreadonly, canplayeroverride = overridedata }
								menu.displayOrderParam(ftable, "default", order, j, param2, k, instance)
							end
						end
					end

					if (playerreadonly ~= 1) and (not canplayeroverride) then
						local row = ftable:addRow({ i, j, "new" }, {  })
						if selectedorder and (selectedorder[1] == i) and (selectedorder[2] == j) and (selectedorder[3] == "new") then
							menu.setrow = row.index
							menu.setcol = nil
						end

						-- kuertee start: callback
						if callbacks ["displayDefaultBehaviour_change_param_behaviouractive"] then
							for _, callback in ipairs (callbacks ["displayDefaultBehaviour_change_param_behaviouractive"]) do
								result = callback (behaviouractive)
								if result then
									behaviouractive = result.behaviouractive
								end
							end
						end
						-- kuertee end: callback

						local active = behaviouractive and (((order.state == "setup") and (j <= (order.actualparams + 1))) or ((order.state ~= "setup") and param.editable))
						row[2]:setColSpan(numcols - 1):createButton({ active = active }):setText("  " .. string.format((param.inputparams.type == "ware") and ReadText(1001, 8378) or ReadText(1001, 3235), param.text), { halign = "center" })
						row[2].handlers.onClick = function () return menu.buttonSetOrderParam("default", j, nil, nil, instance) end
						titlerow[1].properties.helpOverlayHeight = titlerow[1].properties.helpOverlayHeight + row:getHeight() + Helper.borderSize
					end
				elseif (param.type ~= "internal") then
					menu.displayOrderParam(ftable, "default", order, j, param, nil, instance)
				end
			end
		end
	else
		local row = ftable:addRow({ "default" }, {  })
		if selectedorder and (selectedorder[1] == "default") then
			menu.setrow = row.index
			menu.setcol = nil
		end
		row[2]:setColSpan(numcols - 2):createText(ReadText(1001, 8320) .. ReadText(1001, 120) .. " ---")
		row[numcols]:createButton({ active = behaviouractive, mouseOverText = mouseovertext }):setIcon("menu_edit")
		row[numcols].handlers.onClick = function () return menu.buttonNewOrder(nil, true, instance) end
		titlerow[1].properties.helpOverlayHeight = titlerow[1].properties.helpOverlayHeight + row:getHeight() + Helper.borderSize
	end

	local row = ftable:addRow({ "defaultbuttons" }, {  })
	if selectedorder and (selectedorder[1] == "defaultbuttons") then
		menu.setrow = row.index
	end
	row[1]:setColSpan(4):createButton({ active = false }):setText(ReadText(1001, 2821), { halign = "center" })
	row[8]:setColSpan(5):createButton({ active = false }):setText(ReadText(1001, 64), { halign = "center" })
	titlerow[1].properties.helpOverlayHeight = titlerow[1].properties.helpOverlayHeight + row:getHeight() + Helper.borderSize
end

function menu.displayPlannedDefaultBehaviour(ftable, mode, titlerow, instance)
	local infoTableData = menu.infoTableData[instance]
	local persistentData = menu.infoTablePersistentData[instance]
	local selectedorder = persistentData.selectedorder

	local isvalid = menu.isInfoModeValidFor(menu.infoSubmenuObject, mode)
	local playeroccupiedship64 = C.GetPlayerOccupiedShipID()
	local isplayeroccupiedship = menu.infoSubmenuObject == playeroccupiedship64

	local haspilot = GetComponentData(menu.infoSubmenuObject, "assignedpilot") ~= nil
	local behaviouractive = (infoTableData.commander == nil) and isvalid and (not isplayeroccupiedship) and haspilot
	local mouseovertext = isplayeroccupiedship and ReadText(1026, 3226) or ((not haspilot) and ReadText(1026, 3227) or "")

	menu.displayDefaultBehaviourFailure(ftable, mode, titlerow, instance, true)

	menu.setcol = nil

	local order = infoTableData.planneddefaultorder

	local numcols = 12
	local row = ftable:addEmptyRow(1)
	titlerow[1].properties.helpOverlayHeight = titlerow[1].properties.helpOverlayHeight + row:getHeight() + Helper.borderSize

	if persistentData.planneddefaultorderloop then
		-- note
		local row = ftable:addRow(nil, {  })
		row[1]:setColSpan(numcols):createText(ReadText(1001, 8365) .. ReadText(1001, 120), { font = Helper.standardFontBold })
		titlerow[1].properties.helpOverlayHeight = titlerow[1].properties.helpOverlayHeight + row:getHeight() + Helper.borderSize

		-- name
		local row = ftable:addRow({ "default2" }, {  })
		if selectedorder and (selectedorder[1] == "default2") then
			menu.setrow = row.index
			menu.setcol = nil
		end
		row[1]:setColSpan(4):createText(ReadText(1001, 8320) .. ReadText(1001, 120))
		row[5]:setColSpan(8):createButton({ active = behaviouractive, mouseOverText = (mouseovertext == "") and ReadText(1026, 3269) or mouseovertext }):setText(ReadText(1001, 11267)):setText2(Helper.displaySkill(menu.orderloopskill), { halign = "right", color = Color["text_skills"] })
		row[5].handlers.onClick = function () return menu.buttonNewOrder(nil, true, instance) end
		titlerow[1].properties.helpOverlayHeight = titlerow[1].properties.helpOverlayHeight + row:getHeight() + Helper.borderSize

		-- delete existing orders note
		if #infoTableData.orders > 0 then
			local row = ftable:addRow(nil, {  })
			row[1]:setColSpan(numcols):createText(function () return persistentData.planneddefaultorderloop.hasunremoveableorders and ReadText(1001, 11269) or ReadText(1001, 11268) end, { color = Color["text_error"] })
			titlerow[1].properties.helpOverlayHeight = titlerow[1].properties.helpOverlayHeight + row:getHeight() + Helper.borderSize
		end
	elseif next(order) then
		order.params = GetOrderParams(menu.infoSubmenuObject, "planneddefault")

		-- note
		local row = ftable:addRow(nil, {  })
		row[1]:setColSpan(numcols):createText((persistentData.planneddefaultorderiscopy and ReadText(1001, 11610) or ReadText(1001, 8365)) .. ReadText(1001, 120), { font = Helper.standardFontBold })
		titlerow[1].properties.helpOverlayHeight = titlerow[1].properties.helpOverlayHeight + row:getHeight() + Helper.borderSize
		-- name
		local row = ftable:addRow({ "default2" }, {  })
		if selectedorder and (selectedorder[1] == "default2") then
			menu.setrow = row.index
			menu.setcol = nil
		end
		local printedSkillReq = math.floor(order.orderdefref.requiredSkill * 15 / 100)
		row[1]:setColSpan(4):createText(ReadText(1001, 8320) .. ReadText(1001, 120))
		row[5]:setColSpan(8):createButton({ active = behaviouractive, mouseOverText = (mouseovertext == "") and order.orderdefref.description or mouseovertext }):setText(order.orderdefref.name):setText2(Helper.displaySkill(printedSkillReq), { halign = "right", color = Color["text_skills"] })
		row[5].handlers.onClick = function () return menu.buttonNewOrder(nil, true, instance) end
		titlerow[1].properties.helpOverlayHeight = titlerow[1].properties.helpOverlayHeight + row:getHeight() + Helper.borderSize

		for j, param in ipairs(order.params) do
			if (not param.hasinfinitevalue) and ((not param.advanced) or (mode == "orderqueue_advanced")) then
				if param.type == "list" then
					local playerreadonly = param.inputparams and param.inputparams.playerreadonly
					if param.value then
						for k, entry in ipairs(param.value) do
							local param2 = { text = (k == 1) and param.text or "", value = entry, type = param.inputparams.type, editable = param.editable, playerreadonly = playerreadonly }
							menu.displayOrderParam(ftable, "planneddefault", order, j, param2, k, instance)
						end
					end

					if playerreadonly ~= 1 then
						local row = ftable:addRow({ i, j, "new" }, {  })
						if selectedorder and (selectedorder[1] == i) and (selectedorder[2] == j) and (selectedorder[3] == "new") then
							menu.selectedRows["infotable" .. instance] = row.index
							menu.selectedCols["infotable" .. instance] = nil
						end
						local active = isvalid and (not isplayeroccupiedship) and (((order.state == "setup") and (j <= (order.actualparams + 1))) or ((order.state ~= "setup") and param.editable))
						row[2]:setColSpan(numcols - 1):createButton({ active = active }):setText("  " .. (param.inputparams and string.format((param.inputparams.type == "ware") and ReadText(1001, 8378) or ReadText(1001, 3235), param.text) or "---"), { halign = "center" })
						row[2].handlers.onClick = function () return menu.buttonSetOrderParam("planneddefault", j, nil, nil, instance) end
						titlerow[1].properties.helpOverlayHeight = titlerow[1].properties.helpOverlayHeight + row:getHeight() + Helper.borderSize
					end
				elseif (param.type ~= "internal") then
					menu.displayOrderParam(ftable, "planneddefault", order, j, param, nil, instance)
				end
			end
		end
	else
		local row = ftable:addRow({ "planneddefault" }, {  })
		if selectedorder and (selectedorder[1] == "planneddefault") then
			menu.setrow = row.index
		end
		row[2]:setColSpan(numcols - 2):createText(ReadText(1001, 8322) .. ReadText(1001, 120) .. " ---")
		row[numcols]:createButton({ active = behaviouractive, mouseOverText = mouseovertext }):setIcon("menu_edit")
		row[numcols].handlers.onClick = function () return menu.buttonNewOrder(nil, true, instance) end
		titlerow[1].properties.helpOverlayHeight = titlerow[1].properties.helpOverlayHeight + row:getHeight() + Helper.borderSize
	end

	local row = ftable:addRow({ "defaultbuttons" }, {  })
	if selectedorder and (selectedorder[1] == "defaultbuttons") then
		menu.setrow = row.index
	end
	row[1]:setColSpan(4):createButton({ active = function () return menu.buttonConfirmPlannedDefaultOrderActive(instance, isvalid) end, helpOverlayID = "map_confirmdefaultorder", helpOverlayText = " ", helpOverlayHighlightOnly = true }):setText(ReadText(1001, 2821), { halign = "center" })
	row[1].handlers.onClick = function () return menu.buttonDefaultOrderConfirm(instance) end
	row[1].properties.uiTriggerID = "map_confirmdefaultorder"
	row[8]:setColSpan(5):createButton():setText(ReadText(1001, 64), { halign = "center" })
	row[8].handlers.onClick = function () return menu.buttonDefaultOrderDiscard(instance) end
	titlerow[1].properties.helpOverlayHeight = titlerow[1].properties.helpOverlayHeight + row:getHeight() + Helper.borderSize
end

function menu.buttonConfirmPlannedDefaultOrderActive(instance, isvalid)
	if not isvalid then
		return false
	end
	if next(menu.infoTableData[instance].planneddefaultorder) then
		return C.EnablePlannedDefaultOrder(menu.infoSubmenuObject, true)
	else
		menu.infoTablePersistentData[instance].planneddefaultorderloop.hasunremoveableorders = nil
		local numorders = C.GetNumOrders(menu.infoSubmenuObject)
		local currentorders = ffi.new("Order[?]", numorders)
		numorders = C.GetOrders(currentorders, numorders, menu.infoSubmenuObject)
		for i = 0, numorders - 1 do
			if ffi.string(currentorders[i].state) == "critical" then
				menu.infoTablePersistentData[instance].planneddefaultorderloop.hasunremoveableorders = true
				break
			end
		end
		return not menu.infoTablePersistentData[instance].planneddefaultorderloop.hasunremoveableorders
	end
end

function menu.createPlotMode(inputframe)
	local textproperties = { height = config.mapRowHeight, fontsize = config.mapFontSize }

	menu.initPlotList()

	menu.table_plotlist = inputframe:addTable(4, {tabOrder = 1})
	menu.table_plotlist:setColWidth(4, Helper.scaleY(textproperties.height), false)
	menu.table_plotlist:setColWidthPercent(2, 30)
	menu.table_plotlist:setColWidthPercent(3, 5)

	local row = menu.table_plotlist:addRow(false, {fixed = true, bgColor = Color["row_title_background"]})
	row[1]:setColSpan(4):createText(ReadText(1001, 9201), Helper.headerRowCenteredProperties)	-- Your Plots

	local numrows = config.plots.maxPlotRows
	local maxVisibleHeight
	local numplotentries = #menu.plots + 1
	for i, plot in ipairs(menu.plots) do
		local station64 = ConvertStringTo64Bit(tostring(plot.station))
		local stationname = menu.getContainerNameAndColors(station64, 0, false, false)
		row = menu.table_plotlist:addRow(station64, { bgColor = Color["row_background_blue"] })
		row[1]:setBackgroundColSpan(3):createText((stationname), textproperties)
		row[1].properties.color = function() return plot.fullypaid and Color["text_normal"] or Color["text_error"] end

		row[2]:createText((ReadText(1001, 9210) .. " " .. i), textproperties)	-- Plot
		row[2].properties.halign = "right"
		row[2].properties.x = 0
		row[2].properties.color = function() return plot.fullypaid and Color["text_normal"] or Color["text_error"] end

		row[3]:createText(function() return (plot.fullypaid and "" or "!") end, textproperties)
		row[3].properties.halign = "left"
		row[3].properties.font = Helper.standardFontBold
		row[3].properties.color = Color["text_error"]
		local mouseovertext = ReadText(1026, 3280)
		if plot.permanent then
			mouseovertext = mouseovertext .. "\n- " .. ColorText["text_error"] .. ReadText(1026, 3281) .. "\27X"
		end
		row[4]:createButton({ active = not plot.permanent, helpOverlayID = "menu_cancel_plot", helpOverlayText = " ",  helpOverlayHighlightOnly = true, height = Helper.standardTextHeight, mouseOverText = mouseovertext }):setText("x", { halign = "center" })
		row[4].handlers.onClick = function() return menu.buttonRemovePlot(station64) end

		if i == numrows then
			maxVisibleHeight = menu.table_plotlist:getFullHeight()
		end
		if station64 == menu.plotData.component then
			menu.setrow = row.index
		end
	end
	row = menu.table_plotlist:addRow(false, { bgColor = Color["row_separator"] })
	row[1]:setColSpan(4):createText("", { height = 2 })
	row = menu.table_plotlist:addRow("plots_new", { bgColor = Color["row_background_blue"] })
	row[1]:setBackgroundColSpan(4):createText(ReadText(1001, 9200), textproperties)	-- New Plot
	row[2]:createText((ReadText(1001, 9210) .. " " .. tostring(numplotentries)), textproperties)	-- Plot
	row[2].properties.halign = "right"
	row[2].properties.x = 0

	if maxVisibleHeight then
		menu.table_plotlist.properties.maxVisibleHeight = maxVisibleHeight
	end

	if not menu.plotData.component and not menu.plots_initialized then
		for id, _ in pairs(menu.selectedcomponents) do
			local station = ConvertStringTo64Bit(id)
			if GetComponentData(station, "isplayerowned") and C.IsRealComponentClass(station, "station") then
				menu.updatePlotData(station, true)

				for _, row in ipairs(menu.table_plotlist.rows) do
					if row.rowdata == station then
						menu.setplotrow = row.index
						menu.setplottoprow = (row.index - numrows + 1) > 1 and (row.index - numrows + 1) or 1
						break
					end
				end

				break
			end
		end
	elseif menu.plotData.component then
		menu.updatePlotData(menu.plotData.component, true)
	end
	menu.plots_initialized = true

	if menu.setplotrow then
		menu.setrow = menu.setplotrow
		menu.setplotrow = nil
		if menu.setplottoprow then
			menu.settoprow = menu.setplottoprow
			menu.setplottoprow = nil
		end
	end

	if menu.setrow then
		menu.table_plotlist:setSelectedRow(menu.setrow)
		menu.plotDoNotUpdate = true
		menu.setrow = nil
	else
		menu.table_plotlist:setSelectedRow(row.index)
	end
	if menu.settoprow then
		menu.table_plotlist:setTopRow(menu.settoprow)
		menu.settoprow = nil
	else
		menu.table_plotlist:setTopRow((row.index - numrows + 1) > 1 and (row.index - numrows + 1) or 1)
	end

	local table_plotdetails = inputframe:addTable(3, { tabOrder = 2 })
	table_plotdetails:setColWidthPercent(1, 40)
	table_plotdetails:setDefaultBackgroundColSpan(1, 3)

	row = table_plotdetails:addRow(false, { fixed = true, bgColor = Color["row_title_background"] })
	row[1]:setColSpan(3):createText(function () return menu.plotData.name or "" end, Helper.headerRowCenteredProperties)

	local row = table_plotdetails:addRow(false, { fixed = true, bgColor = Color["row_background_unselectable"] })
	row[1]:createText(ReadText(1001, 11284) .. ReadText(1001, 120))
	row[2]:setColSpan(2):createText(function () return ffi.string(C.GetComponentName(menu.plotData.sector)) end, { halign = "right" })

	local row = table_plotdetails:addRow(false, { fixed = true, bgColor = Color["row_background_unselectable"] })
	row[1]:createText(ReadText(1001, 2412) .. ReadText(1001, 120))
	row[2]:setColSpan(2):createText(function () return GetComponentData(ConvertStringTo64Bit(tostring(menu.plotData.sector)), "sunlight") * 100 .. "%" end, { halign = "right" })

	local row = table_plotdetails:addRow(false, { fixed = true, bgColor = Color["row_background_unselectable"] })
	row[1]:createText(ReadText(1001, 11296) .. ReadText(1001, 120))
	row[2]:setColSpan(2):createText(function () return string.format("%+.0f%%", GetComponentData(ConvertStringTo64Bit(tostring(menu.plotData.sector)), "populationworkforcefactor") * 100) end, { halign = "right" })

	local row = table_plotdetails:addRow(false, { fixed = true, bgColor = Color["row_title_background"] })
	row[1]:setColSpan(3):createText(ReadText(1001, 11285), Helper.headerRowCenteredProperties)

	if IsCheatVersion() then
		local setOptions = {}
		local n = C.GetNumAllModuleSets()
		local buf = ffi.new("UIModuleSet[?]", n)
		n = C.GetAllModuleSets(buf, n)
		for i = 0, n - 1 do
			table.insert(setOptions, { id = ffi.string(buf[i].id), text = ffi.string(buf[i].name), icon = "", displayremoveoption = false })
		end
		table.sort(setOptions, function (a, b) return a.text < b.text end)

		row = table_plotdetails:addRow(true, { bgColor = Color["row_background_blue"] })
		row[1]:setColSpan(3):createDropDown(setOptions, { height = config.mapRowHeight, startOption = menu.plotData.set, active = not menu.plotData.placed and not menu.plotData.active }):setTextProperties({fontsize = config.mapFontSize})
		row[1].handlers.onDropDownConfirmed = function(_, idstring) return menu.dropdownModuleSet(_, idstring) end
		row[1].handlers.onDropDownActivated = function () menu.noupdate = true end
	end

	menu.plotsliders = {}
	menu.plotbuttons = {}
	local dimensions = { [1] = { dimension = "posX", text = ReadText(1001, 9220) },
						 [2] = { dimension = "negX", text = ReadText(1001, 9221) },
						 [3] = { dimension = "posY", text = ReadText(1001, 9222) },
						 [4] = { dimension = "negY", text = ReadText(1001, 9223) },
						 [5] = { dimension = "posZ", text = ReadText(1001, 9224) },
						 [6] = { dimension = "negZ", text = ReadText(1001, 9225) },
					}
	local boughtdimensions = {}
	if menu.plotData.paid then
		boughtdimensions = {
			posX = math.ceil((menu.plotData.boughtrawsize.x / 2 + menu.plotData.boughtrawcenteroffset.x) / 1000),
			negX = math.floor((menu.plotData.boughtrawsize.x / 2 - menu.plotData.boughtrawcenteroffset.x) / 1000),
			posY = math.ceil((menu.plotData.boughtrawsize.y / 2 + menu.plotData.boughtrawcenteroffset.y) / 1000),
			negY = math.floor((menu.plotData.boughtrawsize.y / 2 - menu.plotData.boughtrawcenteroffset.y) / 1000),
			posZ = math.ceil((menu.plotData.boughtrawsize.z / 2 + menu.plotData.boughtrawcenteroffset.z) / 1000),
			negZ = math.floor((menu.plotData.boughtrawsize.z / 2 - menu.plotData.boughtrawcenteroffset.z) / 1000),
		}
	end

	for i, dimension in ipairs(dimensions) do
		row = table_plotdetails:addRow(true, {})
		local locdimension = menu.plotData.dimensions[dimension.dimension]
		local minimumdimension = menu.plotData.minimumdimensions[dimension.dimension] or 0
		local boughtdimension = menu.plotData.paid and boughtdimensions[dimension.dimension] or 0
		local locpaireddimension = menu.plotData.dimensions[config.plotPairedDimension[dimension.dimension]]

		local minselect = math.max(menu.plotData.permanent and math.max(boughtdimension, minimumdimension) or boughtdimension, (locpaireddimension == 0 and 1 or 0))
		local maxselect = (menu.plotData.dimensions[config.plotPairedDimension[dimension.dimension]] > config.maxPlotSize) and menu.plotData.dimensions[config.plotPairedDimension[dimension.dimension]] or (config.maxPlotSize - menu.plotData.dimensions[config.plotPairedDimension[dimension.dimension]])
		local max = (menu.plotData.dimensions[config.plotPairedDimension[dimension.dimension]] > config.maxPlotSize) and menu.plotData.dimensions[config.plotPairedDimension[dimension.dimension]] or config.maxPlotSize
		if maxselect > max then
			print("maxselect > max. axis: " .. tostring(dimension.dimension) .. " maxselect: " .. tostring(maxselect) .. ", max: " .. tostring(max) .. ", paired value: " .. tostring(menu.plotData.dimensions[config.plotPairedDimension[dimension.dimension]]))
		end
		if minselect > maxselect then
			print("menu.createPlotMode(): minselect > maxselect [Florian]")
			minselect = maxselect
		end
		if locdimension < minselect then
			print("menu.createPlotMode(): start < minselect [Florian]")
			locdimension = minselect
		end

		-- increased minSelect to 1 because it looks like slider text is rounding to the nearest integer (and shows 0.5 as 0). so smallest possible plot size is 2x2x2.
		local slider = row[1]:setColSpan(3):createSliderCell({
			height = config.mapRowHeight,
			bgColor = Color["slider_background_transparent"],
			min = 0,
			minSelect = minselect,
			max = (locpaireddimension > config.maxPlotSize) and locpaireddimension or config.maxPlotSize,
			maxSelect = (locpaireddimension > config.maxPlotSize) and locpaireddimension or (config.maxPlotSize - locpaireddimension),
			start = locdimension,
			step = 1,
			suffix = ReadText(1001, 108),
			mouseOverText = ffi.string(C.GetDisplayedModifierKey("shift")) .. " - " .. ReadText(1026, 3279),
		}):setText(dimension.text, {fontsize = config.mapFontSize})
		--row[1]:setColSpan(3):createSliderCell({ height = config.mapRowHeight, min = 0, minSelect = (menu.plotData.paid or menu.plotData.permanent) and menu.plotData.dimensions[dimension.dimension] or 1, max = 9, maxSelect = config.maxPlotSize - menu.plotData.dimensions[config.plotPairedDimension[dimension.dimension]], start = menu.plotData.dimensions[dimension.dimension], step = 1, suffix = ReadText(1001, 108) }):setText(dimension.text, {fontsize = config.mapFontSize})
		row[1].handlers.onSliderCellChanged = function(_, val) return menu.slidercellPlotValue(_, val, dimension.dimension) end
		row[1].handlers.onSliderCellConfirm = function() return menu.refreshInfoFrame() end
		row[1].handlers.onSliderCellActivated = function() menu.noupdate = true end
		row[1].handlers.onSliderCellDeactivated = function() menu.noupdate = false end
		table.insert(menu.plotsliders, { table = table_plotdetails, cell = row[1], row = row.index, col = 1, dimension = dimension.dimension, slider = slider })
	end

	table_plotdetails:addEmptyRow(config.mapRowHeight / 2)

	row = table_plotdetails:addRow(nil, { bgColor = Color["row_background_unselectable"] })
	row[1]:createText(ReadText(1001, 8026) .. ReadText(1001, 120))
	row[2]:setColSpan(2):createText(function () return (menu.plotData.dimensions.posX + menu.plotData.dimensions.negX) .. " " .. ReadText(1001, 42) .. " " .. (menu.plotData.dimensions.posY + menu.plotData.dimensions.negY) .. " " .. ReadText(1001, 42) .. " " .. (menu.plotData.dimensions.posZ + menu.plotData.dimensions.negZ) .. " " .. ReadText(1001, 108) end, { halign = "right" })

	row = table_plotdetails:addRow("createplot", {})
	row[2]:createButton({ height = config.mapRowHeight, active = (menu.plotData.isinownedspace and menu.plotData.placed and menu.plotData.paid and (menu.plotData.size.x * 1000 > menu.plotData.boughtrawsize.x or menu.plotData.size.y * 1000 > menu.plotData.boughtrawsize.y or menu.plotData.size.z * 1000 > menu.plotData.boughtrawsize.z) and not menu.plotData.permanent) and true or false }):setText(ReadText(1001, 9230), { halign = "center", fontsize = config.mapFontSize })	-- Reset size
	row[2].handlers.onClick = function() return menu.resetPlotSize() end
	table.insert(menu.plotbuttons, { table = table_plotdetails, cell = row[2], row = row.index, col = 2, rowdata = "createplot", script = function() return menu.resetPlotSize() end })

	row[3]:createButton({ height = config.mapRowHeight, active = not menu.plotData.placed, helpOverlayID = "create_plot_new", helpOverlayText = " ",  helpOverlayHighlightOnly = true}):setText(ReadText(1001, 9231), { halign = "center", fontsize = config.mapFontSize })	-- Create new plot
	row[3].handlers.onClick = function() return menu.buttonNewPlot() end
	row[3].properties.uiTriggerID = "createnewplot"

	table.insert(menu.plotbuttons, { table = table_plotdetails, cell = row[3], row = row.index, col = 3, rowdata = "createplot", script = function() return menu.buttonNewPlot() end })

	table_plotdetails:setSelectedRow(menu.selectedRows.infotable2)
	menu.selectedRows.infotable2 = nil

	row = table_plotdetails:addRow(false, {bgColor = Color["row_title_background"]})
	row[1]:setColSpan(3):createText(ReadText(1001, 9202), Helper.headerRowCenteredProperties)	-- Real Estate Transfer Tax

	row = table_plotdetails:addRow(false, { bgColor = Color["row_background_unselectable"] })
	row2 = table_plotdetails:addRow("buyplot", {})

	row[1]:setColSpan(2):createText(function() return (not menu.plotData.placed and ReadText(1001, 9240)) or ((menu.plotData.fullypaid or not menu.plotData.isinownedspace) and ReadText(1001, 9241)) or (ReadText(1001, 9242) .. ReadText(1001, 120)) end, textproperties)	-- Place or select plot to see required fees., You own this plot., Fee to acquire plot licence, :
	row[3]:createText(function() return (menu.plotData.placed and not menu.plotData.fullypaid and menu.plotData.isinownedspace and (ConvertMoneyString(tostring(menu.plotData.price), false, true, 0, true) .. " " .. ReadText(1001, 101))) or "" end, textproperties)
	row[3].properties.halign = "right"

	-- TODO: activate after there is a distinction between a holomap-only plot and a real one.
	--row2[2]:createButton({active = false, height = config.mapRowHeight}):setText(ReadText(1001, 9232), {halign = "center", fontsize = config.mapFontSize})	-- Ignore licence
	--row2[2]:createButton({active = not menu.plotData.fullypaid and menu.plotData.isinownedspace, height = config.mapRowHeight}):setText(ReadText(1001, 9232), {halign = "center", fontsize = config.mapFontSize})	-- Ignore licence
	--row2[2].handlers.onClick = function() return menu.buttonIgnorePlotLicence() end
	--table.insert(menu.plotbuttons, { table = table_plotdetails, cell = row2[2], row = row2.index, col = 2, rowdata = "buyplot", script = function() return menu.buttonIgnorePlotLicence() end })
	local mouseovertext = ""
	if menu.plotData.placed and (not menu.plotData.fullypaid) and menu.plotData.isinownedspace and (not menu.plotData.affordable) then
		mouseovertext = ReadText(1026, 3222)
	end
	row2[3]:createButton({ active = menu.plotData.placed and not menu.plotData.fullypaid and menu.plotData.isinownedspace and menu.plotData.affordable, height = config.mapRowHeight, mouseOverText = mouseovertext, helpOverlayID = "create_plot_purchase", helpOverlayText = " ",  helpOverlayHighlightOnly = true, uiTriggerID = "buyplot" }):setText(ReadText(1001, 9233), { halign = "center", fontsize = config.mapFontSize })	-- Buy licence
	row2[3].handlers.onClick = function() return menu.buttonBuyPlot() end
	row2[3].properties.uiTriggerID = "buyplot"
	table.insert(menu.plotbuttons, { table = table_plotdetails, cell = row2[3], row = row2.index, col = 3, rowdata = "buyplot", script = function() return menu.buttonBuyPlot() end })

	row = table_plotdetails:addRow(false, {bgColor = Color["row_title_background"]})
	row[1]:setColSpan(3):createText(ReadText(1001, 9234), Helper.headerRowCenteredProperties)	-- Continue to Construction

	row = table_plotdetails:addRow(false, { bgColor = Color["row_background_unselectable"] })
	textproperties.height = config.mapRowHeight * 2
	textproperties.wordwrap = true
	row2 = table_plotdetails:addRow("initiateconstruction", {})

	row[1]:setColSpan(3):createText(function() return (not menu.plotData.placed and ReadText(1001, 9243)) or ((menu.plotData.fullypaid or not menu.plotData.isinownedspace) and ReadText(1001, 9244)) or ReadText(1001, 9245) end, textproperties)	-- Place or select plot to initiate construction., Click continue to initiate construction., Building without a licence will be seen as a hostile act by the local government.
	row[1].properties.color = function() return menu.plotData.placed and menu.plotData.isinownedspace and not menu.plotData.fullypaid and Color["text_error"] or Color["text_normal"] end
	row2[3]:createButton({active = menu.plotData.placed, height = config.mapRowHeight, helpOverlayID = "create_plot_continue", helpOverlayText = " ",  helpOverlayHighlightOnly = true}):setText(ReadText(1001, 9235), {halign = "center", fontsize = config.mapFontSize})	-- Continue
	row2[3].handlers.onClick = function() return menu.plotInitiateConstruction(menu.plotData.component) end
	row2[3].properties.uiTriggerID = "initiateconstruction"

	table.insert(menu.plotbuttons, { table = table_plotdetails, cell = row2[3], row = row2.index, col = 3, rowdata = "initiateconstruction", script = function() return menu.plotInitiateConstruction(menu.plotData.component) end })

	table_plotdetails.properties.y = menu.table_plotlist:getVisibleHeight() + Helper.borderSize

	menu.table_plotlist:addConnection(1, 2, true)
	table_plotdetails:addConnection(2, 2)
end

function menu.createFilterMode(ftable, numCols)
	local title = ""
	local row = ftable:addRow("tabs", { fixed = true })
	for i, entry in ipairs(config.layers) do
		local icon = entry.icon
		local bgcolor = Color["row_title_background"]
		-- active filter groups get different colors
		if entry.mode == menu.displayedFilterLayer then
			title = entry.name
			bgcolor = Color["row_background_selected"]
		end
		if not menu.getFilterOption(entry.mode, false) then
			icon = icon .. "_disabled"
		end

		local colindex = i
		if i > 1 then
			colindex = colindex + 2
		end

		row[colindex]:setColSpan((i == 1) and 3 or 1):createButton({ height = menu.sideBarWidth, bgColor = bgcolor, mouseOverText = entry.name, scaling = false, helpOverlayID = entry.helpOverlayID, helpOverlayText = entry.helpOverlayText }):setIcon(icon, { })
		row[colindex].handlers.onClick = function () return menu.buttonFilterSwitch(entry.mode, row.index, colindex) end
	end

	local row = ftable:addRow(true, { fixed = true, bgColor = Color["row_title_background"] })
	local color = Color["text_normal"]
	local onoffcolor = Color["text_normal"]
	local active = true
	if not __CORE_DETAILMONITOR_MAPFILTER[menu.displayedFilterLayer] then
		color = Color["text_inactive"]
		onoffcolor = Color["text_negative"]
		active = false
	end
	row[1]:setColSpan(2):createButton({ height = Helper.headerRow1Height, helpOverlayID = "toggle_current_filter", helpOverlayText = " ", helpOverlayHighlightOnly = true}):setIcon("menu_on_off", { color = onoffcolor })
	row[1].handlers.onClick = function () return menu.buttonSetFilterLayer(menu.displayedFilterLayer, row.index, 1) end
	row[3]:setColSpan(numCols - 2):createText(title, Helper.headerRowCenteredProperties)

	local settings = config.layersettings[menu.displayedFilterLayer]
	for i, setting in ipairs(settings) do
		if i > 1 then
			ftable:addEmptyRow(config.mapRowHeight / 2)
		end

		local titlerow = ftable:addRow(false, { bgColor = Color["row_title_background"] })
		titlerow[1]:setColSpan(numCols):createText(setting.caption, Helper.subHeaderTextProperties)
		titlerow[1].properties.color = color
		titlerow[1].properties.helpOverlayID = setting.helpOverlayID
		titlerow[1].properties.helpOverlayText = setting.helpOverlayText
		titlerow[1].properties.helpOverlayHeight = titlerow:getHeight()
		titlerow[1].properties.helpOverlayHighlightOnly = setting.helpOverlayHighlightOnly
		titlerow[1].properties.helpOverlayScaling = false

		if setting.type == "multiselectlist" then
			local list = menu.getFilterOption(setting.id, setting.savegame) or {}
			for i, curOption in ipairs(list) do
				local index = i

				local row = ftable:addRow(true, {  })
				row[1]:setColSpan(numCols - 1):createText(setting.displayOption(curOption), { fontsize = config.mapFontSize })
				row[1].properties.color = color
				row[numCols]:createButton({ active = active }):setText("x", { halign = "center" })
				row[numCols].handlers.onClick = function () return menu.removeFilterOption(setting, setting.id, index) end
				titlerow[1].properties.helpOverlayHeight = titlerow[1].properties.helpOverlayHeight + row:getHeight() + Helper.borderSize
			end
			local row = ftable:addRow(true, { bgColor = Color["row_background_blue"] })
			row[1]:setColSpan(numCols):createButton({ mouseOverText = setting.info, active = active }):setText(setting.overrideText, { halign = "center", fontsize = config.mapFontSize })
			row[1].handlers.onClick = function () return menu.setFilterOption(menu.displayedFilterLayer, setting, setting.id) end
			titlerow[1].properties.helpOverlayHeight = titlerow[1].properties.helpOverlayHeight + row:getHeight() + Helper.borderSize
		else
			for _, option in ipairs(setting) do
				local optionactive = true
				if option.active then
					optionactive = option.active()
				end
				if setting.type == "checkbox" then
					local row = ftable:addRow(true, {  })
					row[1]:createCheckBox(menu.getFilterOption(option.id, setting.savegame) or false, { scaling = false, width = Helper.scaleY(config.mapRowHeight), height = Helper.scaleY(config.mapRowHeight), active = active and optionactive })
					row[1].handlers.onClick = function () return menu.setFilterOption(menu.displayedFilterLayer, setting, option.id) end
					row[2]:setColSpan(numCols - 1):createText(option.name, { mouseOverText = option.info })
					row[2].properties.color = color
					titlerow[1].properties.helpOverlayHeight = titlerow[1].properties.helpOverlayHeight + row:getHeight() + Helper.borderSize
				elseif setting.type == "slidercell" then
					if option.scale.exceedmax then
						option.scale.start = math.max(option.scale.min, menu.getFilterOption(option.id, setting.savegame)) or option.scale.max
					else
						option.scale.start = math.max(option.scale.min, math.min(option.scale.max, menu.getFilterOption(option.id, setting.savegame))) or option.scale.max
					end
					local row = ftable:addRow(true, {  })
					row[1]:setColSpan(numCols):createSliderCell({ height = config.mapRowHeight, min = option.scale.min, minSelect = option.scale.minSelect, max = option.scale.max, maxSelect = option.scale.maxSelect, start = option.scale.start, step = option.scale.step, suffix = option.scale.suffix, exceedMaxValue = option.scale.exceedmax, mouseOverText = option.info, readOnly = not active, bgColor = (not active) and Color["slider_background_transparent"] or nil, valueColor = (not active) and color or nil }):setText(option.name, {fontsize = config.mapFontSize})
					row[1].handlers.onSliderCellChanged = function (_, value) menu.noupdate = true; return menu.setFilterOption(menu.displayedFilterLayer, setting, option.id, value) end
					row[1].handlers.onSliderCellConfirm = function() menu.noupdate = false end
					titlerow[1].properties.helpOverlayHeight = titlerow[1].properties.helpOverlayHeight + row:getHeight() + Helper.borderSize
				elseif setting.type == "dropdown" then
					local listOptions = option.listOptions()
					local row = ftable:addRow(true, { bgColor = Color["row_background_blue"] })
					row[1]:setColSpan(numCols):createDropDown(listOptions, { height = config.mapRowHeight, startOption = menu.getFilterOption(option.id, setting.savegame), mouseOverText = option.info, active = active }):setTextProperties({ fontsize = config.mapFontSize }):setText2Properties({ fontsize = config.mapFontSize, halign = "right" })
					row[1].handlers.onDropDownConfirmed = function (_, id) return menu.setFilterOption(menu.displayedFilterLayer, setting, option.id, id) end
					row[1].handlers.onDropDownActivated = function () menu.noupdate = true end
					titlerow[1].properties.helpOverlayHeight = titlerow[1].properties.helpOverlayHeight + row:getHeight() + Helper.borderSize
				end
			end
		end
	end
end

function menu.createLegendMode(ftable, numCols)
	ftable.properties.highlightMode = "grey"

	local row = ftable:addRow(true, { fixed = true, bgColor = Color["row_title_background"] })
	row[1]:setColSpan(numCols):createText(ReadText(1001, 9801), Helper.headerRowCenteredProperties)

	for _, entry in ipairs(config.legend) do
		local row = ftable:addRow(true, {  })
		if entry.icon then
			local iconheight = entry.height or 1.5 * config.mapRowHeight
			local iconwidth  = entry.width  or 1.5 * config.mapRowHeight
			local iconx = 0
			if iconwidth < (1.5 * config.mapRowHeight) then
				iconx = (1.5 * config.mapRowHeight - iconwidth) / 2
			end
			local color
			if entry.color then
				if type(entry.color) == "string" then
					color = menu.holomapcolor[entry.color]
				else
					color = entry.color
				end
			end
			row[1]:setColSpan(3):createIcon(entry.icon, { width = iconwidth, height = iconheight, x = iconx, color = color })
			local texty = 0
			local textheight = math.max(math.max(entry.minRowHeight or 0, Helper.standardTextHeight), iconheight)
			if textheight > Helper.standardTextHeight then
				texty = (textheight - Helper.standardTextHeight) / 2
			end
			row[4]:setColSpan(numCols - 3):createText(entry.text, { minRowHeight = entry.minRowHeight, y = texty })
		else
			row[1]:setColSpan(numCols):createText(entry.text, Helper.subHeaderTextProperties)
			row[1].properties.halign = "center"
		end
	end
end

function menu.createHireMode(ftable, numCols)
	local row = ftable:addRow(false, { fixed = true })
	row[1]:setColSpan(numCols):createText(ishiring and ReadText(1001, 3500) or ReadText(1001, 3264), Helper.headerRowCenteredProperties)

	AddUITriggeredEvent(menu.name, "menu_hiremode")

	local npcseed = C.ConvertStringTo64Bit(tostring(menu.modeparam[4]))
	local npc, object
	if npcseed ~= 0 then
		object = ConvertIDTo64Bit(menu.modeparam[2])
	else
		npc = ConvertIDTo64Bit(menu.modeparam[2])
	end
	local ishiring = menu.modeparam[3] ~= 0
	local name
	if npc then
		name = GetComponentData(npc, "name")
	else
		name = ffi.string(C.GetPersonName(npcseed, object))
	end

	local row = ftable:addRow(false, { fixed = true })
	row[1]:setColSpan(5):createText(ReadText(1001, 2809))
	row[6]:setColSpan(numCols - 5):createText(name, { halign = "right" })
	-- Skills
	local possiblePostsAndRoles = {}
	local n = C.GetNumAllControlPosts()
	local buf = ffi.new("ControlPostInfo[?]", n)
	n = C.GetAllControlPosts(buf, n)
	for i = 0, n - 1 do
		table.insert(possiblePostsAndRoles, { name = ffi.string(buf[i].name), post = ffi.string(buf[i].id) })
	end
	table.insert(possiblePostsAndRoles, { name = ReadText(20208, 20103), role = "service" })
	table.insert(possiblePostsAndRoles, { name = ReadText(20208, 20203), role = "marine" })
	table.insert(possiblePostsAndRoles, { name = ReadText(20208, 20503), role = "trainee_group" })
	table.sort(possiblePostsAndRoles, Helper.sortName)

	local row = ftable:addRow(false, { fixed = true })
	row[1]:setColSpan(numCols):createText(ReadText(1001, 3257))
	for _, entry in ipairs(possiblePostsAndRoles) do
		local adjustedskill
		if npc then
			adjustedskill = math.floor(C.GetEntityCombinedSkill(npc, entry.role, entry.post) * 15 / 100)
		else
			adjustedskill = math.floor(C.GetPersonCombinedSkill(object, npcseed, entry.role, entry.post) * 15 / 100)
		end
		local row = ftable:addRow(false, { fixed = true })
		row[1]:setColSpan(5):createText("   " .. entry.name)
		row[6]:setColSpan(numCols - 5):createText(Helper.displaySkill(adjustedskill), { halign = "right", color = Color["text_skills"] })
	end
end

function menu.hireReasonLookup(reason, isbulk)
	if reason == "" then
		return ""
	elseif reason == "invalid" then
		return ReadText(1026, 3236)
	elseif reason == "sameposition" then
		return ReadText(1026, 3237)
	elseif reason == "intransit" then
		return ReadText(1026, 3238)
	elseif reason == "nofreespace" then
		return isbulk and ReadText(1026, 3243) or ReadText(1026, 3239)
	elseif reason == "pilotbusy" then
		return ReadText(1026, 3240)
	elseif reason == "previouspilotbusy" then
		return ReadText(1026, 3241)
	elseif reason == "shiptraderbusy" then
		return ReadText(1026, 3244)
	elseif reason == "postoccupied" then
		return ReadText(1026, 3246)
	end
end

function menu.createInfoSubmenu(inputframe, instance)
	local mode = ""
	local frameheight = inputframe.properties.height
	if (not menu.infoSubmenuObject) or (menu.infoSubmenuObject == 0) then
		-- only get the first selected item. if multiple items selected, whose information do we show?
		for id, content in pairs(menu.selectedcomponents) do
			menu.infoSubmenuObject = ConvertStringTo64Bit(tostring(id))
			break
		end
		if not menu.infoSubmenuObject or menu.infoSubmenuObject == 0 then
			menu.infoSubmenuObject = ConvertStringTo64Bit(tostring(C.GetPlayerOccupiedShipID()))
			if not menu.infoSubmenuObject or menu.infoSubmenuObject == 0 then
				menu.infoSubmenuObject = ConvertStringTo64Bit(tostring(C.GetPlayerContainerID()))
			end
		end
	end

	AddUITriggeredEvent(menu.name, "infomenu_open", menu.infoSubmenuObject)

	local isdatavault, islandmark = GetComponentData(menu.infoSubmenuObject, "isdatavault", "islandmark")
	if C.IsRealComponentClass(menu.infoSubmenuObject, "ship") then
		mode = "ship"
	elseif C.IsRealComponentClass(menu.infoSubmenuObject, "station") then
		mode = "station"
	elseif C.IsComponentClass(menu.infoSubmenuObject, "buildstorage") then
		mode = "buildstorage"
	elseif C.IsComponentClass(menu.infoSubmenuObject, "sector") then
		mode = "sector"
	elseif C.IsComponentClass(menu.infoSubmenuObject, "gate") then
		mode = "gate"
	elseif C.IsComponentClass(menu.infoSubmenuObject, "mine") or C.IsComponentClass(menu.infoSubmenuObject, "navbeacon") or C.IsComponentClass(menu.infoSubmenuObject, "resourceprobe") or C.IsComponentClass(menu.infoSubmenuObject, "satellite") then
		mode = "deployable"
	elseif C.IsComponentClass(menu.infoSubmenuObject, "asteroid") then
		mode = "asteroid"
	elseif C.IsComponentClass(menu.infoSubmenuObject, "lockbox") or C.IsComponentClass(menu.infoSubmenuObject, "collectablewares") then
		mode = "none"
	elseif C.IsComponentClass(menu.infoSubmenuObject, "object") and (isdatavault or islandmark) then
		mode = "none"
	else
		DebugError("menu.createInfoSubmenu(): Selected component " .. tostring(menu.infoSubmenuObject) .. " of class " .. ffi.string(C.GetComponentClass(menu.infoSubmenuObject)) .. " is unsupported. Support?")
	end

	local table_info = inputframe:addTable(8, { tabOrder = 1 })
	table_info:setColWidth(1, config.mapRowHeight)
	table_info:setColWidthMinPercent(2, 20)
	table_info:setColWidthMinPercent(3, 20)
	table_info:setColWidth(4, 4 * config.mapRowHeight)
	table_info:setColWidth(6, 4 * config.mapRowHeight)
	table_info:setColWidth(8, config.mapRowHeight)

	table_info:setDefaultBackgroundColSpan(1, 8)

	menu.setupInfoSubmenuRows(mode, table_info, menu.infoSubmenuObject, instance)

	if menu.selectedRows["infotable" .. instance] then
		table_info:setSelectedRow(menu.selectedRows["infotable" .. instance])
		menu.selectedRows["infotable" .. instance] = nil
		if menu.topRows["infotable" .. instance] then
			table_info:setTopRow(menu.topRows["infotable" .. instance])
			menu.topRows["infotable" .. instance] = nil
		end
	end
	menu.setrow = nil
	menu.settoprow = nil
	menu.setcol = nil

	local isplayerowned, isdeployable, description = GetComponentData(menu.infoSubmenuObject, "isplayerowned", "isdeployable", "description")

	local table_button_bottom = inputframe:addTable(2, { tabOrder = 2 })
	table_button_bottom:setColWidthPercent(2, 50)

	if ((mode == "ship") or (isplayerowned and ((mode == "station") or (mode == "buildstorage")))) and (not C.IsUnit(menu.infoSubmenuObject)) and (not isdeployable) then
		row = table_button_bottom:addRow("info_button_bottom", { fixed = true })
		if mode == "ship" then
			local library = "shiptypes_xs"
			if IsComponentClass(menu.infoSubmenuObject, "ship_xl") then
				library = "shiptypes_xl"
			elseif IsComponentClass(menu.infoSubmenuObject, "ship_l") then
				library = "shiptypes_l"
			elseif IsComponentClass(menu.infoSubmenuObject, "ship_m") then
				library = "shiptypes_m"
			elseif IsComponentClass(menu.infoSubmenuObject, "ship_s") then
				library = "shiptypes_s"
			end

			row[1]:createButton({ active = true }):setText(ReadText(1001, 2400), { halign = "center" })	-- Encyclopedia
			row[1].handlers.onClick = function() Helper.closeMenuAndOpenNewMenu(menu, "EncyclopediaMenu", { 0, 0, "Ships", library, GetComponentData(menu.infoSubmenuObject, "macro") }); menu.cleanup() end
			if isplayerowned then
				row[2]:createButton({ active = true }):setText(ReadText(1001, 1137), { halign = "center" })	-- Ship Overview
				row[2].handlers.onClick = function() Helper.closeMenuAndOpenNewMenu(menu, "ShipConfigurationMenu", { 0, 0, nil, "upgrade", { tostring(menu.infoSubmenuObject) } }) menu.cleanup() end
			end
		elseif mode == "station" then
			row[1]:createButton({ active = true }):setText(ReadText(1001, 1136), { halign = "center" })	-- Configure Station
			row[1].handlers.onClick = function() Helper.closeMenuAndOpenNewMenu(menu, "StationConfigurationMenu", { 0, 0, menu.infoSubmenuObject }) menu.cleanup() end
			row[2]:createButton({ active = true }):setText(ReadText(1001, 1138), { halign = "center" })	-- Station Overview
			row[2].handlers.onClick = function() Helper.closeMenuAndOpenNewMenu(menu, "StationOverviewMenu", { 0, 0, menu.infoSubmenuObject }) menu.cleanup() end
		elseif mode == "buildstorage" then
			local basestation = GetComponentData(menu.infoSubmenuObject, "basestation")
			if basestation then
				row[1]:createButton({ active = true }):setText(ReadText(1001, 1136), { halign = "center" })	-- Configure Station
				row[1].handlers.onClick = function() Helper.closeMenuAndOpenNewMenu(menu, "StationConfigurationMenu", { 0, 0, basestation }) menu.cleanup() end
				row[2]:createButton({ active = true }):setText(ReadText(1001, 1138), { halign = "center" })	-- Station Overview
				row[2].handlers.onClick = function() Helper.closeMenuAndOpenNewMenu(menu, "StationOverviewMenu", { 0, 0, basestation }) menu.cleanup() end
			end
		end
	end
	table_button_bottom.properties.y = frameheight - table_button_bottom:getFullHeight() - Helper.borderSize

	local table_description = inputframe:addTable(1, { tabOrder = 3, highlightMode = "off" })
	row = table_description:addRow(false, { fixed = true, bgColor = Color["row_title_background"] })
	row[1]:createText(ReadText(1001, 2404), Helper.headerRowCenteredProperties)

	local numlines = math.max(6, math.min(12, math.floor(0.2 * frameheight / Helper.scaleY(Helper.standardTextHeight))))
	local descriptiontext = GetTextLines(description, Helper.standardFont, Helper.scaleFont(Helper.standardFont, Helper.standardFontSize), inputframe.properties.width - 2 * Helper.scaleX(Helper.standardTextOffsetx))
	if #descriptiontext > numlines then
		-- scrollbar case
		descriptiontext = GetTextLines(description, Helper.standardFont, Helper.scaleFont(Helper.standardFont, Helper.standardFontSize), inputframe.properties.width - 2 * Helper.scaleX(Helper.standardTextOffsetx) - Helper.scrollbarWidth)
	end
	for linenum, descline in ipairs(descriptiontext) do
		local row = table_description:addRow(true, {  })
		row[1]:createText(descline)
		if linenum == numlines then
			visibleHeight = table_description:getFullHeight()
		end
	end

	if menu.selectedRows["infotable3" .. instance] then
		table_description:setSelectedRow(menu.selectedRows["infotable3" .. instance])
		menu.selectedRows["infotable3" .. instance] = nil
		if menu.topRows["infotable3" .. instance] then
			table_description:setTopRow(menu.topRows["infotable3" .. instance])
			menu.topRows["infotable3" .. instance] = nil
		end
	end

	if visibleHeight then
		table_description.properties.maxVisibleHeight = visibleHeight
	else
		table_description.properties.maxVisibleHeight = table_description:getFullHeight()
	end

	local table_header = menu.createOrdersMenuHeader(inputframe, instance)

	table_info.properties.y = table_header.properties.y + table_header:getFullHeight() + Helper.borderSize
	table_description.properties.y = table_button_bottom.properties.y - table_description:getVisibleHeight() - Helper.borderSize
	table_info.properties.maxVisibleHeight = table_description.properties.y - table_info.properties.y - Helper.borderSize

	table_header:addConnection(1, (instance == "left") and 2 or 3, true)
	table_info:addConnection(2, (instance == "left") and 2 or 3)
	table_description:addConnection(3, (instance == "left") and 2 or 3)
	table_button_bottom:addConnection(4, (instance == "left") and 2 or 3)
end

function menu.createCrewInfoSubmenu(inputframe, instance)
	local mode = ""
	local frameheight = inputframe.properties.height
	if (not menu.infoSubmenuObject) or (menu.infoSubmenuObject == 0) then
		-- only get the first selected item. if multiple items selected, whose information do we show?
		for id, content in pairs(menu.selectedcomponents) do
			menu.infoSubmenuObject = ConvertStringTo64Bit(tostring(id))
			break
		end
		if (not menu.infoSubmenuObject) or (menu.infoSubmenuObject == 0) then
			menu.infoSubmenuObject = ConvertStringTo64Bit(tostring(C.GetPlayerOccupiedShipID()))
			if (not menu.infoSubmenuObject) or (menu.infoSubmenuObject == 0) then
				menu.infoSubmenuObject = ConvertStringTo64Bit(tostring(C.GetPlayerContainerID()))
			end
		end
	end

	AddUITriggeredEvent(menu.name, "crewinfomenu_open", menu.infoSubmenuObject)

	if C.IsRealComponentClass(menu.infoSubmenuObject, "ship_xs") then
		mode = "none"
	elseif GetMacroData(GetComponentData(menu.infoSubmenuObject, "macro"), "islasertower") then
		mode = "none"
	elseif C.IsRealComponentClass(menu.infoSubmenuObject, "ship") then
		mode = "ship"
	elseif C.IsRealComponentClass(menu.infoSubmenuObject, "station") then
		mode = "station"
	elseif C.IsComponentClass(menu.infoSubmenuObject, "sector") then
		mode = "none"
	elseif C.IsComponentClass(menu.infoSubmenuObject, "gate") then
		mode = "none"
	elseif C.IsComponentClass(menu.infoSubmenuObject, "mine") or C.IsComponentClass(menu.infoSubmenuObject, "navbeacon") or C.IsComponentClass(menu.infoSubmenuObject, "resourceprobe") or C.IsComponentClass(menu.infoSubmenuObject, "satellite") then
		mode = "none"
	elseif C.IsComponentClass(menu.infoSubmenuObject, "asteroid") or C.IsComponentClass(menu.infoSubmenuObject, "collectablewares") then
		mode = "none"
	elseif C.IsComponentClass(menu.infoSubmenuObject, "lockbox") then
		mode = "none"
	else
		DebugError("menu.createCrewInfoSubmenu(): Selected component " .. tostring(menu.infoSubmenuObject) .. " of class " .. ffi.string(C.GetComponentClass(menu.infoSubmenuObject)) .. " is unsupported. Support?")
	end

	if (C.IsComponentClass(menu.infoSubmenuObject, "ship") or C.IsComponentClass(menu.infoSubmenuObject, "station")) and (menu.infoTablePersistentData[instance].resetcrew or (menu.infoTablePersistentData[instance].crew.object ~= menu.infoSubmenuObject)) then
		menu.infoSubmenuPrepareCrewInfo(instance)
		menu.infoTablePersistentData[instance].resetcrew = nil
	end

	local table_info = inputframe:addTable(7, { tabOrder = 1 } )
	table_info:setColWidth(1, config.mapRowHeight)
	table_info:setColWidth(2, config.mapRowHeight)
	table_info:setColWidthPercent(4, 25)
	table_info:setColWidth(5, 0.25 * inputframe.properties.width - Helper.borderSize, false)
	table_info:setColWidth(6, 0.25 * inputframe.properties.width - (Helper.scaleY(config.mapRowHeight) + Helper.borderSize) , false)
	table_info:setColWidth(7, config.mapRowHeight)

	table_info:setDefaultBackgroundColSpan(1, 7)

	menu.setupCrewInfoSubmenuRows(mode, table_info, menu.infoSubmenuObject, instance)

	if menu.selectedRows["infotable" .. instance] then
		table_info:setSelectedRow(menu.selectedRows["infotable" .. instance])
		menu.selectedRows["infotable" .. instance] = nil
		if menu.topRows["infotable" .. instance] then
			table_info:setTopRow(menu.topRows["infotable" .. instance])
			menu.topRows["infotable" .. instance] = nil
		end
		if menu.selectedCols["infotable" .. instance] then
			table_info:setSelectedCol(menu.selectedCols["infotable" .. instance])
			menu.selectedCols["infotable" .. instance] = nil
		end
	end
	menu.setrow = nil
	menu.settoprow = nil
	menu.setcol = nil

	local table_header = menu.createOrdersMenuHeader(inputframe, instance)

	table_info.properties.y = table_header.properties.y + table_header:getFullHeight() + Helper.borderSize

	table_header:addConnection(1, (instance == "left") and 2 or 3, true)
	table_info:addConnection(2, (instance == "left") and 2 or 3)
end

function menu.createLoadoutInfoSubmenu(inputframe, instance)
	local mode = ""
	local frameheight = inputframe.properties.height
	if (not menu.infoSubmenuObject) or (menu.infoSubmenuObject == 0) then
		-- only get the first selected item. if multiple items selected, whose information do we show?
		for id, content in pairs(menu.selectedcomponents) do
			menu.infoSubmenuObject = ConvertStringTo64Bit(tostring(id))
			break
		end
		if (not menu.infoSubmenuObject) or (menu.infoSubmenuObject == 0) then
			menu.infoSubmenuObject = ConvertStringTo64Bit(tostring(C.GetPlayerOccupiedShipID()))
			if (not menu.infoSubmenuObject) or (menu.infoSubmenuObject == 0) then
				menu.infoSubmenuObject = ConvertStringTo64Bit(tostring(C.GetPlayerContainerID()))
			end
		end
	end

	AddUITriggeredEvent(menu.name, "loadoutinfomenu_open", menu.infoSubmenuObject)

	if C.IsRealComponentClass(menu.infoSubmenuObject, "ship_xs") then
		mode = "none"
	elseif GetMacroData(GetComponentData(menu.infoSubmenuObject, "macro"), "islasertower") then
		mode = "none"
	elseif C.IsRealComponentClass(menu.infoSubmenuObject, "ship") then
		mode = "ship"
	elseif C.IsRealComponentClass(menu.infoSubmenuObject, "station") then
		mode = "station"
	elseif C.IsComponentClass(menu.infoSubmenuObject, "sector") then
		mode = "none"
	elseif C.IsComponentClass(menu.infoSubmenuObject, "gate") then
		mode = "none"
	elseif C.IsComponentClass(menu.infoSubmenuObject, "mine") or C.IsComponentClass(menu.infoSubmenuObject, "navbeacon") or C.IsComponentClass(menu.infoSubmenuObject, "resourceprobe") or C.IsComponentClass(menu.infoSubmenuObject, "satellite") then
		mode = "none"
	elseif C.IsComponentClass(menu.infoSubmenuObject, "asteroid") or C.IsComponentClass(menu.infoSubmenuObject, "collectablewares") then
		mode = "none"
	elseif C.IsComponentClass(menu.infoSubmenuObject, "lockbox") then
		mode = "none"
	else
		DebugError("menu.createLoadoutInfoSubmenu(): Selected component " .. tostring(menu.infoSubmenuObject) .. " of class " .. ffi.string(C.GetComponentClass(menu.infoSubmenuObject)) .. " is unsupported. Support?")
	end

	local table_info = inputframe:addTable(13, { tabOrder = 1 } )
	table_info:setColWidth(1, config.mapRowHeight)
	table_info:setColWidth(3, config.mapRowHeight)
	table_info:setColWidth(4, config.mapRowHeight)
	table_info:setColWidth(5, config.mapRowHeight)
	table_info:setColWidth(6, config.mapRowHeight)
	table_info:setColWidth(7, 0.25 * inputframe.properties.width - 4 * (Helper.scaleY(config.mapRowHeight) + Helper.borderSize) , false)
	table_info:setColWidth(8, config.mapRowHeight)
	table_info:setColWidth(9, config.mapRowHeight)
	table_info:setColWidth(10, config.mapRowHeight)
	table_info:setColWidth(11, config.mapRowHeight)
	table_info:setColWidth(12, math.max(1, 0.25 * inputframe.properties.width - 5 * (Helper.scaleY(config.mapRowHeight) + Helper.borderSize)) , false)
	table_info:setColWidth(13, config.mapRowHeight)

	table_info:setDefaultBackgroundColSpan(1, 13)

	menu.setupLoadoutInfoSubmenuRows(mode, table_info, menu.infoSubmenuObject, instance)

	if menu.selectedRows["infotable" .. instance] then
		table_info:setSelectedRow(menu.selectedRows["infotable" .. instance])
		menu.selectedRows["infotable" .. instance] = nil
		if menu.topRows["infotable" .. instance] then
			table_info:setTopRow(menu.topRows["infotable" .. instance])
			menu.topRows["infotable" .. instance] = nil
		end
		if menu.selectedCols["infotable" .. instance] then
			table_info:setSelectedCol(menu.selectedCols["infotable" .. instance])
			menu.selectedCols["infotable" .. instance] = nil
		end
	end
	menu.setrow = nil
	menu.settoprow = nil
	menu.setcol = nil

	local table_header = menu.createOrdersMenuHeader(inputframe, instance)

	table_info.properties.y = table_header.properties.y + table_header:getFullHeight() + Helper.borderSize

	table_header:addConnection(1, (instance == "left") and 2 or 3, true)
	table_info:addConnection(2, (instance == "left") and 2 or 3)
end

function menu.createLogbookInfoSubmenu(inputframe, instance)
	local mode = ""
	local frameheight = inputframe.properties.height
	if (not menu.infoSubmenuObject) or (menu.infoSubmenuObject == 0) then
		-- only get the first selected item. if multiple items selected, whose information do we show?
		for id, content in pairs(menu.selectedcomponents) do
			menu.infoSubmenuObject = ConvertStringTo64Bit(tostring(id))
			break
		end
		if (not menu.infoSubmenuObject) or (menu.infoSubmenuObject == 0) then
			menu.infoSubmenuObject = ConvertStringTo64Bit(tostring(C.GetPlayerOccupiedShipID()))
			if (not menu.infoSubmenuObject) or (menu.infoSubmenuObject == 0) then
				menu.infoSubmenuObject = ConvertStringTo64Bit(tostring(C.GetPlayerContainerID()))
			end
		end
	end

	local isvalid = menu.isInfoModeValidFor(menu.infoSubmenuObject, "objectlogbook")

	AddUITriggeredEvent(menu.name, "logbookinfomenu_open", menu.infoSubmenuObject)

	local useSeparatePageRow = true
	local buttonsize = Helper.scaleY(config.mapRowHeight)
	local table_info = inputframe:addTable(10, { tabOrder = 1 } )
	table_info:setColWidth(1, inputframe.properties.width / 3, false)
	table_info:setColWidth(4, config.mapRowHeight)
	table_info:setColWidth(5, config.mapRowHeight)
	table_info:setColWidth(6, config.mapRowHeight)
	table_info:setColWidth(7, config.mapRowHeight)
	table_info:setColWidth(8, inputframe.properties.width / 3 - 4 * (buttonsize + Helper.borderSize), false)
	table_info:setColWidth(9, config.mapRowHeight)
	table_info:setColWidth(10, config.mapRowHeight)

	menu.setupLogbookInfoSubmenuRows(table_info, menu.infoSubmenuObject, instance, isvalid)

	if menu.selectedRows["infotable" .. instance] then
		table_info:setSelectedRow(menu.selectedRows["infotable" .. instance])
		menu.selectedRows["infotable" .. instance] = nil
		if menu.topRows["infotable" .. instance] then
			table_info:setTopRow(menu.topRows["infotable" .. instance])
			menu.topRows["infotable" .. instance] = nil
		end
		if menu.selectedCols["infotable" .. instance] then
			table_info:setSelectedCol(menu.selectedCols["infotable" .. instance])
			menu.selectedCols["infotable" .. instance] = nil
		end
	end
	menu.setrow = nil
	menu.settoprow = nil
	menu.setcol = nil

	local table_header = menu.createOrdersMenuHeader(inputframe, instance)

	table_info.properties.y = table_header.properties.y + table_header:getFullHeight() + Helper.borderSize

	local table_button = inputframe:addTable(3, { tabOrder = 3 } )
	table_button:addEmptyRow()
	local row = table_button:addRow(true, {  })
	row[3]:createButton({ active = isvalid }):setText(ReadText(1001, 5722), { halign = "center" })
	row[3].handlers.onClick = function () return menu.buttonInfoLogbookClearQuestion(instance) end

	local infotableheight = table_info:getFullHeight()
	local buttontableheight = table_button:getFullHeight()
	if table_info.properties.y + infotableheight + buttontableheight + Helper.borderSize + Helper.frameBorder < frameheight then
		table_button.properties.y = table_info.properties.y + infotableheight + Helper.borderSize
	else
		table_button.properties.y = frameheight - Helper.frameBorder - buttontableheight
		table_info.properties.maxVisibleHeight = table_button.properties.y - Helper.borderSize - table_info.properties.y
	end

	table_header:addConnection(1, (instance == "left") and 2 or 3, true)
	table_info:addConnection(2, (instance == "left") and 2 or 3)
	table_button:addConnection(3, (instance == "left") and 2 or 3)
end

function menu.setupInfoSubmenuRows(mode, inputtable, inputobject, instance)
	local object64 = ConvertStringTo64Bit(tostring(inputobject))

	if (not menu.infoTablePersistentData[instance].cashtransferdetails) or (menu.infoTablePersistentData[instance].cashtransferdetails.curobject ~= inputobject) then
		menu.infoTablePersistentData[instance].cashtransferdetails = { curobject = inputobject, transfers = {} }
		menu.infoTablePersistentData[instance].drops = {}
	end

	local infocashtransferdetails = menu.infoTablePersistentData[instance].cashtransferdetails
	local infodrops = menu.infoTablePersistentData[instance].drops

	local indentsize = 0

	local loadout = {}
	if (mode == "ship") or (mode == "station") then
		loadout = { ["component"] = {}, ["macro"] = {}, ["ware"] = {} }
		for i, upgradetype in ipairs(Helper.upgradetypes) do
			if upgradetype.supertype == "macro" then
				loadout.component[upgradetype.type] = {}
				local numslots = 0
				if C.IsComponentClass(inputobject, "defensible") then
					numslots = tonumber(C.GetNumUpgradeSlots(inputobject, "", upgradetype.type))
				end
				for j = 1, numslots do
					local current = C.GetUpgradeSlotCurrentComponent(inputobject, upgradetype.type, j)
					if current ~= 0 then
						table.insert(loadout.component[upgradetype.type], current)
					end
				end
			elseif upgradetype.supertype == "virtualmacro" then
				loadout.macro[upgradetype.type] = {}
				local numslots = tonumber(C.GetNumVirtualUpgradeSlots(inputobject, "", upgradetype.type))
				for j = 1, numslots do
					local current = ffi.string(C.GetVirtualUpgradeSlotCurrentMacro(inputobject, upgradetype.type, j))
					if current ~= "" then
						table.insert(loadout.macro[upgradetype.type], current)
					end
				end
			elseif upgradetype.supertype == "software" then
				loadout.ware[upgradetype.type] = {}
				local numslots = C.GetNumSoftwareSlots(inputobject, "")
				local buf = ffi.new("SoftwareSlot[?]", numslots)
				numslots = C.GetSoftwareSlots(buf, numslots, inputobject, "")
				for j = 0, numslots - 1 do
					local current = ffi.string(buf[j].current)
					if current ~= "" then
						table.insert(loadout.ware[upgradetype.type], current)
					end
				end
			elseif upgradetype.supertype == "ammo" then
				loadout.macro[upgradetype.type] = {}
			end
		end
	end

	local isplayerowned, isonlineobject, isenemy, ishostile = GetComponentData(object64, "isplayerowned", "isonlineobject", "isenemy", "ishostile")
	local titlecolor = Color["text_normal"]
	if isplayerowned then
		titlecolor = menu.holomapcolor.playercolor
		if object64 == C.GetPlayerObjectID() then
			titlecolor = menu.holomapcolor.currentplayershipcolor
		end
	elseif isonlineobject and menu.getFilterOption("layer_other", false) and menu.getFilterOption("think_diplomacy_highlightvisitor", false) then
		titlecolor = menu.holomapcolor.visitorcolor
	elseif ishostile then
		titlecolor = menu.holomapcolor.hostilecolor
	elseif isenemy then
		titlecolor = menu.holomapcolor.enemycolor
	end
	local unknowntext = ReadText(1001, 3210)
	local cheatsecrecy = false
	-- secrecy stuff
	local nameinfo =					cheatsecrecy or C.IsInfoUnlockedForPlayer(inputobject, "name")
	local ownerinfo =					cheatsecrecy or C.IsInfoUnlockedForPlayer(inputobject, "owner")
	local defenceinfo_low =				cheatsecrecy or C.IsInfoUnlockedForPlayer(inputobject, "defence_level")
	local defenceinfo_high =			cheatsecrecy or C.IsInfoUnlockedForPlayer(inputobject, "defence_status")
	local operatorinfo =				cheatsecrecy or C.IsInfoUnlockedForPlayer(inputobject, "operator_name")
	local operatorinfo_details =		cheatsecrecy or C.IsInfoUnlockedForPlayer(inputobject, "operator_details")
	local operatorinfo_commands =		cheatsecrecy or C.IsInfoUnlockedForPlayer(inputobject, "operator_commands")
	local productioninfo_products =		cheatsecrecy or C.IsInfoUnlockedForPlayer(inputobject, "production_products")
	local productioninfo_rate =			cheatsecrecy or C.IsInfoUnlockedForPlayer(inputobject, "production_rate")
	local productioninfo_resources =	cheatsecrecy or C.IsInfoUnlockedForPlayer(inputobject, "production_resources")
	local productioninfo_time =			cheatsecrecy or C.IsInfoUnlockedForPlayer(inputobject, "production_time")
	local storageinfo_capacity =		cheatsecrecy or C.IsInfoUnlockedForPlayer(inputobject, "storage_capacity")
	local storageinfo_amounts =			cheatsecrecy or C.IsInfoUnlockedForPlayer(inputobject, "storage_amounts")
	local storageinfo_warelist =		cheatsecrecy or C.IsInfoUnlockedForPlayer(inputobject, "storage_warelist")
	local unitinfo_capacity =			cheatsecrecy or C.IsInfoUnlockedForPlayer(inputobject, "units_capacity")
	local unitinfo_amount =				cheatsecrecy or C.IsInfoUnlockedForPlayer(inputobject, "units_amount")
	local unitinfo_details =			cheatsecrecy or C.IsInfoUnlockedForPlayer(inputobject, "units_details")

	if not isplayerowned then
		menu.extendedinfo["info_weaponconfig" .. instance] = nil
	end

	--- title ---
	local row = inputtable:addRow(false, { fixed = true, bgColor = Color["row_title_background"] })
	row[1]:setColSpan(8):createText(ReadText(1001, 2427), Helper.headerRowCenteredProperties)

	local row = inputtable:addRow(false, { fixed = true, bgColor = Color["row_title_background"] })
	row[1]:setColSpan(8):createText(ReadText(1001, 1111), Helper.headerRowCenteredProperties)

	local objectname = Helper.unlockInfo(nameinfo, ffi.string(C.GetComponentName(inputobject)))
	--- object name ---
	local row = inputtable:addRow("info_focus", { fixed = true, bgColor = Color["row_title_background"] })
	row[8]:createButton({ width = config.mapRowHeight, cellBGColor = Color["row_background"] }):setIcon("menu_center_selection", { width = config.mapRowHeight, height = config.mapRowHeight, y = (Helper.headerRow1Height - config.mapRowHeight) / 2 })
	row[8].handlers.onClick = function () return C.SetFocusMapComponent(menu.holomap, menu.infoSubmenuObject, true) end
	if (mode == "ship") or (mode == "station") then
		row[1]:setBackgroundColSpan(7):setColSpan(5):createText(objectname, Helper.headerRow1Properties)
		row[1].properties.color = titlecolor
		row[6]:setColSpan(2):createText(Helper.unlockInfo(nameinfo, ffi.string(C.GetObjectIDCode(inputobject))), Helper.headerRow1Properties)
		row[6].properties.halign = "right"
		row[6].properties.color = titlecolor
	else
		row[1]:setBackgroundColSpan(7):setColSpan(7):createText(objectname, Helper.headerRow1Properties)
		row[1].properties.color = titlecolor
	end

	if mode == "ship" then
		locrowdata = { "info_name", ReadText(1001, 2809) .. ReadText(1001, 120), objectname }	-- Name
		if isplayerowned then
			row = inputtable:addRow(locrowdata[1], {  })
			row[2]:setColSpan(2):createText(locrowdata[2], { minRowHeight = config.mapRowHeight, fontsize = config.mapFontSize, font = Helper.standardFont, x = Helper.standardTextOffsetx + indentsize })
			row[4]:setColSpan(5):createEditBox({ height = config.mapRowHeight, description = locrowdata[2] }):setText(objectname, { halign = "right" })
			row[4].handlers.onEditBoxDeactivated = function(_, text, textchanged) return menu.infoChangeObjectName(inputobject, text, textchanged) end
		else
			row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 1, indentsize, nil, nil, false)
		end

		locrowdata = { false, ReadText(1001, 9040) .. ReadText(1001, 120), Helper.unlockInfo(ownerinfo, GetComponentData(object64, "ownername")) }	-- "Owner"
		row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 1, indentsize)

		local loccontainer = nil
		if isdocked then
			loccontainer = ConvertStringTo64Bit(tostring(C.GetTopLevelContainer(inputobject)))
		end
		local objectlocid64 = ConvertStringTo64Bit(tostring(GetComponentData(object64, "sectorid")))
		if objectlocid64 == 0 then
			objectlocid64 = ConvertStringTo64Bit(tostring(GetComponentData(object64, "clusterid")))		-- no sector; object is in superhighway
		end
		local objectloc = Helper.unlockInfo(C.IsInfoUnlockedForPlayer(objectlocid64, "name"), ffi.string(C.GetComponentName(objectlocid64)))
		if loccontainer then
			objectloc = ReadText(1001, 3248) .. " " .. ffi.string(C.GetComponentName(loccontainer)) .. ", " .. objectloc	-- Docked at
		end
		locrowdata = { false, ReadText(1001, 2943) .. ReadText(1001, 120), objectloc }	-- Location
		row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 1, indentsize)

		local macroname, ware, islasertower = GetMacroData(GetComponentData(object64, "macro"), "name", "ware", "islasertower")
		local objecttype = Helper.unlockInfo(nameinfo, macroname)
		locrowdata = { false, ReadText(1001, 94) .. ReadText(1001, 120), objecttype }	-- Model
		row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 1, indentsize)

		if ware then
			local n = C.GetNumWareBlueprintOwners(ware)
			local buf = ffi.new("const char*[?]", n)
			n = C.GetWareBlueprintOwners(buf, n, ware)
			local first = true
			for i = 0, n - 1 do
				local faction = ffi.string(buf[i])
				local name = GetFactionData(faction, "name")
				local known = IsKnownItem("factions", faction)
				if known then
					locrowdata = { false, first and (ReadText(1001, 8391) .. ReadText(1001, 120)) or "", Helper.unlockInfo(nameinfo, name) }	-- Produced by
					row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 1, indentsize)
					first = false
				end
			end
		end

		locrowdata = { false, ReadText(1001, 9051) .. ReadText(1001, 120), Helper.unlockInfo(nameinfo, (function() return tostring(GetComponentData(object64, "shiptypename") or 0, true, 0, true) end)) }	-- Ship Type
		
		-- start: aegs call-back
		if callbacks ["map_shipInformation_shiptypename_override"] then
			local shiptypename_override
			for _, callback in ipairs (callbacks ["map_shipInformation_shiptypename_override"]) do
				shiptypename_override = callback (GetComponentData(object64, "macro"))
				if shiptypename_override then
					locrowdata = { false, ReadText(1001, 9051) .. ReadText(1001, 120), Helper.unlockInfo(nameinfo, (function() return tostring(shiptypename_override or 0, true, 0, true) end)) }
				end
			end
		end
		-- end: aegs call-back

		row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 1, indentsize)

		local hull_max = Helper.unlockInfo(defenceinfo_low, ConvertIntegerString(Helper.round(GetComponentData(object64, "hullmax")), true, 4, true, true, true))
		locrowdata = { false, ReadText(1001, 1) .. ReadText(1001, 120), (defenceinfo_high and (function() return (ConvertIntegerString(Helper.round(GetComponentData(object64, "hull") or 0), true, 4, true, true, true) .. " / " .. hull_max .. " " .. ReadText(1001, 118) .. " (" .. (GetComponentData(object64, "hullpercent") or 0) .. "%)") end) or (unknowntext .. " / " .. hull_max .. " " .. ReadText(1001, 118) .. " (" ..  (GetComponentData(object64, "hullpercent") or 0) .. "%)")) }	-- Hull, MJ
		row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 1, indentsize)

		local shield_max = Helper.unlockInfo(defenceinfo_low, ConvertIntegerString(Helper.round(GetComponentData(object64, "shieldmax")), true, 4, true, true, true))
		locrowdata = { false, ReadText(1001, 2) .. ReadText(1001, 120), (defenceinfo_high and (function() return (ConvertIntegerString(Helper.round(GetComponentData(object64, "shield") or 0), true, 4, true, true, true) .. " / " .. shield_max .. " " .. ReadText(1001, 118) .. " (" .. (GetComponentData(object64, "shieldpercent") or 0) .. "%)") end) or (unknowntext .. " / " .. shield_max .. " " .. ReadText(1001, 118) .. " (" ..  (GetComponentData(object64, "shieldpercent") or 0) .. "%)")) }	-- Shield, MJ
		row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 1, indentsize)

		locrowdata = { true, ReadText(1001, 9076) .. ReadText(1001, 120), defenceinfo_low and (function() return (ConvertIntegerString(Helper.round(GetComponentData(object64, "maxunboostedforwardspeed") or 0), true, 0, true) .. " " .. ReadText(1001, 113)) end) or (unknowntext .. " " .. ReadText(1001, 113)) }	-- Cruising Speed, m/s
		row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 1, indentsize, nil, nil, false)

		local dpstable = ffi.new("DPSData[?]", 6)
		local hasturrets = (defenceinfo_low and #loadout.component.turret > 0)
		local numtotalquadrants = C.GetDefensibleDPS(dpstable, inputobject, true, true, true, true, hasturrets, false, false)
		if not hasturrets then
			locrowdata = { false, ReadText(1001, 9092) .. ReadText(1001, 120), defenceinfo_high and (function() return (ConvertIntegerString(Helper.round(dpstable[0].dps), true, 0, true) .. " " .. ReadText(1001, 119)) end) or (unknowntext .. " " .. ReadText(1001, 119)) }	-- Weapon Output, MW
			row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 1, indentsize)
		else
			for i = 0, numtotalquadrants - 1 do
				locrowdata = { false, (ReadText(1001, 9092) .. " (" .. ReadText(20220, dpstable[i].quadranttextid) .. ")" .. ReadText(1001, 120)), defenceinfo_high and (function() return (ConvertIntegerString(Helper.round(dpstable[i].dps), true, 0, true) .. " " .. ReadText(1001, 119)) end) or (unknowntext .. " " .. ReadText(1001, 119)) }	-- Weapon Output, MW
				row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 1, indentsize)
			end
		end

		local sustainedfwddps = ffi.new("DPSData[?]", 1)
		C.GetDefensibleDPS(sustainedfwddps, inputobject, true, true, true, true, false, true, false)
		if sustainedfwddps[0].dps > 0 then
			locrowdata = { false, ReadText(1001, 9093) .. ReadText(1001, 120), defenceinfo_high and (function() return (ConvertIntegerString(Helper.round(sustainedfwddps[0].dps), true, 0, true) .. " " .. ReadText(1001, 119)) end) or (unknowntext .. " " .. ReadText(1001, 119)) }	-- MW
			row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 1, indentsize)
		end
		-- weapon range
		local range = C.GetDefensibleWeaponFireRange(inputobject, true, true, true, true, true, false)
		if range > 0 then
			locrowdata = { false, ReadText(1001, 11649) .. ReadText(1001, 120), defenceinfo_high and (function() return (ConvertIntegerString(Helper.round(range), true, 0, true) .. " " .. ReadText(1001, 107)) end) or (unknowntext .. " " .. ReadText(1001, 107)) }	-- MW
			row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 1, indentsize)
		end
		-- crew skill
		if (not C.IsRealComponentClass(inputobject, "ship_xs")) and (not islasertower) then
			local shipcombinedskill = math.floor(C.GetShipCombinedSkill(inputobject) * 15 / 100)
			local printedshipcombinedskill = unknowntext
			local locfont = inputfont
			local locfontcolor = Color["text_normal"]
			if operatorinfo_details then
				printedshipcombinedskill = Helper.displaySkill(shipcombinedskill)
				locfontcolor = Color["text_skills"]
			end
			locrowdata = { false, ReadText(1001, 9427) .. ReadText(1001, 120), printedshipcombinedskill }	-- Crew Skill
			row = inputtable:addRow(locrowdata[1], { bgColor = Color["row_background_unselectable"] })
			row[2]:setColSpan(2):createText(locrowdata[2], { minRowHeight = config.mapRowHeight, fontsize = config.mapFontSize, font = inputfont, x = Helper.standardTextOffsetx + indentsize, mouseOverText = ReadText(1026, 1) })
			row[4]:setColSpan(5):createText(locrowdata[3], { halign = "right", minRowHeight = config.mapRowHeight, fontsize = config.mapFontSize, font = locfont, color = locfontcolor, mouseOverText = ReadText(1026, 1) })
		end
		-- radar range
		local radarrange = Helper.unlockInfo(defenceinfo_low, ConvertIntegerString((Helper.round(GetComponentData(object64, "maxradarrange")) / 1000), true, 0, true))
		locrowdata = { false, ReadText(1001, 2426) .. ReadText(1001, 120), (radarrange .. " " .. ReadText(1001, 108)) }	-- Radar Range, km
		row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 1, indentsize)
		-- boarding strength
		locrowdata = { false, ReadText(1001, 1325) .. ReadText(1001, 120), Helper.unlockInfo(defenceinfo_high, (function() return ConvertIntegerString(GetComponentData(object64, "boardingstrength") or 0, true, 0, true) end)) }	-- Boarding Attack Strength
		row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 1, indentsize)
		-- docked ships
		local shipstoragecapacity, numdockingbays = GetComponentData(inputobject, "shipstoragecapacity", "numdockingbays")
		local maxdockedships = (shipstoragecapacity or 0) + (numdockingbays or 0)
		if maxdockedships > 0 then
			local numdockedships = 0
			if C.IsComponentClass(inputobject, "container") then
				numdockedships = C.GetNumDockedShips(inputobject, nil)
			end
			local row = inputtable:addRow("info_dockedships", {  })
			row[1]:createButton({ height = config.mapRowHeight, active = numdockedships > 0 }):setText(function() return (numdockedships > 0 and menu.isInfoExtended("info_dockedships", instance)) and "-" or "+" end, { halign = "center" })
			row[1].handlers.onClick = function() return menu.buttonExtendInfo("info_dockedships", instance) end
			row[1].properties.uiTriggerID = "info_dockedships_toggle"
			row[2]:setColSpan(2):createText(ReadText(1001, 3265) .. ReadText(1001, 120)) -- Docked Ships
			row[4]:setColSpan(5):createText(numdockedships .. " / " .. maxdockedships, { halign = "right" })
			if menu.isInfoExtended("info_dockedships", instance) then
				local dockedships = ffi.new("UniverseID[?]", numdockedships)
				numdockedships = C.GetDockedShips(dockedships, numdockedships, inputobject, nil)
				local playerowneddockedships = {}
				local npcowneddockedships = {}
				for i = 0, numdockedships-1 do
					local locship = ConvertStringTo64Bit(tostring(dockedships[i]))
					if GetComponentData(locship, "isplayerowned") then
						table.insert(playerowneddockedships, locship)
					else
						table.insert(npcowneddockedships, locship)
					end
				end
				table.sort(playerowneddockedships, function(a, b) return GetComponentData(a, "size") > GetComponentData(b, "size") end)
				table.sort(npcowneddockedships, function(a, b) return GetComponentData(a, "size") > GetComponentData(b, "size") end)

				for i, shipid in ipairs(playerowneddockedships) do
					local shipname = ffi.string(C.GetComponentName(shipid))
					local iconid = GetComponentData(shipid, "icon")
					if iconid and iconid ~= "" then
						shipname = string.format("\027[%s] %s", iconid, shipname)
					end
					row = inputtable:addRow("info_dockedship" .. i, {  })
					row[2]:setColSpan(2):createText(shipname, { color = Color["text_player"], x = Helper.standardTextOffsetx + indentsize })
					row[4]:setColSpan(5):createText(("(" .. ffi.string(C.GetObjectIDCode(shipid)) .. ")"), { halign = "right", color = Color["text_player"], x = Helper.standardTextOffsetx + indentsize })
				end
				for i, shipid in ipairs(npcowneddockedships) do
					local shipname = ffi.string(C.GetComponentName(shipid))
					local iconid = GetComponentData(shipid, "icon")
					if iconid and iconid ~= "" then
						shipname = string.format("\027[%s] %s", iconid, shipname)
					end
					row = inputtable:addRow("info_dockedship" .. (#playerowneddockedships + i), {  })
					row[2]:setColSpan(2):createText(shipname, { x = Helper.standardTextOffsetx + indentsize })
					row[4]:setColSpan(5):createText(("(" .. ffi.string(C.GetObjectIDCode(shipid)) .. ")"), { halign = "right", x = Helper.standardTextOffsetx + indentsize })
				end
			end
		end
		-- pilot
		local pilot = GetComponentData(inputobject, "assignedpilot")
		pilot = ConvertIDTo64Bit(pilot)
		local pilotname, skilltable, postname, aicommandstack, aicommand, aicommandparam, aicommandaction, aicommandactionparam = "-", {}, ReadText(1001, 4847), {}
		if pilot and IsValidComponent(pilot) then
			pilotname, skilltable, postname, aicommandstack, aicommand, aicommandparam, aicommandaction, aicommandactionparam = GetComponentData(pilot, "name", "skills", "postname", "aicommandstack", "aicommand", "aicommandparam", "aicommandaction", "aicommandactionparam")
		end
		local isbigship = C.IsComponentClass(inputobject, "ship_m") or C.IsComponentClass(inputobject, "ship_l") or C.IsComponentClass(inputobject, "ship_xl")
		if (not C.IsRealComponentClass(inputobject, "ship_xs")) and (not islasertower) then
			-- title
			local printedtitle = isbigship and ReadText(1001, 4848) or ReadText(1001, 4847)	-- Captain, Pilot
			local row = inputtable:addRow(false, { bgColor = Color["row_title_background"] })
			row[1]:setColSpan(8):createText(printedtitle, Helper.headerRowCenteredProperties)
			if pilot then
				local adjustedskill = math.floor(C.GetEntityCombinedSkill(pilot, nil, "aipilot") * 15 / 100)
				local printedskill = Helper.unlockInfo(operatorinfo_details, Helper.displaySkill(adjustedskill))
				-- name
				local printedpilotname = Helper.unlockInfo(operatorinfo, pilotname)
				local row = inputtable:addRow({ "info_pilot", pilot, inputobject }, {  })
				row[2]:setColSpan(2):createText(ReadText(1001, 2809) .. ReadText(1001, 120))
				row[4]:setColSpan(5):createText(printedpilotname, { halign = "right" })
				-- combined skill
				local row = inputtable:addRow(false, { bgColor = Color["row_background_unselectable"] })
				row[2]:setColSpan(2):createText(ReadText(1001, 8395) .. ReadText(1001, 120), { mouseOverText = ReadText(1026, 2) })
				local locfontcolor = Color["text_normal"]
				if operatorinfo_details then
					locfontcolor = Color["text_skills"]
				end
				row[4]:setColSpan(5):createText(printedskill, { halign = "right", color = locfontcolor, mouseOverText = ReadText(1026, 2) })
			else
				-- name
				local row = inputtable:addRow(false, { bgColor = Color["row_background_unselectable"] })
				row[2]:setColSpan(2):createText(ReadText(1001, 2809) .. ReadText(1001, 120))
				row[4]:setColSpan(5):createText("-", { halign = "right" })
				-- combined skill
				local row = inputtable:addRow(false, { bgColor = Color["row_background_unselectable"] })
				row[2]:setColSpan(2):createText(ReadText(1001, 8395) .. ReadText(1001, 120), { mouseOverText = ReadText(1026, 2) })
				local locfontcolor = Color["text_normal"]
				row[4]:setColSpan(5):createText("-", { halign = "right", color = locfontcolor, mouseOverText = ReadText(1026, 2) })
			end
			-- commander
			local commander = nil
			if C.IsComponentClass(inputobject, "controllable") then
				commander = GetCommander(menu.infoSubmenuObject)
			end
			local commandername, commandercolor = "-", Color["text_normal"]
			if commander then
				commandername, commandercolor = menu.getContainerNameAndColors(commander, 0, false, false)
			end
			local row = inputtable:addRow(false, { bgColor = Color["row_background_unselectable"] })
			row[2]:setColSpan(2):createText(ReadText(1001, 1112) .. ReadText(1001, 120))
			row[4]:setColSpan(5):createText(commandername, { halign = "right", color = commandercolor })
			-- subordinates
			local subordinates = {}
			if C.IsComponentClass(inputobject, "controllable") then
				subordinates = GetSubordinates(inputobject)
			end
			local row = inputtable:addRow("info_subordinates", { interactive = false })
			row[2]:setColSpan(2):createText(ReadText(1001, 1503) .. ReadText(1001, 120)) -- Subordinates
			row[4]:setColSpan(5):createText(#subordinates, { halign = "right" })
			-- current order
			local numorders = C.GetNumOrders(inputobject)
			local currentorders = ffi.new("Order[?]", numorders)
			local activeorder = ffi.new("Order")
			if numorders > 0 then
				numorders = C.GetOrders(currentorders, numorders, inputobject)
				activeorder = currentorders[0]
			else
				C.GetDefaultOrder(activeorder, inputobject)
			end
			local ordername = ReadText(1001, 31)
			local orderdefinition = ffi.new("OrderDefinition")
			if activeorder.orderdef ~= nil and C.GetOrderDefinition(orderdefinition, activeorder.orderdef) then
				ordername = Helper.unlockInfo(operatorinfo_commands, ffi.string(orderdefinition.name))
			end
			local row = inputtable:addRow(false, { bgColor = Color["row_background_unselectable"] })
			row[2]:setColSpan(2):createText(ReadText(1001, 8392) .. ReadText(1001, 120))
			row[4]:setColSpan(5):createText(ordername, { halign = "right" })
			-- command
			if pilot and IsValidComponent(pilot) then
				local row = inputtable:addRow(false, { bgColor = Color["row_background_unselectable"] })
				row[2]:setColSpan(2):createText(ReadText(1001, 78) .. ReadText(1001, 120), { x = Helper.standardIndentStep })
				if #aicommandstack > 0 then
					aicommand = aicommandstack[1].command
					aicommandparam = aicommandstack[1].param
				end
				row[4]:setColSpan(5):createText(Helper.unlockInfo(operatorinfo_commands, string.format(aicommand, IsComponentClass(aicommandparam, "component") and GetComponentData(aicommandparam, "name") or nil)), { halign = "right" })
				local row = inputtable:addRow(false, { bgColor = Color["row_background_unselectable"] })
				local numaicommands = #aicommandstack
				if numaicommands > 1 then
					aicommandaction = aicommandstack[numaicommands].command
					aicommandactionparam = aicommandstack[numaicommands].param
				end
				row[4]:setColSpan(5):createText(Helper.unlockInfo(operatorinfo_commands, string.format(aicommandaction, IsComponentClass(aicommandactionparam, "component") and GetComponentData(aicommandactionparam, "name") or nil)), { halign = "right" })
			end
			if isplayerowned then
				-- transaction log
				local row = inputtable:addRow(true, {  })
				row[2]:setColSpan(2):createText(ReadText(1001, 11286) .. ReadText(1001, 120))
				row[4]:setColSpan(5):createButton({  }):setText(ReadText(1001, 11287), { halign = "center" })
				row[4].handlers.onClick = function() Helper.closeMenuAndOpenNewMenu(menu, "TransactionLogMenu", { 0, 0, inputobject }); menu.cleanup() end
			end
		end
		-- storage
		local storagemodules = GetStorageData(object64)
		local cargotable = {}
		local sortedwarelist = {}
		local simplewarelist = {}
		for _, storagemodule in ipairs(storagemodules) do
			for _, ware in ipairs(storagemodule) do
				table.insert(sortedwarelist, ware)
				simplewarelist[ware.ware] = true
			end
		end

		local isresupplyship = GetComponentData(object64, "cansupplyships")
		if isresupplyship then
			local n = C.GetNumMaxProductionStorage(object64)
			local buf = ffi.new("UIWareAmount[?]", n)
			n = C.GetMaxProductionStorage(buf, n, object64)
			for i = 0, n - 1 do
				local locwareid = ffi.string(buf[i].wareid)
				if not simplewarelist[locwareid] then
					local locware = {}
					locware["ware"] = locwareid
					locware["name"], locware["volume"] = GetWareData(locwareid, "name", "volume")
					locware["amount"] = 0
					locware["consumption"] = buf[i].amount
					table.insert(sortedwarelist, locware)
					--print("inserting " .. tostring(locware.name) .. ". id: " .. tostring(locware.ware) .. ", name: " .. tostring(locware.name) .. ", amount: " .. tostring(locware.amount) .. ", volume: " .. tostring(locware.volume) .. ", consumption: " .. tostring(locware.consumption))
				end
			end
		end

		table.sort(sortedwarelist, function(a, b) return a.name < b.name end)
		for _, ware in ipairs(sortedwarelist) do
			table.insert(cargotable, { ware = ware.ware, amount = ware.amount })
		end
		local row = inputtable:addRow(false, { bgColor = Color["row_title_background"] })
		row[1]:setColSpan(8):createText(ReadText(1001, 1400), Helper.headerRowCenteredProperties) -- Storage
		if storageinfo_warelist then
			-- slider showing total filled capacity
			local n = C.GetNumCargoTransportTypes(inputobject, true)
			local transporttype = ffi.new("StorageInfo[?]", n)
			n = C.GetCargoTransportTypes(transporttype, n, inputobject, true, false)
			for i = 0, n - 1 do
				-- slider showing total filled capacity
				row = inputtable:addRow("info_storage_used_" .. ffi.string(transporttype[i].transport), { interactive = false })
				row[2]:setColSpan(7):createSliderCell({ height = config.mapRowHeight, start = transporttype[i].spaceused, max = transporttype[i].capacity, suffix = ReadText(1001, 110), readOnly = true }):setText((ReadText(1001, 1402) .. " (" .. ffi.string(transporttype[i].name) .. ")" .. ReadText(1001, 120)), { fontsize = config.mapFontSize })
			end

			--local row = inputtable:addRow("info_storage_totalused", {  })
			--row[2]:setColSpan(7):createSliderCell({ height = config.mapRowHeight, start = storagemodules.stored, max = math.max(storagemodules.capacity, storagemodules.stored), suffix = ReadText(1001, 110), readOnly = true }):setText((ReadText(1001, 1402) .. ReadText(1001, 120)), { fontsize = config.mapFontSize })

			if isplayerowned then
				local numtrips = GetComponentData(object64, "numtrips") or 0
				if numtrips > 0 then
					local cargoaftertrades = GetCargoAfterTradeOrders(object64, true)
					local totalvolume = 0
					for ware, amount in pairs(cargoaftertrades) do
						totalvolume = totalvolume + amount * GetWareData(ware, "volume")
					end
					local row = inputtable:addRow("info_storage_future", { interactive = false })
					row[2]:setColSpan(7):createSliderCell({ height = config.mapRowHeight, start = totalvolume, max = math.max(storagemodules.capacity, totalvolume), suffix = ReadText(1001, 110), readOnly = true }):setText((ReadText(1001, 8374) .. ReadText(1001, 120)), { fontsize = config.mapFontSize })
				end
			end

			inputtable:addEmptyRow(config.mapRowHeight / 2)

			local candrop = isplayerowned and (not C.IsUnit(menu.infoSubmenuObject))
			local locpolicefaction = GetComponentData(GetComponentData(object64, "zoneid"), "policefaction")
			for _, wareentry in ipairs(cargotable) do
				local ware = wareentry.ware
				local amount = wareentry.amount
				local targetamount = GetWareProductionLimit(object64, ware)
				if not infodrops[ware] then
					infodrops[ware] = 0
				end
				local row = inputtable:addRow(ware, { interactive = playerowned })
				if not isresupplyship then
					row[2]:setColSpan(7):createSliderCell({ height = config.mapRowHeight, start = amount - infodrops[ware], maxSelect = amount, max = math.max(math.floor(storagemodules.capacity / GetWareData(ware, "volume")), amount - infodrops[ware]), readOnly = not candrop, hideMaxValue = true }):setText(GetWareData(ware, "name"), { fontsize = config.mapFontSize, color = (locpolicefaction and IsWareIllegalTo(ware, GetComponentData(object64, "owner"), locpolicefaction)) and Color["text_illegal"] or Color["text_normal"] })
				else
					-- applies even if targetamount == 0
					if targetamount then
						row[2]:setColSpan(7):createSliderCell({ height = config.mapRowHeight, start = amount - infodrops[ware], maxSelect = amount, max = math.max(targetamount, amount), readOnly = not candrop }):setText(GetWareData(ware, "name"), { fontsize = config.mapFontSize, color = (locpolicefaction and IsWareIllegalTo(ware, GetComponentData(object64, "owner"), locpolicefaction)) and Color["text_illegal"] or Color["text_normal"] })
					else
						row[2]:setColSpan(7):createSliderCell({ height = config.mapRowHeight, start = amount - infodrops[ware], maxSelect = amount, max = amount, readOnly = not candrop, hideMaxValue = true }):setText(GetWareData(ware, "name"), { fontsize = config.mapFontSize, color = (locpolicefaction and IsWareIllegalTo(ware, GetComponentData(object64, "owner"), locpolicefaction)) and Color["text_illegal"] or Color["text_normal"] })
					end
				end

				if candrop then
					--local oldamount = amount
					row[2].handlers.onSliderCellChanged = function(_, newamount) return menu.infoSubmenuUpdateDrops(ware, amount, newamount, instance) end
					row[2].handlers.onSliderCellConfirm = function() return menu.refreshInfoFrame() end
					row[2].handlers.onSliderCellActivated = function() menu.noupdate = true end
					row[2].handlers.onSliderCellDeactivated = function() menu.noupdate = false end

					local row = inputtable:addRow("Drops", {  })
					row[4]:setColSpan(5):createText(function() return (infodrops[ware] ~= 0) and (ReadText(1001, 9406) .. ReadText(1001, 120) .. " (" .. tostring(infodrops[ware]) .. ")") or "" end, { halign = "right", minRowHeight = config.mapRowHeight, fontsize = config.mapFontSize, font = inputfont })	-- Dropping, :
				end
			end

			if candrop then
				local stufftodrop = false
				for ware, numdrops in pairs(infodrops) do
					if numdrops > 0 then
						stufftodrop = true
						break
					end
				end
				local row = inputtable:addRow("ConfirmDrops", {  })

				-- add a "Drop" button
				row[4]:setColSpan(2):createButton({ height = config.mapRowHeight, active = stufftodrop }):setText(ReadText(1001, 9405), { halign = "center", fontsize = config.mapFontSize })	-- Drop
				row[4].handlers.onClick = function() return menu.infoSubmenuConfirmDrops(inputobject, instance) end
				row[6]:setColSpan(3):createButton({ height = config.mapRowHeight, active = stufftodrop }):setText(ReadText(1001, 64), { halign = "center", fontsize = config.mapFontSize })	-- Cancel
				row[6].handlers.onClick = function() return menu.resetInfoSubmenu(nil, instance) end
			end
		else
			local row = inputtable:addRow(false, { bgColor = Color["row_background_unselectable"] })
			row[2]:setColSpan(7):createText(ReadText(1001, 3210))
		end
	elseif (mode == "station") or (mode == "buildstorage") then
		-- general info
		locrowdata = { "info_name", ReadText(1001, 2809), objectname }	-- Name
		if isplayerowned then
			local row = inputtable:addRow(locrowdata[1], {  })
			row[2]:setColSpan(2):createText(locrowdata[2], { minRowHeight = config.mapRowHeight, fontsize = config.mapFontSize, font = Helper.standardFont, x = Helper.standardTextOffsetx + (1 * indentsize) })
			row[4]:setColSpan(5):createEditBox({ height = config.mapRowHeight, description = locrowdata[2] }):setText(objectname, { halign = "right" })
			row[4].handlers.onEditBoxDeactivated = function(_, text, textchanged) return menu.infoChangeObjectName(inputobject, text, textchanged) end
		else
			row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 1, indentsize, nil, nil, false)
		end

		locrowdata = { false, ReadText(1001, 9040), Helper.unlockInfo(ownerinfo, GetComponentData(object64, "ownername")) }	-- Owner
		row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 1, indentsize)

		locrowdata = { false, ReadText(1001, 2943), GetComponentData(object64, "sector") }	-- Location
		row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 1, indentsize)

		if mode == "station" then
			local hull_max = defenceinfo_low and ConvertIntegerString(Helper.round(GetComponentData(object64, "hullmax")), true, 4, true, true, true) or unknowntext
			locrowdata = { false, ReadText(1001, 1), (defenceinfo_high and (function() return (ConvertIntegerString(Helper.round(GetComponentData(object64, "hull")), true, 4, true, true, true) .. " / " .. hull_max .. " " .. ReadText(1001, 118) .. " (" .. GetComponentData(object64, "hullpercent") .. "%)") end) or (unknowntext .. " / " .. hull_max .. " " .. ReadText(1001, 118) .. " (" .. GetComponentData(object64, "hullpercent") .. "%)")) }	-- Hull, MJ
			row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 1, indentsize)
		end

		local radarrange = defenceinfo_low and (Helper.round(GetComponentData(object64, "maxradarrange")) / 1000) or unknowntext
		locrowdata = { false, ReadText(1001, 2426), (radarrange .. " " .. ReadText(1001, 108)) }	-- Radar Range, km
		row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 1, indentsize)
		-- docked ships
		local shipstoragecapacity, numdockingbays = GetComponentData(inputobject, "shipstoragecapacity", "numdockingbays")
		local maxdockedships = (shipstoragecapacity or 0) + (numdockingbays or 0)
		if maxdockedships > 0 then
			local numdockedships = 0
			if C.IsComponentClass(inputobject, "container") then
				numdockedships = C.GetNumDockedShips(inputobject, nil)
			end
			local row = inputtable:addRow("info_dockedships", {  })
			row[1]:createButton({ height = config.mapRowHeight, active = numdockedships > 0 }):setText(function() return (numdockedships > 0 and menu.isInfoExtended("info_dockedships", instance)) and "-" or "+" end, { halign = "center" })
			row[1].handlers.onClick = function() return menu.buttonExtendInfo("info_dockedships", instance) end
			row[1].properties.uiTriggerID = "info_dockedships_toggle"
			row[2]:setColSpan(2):createText(ReadText(1001, 3265) .. ReadText(1001, 120)) -- Docked Ships
			row[4]:setColSpan(5):createText(numdockedships .. " / " .. maxdockedships, { halign = "right" })
			if menu.isInfoExtended("info_dockedships", instance) then
				local dockedships = ffi.new("UniverseID[?]", numdockedships)
				numdockedships = C.GetDockedShips(dockedships, numdockedships, inputobject, nil)
				local playerowneddockedships = {}
				local npcowneddockedships = {}
				for i = 0, numdockedships-1 do
					local locship = ConvertStringTo64Bit(tostring(dockedships[i]))
					if GetComponentData(locship, "isplayerowned") then
						table.insert(playerowneddockedships, locship)
					else
						table.insert(npcowneddockedships, locship)
					end
				end
				table.sort(playerowneddockedships, function(a, b) return GetComponentData(a, "size") > GetComponentData(b, "size") end)
				table.sort(npcowneddockedships, function(a, b) return GetComponentData(a, "size") > GetComponentData(b, "size") end)

				for i, shipid in ipairs(playerowneddockedships) do
					local shipname = ffi.string(C.GetComponentName(shipid))
					local iconid = GetComponentData(shipid, "icon")
					if iconid and iconid ~= "" then
						shipname = string.format("\027[%s] %s", iconid, shipname)
					end
					row = inputtable:addRow("info_dockedship" .. i, {  })
					row[2]:setColSpan(2):createText(shipname, { color = Color["text_player"], x = Helper.standardTextOffsetx + indentsize })
					row[4]:setColSpan(5):createText(("(" .. ffi.string(C.GetObjectIDCode(shipid)) .. ")"), { halign = "right", color = Color["text_player"], x = Helper.standardTextOffsetx + indentsize })
				end
				for i, shipid in ipairs(npcowneddockedships) do
					local shipname = ffi.string(C.GetComponentName(shipid))
					local iconid = GetComponentData(shipid, "icon")
					if iconid and iconid ~= "" then
						shipname = string.format("\027[%s] %s", iconid, shipname)
					end
					row = inputtable:addRow("info_dockedship" .. (#playerowneddockedships + i), {  })
					row[2]:setColSpan(2):createText(shipname, { x = Helper.standardTextOffsetx + indentsize })
					row[4]:setColSpan(5):createText(("(" .. ffi.string(C.GetObjectIDCode(shipid)) .. ")"), { halign = "right", x = Helper.standardTextOffsetx + indentsize })
				end
			end
		end
		-- trade subscription
		locrowdata = { false, ReadText(1001, 9414), (GetComponentData(object64, "tradesubscription") and ReadText(1001, 2617) or ReadText(1001, 2618)) }	-- Updating Trade Offers
		row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 1, indentsize)

		local buildstorage = ConvertIDTo64Bit(GetComponentData(inputobject, "buildstorage"))
		if isplayerowned then
			-- acccounts
			local row = inputtable:addRow(false, { bgColor = Color["row_title_background"] })
			row[1]:setColSpan(8):createText(ReadText(1001, 7708), Helper.headerRowCenteredProperties) -- Account Management
			local playercash = GetPlayerMoney()
			local cashcontainers = {}
			if C.IsComponentClass(inputobject, "container") then
				if mode == "buildstorage" then
					table.insert(cashcontainers, { container = inputobject, estimatetype = "wantedmoney", text = ReadText(1001, 9429), helpoverlayprefix = "info_buildstorage_account_" }) -- Funds for Station Construction
				else
					table.insert(cashcontainers, { container = inputobject, estimatetype = "productionmoney", supply = true, tradewares = true, text = ReadText(1001, 7710), helpoverlayprefix = "info_station_account_" }) -- Station Account
				end
			end
			if buildstorage then
				table.insert(cashcontainers, { container = buildstorage, estimatetype = "wantedmoney", text = ReadText(1001, 9429), helpoverlayprefix = "info_buildstorage_account_" }) -- Funds for Station Construction
			end
			for i, entry in ipairs(cashcontainers) do
				if i ~= 1 then
					inputtable:addEmptyRow(config.mapRowHeight)
				end

				if not infocashtransferdetails.transfers[i] then
					infocashtransferdetails.transfers[i] = { object = entry.container, amount = 0, estimatetype = entry.estimatetype, supply = entry.supply, tradewares = entry.tradewares }
				end

				local row = inputtable:addRow(false, { bgColor = Color["row_title_background"] })
				row[1]:createText("", { cellBGColor = Color["row_background"] })
				row[2]:setColSpan(7):createText(entry.text, Helper.subHeaderTextProperties)

				local container = entry.container
				local containercash = GetAccountData(container, "money") or 0
				local sliderstart = infocashtransferdetails.transfers[i].amount + containercash
				local slidermax = math.max((containercash + playercash), sliderstart)

				local othertransfers = 0
				for j, transferentry in ipairs(infocashtransferdetails.transfers) do
					if j ~= i then
						othertransfers = othertransfers + transferentry.amount
					end
				end
				local slidermaxselect = math.min(math.max((containercash + playercash - othertransfers), sliderstart), slidermax)

				local row = inputtable:addRow("info_stationaccount" .. i, {  })
				row[2]:setColSpan(7):createSliderCell({
					height = config.mapRowHeight,
					start = sliderstart,
					min = math.min(containercash, 0),
					max = slidermax,
					maxSelect = slidermaxselect,
					suffix = ReadText(1001, 101),
					helpOverlayID = entry.helpoverlayprefix .. "slider",
					helpOverlayText = " ",
					helpOverlayHighlightOnly = true,
				})

				row[2].handlers.onSliderCellChanged = function(_, value)
					local idx = i
					local loccash = containercash
					return menu.infoSubmenuUpdateTransferAmount(instance, value, idx, loccash) end
				row[2].handlers.onSliderCellActivated = function() menu.noupdate = true end
				row[2].handlers.onSliderCellDeactivated = function() menu.noupdate = false end
				row[2].handlers.onSliderCellConfirm = function() menu.over = true end

				local row = inputtable:addRow(nil, { bgColor = Color["row_background_unselectable"] })
				row[1]:createText("", { cellBGColor = Color["row_background"] })

				local baseestimate = GetComponentData(container, entry.estimatetype)
				local supplymoney, tradewaremoney = 0, 0
				local estimate = baseestimate
				if entry.supply then
					supplymoney = tonumber(C.GetSupplyBudget(container)) / 100
					estimate = estimate + supplymoney
				end
				if entry.tradewares then
					tradewaremoney = tonumber(C.GetTradeWareBudget(container)) / 100
					estimate = estimate + tradewaremoney
				end

				local text = ReadText(1001, 9434)
				local mouseovertext = ""
				if container == buildstorage then
					text = ReadText(1001, 9436)
				else
					mouseovertext =	ReadText(1001, 8420) .. ReadText(1001, 120) .. " " .. ConvertMoneyString(baseestimate, false, true, 0, true)	.. " " .. ReadText(1001, 101) .. "\n" ..
									ReadText(1001, 8423) .. ReadText(1001, 120) .. " " .. ConvertMoneyString(supplymoney, false, true, 0, true)		.. " " .. ReadText(1001, 101) .. "\n" ..
									ReadText(1001, 8447) .. ReadText(1001, 120) .. " " .. ConvertMoneyString(tradewaremoney, false, true, 0, true)	.. " " .. ReadText(1001, 101)
				end
				row[2]:setColSpan(2):createText(text .. ReadText(1001, 120), { mouseOverText = mouseovertext })
				row[4]:setColSpan(5):createText(ConvertMoneyString(estimate, false, true, nil, true) .. " " .. ReadText(1001, 101), { halign = "right", mouseOverText = mouseovertext })

				local row = inputtable:addRow("info_updateaccount", {  })
				row[3]:createButton({ height = config.mapRowHeight, active = function () local money, estimate, isplayerowned = GetComponentData(container, "money", entry.estimatetype, "isplayerowned"); if not isplayerowned then return false end; if entry.supply then estimate = estimate + tonumber(C.GetSupplyBudget(container)) / 100 end; if entry.tradewares then estimate = estimate + tonumber(C.GetTradeWareBudget(container)) / 100 end; return (money + GetPlayerMoney()) > estimate end, helpOverlayID = entry.helpoverlayprefix .. "accept_estimate", helpOverlayText = " ", helpOverlayHighlightOnly = true }):setText(ReadText(1001, 7965), { halign = "center", fontsize = config.mapFontSize })	-- Accept Estimate
				row[3].handlers.onClick = function () return menu.infoSubmenuSetManagerAccountToEstimate(i, instance) end
				row[4]:setColSpan(2):createButton({ height = config.mapRowHeight, active = function () local isplayerowned = GetComponentData(container, "isplayerowned"); if not isplayerowned then return false end; return menu.checkTransferDetails(i, instance) end }):setText(ReadText(1001, 2821), { halign = "center", fontsize = config.mapFontSize })	-- Confirm
				row[4].handlers.onClick = function () return menu.infoSubmenuUpdateManagerAccount(i, instance) end
				row[6]:setColSpan(3):createButton({ height = config.mapRowHeight, active = function () return menu.checkTransferDetails(i, instance) end }):setText(ReadText(1001, 64), { halign = "center", fontsize = config.mapFontSize })	-- Cancel
				row[6].handlers.onClick = function() return menu.resetInfoSubmenu(i, instance) end
			end
			if mode == "station" then
				-- trade rules
				local row = inputtable:addRow(false, { bgColor = Color["row_title_background"] })
				row[1]:setColSpan(8):createText(ReadText(1001, 11010), Helper.headerRowCenteredProperties)

				local types = {
					{ type = "trade",	name = ReadText(1001, 11017) },
					{ type = "supply",	name = ReadText(1001, 11018) },
					{ type = "build",	name = ReadText(1001, 11019), condition = GetComponentData(inputobject, "canequipships") },
				}
				if buildstorage then
					table.insert(types, { type = "trade",	name = ReadText(1001, 11032), object = buildstorage })
				end
				local displayed = false
				for i, entry in ipairs(types) do
					if (entry.condition == nil) or entry.condition then
						if displayed then
							row = inputtable:addRow(false, {  })
							row[1]:setColSpan(8):createText("")
						end
						displayed = true

						row = inputtable:addRow(false, { bgColor = Color["row_background_unselectable"] })
						row[1]:setColSpan(8):createText(entry.name .. ReadText(1001, 120))

						local object = entry.object or inputobject
						local hasownlist, traderuleid
						if entry.type == "trade" then
							hasownlist = C.HasContainerOwnTradeRule(object, "buy", "") or C.HasContainerOwnTradeRule(object, "sell", "")
							traderuleid = C.GetContainerTradeRuleID(object, "buy", "")
							if traderuleid ~= C.GetContainerTradeRuleID(object, "sell", "") then
								DebugError("menu.setupInfoSubmenuRows(): Mismatch between buy and sell trade rule on station level: " .. tostring(traderuleid) .. " vs " .. tostring(C.GetContainerTradeRuleID(inputobject, "sell", "")))
							end
						else
							hasownlist = C.HasContainerOwnTradeRule(object, entry.type, "")
							traderuleid = C.GetContainerTradeRuleID(object, entry.type, "")
						end

						local rowdata = "info_traderule_" .. entry.type .. "_global"
						local row = inputtable:addRow({ rowdata }, {  })
						row[1]:createCheckBox(not hasownlist, { width = config.mapRowHeight, height = config.mapRowHeight })
						row[1].handlers.onClick = function(_, checked) return menu.checkboxSetTradeRuleOverride(object, entry.type, checked) end
						row[2]:setColSpan(7):createText(ReadText(1001, 8367))

						local row = inputtable:addRow("info_traderule_" .. entry.type .. "_current", {  })
						row[1]:setColSpan(7):createDropDown(Helper.traderuleOptions, { startOption = (traderuleid ~= 0) and traderuleid or -1, active = hasownlist }):setTextProperties({ fontsize = config.mapFontSize })
						row[1].handlers.onDropDownConfirmed = function (_, id) return menu.dropdownTradeRule(object, entry.type, id, nil, true) end
						row[1].handlers.onDropDownActivated = function () menu.noupdate = true end
						row[8]:createButton({ mouseOverText = ReadText(1026, 8407) }):setIcon("menu_edit")
						row[8].handlers.onClick = menu.buttonEditTradeRule
					end
				end
				-- preferred build method
				local row = inputtable:addRow(false, { bgColor = Color["row_title_background"] })
				row[1]:setColSpan(8):createText(ReadText(1001, 11298), Helper.headerRowCenteredProperties)

				local cursetting = ffi.string(C.GetContainerBuildMethod(inputobject))
				local curglobalsetting = ffi.string(C.GetPlayerBuildMethod())
				local foundcursetting = false
				local locresponses = {}
				local n = C.GetNumPlayerBuildMethods()
				if n > 0 then
					local buf = ffi.new("ProductionMethodInfo[?]", n)
					n = C.GetPlayerBuildMethods(buf, n)
					for i = 0, n - 1 do
						local id = ffi.string(buf[i].id)
						-- check if the curglobalsetting (which can be the method of the player's race) is in the list of options
						if id == curglobalsetting then
							foundcursetting = true
						end
						table.insert(locresponses, { id = id, text = ffi.string(buf[i].name), icon = "", displayremoveoption = false })
					end
				end
				-- if the setting is not in the list, default to default (if the race method is not in the list, there is no ware that has this method and it will always use default)
				if not foundcursetting then
					curglobalsetting = "default"
				end
				local hasownsetting = cursetting ~= ""

				local rowdata = "info_buildrule_global"
				local row = inputtable:addRow({ rowdata }, {  })
				row[1]:createCheckBox(not hasownsetting, { width = config.mapRowHeight, height = config.mapRowHeight })
				row[1].handlers.onClick = function(_, checked) return menu.checkboxSetBuildRuleOverride(inputobject, checked, curglobalsetting) end
				row[2]:setColSpan(7):createText(ReadText(1001, 8367))

				local row = inputtable:addRow("info_buildrule", {  })
				row[1]:setColSpan(8):createDropDown(locresponses, { height = Helper.standardTextHeight, startOption = hasownsetting and cursetting or curglobalsetting, active = hasownsetting }):setTextProperties({ fontsize = config.mapFontSize })
				row[1].handlers.onDropDownConfirmed = function (_, id) return menu.dropdownBuildRule(inputobject, id) end
				row[1].handlers.onDropDownActivated = function () menu.noupdate = true end
			end
		end
		if mode == "station" then
			-- manager
			local manager = GetComponentData(inputobject, "tradenpc")
			manager = ConvertIDTo64Bit(manager)
			local managername, skilltable, postname, isfemale = "-", {}, ReadText(1001, 4847)
			if manager then
				managername, skilltable, postname, isfemale = GetComponentData(manager, "name", "skills", "postname", "isfemale")
			end
			-- title
			local printedtitle = (manager and isfemale) and ReadText(20208, 30302) or ReadText(20208, 30301)
			local row = inputtable:addRow(false, { bgColor = Color["row_title_background"] })
			row[1]:setColSpan(8):createText(printedtitle, Helper.headerRowCenteredProperties)
			if manager then
				local adjustedskill = math.floor(C.GetEntityCombinedSkill(manager, nil, "manager") * 15 / 100)
				local printedskill = Helper.unlockInfo(operatorinfo_details, Helper.displaySkill(adjustedskill))
				-- name
				local printedmanagername = Helper.unlockInfo(operatorinfo, managername)
				local row = inputtable:addRow({ "info_pilot", manager, inputobject }, {  })
				row[2]:setColSpan(2):createText(ReadText(1001, 2809) .. ReadText(1001, 120))
				row[4]:setColSpan(5):createText(printedmanagername, { halign = "right" })
				-- combined skill
				local row = inputtable:addRow(false, { bgColor = Color["row_background_unselectable"] })
				row[2]:setColSpan(2):createText(ReadText(1001, 8395) .. ReadText(1001, 120), { mouseOverText = ReadText(1026, 2) })
				local locfontcolor = Color["text_normal"]
				if operatorinfo_details then
					locfontcolor = Color["text_skills"]
				end
				row[4]:setColSpan(5):createText(printedskill, { halign = "right", color = locfontcolor, mouseOverText = ReadText(1026, 2) })
			else
				-- name
				local row = inputtable:addRow(false, { bgColor = Color["row_background_unselectable"] })
				row[2]:setColSpan(2):createText(ReadText(1001, 2809) .. ReadText(1001, 120))
				row[4]:setColSpan(5):createText("-", { halign = "right" })
				-- combined skill
				local row = inputtable:addRow(false, { bgColor = Color["row_background_unselectable"] })
				row[2]:setColSpan(2):createText(ReadText(1001, 8395) .. ReadText(1001, 120), { mouseOverText = ReadText(1026, 2) })
				local locfontcolor = Color["text_normal"]
				row[4]:setColSpan(5):createText("-", { halign = "right", color = locfontcolor, mouseOverText = ReadText(1026, 2) })
			end
			-- subordinates
			local subordinates = C.IsComponentClass(inputobject, "controllable") and GetSubordinates(inputobject) or {}
			local row = inputtable:addRow("info_subordinates", { interactive = false })
			row[2]:setColSpan(2):createText(ReadText(1001, 1503) .. ReadText(1001, 120)) -- Subordinates
			row[4]:setColSpan(5):createText(#subordinates, { halign = "right" })
			if isplayerowned then
				-- transaction log
				local row = inputtable:addRow(true, {  })
				row[2]:setColSpan(2):createText(ReadText(1001, 11286) .. ReadText(1001, 120))
				row[4]:setColSpan(5):createButton({  }):setText(ReadText(1001, 11287), { halign = "center" })
				row[4].handlers.onClick = function() Helper.closeMenuAndOpenNewMenu(menu, "TransactionLogMenu", { 0, 0, inputobject }); menu.cleanup() end
			end
		end
		--storage
		local productiontable = {}
		local products = {}
		local intermediatewares = {}
		local resources = {}
		local productionmodules = GetProductionModules(object64)
		for i, prodmod in ipairs(productionmodules) do
			local macro = GetComponentData(prodmod, "macro")
			local macrodata = GetLibraryEntry(GetMacroData(macro, "infolibrary"), macro)
			for _, productdata in ipairs(macrodata.products) do
				if not products[productdata.ware] then
					products[productdata.ware] = { name = GetWareData(productdata.ware, "name"), amount = 0, ware = productdata.ware }
					products[productdata.ware].listed = false
				end
			end
		end
		list_allresources = GetComponentData(inputobject, "allresources")
		for _, resource in ipairs(list_allresources) do
			if products[resource] then
				intermediatewares[resource] = { name = tostring(GetWareData(resource, "name")), amount = 0, ware = resource }
				intermediatewares[resource].listed = false
				products[resource] = nil
			elseif not resources[resource] then
				resources[resource] = { name = tostring(GetWareData(resource, "name")), amount = 0, ware = resource }
				resources[resource].listed = false
			end
		end
		storagemodules = {capacity = 0, stored = 0}
		if C.IsComponentClass(inputobject, "container") then
			storagemodules = GetStorageData(inputobject)
		end
		cargotable = { products = {text = ReadText(1001, 1610), numcatwares = 0, wares = {}}, intermediatewares = {text = ReadText(1001, 6100), numcatwares = 0, wares = {}}, resources = {text = ReadText(1001, 41), numcatwares = 0, wares = {}}, storage = {text = ReadText(1001, 1400), numcatwares = 0, wares = {}} }	-- Products, Resources, Storage
		local cargocatindex = { "products", "intermediatewares", "resources", "storage" }
		numwares = 0
		local sortedwarelist = {}
		-- numbered: ware (see below); storagemodule.name, storagemodule.consumption, storagemodule.stored, storagemodule.capacity
		for _, storagemodule in ipairs(storagemodules) do
			--print("storage module: " .. tostring(storagemodule.name) .. ", consumption: " .. tostring(storagemodule.consumption) .. ", stored: " .. tostring(storagemodule.stored) .. ", capacity: " .. tostring(storagemodule.capacity))
			-- can query: ware.ware, ware.name, ware.amount, ware.consumption, ware.volume
			for _, ware in ipairs(storagemodule) do
				--print("sortedwarelist. inserting stored ware: " .. ware.name .. ", amount: " .. tostring(ware.amount))
				table.insert(sortedwarelist, ware)
				if resources[ware.ware] then
					--print("resource: " .. ware.name .. " is already listed.")
					resources[ware.ware].listed = true
				end
				if intermediatewares[ware.ware] then
					--print("resource: " .. ware.name .. " is already listed.")
					intermediatewares[ware.ware].listed = true
				end
				if products[ware.ware] then
					--print("product: " .. ware.name .. " is already listed.")
					products[ware.ware].listed = true
				end
			end
		end
		for _, resource in pairs(resources) do
			if not resource.listed then
				--print("sortedwarelist. inserting resource: " .. resource.name)
				table.insert(sortedwarelist, resource)
			end
		end
		for _, intermediateware in pairs(intermediatewares) do
			if not intermediateware.listed then
				--print("sortedwarelist. inserting intermediate ware: " .. intermediateware.name)
				table.insert(sortedwarelist, intermediateware)
			end
		end
		for _, product in pairs(products) do
			if not product.listed then
				--print("sortedwarelist. inserting product: " .. product.name)
				table.insert(sortedwarelist, product)
			end
		end
		table.sort(sortedwarelist, function(a, b) return a.name < b.name end)

		for _, ware in ipairs(sortedwarelist) do
			local usage = "storage"
			if intermediatewares[ware.ware] then
				usage = "intermediatewares"
			elseif products[ware.ware] then
				usage = "products"
			elseif resources[ware.ware] then
				usage = "resources"
			end
			--print("usage: " .. tostring(usage) .. ", ware: " .. tostring(ware.ware) .. ", amount: " .. tostring(ware.amount) .. ", entry: " .. tostring(ware))
			table.insert(cargotable[usage].wares, { ware = ware.ware, amount = ware.amount })
			cargotable[usage].numcatwares = cargotable[usage].numcatwares + 1
			numwares = numwares + 1
		end
		--print("estimated: " .. tostring(storagemodules.estimated) .. ", productionestimated: " .. tostring(storagemodules.productionestimated))
		local loccapacity = (storagemodules.capacity > 0) and storagemodules.capacity or 0
		local locamount = storageinfo_amounts and storagemodules.stored or unknowntext
		local printednumwares = storageinfo_amounts and ConvertIntegerString(numwares, true, 0, true) or unknowntext

		-- ware reservations
		local reservationscapacity = menu.getReservationsVolumeByTransportType(inputobject)
		local reservationscargo = menu.getReservationsAmountByWareType(inputobject)

		-- title
		local row = inputtable:addRow(false, { bgColor = Color["row_title_background"] })
		row[1]:setColSpan(8):createText(ReadText(1001, 1400), Helper.headerRowCenteredProperties)
		if storageinfo_warelist then
			local n = C.GetNumCargoTransportTypes(inputobject, true)
			local transporttype = ffi.new("StorageInfo[?]", n)
			n = C.GetCargoTransportTypes(transporttype, n, inputobject, true, false)
			for i = 0, n - 1 do
				-- slider showing total filled capacity
				local rowdata = {
					inputtable = inputtable,
					textcolumn = 2,
					textcolspan = 7,
					barcolumn = 1,
					currentamount = transporttype[i].spaceused,
					futureamount = transporttype[i].spaceused,
					maxcapacity = transporttype[i].capacity,
					transporttypename = ffi.string(transporttype[i].name)
				}

				if reservationscapacity[ffi.string(transporttype[i].transport)] then
					rowdata.futureamount = rowdata.futureamount + reservationscapacity[ffi.string(transporttype[i].transport)]
				end

				menu.addCapacityRow(rowdata)
			end

			locrowdata = { "info_station_storage", (ReadText(1001, 1400) .. " (" .. printednumwares .. " " .. ((printednumwares == "1") and ReadText(1001, 45) or ReadText(1001, 46)) .. ")") }	-- Storage, Ware, Wares
			local row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, true, (numwares > 0) and true or false, 1, indentsize)
			local setting, list = menu.getTradeWareFilter(true)
			if menu.isInfoExtended(locrowdata[1], instance) then
				for i, usagecat in ipairs(cargocatindex) do
					if (cargotable[usagecat].numcatwares > 0) then
						--print("adding category: " .. cargotable[usagecat].text)
						locrowdata = { false, (cargotable[usagecat].text .. ReadText(1001, 120)) }
						local row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata)
						for _, wareentry in ipairs(cargotable[usagecat].wares) do
							local ware = wareentry.ware
							local currentamount = wareentry.amount
							--print("ware: " .. tostring(ware) .. ", amount: " .. tostring(currentamount))
							locrowdata = { GetWareData(ware, "name"), currentamount }
							local printedwarecapacity = GetWareProductionLimit(inputobject, ware)
							--print("printedwarecapacity: " .. tostring(printedwarecapacity) .. ", amount: " .. tostring(currentamount))
							if (printedwarecapacity < 1) or (printedwarecapacity < currentamount) then
								printedwarecapacity = currentamount
							end

							local buttondata = {
								inputtable = inputtable,
								buttoncolumn = 2,
								buttoncolspan = 7,
								barcolumn = 1,
								currentamount = currentamount,
								futureamount = currentamount,
								maxcapacity = printedwarecapacity,
								warename = GetWareData(ware, "name")
							}

							if reservationscargo[ware] then
								buttondata.futureamount = buttondata.futureamount + reservationscargo[ware]
							end

							buttondata.textcolor, buttondata.buttonscript = menu.getWareButtonColorAndScript(list, setting, ware)
							menu.addWareInfoButtonRow(buttondata)
						end
					end
				end
			end
		else
			local row = inputtable:addRow(false, { bgColor = Color["row_background_unselectable"] })
			row[2]:setColSpan(7):createText(ReadText(1001, 3210))
		end

		-- build storage
		local storagemodules = {}
		local cargotable = {}
		local numwares = 0
		local sortedwarelist = {}
		local list_allresources = {}
		local resources = {}
		local reservationsbuildcapacity = 0
		local reservationsbuildcargo = 0
		if buildstorage then
			-- insert build storage details
			storagemodules = GetStorageData(buildstorage)
			list_allresources = GetComponentData(buildstorage, "allresources")
			-- build storage reservations
			reservationsbuildcapacity = menu.getReservationsAmountTotal(buildstorage)
			reservationsbuildcargo = menu.getReservationsAmountByWareType(buildstorage)
		end
		for _, resource in ipairs(list_allresources) do
			if not resources[resource] then
				resources[resource] = { name = tostring(GetWareData(resource, "name")), amount = 0, ware = resource }
				resources[resource].listed = false
				--print("registering resource: " .. tostring(resource))
			end
		end
		for _, storagemodule in ipairs(storagemodules) do
			for _, ware in ipairs(storagemodule) do
				table.insert(sortedwarelist, ware)
				--print("ware in storage. adding " .. tostring(ware.ware))
				if resources[ware.ware] then
					resources[ware.ware].listed = true
					--print(tostring(ware.ware) .. "is a resource.")
				end
			end
		end
		for _, resource in pairs(resources) do
			if not resource.listed then
				table.insert(sortedwarelist, resource)
				resource.listed = true
				--print("adding unlisted resource: " .. tostring(resource.ware))
			end
		end
		table.sort(sortedwarelist, function(a, b) return a.name < b.name end)
		for _, ware in ipairs(sortedwarelist) do
			table.insert(cargotable, { ware = ware.ware, amount = ware.amount })
			numwares = numwares + 1
		end
		--print("storageinfo_warelist: " .. tostring(storageinfo_warelist) .. " numwares > 0: " .. tostring(numwares > 0))
		--print("buildstorage: " .. ffi.string(C.GetComponentName(buildstorage)) .. " " .. tostring(buildstorage) .. " numwares: " .. tostring(numwares))

		-- title
		if buildstorage then
			local row = inputtable:addRow(false, { bgColor = Color["row_title_background"] })
			row[1]:setColSpan(8):createText(ReadText(20104, 80101), Helper.headerRowCenteredProperties)
			if storageinfo_warelist then
				local n = C.GetNumCargoTransportTypes(buildstorage, true)
				local transporttype = ffi.new("StorageInfo[?]", n)
				n = C.GetCargoTransportTypes(transporttype, n, buildstorage, true, false)
				for i = 0, n - 1 do
					-- slider showing total filled capacity
					local rowdata = {
						inputtable = inputtable,
						textcolumn = 2,
						textcolspan = 7,
						barcolumn = 1,
						currentamount = transporttype[i].spaceused,
						futureamount = transporttype[i].spaceused + reservationsbuildcapacity,
						maxcapacity = transporttype[i].capacity,
						transporttypename = ReadText(20104, 23003)
					}

					menu.addCapacityRow(rowdata)
				end

				local loccapacity = storageinfo_capacity and storagemodules.capacity or unknowntext
				local locamount = storageinfo_amounts and storagemodules.stored or unknowntext
				local printednumwares = storageinfo_amounts and ConvertIntegerString(numwares, true, 0, true) or unknowntext
				locrowdata = { "info_station_buildstorage_storage", (ReadText(1001, 1400) .. " (" .. printednumwares .. " " .. ((printednumwares == "1") and ReadText(1001, 45) or ReadText(1001, 46)) .. ")") }	-- Storage, Ware, Wares
				local row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, true, (numwares > 0) and true or false, 1, indentsize)
				local setting, list = menu.getTradeWareFilter(true)
				if menu.isInfoExtended(locrowdata[1], instance) then
					for _, wareentry in ipairs(cargotable) do
						local ware = wareentry.ware
						local currentamount = wareentry.amount
						--print("ware: " .. tostring(ware) .. ", amount: " .. tostring(currentamount))
						local printedwarecapacity = GetWareProductionLimit(buildstorage, ware)
						--print("printedwarecapacity: " .. tostring(printedwarecapacity) .. ", amount: " .. tostring(currentamount))
						if (printedwarecapacity < 1) or (printedwarecapacity < currentamount) then
							printedwarecapacity = currentamount
						end
						locrowdata = { GetWareData(ware, "name"), currentamount }

						local buttondata = {
							inputtable = inputtable,
							buttoncolumn = 2,
							buttoncolspan = 7,
							barcolumn = 1,
							currentamount = currentamount,
							futureamount = currentamount,
							maxcapacity = printedwarecapacity,
							warename = GetWareData(ware, "name")
						}

						if reservationsbuildcargo[ware] then
							buttondata.futureamount = buttondata.futureamount + reservationsbuildcargo[ware]
						end

						buttondata.textcolor, buttondata.buttonscript = menu.getWareButtonColorAndScript(list, setting, ware)
						menu.addWareInfoButtonRow(buttondata)
					end
				end
			else
				local row = inputtable:addRow(false, { bgColor = Color["row_background_unselectable"] })
				row[2]:setColSpan(7):createText(ReadText(1001, 3210))
			end
		end

	elseif mode == "sector" then
		-- general info
		locrowdata = { "info_name", ReadText(1001, 2809), objectname }	-- Name
		if isplayerowned then
			row = inputtable:addRow(locrowdata[1], {  })
			row[2]:setColSpan(2):createText(locrowdata[2], { minRowHeight = config.mapRowHeight, fontsize = config.mapFontSize, font = Helper.standardFont, x = Helper.standardTextOffsetx + (1 * indentsize) })
			row[4]:setColSpan(5):createEditBox({ height = config.mapRowHeight, description = locrowdata[2] }):setText(objectname, { halign = "right" })
			row[4].handlers.onEditBoxDeactivated = function(_, text, textchanged) return menu.infoChangeObjectName(inputobject, text, textchanged) end
		else
			row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 1, indentsize)
		end

		local owner = GetComponentData(object64, "ownername")
		if C.IsContestedSector(object64) then
			owner = owner .. " " .. ReadText(1001, 3247)
		end
		locrowdata = { false, ReadText(1001, 9040), Helper.unlockInfo(ownerinfo, owner) }	-- Owner
		row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 1, indentsize)

		local stationtable = GetContainedStations(object64, true)
		local numstations = #stationtable
		local productiontable = {}
		local products = {}
		local sectorpopulation = 0
		for _, station in ipairs(stationtable) do
			local workforceinfo = C.GetWorkForceInfo(ConvertStringTo64Bit(tostring(station)), "")
			sectorpopulation = sectorpopulation + workforceinfo.current
			table.insert(productiontable, GetComponentData(station, "products"))
		end
		for _, entry in ipairs(productiontable) do
			for _, product in ipairs(entry) do
				local notincremented = true
				for compproduct, count in pairs(products) do
					if compproduct == product then
						products[product] = count + 1
						notincremented = false
						break
					end
				end
				if notincremented then
					products[product] = 1
				end
			end
		end
		local maxproductgrp = ReadText(1001, 9002)	-- Unknown
		local maxcount = 0
		for product, count in pairs(products) do
			if not maxproductgrp or (count > maxcount) then
				maxproductgrp = GetWareData(product, "groupName")
				maxcount = count
			end
		end

		locrowdata = { false, ReadText(1001, 9041), ConvertIntegerString(tonumber(C.GetSectorPopulation(object64)), true, 3, true) }	-- Population
		row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 1, indentsize)

		locrowdata = { false, ReadText(1001, 11296), string.format("%+.0f%%", GetComponentData(object64, "populationworkforcefactor") * 100) }	-- Workforce Availability Bonus
		row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 1, indentsize)

		locrowdata = { false, ReadText(1001, 2456), ConvertIntegerString(sectorpopulation, true, 3, true) }	-- Station Workforce
		row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 1, indentsize)

		locrowdata = { false, ReadText(1001, 9042), (numstations > 0 and numstations or 0) }	-- Known Stations
		row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 1, indentsize)

		locrowdata = { false, ReadText(1001, 9050), maxproductgrp }	-- Main Production
		row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 1, indentsize)

		-- natural resources
		local row = inputtable:addRow(false, { bgColor = Color["row_title_background"] })
		row[1]:setColSpan(8):createText(ReadText(1001, 9423), Helper.headerRowCenteredProperties) -- Natural Resources
		local sunlight = (GetComponentData(object64, "sunlight") * 100 .. "%")
		locrowdata = { false, ReadText(1001, 2412), sunlight }	-- Sunlight
		row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 1, indentsize)

		local resources = {}
		local n = C.GetNumDiscoveredSectorResources(object64)
		local buf = ffi.new("WareYield[?]", n)
		n = C.GetDiscoveredSectorResources(buf, n, object64)
		for i = 0, n - 1 do
			table.insert(resources, { name = GetWareData(ffi.string(buf[i].ware), "name"), current = buf[i].current, max = buf[i].max })
		end
		table.sort(resources, Helper.sortName)

		for _, entry in ipairs(resources) do
			locrowdata = { false, entry.name, ConvertIntegerString(entry.current, true, 3, true) }
			row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 1, indentsize)
		end

		-- TODO: Add Region info: NB: Matthias says that yield numbers for regions could be too big to be useful, and that retrieving that info is very inefficient. But we'll try when the function is up.

	elseif mode == "gate" then
		-- general info
		local isgateactive = GetComponentData(object64, "isactive")
		local gatedestinationsector, gatedestinationsector64
		local gatedestination = unknowntext
		if isgateactive then
			local destgate = GetComponentData(object64, "destination")
			if destgate then
				gatedestinationsector = GetContextByClass(destgate, "sector")
				gatedestinationsector64 = ConvertStringTo64Bit(tostring(gatedestinationsector))
				local destspace = Helper.getDisplayableGateDestinationSpace(object64)
				if destspace then
					gatedestination = GetComponentData(destspace, "name")
				end
			end
		end
		locrowdata = { false, ReadText(1001, 3215), tostring(gatedestination) }	-- (gate) Destination
		row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 1, indentsize)

		local destinationowner = unknowntext
		if C.IsInfoUnlockedForPlayer(gatedestinationsector64, "name") then
			destinationowner = GetComponentData(gatedestinationsector, "ownername") or ""
			if C.IsContestedSector(gatedestinationsector64) then
				destinationowner = destinationowner .. " " .. ReadText(1001, 3247)
			end
		end
		locrowdata = { false, ReadText(1001, 9424), tostring(destinationowner) }	-- Destination Owner
		row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 1, indentsize)

		locrowdata = { false, ReadText(1001, 9425), (isgateactive and ReadText(1001, 2617) or ReadText(1001, 2618)) }	-- Active, Yes, No
		row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 1, indentsize)
	elseif mode == "deployable" then
		-- general info
		locrowdata = { "info_name", ReadText(1001, 2809), objectname }	-- Name
		if isplayerowned then
			row = inputtable:addRow(locrowdata[1], {  })
			row[2]:setColSpan(2):createText(locrowdata[2], { minRowHeight = config.mapRowHeight, fontsize = config.mapFontSize, font = Helper.standardFont, x = Helper.standardTextOffsetx + (1 * indentsize) })
			row[4]:setColSpan(5):createEditBox({ height = config.mapRowHeight, description = locrowdata[2] }):setText(objectname, { halign = "right" })
			row[4].handlers.onEditBoxDeactivated = function(_, text, textchanged) return menu.infoChangeObjectName(inputobject, text, textchanged) end
		else
			row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 1, indentsize)
		end

		locrowdata = { false, ReadText(1001, 9040), Helper.unlockInfo(ownerinfo, GetComponentData(inputobject, "ownername")) }	-- Owner
		row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 1, indentsize)

		locrowdata = { false, ReadText(1001, 2943), GetComponentData(inputobject, "sector") }	-- Location
		row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 1, indentsize)

		local hull_max = defenceinfo_low and ConvertIntegerString(Helper.round(GetComponentData(inputobject, "hullmax")), true, 4, true, true, true) or unknowntext
		locrowdata = { false, ReadText(1001, 1), (defenceinfo_high and (function() return (ConvertIntegerString(Helper.round(GetComponentData(inputobject, "hull")), true, 4, true, true, true) .. " / " .. hull_max .. " " .. ReadText(1001, 118) .. " (" .. GetComponentData(inputobject, "hullpercent") .. "%)") end) or (unknowntext .. " / " .. hull_max .. " " .. ReadText(1001, 118) .. " (" .. unknowntext .. "%)")) }	-- Hull, MJ
		row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 1, indentsize)

		local radarrange, resourcedetectionrange = unknowntext, unknowntext
		if defenceinfo_low then
			radarrange, resourcedetectionrange = GetComponentData(inputobject, "maxradarrange", "resourcedetectionrange")
		end

		if C.IsComponentClass(menu.infoSubmenuObject, "mine") then
			-- add if mines are made selectable in the map again:
			--	detonation output (s), tracking capability (s), friend/foe (s), proximity (s)
		elseif C.IsComponentClass(menu.infoSubmenuObject, "resourceprobe") then
			if resourcedetectionrange and resourcedetectionrange ~= unknowntext then
				resourcedetectionrange = Helper.round(resourcedetectionrange / 1000)
			end
			locrowdata = { "info_radarrange", ReadText(1001, 9082), (resourcedetectionrange .. " " .. ReadText(1001, 108)) }	-- Scanning Range, km
			row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 1, indentsize)
		elseif C.IsComponentClass(menu.infoSubmenuObject, "satellite") then
			if radarrange and radarrange ~= unknowntext then
				radarrange = Helper.round(radarrange / 1000)
			end
			locrowdata = { false, ReadText(1001, 2426), (radarrange .. " " .. ReadText(1001, 108)) }	-- Radar Range, km
			row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 1, indentsize)
		end
	elseif mode == "asteroid" then
		-- general info
		local rawlength = GetComponentData(inputobject, "length")
		local rawwidth = GetComponentData(inputobject, "width")
		local rawheight = GetComponentData(inputobject, "height")
		local loclength = ConvertIntegerString(rawlength, true, 0, true)
		local locwidth = ConvertIntegerString(rawwidth, true, 0, true)
		local locheight = ConvertIntegerString(rawheight, true, 0, true)
		locrowdata = { false, ReadText(1001, 9229), (loclength .. ReadText(1001, 107) .. " " .. ReadText(1001, 42) .. " " .. locwidth .. ReadText(1001, 107) .. " " .. ReadText(1001, 42) .. " " .. locheight .. ReadText(1001, 107)) }	-- m, x
		row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 1, indentsize)

		local rawvolume = rawlength * rawwidth * rawheight
		local locvolume = ConvertIntegerString(rawvolume, true, 0, true)
		locrowdata = { false, ReadText(1001, 1407), (locvolume .. " " .. ReadText(1001, 110)) }	-- Volume, m^3
		row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 1, indentsize)

		local wares = GetComponentData(inputobject, "wares")
		local hasyield = false
		if wares then
			for _, ware in ipairs(wares) do
				if ware.amount > 0 then
					hasyield = true
					break
				end
			end

			if hasyield then
				locrowdata = { false, ReadText(1001, 3214) .. ReadText(1001, 120) }	-- Yield, :
				row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 1, indentsize)

				for i, ware in ipairs(wares) do
					if ware.amount > 0 then
						local warename = GetWareData(ware.ware, "name")
						locrowdata = { false, warename, ware.amount }
						row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 2, indentsize)
					end
				end
			end
		end
	elseif mode == "none" then
		local locrowdata = { "info_none", ReadText(1001, 6526) }
		row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false)
	else
		DebugError("menu.setupInfoSubmenuRows(): called with unsupported mode: " .. tostring(mode) .. ".")
	end

	-- [UniTrader's Advanced Renaming] Forleyor start: callback
	if callbacks ["utRenaming_setupInfoSubmenuRows_on_end"] then
		for _, callback in ipairs (callbacks ["utRenaming_setupInfoSubmenuRows_on_end"]) do
			callback(mode, inputtable, inputobject, instance)
		end
	end
	-- [UniTrader's Advanced Renaming] Forleyor end: callback
end

function menu.setupCrewInfoSubmenuRows(mode, inputtable, inputobject, instance)
	local infocrew = menu.infoTablePersistentData[instance].crew

	local object64 = ConvertStringTo64Bit(tostring(inputobject))
	local isplayerowned, isonlineobject, isenemy, ishostile = GetComponentData(object64, "isplayerowned", "isonlineobject", "isenemy", "ishostile")
	local titlecolor = Color["text_normal"]
	if isplayerowned then
		titlecolor = menu.holomapcolor.playercolor
		if object64 == C.GetPlayerObjectID() then
			titlecolor = menu.holomapcolor.currentplayershipcolor
		end
	elseif isonlineobject and menu.getFilterOption("layer_other", false) and menu.getFilterOption("think_diplomacy_highlightvisitor", false) then
		titlecolor = menu.holomapcolor.visitorcolor
	elseif ishostile then
		titlecolor = menu.holomapcolor.hostilecolor
	elseif isenemy then
		titlecolor = menu.holomapcolor.enemycolor
	end

	local cheatsecrecy = false
	-- secrecy stuff
	local nameinfo =					cheatsecrecy or C.IsInfoUnlockedForPlayer(inputobject, "name")
	local operatorinfo =				cheatsecrecy or C.IsInfoUnlockedForPlayer(inputobject, "operator_name")
	local operatorinfo_details =		cheatsecrecy or C.IsInfoUnlockedForPlayer(inputobject, "operator_details")
	local operatorinfo_commands =		cheatsecrecy or C.IsInfoUnlockedForPlayer(inputobject, "operator_commands")

	--- title ---
	local row = inputtable:addRow(false, { fixed = true, bgColor = Color["row_title_background"] })
	row[1]:setColSpan(7):createText(ReadText(1001, 2427), Helper.headerRowCenteredProperties)
	local row = inputtable:addRow(false, { fixed = true, bgColor = Color["row_title_background"] })
	row[1]:setColSpan(7):createText(ReadText(1001, 80), Helper.headerRowCenteredProperties)

	local objectname = Helper.unlockInfo(nameinfo, ffi.string(C.GetComponentName(inputobject)))

	-- object name
	local row = inputtable:addRow("info_focus", { fixed = true, bgColor = Color["row_title_background"] })
	row[7]:createButton({ width = config.mapRowHeight, cellBGColor = Color["row_background"] }):setIcon("menu_center_selection", { width = config.mapRowHeight, height = config.mapRowHeight, y = (Helper.headerRow1Height - config.mapRowHeight) / 2 })
	row[7].handlers.onClick = function () return C.SetFocusMapComponent(menu.holomap, menu.infoSubmenuObject, true) end
	if (mode == "ship") or (mode == "station") then
		row[1]:setBackgroundColSpan(6):setColSpan(5):createText(objectname, Helper.headerRow1Properties)
		row[1].properties.color = titlecolor
		row[6]:createText(Helper.unlockInfo(nameinfo, ffi.string(C.GetObjectIDCode(inputobject))), Helper.headerRow1Properties)
		row[6].properties.halign = "right"
		row[6].properties.color = titlecolor
	else
		row[1]:setBackgroundColSpan(6):setColSpan(6):createText(objectname, Helper.headerRow1Properties)
		row[1].properties.color = titlecolor
	end

	if mode == "ship" then
		local pilot = ConvertIDTo64Bit(GetComponentData(inputobject, "assignedpilot"))
		local pilotname, skilltable, aicommandstack, aicommand, aicommandparam, aicommandaction, aicommandactionparam = "-", {}, {}
		if pilot and IsValidComponent(pilot) then
			pilotname, skilltable, aicommandstack, aicommand, aicommandparam, aicommandaction, aicommandactionparam = GetComponentData(pilot, "name", "skills", "aicommandstack", "aicommand", "aicommandparam", "aicommandaction", "aicommandactionparam")
		end

		local isbigship = C.IsComponentClass(inputobject, "ship_m") or C.IsComponentClass(inputobject, "ship_l") or C.IsComponentClass(inputobject, "ship_xl")
		-- pilot
		local printedtitle = isbigship and ReadText(1001, 4848) or ReadText(1001, 4847)	-- Captain, Pilot
		local row = inputtable:addRow(false, { bgColor = Color["row_title_background"] })
		row[1]:setColSpan(7):createText(printedtitle, Helper.headerRowCenteredProperties)
		if pilot then
			local adjustedskill = math.floor(C.GetEntityCombinedSkill(pilot, nil, "aipilot") * 15 / 100)
			local printedskill = Helper.unlockInfo(operatorinfo_details, Helper.displaySkill(adjustedskill))
			-- name
			local printedpilotname = Helper.unlockInfo(operatorinfo, pilotname)
			local row = inputtable:addRow({ "info_pilot", pilot, inputobject }, {  })
			row[2]:setColSpan(4):createText(printedpilotname)
			local locfontcolor
			if operatorinfo_details then
				locfontcolor = Color["text_skills"]
			end
			row[6]:setColSpan(2):createText(printedskill, { halign = "right", color = locfontcolor, mouseOverText = ReadText(1026, 2) })
			-- skills
			table.sort(skilltable, function(a, b) return a.relevance > b.relevance end)
			for _, skillproperties in ipairs(skilltable) do
				local skillname = ReadText(1013, skillproperties.textid)
				local adjustedskill = skillproperties.value
				local printedskill = Helper.unlockInfo(operatorinfo_details, Helper.displaySkill(adjustedskill, skillproperties.relevance > 0))
				local mouseovertext = ReadText(1013, skillproperties.descriptionid)
				local row = inputtable:addRow(false, { bgColor = Color["row_background_unselectable"] })
				row[3]:setColSpan(3):createText(skillname, { font = (skillproperties.relevance > 0) and Helper.standardFontBold or nil, color = (skillproperties.relevance > 0) and Color["text_normal"] or Color["text_inactive"], mouseOverText = mouseovertext })
				local locfontcolor
				if operatorinfo_details then
					locfontcolor = (skillproperties.relevance > 0) and Color["text_skills"] or Color["text_skills_irrelevant"]
				end
				row[6]:setColSpan(2):createText(printedskill, { halign = "right", color = locfontcolor, mouseOverText = mouseovertext })
			end
			-- replace pilot
			if isplayerowned then
				local line_replace = isbigship and ReadText(1001, 9430) or ReadText(1001, 9431)	-- Replace captain with best crewmember, Replace pilot with best crewmember
				-- button is clickable if:
				-- we have crew,
				-- we have a pilot,
				-- the pilot is not in a critical state (NPC_State_Machines),
				-- the controllable is not running an order in a critical state,
				-- and one of our crew members is better than the current pilot.
				-- NB: check to see if there is a pilot is necessary since there is a delay between pressing this button and the old pilot getting dismissed leading to errors in the later checks.
				local row = inputtable:addRow("ReplacePilot", {  })
				row[2]:setColSpan(6):createButton({ height = config.mapRowHeight, active = function() local locpilot = GetComponentData(inputobject, "assignedpilot"); return (infocrew.current.total > 0) and locpilot and IsValidComponent(locpilot) and (not C.IsCurrentOrderCritical(inputobject)) and menu.infoSubmenuReplacePilot(inputobject, ConvertIDTo64Bit(locpilot), nil, true, nil, instance) end }):setText(line_replace, { halign = "center", fontsize = config.mapFontSize })
				row[2].handlers.onClick = function() return menu.infoSubmenuReplacePilot(inputobject, pilot, nil, nil, nil, instance) end
			end
		else
			-- name
			local printedpilotname = Helper.unlockInfo(operatorinfo, pilotname)
			local row = inputtable:addRow(false, { bgColor = Color["row_background_unselectable"] })
			row[2]:setColSpan(4):createText("-")
			row[6]:setColSpan(2):createText("-", { halign = "right", mouseOverText = ReadText(1026, 2) })
			if isplayerowned then
				-- replace pilot
				local line_replace = ReadText(1001, 9432) .. " " .. printedtitle	-- Promote best crewmember to
				local row = inputtable:addRow("ReplacePilot", {  })
				row[2]:setColSpan(5):createButton({ height = config.mapRowHeight, active = function () return (infocrew.current.total > 0) and menu.infoSubmenuReplacePilot(inputobject, nil, nil, true, nil, instance) end }):setText(line_replace, { halign = "center", fontsize = config.mapFontSize })
				row[2].handlers.onClick = function() return menu.infoSubmenuReplacePilot(inputobject, nil, nil, nil, nil, instance) end
			end
		end
		-- commander
		local commander
		if C.IsComponentClass(inputobject, "controllable") then
			commander = GetCommander(menu.infoSubmenuObject)
		end
		local commandername, commandercolor = "-", Color["text_normal"]
		if commander then
			commandername, commandercolor = menu.getContainerNameAndColors(commander, 0, false, false)
		end
		local row = inputtable:addRow(false, { bgColor = Color["row_background_unselectable"] })
		row[2]:setColSpan(3):createText(ReadText(1001, 1112) .. ReadText(1001, 120))
		row[5]:setColSpan(3):createText(commandername, { halign = "right", color = commandercolor })
		-- subordinates
		local subordinates = {}
		if C.IsComponentClass(inputobject, "controllable") then
			subordinates = GetSubordinates(inputobject)
		end
		local row = inputtable:addRow("info_subordinates", {  })
		row[1]:createButton({ height = config.mapRowHeight, active = #subordinates > 0 }):setText(function() return (#subordinates > 0 and menu.isInfoExtended("info_subordinates", instance)) and "-" or "+" end, { halign = "center" })
		row[1].handlers.onClick = function() return menu.buttonExtendInfo("info_subordinates", instance) end
		row[1].properties.uiTriggerID = "info_subordinates_toggle"
		row[2]:setColSpan(4):createText(ReadText(1001, 1503) .. ReadText(1001, 120)) -- Subordinates
		row[6]:setColSpan(2):createText(#subordinates, { halign = "right" })
		if (#subordinates > 0) and menu.isInfoExtended("info_subordinates", instance) then
			for i, locship in ipairs(subordinates) do
				local locship64 = ConvertIDTo64Bit(locship)
				subordinates[i] = { id = locship64, name = ffi.string(C.GetComponentName(locship64)), objectid = ffi.string(C.GetObjectIDCode(locship64)), class = ffi.string(C.GetComponentClass(locship64)), purpose = GetComponentData(locship, "primarypurpose") }
			end
			table.sort(subordinates, Helper.sortShipsByClassAndPurpose)

			for i, shipentry in ipairs(subordinates) do
				local shipname, textcolor = menu.getContainerNameAndColors(shipentry.id, 0, false, false)

				local row = inputtable:addRow("info_subordinate" .. i, {  })
				row[3]:setColSpan(4):createText(shipname, { color = textcolor })
				row[7]:createButton({ height = config.mapRowHeight }):setIcon("menu_center_selection", { width = Helper.standardTextHeight, height = Helper.standardTextHeight })
				row[7].handlers.onClick = function () return C.SetFocusMapComponent(menu.holomap, shipentry.id, true) end
			end
		end
		-- current order
		local numorders = C.GetNumOrders(inputobject)
		local currentorders = ffi.new("Order[?]", numorders)
		local activeorder = ffi.new("Order")
		if numorders > 0 then
			numorders = C.GetOrders(currentorders, numorders, inputobject)
			activeorder = currentorders[0]
		else
			C.GetDefaultOrder(activeorder, inputobject)
		end
		local ordername = ReadText(1001, 31)
		local orderdefinition = ffi.new("OrderDefinition")
		if activeorder.orderdef ~= nil and C.GetOrderDefinition(orderdefinition, activeorder.orderdef) then
			ordername = Helper.unlockInfo(operatorinfo_commands, ffi.string(orderdefinition.name))
		end
		local row = inputtable:addRow(false, { bgColor = Color["row_background_unselectable"] })
		row[2]:setColSpan(3):createText(ReadText(1001, 8392) .. ReadText(1001, 120))
		row[5]:setColSpan(3):createText(ordername, { halign = "right" })
		-- command
		if pilot and IsValidComponent(pilot) then
			local row = inputtable:addRow(false, { bgColor = Color["row_background_unselectable"] })
			row[3]:setColSpan(2):createText(ReadText(1001, 78) .. ReadText(1001, 120))
			if #aicommandstack > 0 then
				aicommand = aicommandstack[1].command
				aicommandparam = aicommandstack[1].param
			end
			row[5]:setColSpan(3):createText(Helper.unlockInfo(operatorinfo_commands, string.format(aicommand, IsComponentClass(aicommandparam, "component") and GetComponentData(aicommandparam, "name") or nil)), { halign = "right" })
			local row = inputtable:addRow(false, { bgColor = Color["row_background_unselectable"] })
			local numaicommands = #aicommandstack
			if numaicommands > 1 then
				aicommandaction = aicommandstack[numaicommands].command
				aicommandactionparam = aicommandstack[numaicommands].param
			end
			row[5]:setColSpan(3):createText(Helper.unlockInfo(operatorinfo_commands, string.format(aicommandaction, IsComponentClass(aicommandactionparam, "component") and GetComponentData(aicommandactionparam, "name") or nil)), { halign = "right" })
		end
		-- # orders
		local row = inputtable:addRow(false, { bgColor = Color["row_background_unselectable"] })
		row[2]:setColSpan(4):createText(ReadText(1001, 9402) .. ReadText(1001, 120))
		row[6]:setColSpan(2):createText(Helper.unlockInfo(operatorinfo_commands, numorders), { halign = "right" })
		-- inventory
		if isplayerowned and pilot and IsValidComponent(pilot) then
			local inventory = GetInventory(pilot)
			local onlineitems = OnlineGetUserItems()

			local sortedWares = {}
			local totalamount = 0
			for ware, entry in pairs(inventory) do
				local ispersonalupgrade = GetWareData(ware, "ispersonalupgrade")
				if (not ispersonalupgrade) and (not onlineitems[ware]) then
					table.insert(sortedWares, { ware = ware, name = entry.name, amount = entry.amount })
					totalamount = totalamount + entry.amount
				end
			end
			-- title
			local row = inputtable:addRow("info_pilot_inventory", {  })
			row[1]:createButton({ height = config.mapRowHeight, active = totalamount > 0 }):setText(function() return ((totalamount > 0) and menu.isInfoExtended("info_pilot_inventory", instance)) and "-" or "+" end, { halign = "center" })
			row[1].handlers.onClick = function() return menu.buttonExtendInfo("info_pilot_inventory", instance) end
			row[2]:setColSpan(4):createText(ReadText(1001, 2202) .. ReadText(1001, 120))
			row[6]:setColSpan(2):createText(totalamount, { halign = "right" })
			if next(inventory) and menu.isInfoExtended("info_pilot_inventory", instance) then
				if #sortedWares > 0 then
					table.sort(sortedWares, Helper.sortName)
					-- wares
					for i, entry in ipairs(sortedWares) do
						local row = inputtable:addRow({ "info_inventory", entry.ware, inputobject }, {  })
						row[3]:setColSpan(3):createText(entry.name)
						row[6]:setColSpan(2):createText(ConvertIntegerString(entry.amount, true, 0, true), { halign = "right" })
					end
					-- drop inventory
					local row = inputtable:addRow("DropPilotInventory", {  })
					row[2]:setColSpan(3):createButton({ height = config.mapRowHeight }):setText(ReadText(1001, 7733), { halign = "center" })
					row[2].handlers.onClick = function() return menu.buttonDropPilotInventory(pilot, sortedWares) end
				end
			end
		end
		-- relief pilot
		local aipilot = ConvertIDTo64Bit(GetComponentData(inputobject, "assignedaipilot"))
		if aipilot and aipilot ~= pilot then
			local aipilotname, aipilotskilltable = GetComponentData(aipilot, "name", "skills")
			-- title
			local row = inputtable:addRow(false, { bgColor = Color["row_title_background"] })
			row[1]:setColSpan(7):createText(ReadText(1001, 9403), Helper.headerRowCenteredProperties)
			local adjustedskill = math.floor(C.GetEntityCombinedSkill(aipilot, nil, "aipilot") * 15 / 100)
			local printedskill = Helper.unlockInfo(operatorinfo_details, Helper.displaySkill(adjustedskill))
			-- name
			local printedpilotname = Helper.unlockInfo(operatorinfo, aipilotname)
			local row = inputtable:addRow({ "info_pilot", aipilot, inputobject }, {  })
			row[2]:setColSpan(4):createText(printedpilotname)
			local locfontcolor
			if operatorinfo_details then
				locfontcolor = Color["text_skills"]
			end
			row[6]:setColSpan(2):createText(printedskill, { halign = "right", color = locfontcolor, mouseOverText = ReadText(1026, 2) })
			-- skills
			table.sort(aipilotskilltable, function(a, b) return a.relevance > b.relevance end)
			for _, skillproperties in ipairs(aipilotskilltable) do
				local skillname = ReadText(1013, skillproperties.textid)
				local adjustedskill = skillproperties.value
				local printedskill = Helper.unlockInfo(operatorinfo_details, Helper.displaySkill(adjustedskill, skillproperties.relevance > 0))
				local mouseovertext = ReadText(1013, skillproperties.descriptionid)
				local row = inputtable:addRow(false, { bgColor = Color["row_background_unselectable"] })
				row[3]:setColSpan(3):createText(skillname, { font = (skillproperties.relevance > 0) and Helper.standardFontBold or nil, color = (skillproperties.relevance > 0) and Color["text_normal"] or Color["text_inactive"], mouseOverText = mouseovertext })
				local locfontcolor
				if operatorinfo_details then
					locfontcolor = (skillproperties.relevance > 0) and Color["text_skills"] or Color["text_skills_irrelevant"]
				end
				row[6]:setColSpan(2):createText(printedskill, { halign = "right", color = locfontcolor, mouseOverText = mouseovertext })
			end
		end
		if C.IsComponentClass(inputobject, "controllable") then
			menu.addCrewSection(mode, inputtable, inputobject, instance, infocrew, operatorinfo, aipilot, isplayerowned)
		end
	elseif mode == "station" then
		local manager, shiptrader, individualtrainee = GetComponentData(inputobject, "tradenpc", "shiptrader", "individualtrainee")
		manager = ConvertIDTo64Bit(manager)
		shiptrader = ConvertIDTo64Bit(shiptrader)
		local managername, skilltable, postname, isfemale = "-", {}, ReadText(1001, 4847)
		if manager then
			managername, skilltable, postname, isfemale = GetComponentData(manager, "name", "skills", "postname", "isfemale")
		end

		-- manager
		local printedtitle = (manager and isfemale) and ReadText(20208, 30302) or ReadText(20208, 30301)
		local row = inputtable:addRow(false, { bgColor = Color["row_title_background"] })
		row[1]:setColSpan(7):createText(printedtitle, Helper.headerRowCenteredProperties)
		if manager then
			local adjustedskill = math.floor(C.GetEntityCombinedSkill(manager, nil, "manager") * 15 / 100)
			local printedskill = Helper.unlockInfo(operatorinfo_details, Helper.displaySkill(adjustedskill))
			-- name
			local printedmanagername = Helper.unlockInfo(operatorinfo, managername)
			local row = inputtable:addRow({ "info_manager", manager, inputobject }, {  })
			row[2]:setColSpan(4):createText(printedmanagername)
			local locfontcolor
			if operatorinfo_details then
				locfontcolor = Color["text_skills"]
			end
			row[6]:setColSpan(2):createText(printedskill, { halign = "right", color = locfontcolor, mouseOverText = ReadText(1026, 2) })
			-- skills
			table.sort(skilltable, function(a, b) return a.relevance > b.relevance end)
			for _, skillproperties in ipairs(skilltable) do
				local skillname = ReadText(1013, skillproperties.textid)
				local adjustedskill = skillproperties.value
				local printedskill = Helper.unlockInfo(operatorinfo_details, Helper.displaySkill(adjustedskill, skillproperties.relevance > 0))
				local mouseovertext = ReadText(1013, skillproperties.descriptionid)
				local row = inputtable:addRow(false, { bgColor = Color["row_background_unselectable"] })
				row[3]:setColSpan(3):createText(skillname, { font = (skillproperties.relevance > 0) and Helper.standardFontBold or nil, color = (skillproperties.relevance > 0) and Color["text_normal"] or Color["text_inactive"], mouseOverText = mouseovertext })
				local locfontcolor
				if operatorinfo_details then
					locfontcolor = (skillproperties.relevance > 0) and Color["text_skills"] or Color["text_skills_irrelevant"]
				end
				row[6]:setColSpan(2):createText(printedskill, { halign = "right", color = locfontcolor, mouseOverText = mouseovertext })
			end
		else
			-- name
			local printedmanagername = Helper.unlockInfo(operatorinfo, managername)
			local row = inputtable:addRow(false, { bgColor = Color["row_background_unselectable"] })
			row[2]:setColSpan(4):createText("-")
			row[6]:setColSpan(2):createText("-", { halign = "right", mouseOverText = ReadText(1026, 2) })
		end
		if isplayerowned then
			-- budget
			local recommendedfunds = GetComponentData(inputobject, "productionmoney") or 0
			local row = inputtable:addRow(false, { bgColor = Color["row_background_unselectable"] })
			row[2]:setColSpan(4):createText(ReadText(1001, 9434) .. ReadText(1001, 120)) -- Expected operating budget
			row[6]:setColSpan(2):createText(ConvertMoneyString(recommendedfunds, false, true, nil, true) .. " " .. ReadText(1001, 101), { halign = "right" })
		end
		-- subordinates
		if C.IsComponentClass(inputobject, "controllable") then
			local subordinates = GetSubordinates(inputobject)
			local row = inputtable:addRow("info_subordinates", {  })
			row[1]:createButton({ height = config.mapRowHeight, active = #subordinates > 0 }):setText(function() return (#subordinates > 0 and menu.isInfoExtended("info_subordinates", instance)) and "-" or "+" end, { halign = "center" })
			row[1].handlers.onClick = function() return menu.buttonExtendInfo("info_subordinates", instance) end
			row[1].properties.uiTriggerID = "info_subordinates_toggle"
			row[2]:setColSpan(4):createText(ReadText(1001, 1503) .. ReadText(1001, 120)) -- Subordinates
			row[6]:setColSpan(2):createText(#subordinates, { halign = "right" })
			if (#subordinates > 0) and menu.isInfoExtended("info_subordinates", instance) then
				for i, locship in ipairs(subordinates) do
					local locship64 = ConvertIDTo64Bit(locship)
					subordinates[i] = { id = locship64, name = ffi.string(C.GetComponentName(locship64)), objectid = ffi.string(C.GetObjectIDCode(locship64)), class = ffi.string(C.GetComponentClass(locship64)), purpose = GetComponentData(locship, "primarypurpose") }
				end
				table.sort(subordinates, Helper.sortShipsByClassAndPurpose)

				for i, shipentry in ipairs(subordinates) do
					local shipname, textcolor = menu.getContainerNameAndColors(shipentry.id, 0, false, false)

					local row = inputtable:addRow("info_subordinate" .. i, { interactive = false })
					row[3]:setColSpan(4):createText(shipname, { color = textcolor })
					row[7]:createButton({ height = config.mapRowHeight }):setIcon("menu_center_selection", { width = Helper.standardTextHeight, height = Helper.standardTextHeight })
					row[7].handlers.onClick = function () return C.SetFocusMapComponent(menu.holomap, shipentry.id, true) end
				end
			end
		end
		-- shiptrader
		if shiptrader then
			shiptrader = ConvertIDTo64Bit(shiptrader)
			local row = inputtable:addRow(false, { bgColor = Color["row_title_background"] })
			row[1]:setColSpan(7):createText(GetComponentData(shiptrader, "isfemale") and ReadText(20208, 30502) or ReadText(20208, 30501), Helper.headerRowCenteredProperties) -- Ship Trader (female), Ship Trader (male)
			-- name
			local name = GetComponentData(shiptrader, "name")
			local row = inputtable:addRow({ "info_shiptrader", shiptrader, inputobject }, {  })
			row[2]:setColSpan(6):createText(Helper.unlockInfo(operatorinfo, tostring(name)))
		end
		-- individualtrainee
		if individualtrainee then
			individualtrainee = ConvertIDTo64Bit(individualtrainee)
			local row = inputtable:addRow(false, { bgColor = Color["row_title_background"] })
			row[1]:setColSpan(7):createText(GetComponentData(individualtrainee, "isfemale") and ReadText(20208, 20602) or ReadText(20208, 20601), Helper.headerRowCenteredProperties)
			-- name
			local name, skilltable = GetComponentData(individualtrainee, "name", "skills")
			local row = inputtable:addRow({ "info_individualtrainee", individualtrainee, inputobject }, {  })
			row[1]:createButton({ height = config.mapRowHeight }):setText(function() return menu.isInfoExtended("info_individualtrainee", instance) and "-" or "+" end, { halign = "center" })
			row[1].handlers.onClick = function() return menu.buttonExtendInfo("info_individualtrainee", instance) end
			row[2]:setColSpan(6):createText(Helper.unlockInfo(operatorinfo, tostring(name)))
			-- skills
			if menu.isInfoExtended("info_individualtrainee", instance) then
				table.sort(skilltable, function(a, b) return a.relevance > b.relevance end)
				for _, skillproperties in ipairs(skilltable) do
					local skillname = ReadText(1013, skillproperties.textid)
					local adjustedskill = skillproperties.value
					local printedskill = Helper.unlockInfo(operatorinfo_details, Helper.displaySkill(adjustedskill, skillproperties.relevance > 0))
					local mouseovertext = ReadText(1013, skillproperties.descriptionid)
					local row = inputtable:addRow(false, { bgColor = Color["row_background_unselectable"] })
					row[3]:setColSpan(3):createText(skillname, { font = (skillproperties.relevance > 0) and Helper.standardFontBold or nil, color = (skillproperties.relevance > 0) and Color["text_normal"] or Color["text_inactive"], mouseOverText = mouseovertext })
					local locfontcolor
					if operatorinfo_details then
						locfontcolor = (skillproperties.relevance > 0) and Color["text_skills"] or Color["text_skills_irrelevant"]
					end
					row[6]:setColSpan(2):createText(printedskill, { halign = "right", color = locfontcolor, mouseOverText = mouseovertext })
				end
			end
		end
		-- workforce
		local races = {}
		local n = C.GetNumAllRaces()
		local buf = ffi.new("RaceInfo[?]", n)
		n = C.GetAllRaces(buf, n)
		for i = 0, n - 1 do
			local entry = {}
			entry.id = ffi.string(buf[i].id)
			entry.name = ffi.string(buf[i].name)
			entry.workforceinfo = C.GetWorkForceInfo(inputobject, entry.id)
			if entry.workforceinfo.capacity > 0 then
				table.insert(races, entry)
			end
		end
		table.sort(races, Helper.sortName)
		if #races > 0 then
			local row = inputtable:addRow(false, { bgColor = Color["row_title_background"] })
			row[1]:setColSpan(7):createText(ReadText(1001, 9415), Helper.headerRowCenteredProperties) -- Workforce
			for _, race in ipairs(races) do
				local row = inputtable:addRow(nil, { bgColor = Color["row_background_unselectable"] })
				row[2]:setColSpan(4):createText(race.name)
				row[6]:setColSpan(2):createText(Helper.unlockInfo(operatorinfo, race.workforceinfo.current .. " / " .. race.workforceinfo.capacity), { halign = "right" })
			end
		end
		-- player personnel
		local npctable = GetNPCs(inputobject)
		for i = #npctable, 1, -1 do
			if not GetComponentData(npctable[i], "isplayerowned") then
				table.remove(npctable, i)
			elseif ConvertIDTo64Bit(npctable[i]) == manager then
				table.remove(npctable, i)
			elseif ConvertIDTo64Bit(npctable[i]) == shiptrader then
				table.remove(npctable, i)
			elseif ConvertIDTo64Bit(npctable[i]) == individualtrainee then
				table.remove(npctable, i)
			end
		end
		if #npctable > 0 then
			local row = inputtable:addRow(false, { bgColor = Color["row_title_background"] })
			row[1]:setColSpan(7):createText(ReadText(1001, 9416), Helper.headerRowCenteredProperties) -- Player Employees On Board
			for i, npc in ipairs(npctable) do
				npc = ConvertIDTo64Bit(npc)
				local extendinfoid = string.format("info_crewperson_r%d", i)
				local row = inputtable:addRow({ "info_crewnpc", npc, inputobject }, {  })
				row[2]:createButton({ height = config.mapRowHeight }):setText(function() return menu.isInfoExtended(extendinfoid, instance) and "-" or "+" end, { halign = "center" })
				row[2].handlers.onClick = function() return menu.buttonExtendInfo(extendinfoid, instance) end
				row[3]:setColSpan(3):createText(GetComponentData(npc, "name"), { mouseOverText = mouseovertext })
				row[6]:setColSpan(2):createText(printedskill, { halign = "right", color = Color["text_skills"], mouseOverText = ReadText(1026, 2) })
				if menu.isInfoExtended(extendinfoid, instance) then
					local skilltable = GetComponentData(npc, "skills")
					table.sort(skilltable, function(a, b) return a.relevance > b.relevance end)
					for _, skill in ipairs(skilltable) do
						local skillname = ReadText(1013, skill.textid)
						local printedskill = Helper.displaySkill(skill.value, skill.relevance > 0)
						local mouseovertext = ReadText(1013, skill.descriptionid)
						local row = inputtable:addRow(false, { bgColor = Color["row_background_unselectable"] })
						row[3]:setColSpan(3):createText(skillname, { font = (skill.relevance > 0) and Helper.standardFontBold or nil, x = Helper.standardIndentStep, color = (skill.relevance > 0) and Color["text_normal"] or Color["text_inactive"], mouseOverText = mouseovertext })
						row[6]:setColSpan(2):createText(printedskill, { halign = "right", color = (skill.relevance > 0) and Color["text_skills"] or Color["text_skills_irrelevant"], mouseOverText = mouseovertext })
					end
				end
			end
		end

		if C.CanControllableHaveAnyTrainees(inputobject) then
			menu.addCrewSection(mode, inputtable, inputobject, instance, infocrew, operatorinfo, nil, isplayerowned)
		end
	elseif mode == "none" then
		local row = inputtable:addRow(false, { bgColor = Color["row_background_unselectable"] })
		row[2]:setColSpan(6):createText(ReadText(1001, 6526))
	end
end

function menu.addCrewSection(mode, inputtable, inputobject, instance, infocrew, operatorinfo, aipilot, isplayerowned)
	-- capacity
	local peoplecapacity = C.GetPeopleCapacity(inputobject, "", false)
	local totalcrewcapacity = infocrew.capacity
	if mode == "ship" then
		totalcrewcapacity = totalcrewcapacity + 1
	end
	local totalnumpeople = infocrew.total
	if aipilot then
		totalnumpeople = totalnumpeople + 1
	end
	local titlerow
	if (mode == "ship") or (totalnumpeople > 0) then
		-- crew
		titlerow = inputtable:addRow(false, { bgColor = Color["row_title_background"] })
		titlerow[1]:setColSpan(7):createText(ReadText(1001, 80), Helper.headerRowCenteredProperties)
		titlerow[1].properties.helpOverlayID = "crew_assigncrew"
		titlerow[1].properties.helpOverlayText = " "
		titlerow[1].properties.helpOverlayHeight = titlerow:getHeight()
		titlerow[1].properties.helpOverlayHighlightOnly = true
		titlerow[1].properties.helpOverlayScaling = false
		local row = inputtable:addRow(false, { bgColor = Color["row_background_unselectable"] })
		row[2]:setColSpan(4):createText(ReadText(1001, 9078) .. ReadText(1001, 120))
		row[6]:setColSpan(2):createText(Helper.unlockInfo(operatorinfo, tostring(totalnumpeople)) .. " / " .. Helper.unlockInfo(operatorinfo, tostring(totalcrewcapacity)), { halign = "right" })
		titlerow[1].properties.helpOverlayHeight = titlerow[1].properties.helpOverlayHeight + row:getHeight() + Helper.borderSize
	end
	-- crew assignment
	if operatorinfo and totalnumpeople > 0 then
		local sliderrows = {}
		local slidercounter = 0
		-- unassigned
		local row = inputtable:addRow(true, { bgColor = Color["row_background_unselectable"] })
		row[1]:setBackgroundColSpan(6)
		row[2]:setColSpan(4):createText(ReadText(1001, 5207)) -- Unassigned
		row[6]:createText(function() return (tostring(infocrew.unassigned.total)) end, { halign = "right" })
		row[7]:createButton({ active = function () return infocrew.unassigned.total > 0 end, mouseOverText = ReadText(1026, 8002) }):setIcon("menu_dismiss")
		row[7].handlers.onClick = function () return menu.infoSubmenuFireAllNPCConfirm(inputobject, instance) end
		titlerow[1].properties.helpOverlayHeight = titlerow[1].properties.helpOverlayHeight + row:getHeight() + Helper.borderSize

		local rolewhitelist = {
			["prisoner"] = true,
			["passenger"] = true,
		}
		if mode == "ship" then
			rolewhitelist["service"] = true
			rolewhitelist["marine"] = true
		end
		if C.CanControllableHaveAnyTrainees(inputobject) then
			rolewhitelist["trainee_group"] = true
		end

		for i, roletable in ipairs(infocrew.current.roles) do
			if rolewhitelist[roletable.id] and (roletable.amount > 0 or roletable.canhire) then
				slidercounter = slidercounter + 1
				-- can query: .id, .name, .desc, .amount, .numtiers, .canhire
				--{
				--	id = ffi.string(peopletable[i].id),
				--	name = ffi.string(peopletable[i].name),
				--	desc = ffi.string(peopletable[i].desc),
				--	amount = peopletable[i].amount,
				--	canhire = peopletable[i].canhire,
				--	numtiers = peopletable[i].numtiers,
				--	tiers = {}
				--}
				local row = inputtable:addRow(ffi.string(roletable.id), { interactive = isplayerowned and roletable.canhire })
				--print("name: " .. ffi.string(roletable.name) .. ", canhire: " .. tostring(roletable.canhire))
				local maxselect = math.min(peoplecapacity, roletable.amount + infocrew.reassigned.roles[i].amount + infocrew.unassigned.total)
				local start = math.min(maxselect, roletable.amount + infocrew.reassigned.roles[i].amount)
				row[2]:setColSpan(6):createSliderCell({ height = config.mapRowHeight, start = start, minSelect = roletable.transferring, max = peoplecapacity, maxSelect = maxselect, readOnly = not isplayerowned or not roletable.canhire }):setText(ffi.string(roletable.name), { fontsize = config.mapFontSize })
				sliderrows[slidercounter] = { ["row"] = row, ["col"] = 2, ["roleindex"] = i,["id"] = roletable.id, ["name"] = roletable.name, ["desc"] = roletable.desc, ["amount"] = roletable.amount, ["numtiers"] = roletable.numtiers, ["canhire"] = roletable.canhire, ["tiers"] = {} }
				titlerow[1].properties.helpOverlayHeight = titlerow[1].properties.helpOverlayHeight + row:getHeight() + Helper.borderSize
				local numtiers = roletable.numtiers
				for j, tiertable in ipairs(roletable.tiers) do
					if not tiertable.hidden then
						-- can query: .name, .skilllevel, .amount
						--{
						--	name = ffi.string(tiertable[j].name),
						--	skilllevel = tiertable[j].skilllevel,
						--	amount = tiertable[j].amount,
						--	persons = {}
						--}
						--print("tier name: " .. ffi.string(tiertable.name) .. ", skill level: " .. tostring(tiertable.skilllevel) .. ", num: " .. tostring(tiertable.amount))
						local row = inputtable:addRow(ffi.string(roletable.id) .. j, { interactive = isplayerowned })
						local maxselect = math.min(peoplecapacity, tiertable.amount + infocrew.reassigned.roles[i].tiers[j].amount)
						local start = math.min(maxselect, tiertable.amount + infocrew.reassigned.roles[i].tiers[j].amount)
						row[3]:setColSpan(5):createSliderCell({ height = config.mapRowHeight, start = start, minSelect = tiertable.transferring, max = peoplecapacity, maxSelect = maxselect, readOnly = not isplayerowned }):setText(ffi.string(tiertable.name), { fontsize = config.mapFontSize })
						sliderrows[slidercounter].tiers[j] = { ["row"] = row, ["col"] = 3, ["roleindex"] = i, ["name"] = tiertable.name, ["skilllevel"] = tiertable.skilllevel, ["amount"] = tiertable.amount }
						titlerow[1].properties.helpOverlayHeight = titlerow[1].properties.helpOverlayHeight + row:getHeight() + Helper.borderSize
					end
				end
			end
		end
		if isplayerowned then
			local row = inputtable:addRow("UpdateCrew", {  })
			row[2]:setColSpan(3):createButton({ height = config.mapRowHeight, active = function() return (infocrew.reassigned.total > 0) end }):setText(ReadText(1001, 2821), { halign = "center", fontsize = config.mapFontSize })	-- Confirm
			row[2].handlers.onClick = function() return menu.infoSubmenuConfirmCrewChanges(instance) end
			row[5]:setColSpan(3):createButton({ height = config.mapRowHeight, active = function() return (infocrew.reassigned.total > 0) end }):setText(ReadText(1001, 3318), { halign = "center", fontsize = config.mapFontSize })	-- Reset
			row[5].handlers.onClick = function() return menu.resetInfoSubmenu(nil, instance) end
			titlerow[1].properties.helpOverlayHeight = titlerow[1].properties.helpOverlayHeight + row:getHeight() + Helper.borderSize
			for i, role in ipairs(sliderrows) do
				-- TODO: cleanup these tables. not all data is used.
				local sliderupdatetable = { ["table"] = inputtable, ["row"] = role.row, ["col"] = role.col, ["tierrows"] = {}, ["text"] = role.name, ["xoffset"] = role.row[2].properties.x, ["width"] = role.row[2].properties.width }
				for j, tier in ipairs(role.tiers) do
					table.insert(sliderupdatetable.tierrows, { ["row"] = tier.row, ["col"] = tier.col, ["text"] = tier.name, ["xoffset"] = tier.row[2].properties.x, ["width"] = tier.row[2].properties.width })
				end

				role.row[2].handlers.onSliderCellChanged = function(_, newamount) return menu.infoSubmenuUpdateCrewChanges(instance, newamount, sliderrows, i, false, nil, sliderupdatetable) end
				role.row[2].handlers.onSliderCellConfirm = function() return menu.refreshInfoFrame() end
				role.row[2].handlers.onSliderCellActivated = function() menu.noupdate = true end
				role.row[2].handlers.onSliderCellDeactivated = function() menu.noupdate = false end
				for j, tier in ipairs(role.tiers) do
					tier.row[3].handlers.onSliderCellChanged = function(_, newamount) return menu.infoSubmenuUpdateCrewChanges(instance, newamount, sliderrows, i, true, j, sliderupdatetable) end
					tier.row[3].handlers.onSliderCellConfirm = function() return menu.refreshInfoFrame() end
					tier.row[3].handlers.onSliderCellActivated = function() menu.noupdate = true end
					tier.row[3].handlers.onSliderCellDeactivated = function() menu.noupdate = false end
				end
			end
		end
		-- full crew list
		local row = inputtable:addRow(false, { bgColor = Color["row_title_background"] })
		row[1]:setColSpan(7):createText(ReadText(1001, 9404), Helper.headerRowCenteredProperties) -- Full Crew List
		-- sorting
		local arrowWidth = Helper.scaleY(config.mapRowHeight)
		local row = inputtable:addRow(true, {  })
		row[2]:setColSpan(2):createText(ReadText(1001, 2906) .. ReadText(1001, 120))
		row[4]:createButton({ height = config.mapRowHeight }):setText(ReadText(1001, 2809)):setIcon((menu.crewSort == "name_inv") and "table_arrow_inv_up" or "table_arrow_inv_down", { scaling = false, width = arrowWidth, height = arrowWidth, x = row[4]:getColSpanWidth() - arrowWidth, color = ((menu.crewSort == "name") or (menu.crewSort == "name_inv")) and Color["icon_normal"] or Color["icon_hidden"] })
		row[4].handlers.onClick = function () menu.crewSort = (menu.crewSort == "name") and "name_inv" or "name"; menu.refreshInfoFrame() end
		row[5]:createButton({ height = config.mapRowHeight }):setText(ReadText(1001, 11200)):setIcon((menu.crewSort == "role_inv") and "table_arrow_inv_up" or "table_arrow_inv_down", { scaling = false, width = arrowWidth, height = arrowWidth, x = row[4]:getColSpanWidth() - arrowWidth, color = ((menu.crewSort == "role") or (menu.crewSort == "role_inv")) and Color["icon_normal"] or Color["icon_hidden"] })
		row[5].handlers.onClick = function () menu.crewSort = (menu.crewSort == "role") and "role_inv" or "role"; menu.refreshInfoFrame() end
		row[6]:setColSpan(2):createButton({ height = config.mapRowHeight }):setText(ReadText(1001, 9124)):setIcon((menu.crewSort == "skill_inv") and "table_arrow_inv_up" or "table_arrow_inv_down", { scaling = false, width = arrowWidth, height = arrowWidth, x = row[4]:getColSpanWidth() - arrowWidth, color = ((menu.crewSort == "skill") or (menu.crewSort == "skill_inv")) and Color["icon_normal"] or Color["icon_hidden"] })
		row[6].handlers.onClick = function () menu.crewSort = (menu.crewSort == "skill") and "skill_inv" or "skill"; menu.refreshInfoFrame() end
		-- skill display
		local roleOptions = {
			{ id = "post:aipilot",		text = ReadText(20208, 30101), icon = "", displayremoveoption = false },
			{ id = "post:manager",		text = ReadText(20208, 30301), icon = "", displayremoveoption = false },
			{ id = "post:shiptrader",	text = ReadText(20208, 30501), icon = "", displayremoveoption = false },
			{ id = "role:service",		text = ReadText(20208, 20103), icon = "", displayremoveoption = false },
			{ id = "role:marine",		text = ReadText(20208, 20203), icon = "", displayremoveoption = false },
		}
		table.sort(roleOptions, function (a, b) return a.text < b.text end)
		table.insert(roleOptions, 1, { id = "current", text = ReadText(1001, 8373), icon = "", displayremoveoption = false })
		local row = inputtable:addRow(true, {  })
		row[2]:setColSpan(4):createText(ReadText(1001, 8399) .. ReadText(1001, 120))
		row[6]:setColSpan(2):createDropDown(roleOptions, { startOption = menu.crewRole })
		row[6].handlers.onDropDownConfirmed = function (_, newrole) menu.noupdate = false; if menu.crewRole ~= newrole then menu.crewRole = newrole; menu.refreshInfoFrame() end end
		row[6].handlers.onDropDownActivated = function () menu.noupdate = true end

		inputtable:addEmptyRow(config.mapRowHeight / 2)

		local role, post, rolename
		if menu.crewRole ~= "current" then
			local type, id = string.match(menu.crewRole, "(.+):(.+)")
			if type == "post" then
				post = id
			elseif type == "role" then
				role = id
			end
			for _, option in ipairs(roleOptions) do
				if option.id == menu.crewRole then
					rolename = option.text
					break
				end
			end
		end

		local tierinfo
		if role then
			tierinfo = {}
			local numpeople = C.GetNumAllRoles()
			local peopletable = ffi.new("PeopleInfo[?]", numpeople)
			numpeople = C.GetPeople2(peopletable, numpeople, inputobject, true)
			for i = 0, numpeople - 1 do
				if ffi.string(peopletable[i].id) == role then
					local numtiers = peopletable[i].numtiers
					local tiertable = ffi.new("RoleTierData[?]", numtiers)
					numtiers = C.GetRoleTiers(tiertable, numtiers, inputobject, role)
					for j = 0, numtiers - 1 do
						tierinfo[j + 1] = { name = ffi.string(tiertable[j].name), skilllevel = tiertable[j].skilllevel }
					end
					table.sort(tierinfo, function (a, b) return a.skilllevel > b.skilllevel end)
				end
			end
		end

		local combinedcrew = menu.infoSubmenuCombineCrewTables(instance)
		local prevrole, prevtier
		for _, personentry in ipairs(combinedcrew) do
			if (menu.crewSort == "role") or (menu.crewSort == "role_inv") then
				if (not prevrole) or (prevrole ~= personentry.rolename) or (prevtier ~= personentry.tiername) then
					prevrole = personentry.rolename
					prevtier = personentry.tiername

					local row = inputtable:addRow(false, { bgColor = Color["row_title_background"] })
					row[1]:setColSpan(7):createText(personentry.rolename .. (personentry.tiername and (" - " .. personentry.tiername) or ""), Helper.headerRowCenteredProperties)
					row[1].properties.font = Helper.standardFont
				end
			elseif role and ((menu.crewSort == "skill") or (menu.crewSort == "skill_inv")) then
				local tiername
				for _, tierentry in ipairs(tierinfo) do
					if personentry.skill >= tierentry.skilllevel then
						tiername = tierentry.name
						break
					end
				end
				if (not prevrole) or (prevrole ~= rolename) or (prevtier ~= tiername) then
					prevrole = rolename
					prevtier = tiername

					local row = inputtable:addRow(false, { bgColor = Color["row_title_background"] })
					row[1]:setColSpan(7):createText(rolename .. (tiername and (" - " .. tiername) or ""), Helper.headerRowCenteredProperties)
					row[1].properties.font = Helper.standardFont
				end
			end

			local adjustedcombinedskill = math.floor(personentry.skill * 15 / 100)
			local extendinfoid = string.format("info_crewperson_%s", tostring(personentry.person))
			local printedname = personentry.name
			local mouseovertext = ""
			local color
			if C.IsPersonTransferScheduled(inputobject, personentry.person) then
				printedname = ColorText["crew_transfer"] .. "\027[warning]" .. printedname
				mouseovertext = ReadText(1026, 3228)
			elseif not C.HasPersonArrived(inputobject, personentry.person) then
				color = Color["text_inactive"]
				mouseovertext = ReadText(1026, 3247)
			end
			local printedskill = Helper.displaySkill(adjustedcombinedskill)
			local row = inputtable:addRow({ "info_crewperson", personentry.person, inputobject }, {  })
			row[1]:createButton({ height = config.mapRowHeight, helpOverlayID = "info_crewperson", helpOverlayText = " " }):setText(function() return menu.isInfoExtended(extendinfoid, instance) and "-" or "+" end, { halign = "center" })
			row[1].properties.uiTriggerID = "info_crewperson"
			row[1].handlers.onClick = function() return menu.buttonExtendInfo(extendinfoid, instance) end
			row[2]:setColSpan(3):createText(printedname, { mouseOverText = mouseovertext, color = color })
			local roleColor, mouseovertext
			if (menu.crewRole ~= "current") and (role ~= personentry.roleid) and (post ~= personentry.roleid) then
				roleColor = Color["text_inactive"]
				mouseovertext = string.format(ReadText(1026, 3231), rolename)
			end
			row[5]:createText(personentry.rolename, { color = roleColor, mouseOverText = mouseovertext })
			row[6]:setColSpan(2):createText(printedskill, { halign = "right", color = Color["text_skills"], mouseOverText = ReadText(1026, 2) })
			if menu.isInfoExtended(extendinfoid, instance) then
				local numskills = C.GetNumSkills()
				local skilltable = ffi.new("Skill2[?]", numskills + 1)
				numskills = C.GetPersonSkillsForAssignment(skilltable, personentry.person, inputobject, role, post)
				local sortedskilltable = {}
				for i = 1, numskills do
					table.insert(sortedskilltable, skilltable[i])
				end
				table.sort(sortedskilltable, function(a, b) return a.relevance > b.relevance end)
				for i, skill in ipairs(sortedskilltable) do
					local skillname = ReadText(1013, skill.textid)
					local printedskill = Helper.displaySkill(skill.value, skill.relevance > 0)
					local mouseovertext = ReadText(1013, skill.descriptionid)
					local row = inputtable:addRow(false, { bgColor = Color["row_background_unselectable"] })
					row[3]:setColSpan(3):createText(skillname, { font = (skill.relevance > 0) and Helper.standardFontBold or nil, color = (skill.relevance > 0) and Color["text_normal"] or Color["text_inactive"], mouseOverText = mouseovertext })
					row[6]:setColSpan(2):createText(printedskill, { halign = "right", color = (skill.relevance > 0) and Color["text_skills"] or Color["text_skills_irrelevant"], mouseOverText = mouseovertext })
				end
			end
		end
	end
end

function menu.setupLoadoutInfoSubmenuRows(mode, inputtable, inputobject, instance)
	local object64 = ConvertStringTo64Bit(tostring(inputobject))
	local isplayerowned, isonlineobject, isenemy, ishostile = GetComponentData(object64, "isplayerowned", "isonlineobject", "isenemy", "ishostile")
	local titlecolor = Color["text_normal"]
	if isplayerowned then
		titlecolor = menu.holomapcolor.playercolor
		if object64 == C.GetPlayerObjectID() then
			titlecolor = menu.holomapcolor.currentplayershipcolor
		end
	elseif isonlineobject and menu.getFilterOption("layer_other", false) and menu.getFilterOption("think_diplomacy_highlightvisitor", false) then
		titlecolor = menu.holomapcolor.visitorcolor
	elseif ishostile then
		titlecolor = menu.holomapcolor.hostilecolor
	elseif isenemy then
		titlecolor = menu.holomapcolor.enemycolor
	end

	local loadout = {}
	if mode == "ship" or mode == "station" then
		loadout = { ["component"] = {}, ["macro"] = {}, ["ware"] = {} }
		for i, upgradetype in ipairs(Helper.upgradetypes) do
			if upgradetype.supertype == "macro" then
				loadout.component[upgradetype.type] = {}
				local numslots = 0
				if C.IsComponentClass(inputobject, "defensible") then
					numslots = tonumber(C.GetNumUpgradeSlots(inputobject, "", upgradetype.type))
				end
				for j = 1, numslots do
					local current = C.GetUpgradeSlotCurrentComponent(inputobject, upgradetype.type, j)
					if current ~= 0 then
						table.insert(loadout.component[upgradetype.type], current)
					end
				end
			elseif upgradetype.supertype == "virtualmacro" then
				loadout.macro[upgradetype.type] = {}
				local numslots = tonumber(C.GetNumVirtualUpgradeSlots(inputobject, "", upgradetype.type))
				for j = 1, numslots do
					local current = ffi.string(C.GetVirtualUpgradeSlotCurrentMacro(inputobject, upgradetype.type, j))
					if current ~= "" then
						table.insert(loadout.macro[upgradetype.type], current)
					end
				end
			elseif upgradetype.supertype == "software" then
				loadout.ware[upgradetype.type] = {}
				local numslots = C.GetNumSoftwareSlots(inputobject, "")
				local buf = ffi.new("SoftwareSlot[?]", numslots)
				numslots = C.GetSoftwareSlots(buf, numslots, inputobject, "")
				for j = 0, numslots - 1 do
					local current = ffi.string(buf[j].current)
					if current ~= "" then
						table.insert(loadout.ware[upgradetype.type], current)
					end
				end
			elseif upgradetype.supertype == "ammo" then
				loadout.macro[upgradetype.type] = {}
			end
		end
	end

	local cheatsecrecy = false
	-- secrecy stuff
	local nameinfo =					cheatsecrecy or C.IsInfoUnlockedForPlayer(inputobject, "name")
	local defenceinfo_low =				cheatsecrecy or C.IsInfoUnlockedForPlayer(inputobject, "defence_level")
	local defenceinfo_high =			cheatsecrecy or C.IsInfoUnlockedForPlayer(inputobject, "defence_status")
	local unitinfo_capacity =			cheatsecrecy or C.IsInfoUnlockedForPlayer(inputobject, "units_capacity")
	local unitinfo_amount =				cheatsecrecy or C.IsInfoUnlockedForPlayer(inputobject, "units_amount")
	local unitinfo_details =			cheatsecrecy or C.IsInfoUnlockedForPlayer(inputobject, "units_details")
	local equipment_mods =				cheatsecrecy or C.IsInfoUnlockedForPlayer(inputobject, "equipment_mods")

	--- title ---
	local row = inputtable:addRow(false, { fixed = true, bgColor = Color["row_title_background"] })
	row[1]:setColSpan(13):createText(ReadText(1001, 2427), Helper.headerRowCenteredProperties)
	local row = inputtable:addRow(false, { fixed = true, bgColor = Color["row_title_background"] })
	row[1]:setColSpan(13):createText(ReadText(1001, 9413), Helper.headerRowCenteredProperties)

	local objectname = Helper.unlockInfo(nameinfo, ffi.string(C.GetComponentName(inputobject)))
	-- object name
	local row = inputtable:addRow("info_focus", { fixed = true, bgColor = Color["row_title_background"] })
	row[13]:createButton({ width = config.mapRowHeight, cellBGColor = Color["row_background"] }):setIcon("menu_center_selection", { width = config.mapRowHeight, height = config.mapRowHeight, y = (Helper.headerRow1Height - config.mapRowHeight) / 2 })
	row[13].handlers.onClick = function () return C.SetFocusMapComponent(menu.holomap, menu.infoSubmenuObject, true) end
	if (mode == "ship") or (mode == "station") then
		row[1]:setBackgroundColSpan(12):setColSpan(6):createText(objectname, Helper.headerRow1Properties)
		row[1].properties.color = titlecolor
		row[7]:setColSpan(6):createText(Helper.unlockInfo(nameinfo, ffi.string(C.GetObjectIDCode(inputobject))), Helper.headerRow1Properties)
		row[7].properties.halign = "right"
		row[7].properties.color = titlecolor
	else
		row[1]:setBackgroundColSpan(12):setColSpan(12):createText(objectname, Helper.headerRow1Properties)
		row[1].properties.color = titlecolor
	end

	if mode == "ship" then
		local pilot = GetComponentData(inputobject, "assignedpilot")
		pilot = ConvertIDTo64Bit(pilot)
		local pilotname, skilltable, postname, aicommandstack, aicommand, aicommandparam, aicommandaction, aicommandactionparam = "-", {}, ReadText(1001, 4847), {}
		if pilot and IsValidComponent(pilot) then
			pilotname, skilltable, postname, aicommandstack, aicommand, aicommandparam, aicommandaction, aicommandactionparam = GetComponentData(pilot, "name", "skills", "postname", "aicommandstack", "aicommand", "aicommandparam", "aicommandaction", "aicommandactionparam")
		end

		local isbigship = C.IsComponentClass(inputobject, "ship_m") or C.IsComponentClass(inputobject, "ship_l") or C.IsComponentClass(inputobject, "ship_xl")
		-- weapon config
		if isplayerowned and (#loadout.component.weapon > 0) then
			local row = inputtable:addRow(false, { bgColor = Color["row_title_background"] })
			row[1]:setColSpan(13):createText(ReadText(1001, 9409), Helper.headerRowCenteredProperties) -- Weapon Configuration
			-- subheader
			local row = inputtable:addRow(false, { bgColor = Color["row_background_unselectable"] })
			row[3]:setColSpan(5):createText(ReadText(1001, 9410), { font = Helper.standardFontBold }) -- Primary
			row[8]:setColSpan(6):createText(ReadText(1001, 9411), { font = Helper.standardFontBold }) -- Secondary
			-- active weapon groups
			local row = inputtable:addRow("info_weaponconfig_active", {  })
			row[2]:createText(ReadText(1001, 11218))
			for j = 1, 4 do
				row[2 + j]:createCheckBox(function () return C.GetDefensibleActiveWeaponGroup(inputobject, true) == j end, { width = config.mapRowHeight, height = config.mapRowHeight, symbol = "arrow", bgColor = function () return menu.infoWeaponGroupCheckBoxColor(inputobject, j, true) end })
				row[2 + j].handlers.onClick = function () C.SetDefensibleActiveWeaponGroup(inputobject, true, j) end
			end
			for j = 1, 4 do
				row[7 + j]:createCheckBox(function () return C.GetDefensibleActiveWeaponGroup(inputobject, false) == j end, { width = config.mapRowHeight, height = config.mapRowHeight, symbol = "arrow", bgColor = function () return menu.infoWeaponGroupCheckBoxColor(inputobject, j, false) end })
				row[7 + j].handlers.onClick = function () C.SetDefensibleActiveWeaponGroup(inputobject, false, j) end
			end
			inputtable:addEmptyRow(config.mapRowHeight / 2)
			-- weapons
			for i, gun in ipairs(loadout.component.weapon) do
				local gun = ConvertStringTo64Bit(tostring(gun))
				local numweapongroups = C.GetNumWeaponGroupsByWeapon(inputobject, gun)
				local rawweapongroups = ffi.new("UIWeaponGroup[?]", numweapongroups)
				numweapongroups = C.GetWeaponGroupsByWeapon(rawweapongroups, numweapongroups, inputobject, gun)
				local uiweapongroups = { primary = {}, secondary = {} }
				for j = 0, numweapongroups - 1 do
					-- there are two sets: primary and secondary.
					-- each set has four groups.
					-- .primary tells you if this particular weapon is active in a group in the primary or secondary group set.
					-- .idx tells you which group in that group set it is active in.
					if rawweapongroups[j].primary then
						uiweapongroups.primary[rawweapongroups[j].idx] = true
					else
						uiweapongroups.secondary[rawweapongroups[j].idx] = true
					end
					--print("primary: " .. tostring(rawweapongroups[j].primary) .. ", idx: " .. tostring(rawweapongroups[j].idx))
				end

				local row = inputtable:addRow("info_weaponconfig" .. i, {  })
				row[2]:createText(ffi.string(C.GetComponentName(gun)))

				-- primary weapon groups
				for j = 1, 4 do
					row[2 + j]:createCheckBox(uiweapongroups.primary[j], { width = config.mapRowHeight, height = config.mapRowHeight, bgColor = function () return menu.infoWeaponGroupCheckBoxColor(inputobject, j, true) end })
					row[2 + j].handlers.onClick = function() menu.infoSetWeaponGroup(inputobject, gun, true, j, not uiweapongroups.primary[j]) end
				end

				-- secondary weapon groups
				for j = 1, 4 do
					row[7 + j]:createCheckBox(uiweapongroups.secondary[j], { width = config.mapRowHeight, height = config.mapRowHeight, bgColor = function () return menu.infoWeaponGroupCheckBoxColor(inputobject, j, false) end })
					row[7 + j].handlers.onClick = function() menu.infoSetWeaponGroup(inputobject, gun, false, j, not uiweapongroups.secondary[j]) end
				end

				if IsComponentClass(gun, "missilelauncher") then
					local nummissiletypes = C.GetNumAllMissiles(inputobject)
					local missilestoragetable = ffi.new("AmmoData[?]", nummissiletypes)
					nummissiletypes = C.GetAllMissiles(missilestoragetable, nummissiletypes, inputobject)

					local gunmacro = GetComponentData(gun, "macro")
					local dropdowndata = {}
					for j = 0, nummissiletypes - 1 do
						local ammomacro = ffi.string(missilestoragetable[j].macro)
						if C.IsAmmoMacroCompatible(gunmacro, ammomacro) then
							table.insert(dropdowndata, {id = ammomacro, text = GetMacroData(ammomacro, "name") .. " (" .. ConvertIntegerString(missilestoragetable[j].amount, true, 0, true) .. ")", icon = "", displayremoveoption = false})
						end
					end

					-- if the ship has no compatible ammunition in ammo storage, have the dropdown print "Out of ammo" and make it inactive.
					local currentammomacro = "empty"
					local dropdownactive = true
					if #dropdowndata == 0 then
						dropdownactive = false
						table.insert(dropdowndata, {id = "empty", text = ReadText(1001, 9412), icon = "", displayremoveoption = false})	-- Out of ammo
					else
						-- NB: currentammomacro can be null
						currentammomacro = ffi.string(C.GetCurrentAmmoOfWeapon(gun))
					end

					row = inputtable:addRow(("info_weaponconfig" .. i .. "_ammo"), {  })
					row[2]:createText((ReadText(1001, 2800) .. ReadText(1001, 120)))	-- Ammunition, :
					row[3]:setColSpan(11):createDropDown(dropdowndata, {startOption = currentammomacro, active = dropdownactive})
					row[3].handlers.onDropDownConfirmed = function(_, newammomacro) C.SetAmmoOfWeapon(gun, newammomacro) end
				elseif pilot and IsValidComponent(pilot) and IsComponentClass(gun, "bomblauncher") then
					local numbombtypes = C.GetNumAllInventoryBombs(pilot)
					local bombstoragetable = ffi.new("AmmoData[?]", numbombtypes)
					numbombtypes = C.GetAllInventoryBombs(bombstoragetable, numbombtypes, pilot)

					local gunmacro = GetComponentData(gun, "macro")
					local dropdowndata = {}
					for j = 0, numbombtypes - 1 do
						local ammomacro = ffi.string(bombstoragetable[j].macro)
						if C.IsAmmoMacroCompatible(gunmacro, ammomacro) then
							table.insert(dropdowndata, {id = ammomacro, text = GetMacroData(ammomacro, "name") .. " (" .. ConvertIntegerString(bombstoragetable[j].amount, true, 0, true) .. ")", icon = "", displayremoveoption = false})
						end
					end

					-- if the ship has no compatible ammunition in ammo storage, have the dropdown print "Out of ammo" and make it inactive.
					local currentammomacro = "empty"
					local dropdownactive = true
					if #dropdowndata == 0 then
						dropdownactive = false
						table.insert(dropdowndata, {id = "empty", text = ReadText(1001, 9412), icon = "", displayremoveoption = false})	-- Out of ammo
					else
						-- NB: currentammomacro can be null
						currentammomacro = ffi.string(C.GetCurrentAmmoOfWeapon(gun))
					end

					row = inputtable:addRow(("info_weaponconfig" .. i .. "_ammo"), {  })
					row[2]:createText((ReadText(1001, 2800) .. ReadText(1001, 120)))	-- Ammunition, :
					row[3]:setColSpan(11):createDropDown(dropdowndata, {startOption = currentammomacro, active = dropdownactive})
					row[3].handlers.onDropDownConfirmed = function(_, newammomacro) C.SetAmmoOfWeapon(gun, newammomacro) end
				end
			end
		end
	end
	if (mode == "ship") or (mode == "station") then
		-- turret behaviour
		menu.turrets = {}
		menu.turretgroups = {}
		if isplayerowned and #loadout.component.turret > 0 then
			local hasnormalturrets = false
			local hasmissileturrets = false
			local hasoperationalnormalturrets = false
			local hasoperationalmissileturrets = false
			local hasonlytugturrets = true

			local row = inputtable:addRow(false, { bgColor = Color["row_title_background"] })
			row[1]:setColSpan(13):createText(ReadText(1001, 8612), Helper.headerRowCenteredProperties) -- Turret Behaviour
			local numslots = tonumber(C.GetNumUpgradeSlots(inputobject, "", "turret"))
			for j = 1, numslots do
				local groupinfo = C.GetUpgradeSlotGroup(inputobject, "", "turret", j)
				if (ffi.string(groupinfo.path) == "..") and (ffi.string(groupinfo.group) == "") then
					local current = C.GetUpgradeSlotCurrentComponent(inputobject, "turret", j)
					if current ~= 0 then
						if (not hasmissileturrets) or (not hasnormalturrets) then
							local ismissileturret = C.IsComponentClass(current, "missileturret")
							hasmissileturrets = hasmissileturrets or ismissileturret
							hasnormalturrets = hasnormalturrets or (not ismissileturret)
						end
						if not GetComponentData(ConvertStringTo64Bit(tostring(current)), "istugweapon") then
							hasonlytugturrets = false
						end
						table.insert(menu.turrets, current)
					end
				end
			end

			local turretsizecounts = {}
			local n = C.GetNumUpgradeGroups(inputobject, "")
			local buf = ffi.new("UpgradeGroup2[?]", n)
			n = C.GetUpgradeGroups2(buf, n, inputobject, "")
			for i = 0, n - 1 do
				if (ffi.string(buf[i].path) ~= "..") or (ffi.string(buf[i].group) ~= "") then
					local group = { context = buf[i].contextid, path = ffi.string(buf[i].path), group = ffi.string(buf[i].group) }
					local groupinfo = C.GetUpgradeGroupInfo2(inputobject, "", group.context, group.path, group.group, "turret")
					if (groupinfo.count > 0) then
						group.operational = groupinfo.operational
						group.currentcomponent = groupinfo.currentcomponent
						group.currentmacro = ffi.string(groupinfo.currentmacro)
						group.slotsize = ffi.string(groupinfo.slotsize)
						group.sizecount = 0
						if (not hasmissileturrets) or (not hasnormalturrets) then
							local ismissileturret = IsMacroClass(group.currentmacro, "missileturret")
							hasmissileturrets = hasmissileturrets or ismissileturret
							hasnormalturrets = hasnormalturrets or (not ismissileturret)
							if ismissileturret then
								if not hasoperationalmissileturrets then
									hasoperationalmissileturrets = group.operational > 0
								end
							else
								if not hasoperationalnormalturrets then
									hasoperationalnormalturrets = group.operational > 0
								end
							end
						end
						if not GetComponentData(ConvertStringTo64Bit(tostring(group.currentcomponent)), "istugweapon") then
							hasonlytugturrets = false
						end

						if group.slotsize ~= "" then
							if turretsizecounts[group.slotsize] then
								turretsizecounts[group.slotsize] = turretsizecounts[group.slotsize] + 1
							else
								turretsizecounts[group.slotsize] = 1
							end
							group.sizecount = turretsizecounts[group.slotsize]
						end

						table.insert(menu.turretgroups, group)
					end
				end
			end

			if #menu.turretgroups > 0 then
				table.sort(menu.turretgroups, Helper.sortSlots)
			end

			if (#menu.turrets > 0) or (#menu.turretgroups > 0) then
				if mode == "ship" then
					local row = inputtable:addRow("info_turretconfig", {  })
					row[2]:setColSpan(3):createText(ReadText(1001, 2963))
					
					-- Start Subsystem Targeting Orders callback
					local sto_callbackVal
					if callbacks ["sto_addTurretBehavioursMapMenu"] then
						for _, callback in ipairs (callbacks ["sto_addTurretBehavioursMapMenu"]) do
							sto_callbackVal = callback (row, inputobject)
						end
					end
					if not sto_callbackVal then
						row[5]:setColSpan(9):createDropDown(Helper.getTurretModes(nil, not hasonlytugturrets), { startOption = function () return menu.getDropDownTurretModeOption(inputobject, "all") end })
						row[5].handlers.onDropDownConfirmed = function(_, newturretmode) menu.noupdate = false; C.SetAllTurretModes(inputobject, newturretmode) end
					end
					-- End Subsystem Targeting Orders callback

					row[5].handlers.onDropDownActivated = function () menu.noupdate = true end

					local row = inputtable:addRow("info_turretconfig_2", {  })
					row[5]:setColSpan(9):createButton({ height = config.mapRowHeight }):setText(function () return menu.areTurretsArmed(inputobject) and ReadText(1001, 8631) or ReadText(1001, 8632) end, { halign = "center" })
					row[5].handlers.onClick = function () return C.SetAllTurretsArmed(inputobject, not menu.areTurretsArmed(inputobject)) end

					local dropdownCount = 1
					for i, turret in ipairs(menu.turrets) do
						inputtable:addEmptyRow(config.mapRowHeight / 2)

						local row = inputtable:addRow("info_turretconfig" .. i, {  })
						row[2]:setColSpan(3):createText(ffi.string(C.GetComponentName(turret)))
						row[5]:setColSpan(9):createDropDown(Helper.getTurretModes(turret), { startOption = function () return menu.getDropDownTurretModeOption(turret) end })
						row[5].handlers.onDropDownConfirmed = function(_, newturretmode) menu.noupdate = false; C.SetWeaponMode(turret, newturretmode) end
						row[5].handlers.onDropDownActivated = function () menu.noupdate = true end
						dropdownCount = dropdownCount + 1
						if dropdownCount == 14 then
							inputtable.properties.maxVisibleHeight = inputtable:getFullHeight()
						end

						local row = inputtable:addRow("info_turretconfig" .. i .. "_2", {  })
						row[5]:setColSpan(9):createButton({ height = config.mapRowHeight }):setText(function () return C.IsWeaponArmed(turret) and ReadText(1001, 8631) or ReadText(1001, 8632) end, { halign = "center" })
						row[5].handlers.onClick = function () return C.SetWeaponArmed(turret, not C.IsWeaponArmed(turret)) end
					end

					for i, group in ipairs(menu.turretgroups) do
						inputtable:addEmptyRow(config.mapRowHeight / 2)

						local name = ReadText(1001, 8023) .. " " .. Helper.getSlotSizeText(group.slotsize) .. group.sizecount .. ((group.currentmacro ~= "") and (" (" .. Helper.getSlotSizeText(group.slotsize) .. " " .. GetMacroData(group.currentmacro, "shortname") .. ")") or "")

						local row = inputtable:addRow("info_turretgroupconfig" .. i, {  })
						row[2]:setColSpan(3):createText(name, { color = (group.operational > 0) and Color["text_normal"] or Color["text_error"] })
						row[5]:setColSpan(9):createDropDown(Helper.getTurretModes(group.currentcomponent), { startOption = function () return menu.getDropDownTurretModeOption(inputobject, group.context, group.path, group.group) end, active = group.operational > 0 })
						row[5].handlers.onDropDownConfirmed = function(_, newturretmode) menu.noupdate = false; C.SetTurretGroupMode2(inputobject, group.context, group.path, group.group, newturretmode) end
						row[5].handlers.onDropDownActivated = function () menu.noupdate = true end
						dropdownCount = dropdownCount + 1
						if dropdownCount == 14 then
							inputtable.properties.maxVisibleHeight = inputtable:getFullHeight()
						end

						local row = inputtable:addRow("info_turretgroupconfig" .. i .. "_2", {  })
						row[5]:setColSpan(9):createButton({ height = config.mapRowHeight }):setText(function () return C.IsTurretGroupArmed(inputobject, group.context, group.path, group.group) and ReadText(1001, 8631) or ReadText(1001, 8632) end, { halign = "center" })
						row[5].handlers.onClick = function () return C.SetTurretGroupArmed(inputobject, group.context, group.path, group.group, not C.IsTurretGroupArmed(inputobject, group.context, group.path, group.group)) end
					end
				elseif mode == "station" then
					local turretmodes = {
						[1] = { id = "defend",			text = ReadText(1001, 8613),	icon = "",	displayremoveoption = false },
						[2] = { id = "attackenemies",	text = ReadText(1001, 8614),	icon = "",	displayremoveoption = false },
						[3] = { id = "attackcapital",	text = ReadText(1001, 8634),	icon = "",	displayremoveoption = false },
						[4] = { id = "prefercapital",	text = ReadText(1001, 8637),	icon = "",	displayremoveoption = false },
						[5] = { id = "attackfighters",	text = ReadText(1001, 8635),	icon = "",	displayremoveoption = false },
						[6] = { id = "preferfighters",	text = ReadText(1001, 8638),	icon = "",	displayremoveoption = false },
						[7] = { id = "missiledefence",	text = ReadText(1001, 8636),	icon = "",	displayremoveoption = false },
						[8] = { id = "prefermissiles",	text = ReadText(1001, 8639),	icon = "",	displayremoveoption = false },
					}

					if hasnormalturrets then
						-- non-missile
						local row = inputtable:addRow("info_turretconfig", {  })
						row[2]:setColSpan(3):createText(ReadText(1001, 8397))
						row[5]:setColSpan(9):createDropDown(turretmodes, { startOption = function () return menu.getDropDownTurretModeOption(inputobject, "all", false) end, active = hasoperationalnormalturrets, mouseOverText = (not hasoperationalnormalturrets) and ReadText(1026, 3235) or nil })
						row[5].handlers.onDropDownConfirmed = function(_, newturretmode) menu.noupdate = false; C.SetAllNonMissileTurretModes(inputobject, newturretmode) end
						row[5].handlers.onDropDownActivated = function () menu.noupdate = true end

						local row = inputtable:addRow("info_turretconfig_2", {  })
						row[5]:setColSpan(9):createButton({ height = config.mapRowHeight }):setText(function () return menu.areTurretsArmed(inputobject, false) and ReadText(1001, 8631) or ReadText(1001, 8632) end, { halign = "center" })
						row[5].handlers.onClick = function () return C.SetAllNonMissileTurretsArmed(inputobject, not menu.areTurretsArmed(inputobject, false)) end
					end
					if hasmissileturrets then
						-- missile
						local row = inputtable:addRow("info_turretconfig_missile", {  })
						row[2]:setColSpan(3):createText(ReadText(1001, 9031))
						row[5]:setColSpan(9):createDropDown(turretmodes, { startOption = function () return menu.getDropDownTurretModeOption(inputobject, "all", true) end, active = hasoperationalmissileturrets, mouseOverText = (not hasoperationalnormalturrets) and ReadText(1026, 3235) or nil })
						row[5].handlers.onDropDownConfirmed = function(_, newturretmode) menu.noupdate = false; C.SetAllMissileTurretModes(inputobject, newturretmode) end
						row[5].handlers.onDropDownActivated = function () menu.noupdate = true end

						local row = inputtable:addRow("info_turretconfig_missile_2", {  })
						row[5]:setColSpan(9):createButton({ height = config.mapRowHeight }):setText(function () return menu.areTurretsArmed(inputobject, true) and ReadText(1001, 8631) or ReadText(1001, 8632) end, { halign = "center" })
						row[5].handlers.onClick = function () return C.SetAllMissileTurretsArmed(inputobject, not menu.areTurretsArmed(inputobject, true)) end
					end
				end
			end
		end
		-- drones
		local isplayeroccupiedship = menu.infoSubmenuObject == ConvertStringTo64Bit(tostring(C.GetPlayerOccupiedShipID()))

		local unitstoragetable = C.IsComponentClass(object64, "defensible") and GetUnitStorageData(object64) or { stored = 0, capacity = 0 }
		local locunitcapacity = Helper.unlockInfo(unitinfo_capacity, tostring(unitstoragetable.capacity))
		local locunitcount = Helper.unlockInfo(unitinfo_amount, tostring(unitstoragetable.stored))
		menu.drones = {}
		local dronetypes = {
			{ id = "orecollector",	name = ReadText(20214, 500),	displayonly = true },
			{ id = "gascollector",	name = ReadText(20214, 400),	displayonly = true },
			{ id = "defence",		name = ReadText(20214, 300) },
			{ id = "transport",		name = ReadText(20214, 900) },
			{ id = "build",			name = ReadText(20214, 1000),	skipmode = true },
			{ id = "repair",		name = ReadText(20214, 1100),	skipmode = true },
		}
		for _, dronetype in ipairs(dronetypes) do
			if C.GetNumStoredUnits(inputobject, dronetype.id, false) > 0 then
				local entry
				if not dronetype.skipmode then
					entry = {
						type = dronetype.id,
						name = dronetype.name,
						current = ffi.string(C.GetCurrentDroneMode(inputobject, dronetype.id)),
						modes = {},
						displayonly = dronetype.displayonly,
					}
					local n = C.GetNumDroneModes(inputobject, dronetype.id)
					local buf = ffi.new("DroneModeInfo[?]", n)
					n = C.GetDroneModes(buf, n, inputobject, dronetype.id)
					for i = 0, n - 1 do
						local id = ffi.string(buf[i].id)
						if (id ~= "trade") or (id == entry.current) then
							table.insert(entry.modes, { id = id, text = ffi.string(buf[i].name), icon = "", displayremoveoption = false })
						end
					end
				else
					entry = {
						type = dronetype.id,
						name = dronetype.name,
					}
				end
				table.insert(menu.drones, entry)
			end
		end
		if unitstoragetable.capacity > 0 then
			-- title
			local row = inputtable:addRow(false, { bgColor = Color["row_title_background"] })
			row[1]:setColSpan(13):createText(ReadText(1001, 8619), Helper.headerRowCenteredProperties)
			-- capcity
			local row = inputtable:addRow(false, { bgColor = Color["row_background_unselectable"] })
			row[2]:createText(ReadText(1001, 8393))
			row[8]:setColSpan(6):createText(locunitcount .. " / " .. locunitcapacity, { halign = "right" })
			-- drones
			if unitinfo_details then
				for i, entry in ipairs(menu.drones) do
					if i ~= 1 then
						inputtable:addEmptyRow(config.mapRowHeight / 2)
					end
					local hasmodes = (mode == "ship") and entry.current
					-- drone name, amount and mode
					local row1 = inputtable:addRow("drone_config", {  })
					row1[2]:createText(entry.name)
					row1[3]:setColSpan(isplayerowned and 2 or 11):createText(function () return Helper.unlockInfo(unitinfo_amount, C.GetNumStoredUnits(inputobject, entry.type, false)) end, { halign = isplayerowned and "left" or "right" })
					-- active and armed status
					local row2 = inputtable:addRow("drone_config", {  })
					row2[2]:createText("    " .. ReadText(1001, 11229), { color = hasmodes and function () return C.IsDroneTypeArmed(inputobject, entry.type) and Color["text_normal"] or Color["text_inactive"] end or nil })
					row2[3]:setColSpan(isplayerowned and 2 or 11):createText(function () return Helper.unlockInfo(unitinfo_amount, C.GetNumUnavailableUnits(inputobject, entry.type)) end, { halign = isplayerowned and "left" or "right", color = hasmodes and function () return C.IsDroneTypeBlocked(inputobject, entry.type) and Color["text_warning"] or (C.IsDroneTypeArmed(inputobject, entry.type) and Color["text_normal"] or Color["text_inactive"]) end or nil })

					-- drone mode support - disabled for mining drones, to avoid conflicts with order defined drone behaviour
					if hasmodes then
						local isblocked = C.IsDroneTypeBlocked(inputobject, entry.type)
						if isplayerowned then
							local active = (isplayeroccupiedship or (not entry.displayonly)) and (not isblocked)
							local mouseovertext = ""
							if isblocked then
								mouseovertext = ReadText(1026, 3229)
							elseif (not isplayeroccupiedship) and entry.displayonly then
								mouseovertext = ReadText(1026, 3230)
							end

							row1[5]:setColSpan(9):createDropDown(entry.modes, { startOption = function () return ffi.string(C.GetCurrentDroneMode(inputobject, entry.type)) end, active = active, mouseOverText = mouseovertext })
							row1[5].handlers.onDropDownConfirmed = function (_, newdronemode) C.SetDroneMode(inputobject, entry.type, newdronemode) end

							row2[5]:setColSpan(9):createButton({ active = active, mouseOverText = mouseovertext, height = config.mapRowHeight }):setText(function () return C.IsDroneTypeArmed(inputobject, entry.type) and ReadText(1001, 8622) or ReadText(1001, 8623) end, { halign = "center" })
							row2[5].handlers.onClick = function () return C.SetDroneTypeArmed(inputobject, entry.type, not C.IsDroneTypeArmed(inputobject, entry.type)) end
						end
					end
				end
			end
		end
		-- subordinates
		if isplayerowned then
			if C.IsComponentClass(inputobject, "controllable") then
				local subordinates = GetSubordinates(inputobject)
				local groups = {}
				local usedassignments = {}
				for _, subordinate in ipairs(subordinates) do
					local purpose, shiptype = GetComponentData(subordinate, "primarypurpose", "shiptype")
					local group = GetComponentData(subordinate, "subordinategroup")
					if group and group > 0 then
						if groups[group] then
							table.insert(groups[group].subordinates, subordinate)
							if shiptype == "resupplier" then
								groups[group].numassignableresupplyships = groups[group].numassignableresupplyships + 1
							end
							if purpose == "mine" then
								groups[group].numassignableminingships = groups[group].numassignableminingships + 1
							end
							if shiptype == "tug" then
								groups[group].numassignabletugships = groups[group].numassignabletugships + 1
							end
						else
							local assignment = ffi.string(C.GetSubordinateGroupAssignment(inputobject, group))
							usedassignments[assignment] = group
							groups[group] = { assignment = assignment, subordinates = { subordinate }, numassignableresupplyships = (shiptype == "resupplier") and 1 or 0, numassignableminingships = (purpose == "mine") and 1 or 0, numassignabletugships = (shiptype == "tug") and 1 or 0 }
						end
					end
				end

				if #subordinates > 0 then
					-- title
					local row = inputtable:addRow(false, { bgColor = Color["row_title_background"] })
					row[1]:setColSpan(13):createText(ReadText(1001, 8626), Helper.headerRowCenteredProperties)

					local isstation = C.IsComponentClass(inputobject, "station")
					for i = 1, isstation and 5 or 10 do
						if groups[i] then
							local defenceactive = true
							if isstation then
								defenceactive = ((not usedassignments["defence"]) or (usedassignments["defence"] == i))
							end
							local supplyactive = (groups[i].numassignableresupplyships == #groups[i].subordinates) and ((not usedassignments["supplyfleet"]) or (usedassignments["supplyfleet"] == i))
							local subordinateassignments = {
								[1] = { id = "defence",			text = ReadText(20208, 40301),	icon = "",	displayremoveoption = false, active = defenceactive, mouseovertext = defenceactive and "" or ReadText(1026, 7840) },
								[2] = { id = "supplyfleet",		text = ReadText(20208, 40701),	icon = "",	displayremoveoption = false, active = supplyactive, mouseovertext = supplyactive and "" or ReadText(1026, 8601) },
							}
							local shiptype = GetComponentData(inputobject, "shiptype")
							if shiptype == "resupplier" then
								table.insert(subordinateassignments, { id = "trade",			text = ReadText(20208, 40101),	icon = "",	displayremoveoption = false })
							end

							if isstation then
								local miningactive = (groups[i].numassignableminingships == #groups[i].subordinates) and ((not usedassignments["mining"]) or (usedassignments["mining"] == i))
								table.insert(subordinateassignments, { id = "mining", text = ReadText(20208, 40201), icon = "", displayremoveoption = false, active = miningactive, mouseovertext = miningactive and "" or ReadText(1026, 8602) })
								local tradeactive = ((not usedassignments["trade"]) or (usedassignments["trade"] == i))
								table.insert(subordinateassignments, { id = "trade", text = ReadText(20208, 40101), icon = "", displayremoveoption = false, active = tradeactive, mouseovertext = tradeactive and ((groups[i].numassignableminingships > 0) and (ColorText["text_warning"] .. ReadText(1026, 8607)) or "") or ReadText(1026, 7840) })
								local tradeforbuildstorageactive = (groups[i].numassignableminingships == 0) and ((not usedassignments["tradeforbuildstorage"]) or (usedassignments["tradeforbuildstorage"] == i))
								table.insert(subordinateassignments, { id = "tradeforbuildstorage", text = ReadText(20208, 40801), icon = "", displayremoveoption = false, active = tradeforbuildstorageactive, mouseovertext = tradeforbuildstorageactive and "" or ReadText(1026, 8603) })
								local salvageactive = (groups[i].numassignabletugships == #groups[i].subordinates) and ((not usedassignments["salvage"]) or (usedassignments["salvage"] == i))
								table.insert(subordinateassignments, { id = "salvage", text = ReadText(20208, 41401), icon = "", displayremoveoption = false, active = salvageactive, mouseovertext = salvageactive and "" or ReadText(1026, 8610) })
							elseif C.IsComponentClass(inputobject, "ship") then
								-- position defence
								local parentcommander = ConvertIDTo64Bit(GetCommander(inputobject))
								local isfleetcommander = (not parentcommander) and (#subordinates > 0)
								if (shiptype == "carrier") and isfleetcommander then
									table.insert(subordinateassignments, { id = "positiondefence", text = ReadText(20208, 41501), icon = "", displayremoveoption = false })
								end
								-- start: aegs call-back
								if callbacks ["map_ship_subordinateassignments_insert"] then
									local ship_assignment
									for _, callback in ipairs (callbacks ["map_ship_subordinateassignments_insert"]) do
										ship_assignment = callback (GetComponentData(inputobject, "macro"),(groups[i].numassignableminingships == #groups[i].subordinates) and ((not usedassignments["mining"]) or (usedassignments["mining"] == i)),(groups[i].numassignabletugships == #groups[i].subordinates) and ((not usedassignments["salvage"]) or (usedassignments["salvage"] == i)))
										if ship_assignment then
											table.insert(subordinateassignments, ship_assignment)
										end
									end
								end
								-- end: aegs call-back
								table.insert(subordinateassignments, { id = "attack", text = ReadText(20208, 40901), icon = "", displayremoveoption = false })
								table.insert(subordinateassignments, { id = "interception", text = ReadText(20208, 41001), icon = "", displayremoveoption = false })
								table.insert(subordinateassignments, { id = "bombardment", text = ReadText(20208, 41601), icon = "", displayremoveoption = false })
								table.insert(subordinateassignments, { id = "follow", text = ReadText(20208, 41301), icon = "", displayremoveoption = false })
								local active = true
								local mouseovertext = ""
								local buf = ffi.new("Order")
								if not C.GetDefaultOrder(buf, inputobject) then
									active = false
									mouseovertext = ReadText(1026, 8606)
								end
								table.insert(subordinateassignments, { id = "assist", text = ReadText(20208, 41201), icon = "", displayremoveoption = false, active = active, mouseovertext = mouseovertext })
							end

							local isdockingpossible = false
							for _, subordinate in ipairs(groups[i].subordinates) do
								if IsDockingPossible(subordinate, inputobject) then
									isdockingpossible = true
									break
								end
							end
							local active = function () return menu.buttonActiveSubordinateGroupLaunch(inputobject, i) end
							local mouseovertext = ""
							if isstation then
								active = false
							elseif not GetComponentData(inputobject, "hasshipdockingbays") then
								active = false
								mouseovertext = ReadText(1026, 8604)
							elseif not isdockingpossible then
								active = false
								mouseovertext = ReadText(1026, 8605)
							end

							local row = inputtable:addRow("subordinate_config", {  })
							row[2]:createText(function () menu.updateSubordinateGroupInfo(inputobject); return ReadText(20401, i) .. (menu.subordinategroups[i] and (" (" .. ((not C.ShouldSubordinateGroupDockAtCommander(inputobject, i)) and ((#menu.subordinategroups[i].subordinates - menu.subordinategroups[i].numdockedatcommander) .. "/") or "") .. #menu.subordinategroups[i].subordinates ..")") or "") end, { color = isblocked and Color["text_warning"] or nil })
							row[3]:setColSpan(11):createDropDown(subordinateassignments, { startOption = function () menu.updateSubordinateGroupInfo(inputobject); return menu.subordinategroups[i] and menu.subordinategroups[i].assignment or "" end })
							row[3].handlers.onDropDownActivated = function () menu.noupdate = true end
							row[3].handlers.onDropDownConfirmed = function(_, newassignment) return Helper.dropdownAssignment(_, nil, i, inputobject, newassignment) end
							local row = inputtable:addRow("subordinate_config", {  })
							-- Start Reactive Docking callback
							local rd_callbackVal
							if callbacks ["rd_addReactiveDockingMapMenu"] then
								for _, callback in ipairs (callbacks ["rd_addReactiveDockingMapMenu"]) do
									rd_callbackVal = callback (row, inputobject, i, mode, active, mouseovertext)
								end
							end
							if not rd_callbackVal then
								row[3]:setColSpan(11):createButton({ active = active, mouseOverText = mouseovertext, height = config.mapRowHeight }):setText(function () return C.ShouldSubordinateGroupDockAtCommander(inputobject, i) and ReadText(1001, 8630) or ReadText(1001, 8629) end, { halign = "center" })
								row[3].handlers.onClick = function () return C.SetSubordinateGroupDockAtCommander(inputobject, i, not C.ShouldSubordinateGroupDockAtCommander(inputobject, i)) end
							end
							-- End Reactive Docking callback
						end
					end
				end
			end
		end
		-- ammunition
		local nummissiletypes = C.GetNumAllMissiles(inputobject)
		local missilestoragetable = ffi.new("AmmoData[?]", nummissiletypes)
		nummissiletypes = C.GetAllMissiles(missilestoragetable, nummissiletypes, inputobject)
		local totalnummissiles = 0
		for i = 0, nummissiletypes - 1 do
			totalnummissiles = totalnummissiles + missilestoragetable[i].amount
		end
		local missilecapacity = 0
		if C.IsComponentClass(inputobject, "defensible") then
			missilecapacity = GetComponentData(inputobject, "missilecapacity")
		end
		local locmissilecapacity = Helper.unlockInfo(defenceinfo_low, tostring(missilecapacity))
		local locnummissiles = Helper.unlockInfo(defenceinfo_high, tostring(totalnummissiles))
		if totalnummissiles > 0 then
			-- title
			local row = inputtable:addRow(false, { bgColor = Color["row_title_background"] })
			row[1]:setColSpan(13):createText(ReadText(1001, 2800), Helper.headerRowCenteredProperties) -- Ammunition
			-- capcity
			local row = inputtable:addRow(false, { bgColor = Color["row_background_unselectable"] })
			row[2]:createText(ReadText(1001, 8393))
			row[8]:setColSpan(6):createText(locnummissiles .. " / " .. locmissilecapacity, { halign = "right" })
			if defenceinfo_high then
				for i = 0, nummissiletypes - 1 do
					local macro = ffi.string(missilestoragetable[i].macro)
					local row = inputtable:addRow({ "info_weapons", macro, inputobject }, {  })
					row[2]:createText(GetMacroData(macro, "name"))
					row[8]:setColSpan(6):createText(tostring(missilestoragetable[i].amount), { halign = "right" })
				end
			end
		end
	end

	-- start: aegs call-back
		if callbacks ["map_loadoutinfo_double_insert"] then
			local state,title_text,label_text_1,label_text_2,subsystems
			for _, callback in ipairs (callbacks ["map_loadoutinfo_double_insert"]) do
				state,title_text,label_text_1,label_text_2,subsystems = callback (GetComponentData(inputobject, "macro"))
				if state then
					local row = inputtable:addRow(false, { bgColor = Color["row_title_background"] })
					row[1]:setColSpan(13):createText(title_text, Helper.headerRowCenteredProperties)
					for _, subsystem in ipairs(subsystems) do
						local row = inputtable:addRow(false, { interactive = false })
						row[1]:setColSpan(13):createText(subsystem.name, {halign = "center"})
						if subsystem.icon then
							local row = inputtable:addRow(false, { interactive = false })
							row[2]:setColSpan(11):createIcon(subsystem.icon, {height = config.mapRowHeight * 10, mouseOverText = subsystem.intro,halign = "center"})
						end
					end
				end
			end
		end
	-- end: aegs call-back

	if mode == "ship" then
		-- countermeasures
		local numcountermeasuretypes = C.GetNumAllCountermeasures(inputobject)
		local countermeasurestoragetable = ffi.new("AmmoData[?]", numcountermeasuretypes)
		numcountermeasuretypes = C.GetAllCountermeasures(countermeasurestoragetable, numcountermeasuretypes, inputobject)
		local totalnumcountermeasures = 0
		for i = 0, numcountermeasuretypes - 1 do
			totalnumcountermeasures = totalnumcountermeasures + countermeasurestoragetable[i].amount
		end
		local countermeasurecapacity = GetComponentData(object64, "countermeasurecapacity")
		local loccountermeasurecapacity = Helper.unlockInfo(defenceinfo_low, tostring(countermeasurecapacity))
		local locnumcountermeasures = Helper.unlockInfo(defenceinfo_high, tostring(totalnumcountermeasures))
		if totalnumcountermeasures > 0 then
			-- title
			local row = inputtable:addRow(false, { bgColor = Color["row_title_background"] })
			row[1]:setColSpan(13):createText(ReadText(20215, 1701), Helper.headerRowCenteredProperties) -- Countermeasures
			-- capcity
			local row = inputtable:addRow(false, { bgColor = Color["row_background_unselectable"] })
			row[2]:createText(ReadText(1001, 8393))
			row[8]:setColSpan(6):createText(locnumcountermeasures .. " / " .. loccountermeasurecapacity, { halign = "right" })
			if defenceinfo_high then
				for i = 0, numcountermeasuretypes - 1 do
					local row = inputtable:addRow(true, { interactive = false })
					row[2]:createText(GetMacroData(ffi.string(countermeasurestoragetable[i].macro), "name"))
					row[8]:setColSpan(6):createText(tostring(countermeasurestoragetable[i].amount), { halign = "right" })
				end
			end
		end
		-- deployables
		local consumables = {
			{ id = "satellite",		type = "civilian",	getnum = C.GetNumAllSatellites,		getdata = C.GetAllSatellites,		callback = C.LaunchSatellite },
			{ id = "navbeacon",		type = "civilian",	getnum = C.GetNumAllNavBeacons,		getdata = C.GetAllNavBeacons,		callback = C.LaunchNavBeacon },
			{ id = "resourceprobe",	type = "civilian",	getnum = C.GetNumAllResourceProbes,	getdata = C.GetAllResourceProbes,	callback = C.LaunchResourceProbe },
			{ id = "lasertower",	type = "military",	getnum = C.GetNumAllLaserTowers,	getdata = C.GetAllLaserTowers,		callback = C.LaunchLaserTower },
			{ id = "mine",			type = "military",	getnum = C.GetNumAllMines,			getdata = C.GetAllMines,			callback = C.LaunchMine },
		}
		local totalnumdeployables = 0
		local consumabledata = {}
		for _, entry in ipairs(consumables) do
			local n = entry.getnum(inputobject)
			local buf = ffi.new("AmmoData[?]", n)
			n = entry.getdata(buf, n, inputobject)
			consumabledata[entry.id] = {}
			for i = 0, n - 1 do
				table.insert(consumabledata[entry.id], { macro = ffi.string(buf[i].macro), name = GetMacroData(ffi.string(buf[i].macro), "name"), amount = buf[i].amount, capacity = buf[i].capacity })
				totalnumdeployables = totalnumdeployables + buf[i].amount
			end
		end
		local deployablecapacity = C.GetDefensibleDeployableCapacity(inputobject)
		local printednumdeployables = Helper.unlockInfo(defenceinfo_low, tostring(totalnumdeployables))
		local printeddeployablecapacity = Helper.unlockInfo(defenceinfo_low, tostring(deployablecapacity))
		if totalnumdeployables > 0 then
			-- title
			local row = inputtable:addRow(false, { bgColor = Color["row_title_background"] })
			row[1]:setColSpan(13):createText(ReadText(1001, 1332), Helper.headerRowCenteredProperties) -- Deployables
			-- capcity
			local row = inputtable:addRow(false, { bgColor = Color["row_background_unselectable"] })
			row[2]:createText(ReadText(1001, 8393))
			row[8]:setColSpan(6):createText(printednumdeployables .. " / " .. printeddeployablecapacity, { halign = "right" })
			if defenceinfo_high then
				for _, entry in ipairs(consumables) do
					if #consumabledata[entry.id] > 0 then
						for _, data in ipairs(consumabledata[entry.id]) do
							local row = inputtable:addRow({ "info_deploy", data.macro, inputobject }, {  })
							row[2]:createText(data.name)
							row[8]:setColSpan(6):createText(data.amount, { halign = "right" })
						end
					end
				end
				if isplayerowned then
					-- deploy
					local row = inputtable:addRow("info_deploy", {  })
					row[3]:setColSpan(11):createButton({ height = config.mapRowHeight, active = function () return next(menu.infoTablePersistentData[instance].macrostolaunch) ~= nil end }):setText(ReadText(1001, 8390), { halign = "center" })
					row[3].handlers.onClick = function () return menu.buttonDeploy(instance) end
				end
			end
		end
	end
	if (mode == "ship") or (mode == "station") then
		-- loadout
		if (#loadout.component.weapon > 0) or (#loadout.component.turret > 0) or (#loadout.component.shield > 0) or (#loadout.component.engine > 0) or (#loadout.macro.thruster > 0) or (#loadout.ware.software > 0) then
			if defenceinfo_high then
				local hasshown = false
				-- title
				local row = inputtable:addRow(false, { bgColor = Color["row_title_background"] })
				row[1]:setColSpan(13):createText(ReadText(1001, 9413), Helper.headerRowCenteredProperties) -- Loadout
				local row = inputtable:addRow(false, { bgColor = Color["row_background_unselectable"] })
				row[2]:setColSpan(5):createText(ReadText(1001, 7935), { font = Helper.standardFontBold })
				row[7]:setColSpan(4):createText(ReadText(1001, 1311), { font = Helper.standardFontBold, halign = "right" })
				row[11]:setColSpan(3):createText(ReadText(1001, 12), { font = Helper.standardFontBold, halign = "right" })

				inputtable:addEmptyRow(config.mapRowHeight / 2)

				local macroequipment = {
					{ type = "weapon", encyclopedia = "info_weapon" },
					{ type = "turret", encyclopedia = "info_weapon" },
					{ type = "shield", encyclopedia = "info_equipment" },
					{ type = "engine", encyclopedia = "info_equipment" },
				}
				for _, entry in ipairs(macroequipment) do
					if #loadout.component[entry.type] > 0 then
						if hasshown then
							inputtable:addEmptyRow(config.mapRowHeight / 2)
						end
						hasshown = true
						local locmacros = menu.infoCombineLoadoutComponents(loadout.component[entry.type])
						for macro, data in pairs(locmacros) do
							local row = inputtable:addRow({ entry.encyclopedia, macro, inputobject }, {  })
							row[2]:setColSpan(5):createText(GetMacroData(macro, "name"))
							row[7]:setColSpan(4):createText(data.count .. " / " .. data.count + data.construction + data.wreck, { halign = "right" })
							local shieldpercent = data.shieldpercent
							local hullpercent = data.hullpercent
							if data.count > 0 then
								shieldpercent = shieldpercent / data.count
								hullpercent = hullpercent / data.count
							end
							row[11]:setColSpan(3):createShieldHullBar(shieldpercent, hullpercent, { scaling = false, width = row[11]:getColSpanWidth() / 2, x = row[11]:getColSpanWidth() / 4 })

							AddKnownItem(GetMacroData(macro, "infolibrary"), macro)
						end
					end
				end

				if #loadout.macro.thruster > 0 then
					if hasshown then
						inputtable:addEmptyRow(config.mapRowHeight / 2)
					end
					hasshown = true
					-- ships normally only have 1 set of thrusters. in case a ship has more, this will list all of them.
					for i, val in ipairs(loadout.macro.thruster) do
						local row = inputtable:addRow({ "info_equipment", macro, inputobject }, {  })
						row[2]:setColSpan(12):createText(GetMacroData(val, "name"))

						AddKnownItem(GetMacroData(val, "infolibrary"), val)
					end
				end
				if #loadout.ware.software > 0 then
					if hasshown then
						inputtable:addEmptyRow(config.mapRowHeight / 2)
					end
					hasshown = true
					for i, val in ipairs(loadout.ware.software) do
						local row = inputtable:addRow({ "info_software", val, inputobject }, {  })
						row[2]:setColSpan(12):createText(GetWareData(val, "name"))

						AddKnownItem("software", val)
					end
				end
			else
				local row = inputtable:addRow(false, { bgColor = Color["row_background_unselectable"] })
				row[2]:setColSpan(12):createText(ReadText(1001, 3210))
			end
		end
	end
	if mode == "ship" then
		-- mods
		-- title
		local row = inputtable:addRow(false, { bgColor = Color["row_title_background"] })
		row[1]:setColSpan(13):createText(ReadText(1001, 8031), Helper.headerRowCenteredProperties)
		if equipment_mods and GetComponentData(object64, "hasanymod") then
			local hasshown = false
			-- chassis
			local hasinstalledmod, installedmod = Helper.getInstalledModInfo("ship", inputobject)
			if hasinstalledmod then
				if hasshown then
					inputtable:addEmptyRow(config.mapRowHeight / 2)
				end
				hasshown = true
				row = menu.addEquipmentModInfoRow(inputtable, "ship", installedmod, ReadText(1001, 8008))
			end
			-- weapon
			for i, weapon in ipairs(loadout.component.weapon) do
				local hasinstalledmod, installedmod = Helper.getInstalledModInfo("weapon", weapon)
				if hasinstalledmod then
					if hasshown then
						inputtable:addEmptyRow(config.mapRowHeight / 2)
					end
					hasshown = true
					row = menu.addEquipmentModInfoRow(inputtable, "weapon", installedmod, ffi.string(C.GetComponentName(weapon)))
				end
			end
			-- turret
			for i, group in ipairs(menu.turretgroups) do
				local hasinstalledmod, installedmod = Helper.getInstalledModInfo("turret", inputobject, group.context, group.group, true)
				if hasinstalledmod then
					if hasshown then
						inputtable:addEmptyRow(config.mapRowHeight / 2)
					end
					hasshown = true

					local name = ReadText(1001, 8023) .. " " .. Helper.getSlotSizeText(group.slotsize) .. group.sizecount .. ((group.currentmacro ~= "") and (" (" .. Helper.getSlotSizeText(group.slotsize) .. " " .. GetMacroData(group.currentmacro, "shortname") .. ")") or "")
					row = menu.addEquipmentModInfoRow(inputtable, "weapon", installedmod, name)
				end
			end
			for i, turret in ipairs(menu.turrets) do
				local hasinstalledmod, installedmod = Helper.getInstalledModInfo("turret", turret)
				if hasinstalledmod then
					if hasshown then
						inputtable:addEmptyRow(config.mapRowHeight / 2)
					end
					hasshown = true
					row = menu.addEquipmentModInfoRow(inputtable, "weapon", installedmod, ffi.string(C.GetComponentName(turret)))
				end
			end
			-- shield
			local shieldgroups = {}
			local n = C.GetNumShieldGroups(inputobject)
			local buf = ffi.new("ShieldGroup[?]", n)
			n = C.GetShieldGroups(buf, n, inputobject)
			for i = 0, n - 1 do
				local entry = {}
				entry.context = buf[i].context
				entry.group = ffi.string(buf[i].group)
				entry.component = buf[i].component

				table.insert(shieldgroups, entry)
			end
			for i, entry in ipairs(shieldgroups) do
				if (entry.context == inputobject) and (entry.group == "") then
					shieldgroups.hasMainGroup = true
					-- force maingroup to first index
					table.insert(shieldgroups, 1, entry)
					table.remove(shieldgroups, i + 1)
					break
				end
			end
			for i, shieldgroupdata in ipairs(shieldgroups) do
				local hasinstalledmod, installedmod = Helper.getInstalledModInfo("shield", inputobject, shieldgroupdata.context, shieldgroupdata.group)
				if hasinstalledmod then
					local name = GetMacroData(GetComponentData(ConvertStringTo64Bit(tostring(shieldgroupdata.component)), "macro"), "name")
					if (i == 1) and shieldgroups.hasMainGroup then
						name = ReadText(1001, 8044)
					end
					if hasshown then
						inputtable:addEmptyRow(config.mapRowHeight / 2)
					end
					hasshown = true
					row = menu.addEquipmentModInfoRow(inputtable, "shield", installedmod, name)
				end
			end
			-- engine
			local hasinstalledmod, installedmod = Helper.getInstalledModInfo("engine", inputobject)
			if hasinstalledmod then
				if hasshown then
					inputtable:addEmptyRow(config.mapRowHeight / 2)
				end
				hasshown = true
				row = menu.addEquipmentModInfoRow(inputtable, "engine", installedmod, ffi.string(C.GetComponentName(loadout.component.engine[1])))
			end
		else
			local row = inputtable:addRow(false, { bgColor = Color["row_background_unselectable"] })
			row[2]:setColSpan(12):createText(Helper.unlockInfo(equipment_mods, ReadText(1001, 8394)))
		end
	end
	if mode == "none" then
		local row = inputtable:addRow(false, { bgColor = Color["row_background_unselectable"] })
		row[2]:setColSpan(12):createText(ReadText(1001, 6526))
	end
end

function menu.infologbookSearchHelper(entry, text, text2)
	text = utf8.lower(text)

	if string.find(utf8.lower(entry.title), text, 1, true) then
		if text2 then
			return menu.infologbookSearchHelper(entry, text2)
		end
		return true
	end
	if string.find(utf8.lower(entry.text), text, 1, true) then
		if text2 then
			return menu.infologbookSearchHelper(entry, text2)
		end
		return true
	end
	if string.find(utf8.lower(entry.entityname), text, 1, true) then
		if text2 then
			return menu.infologbookSearchHelper(entry, text2)
		end
		return true
	end
	if string.find(utf8.lower(entry.factionname), text, 1, true) then
		if text2 then
			return menu.infologbookSearchHelper(entry, text2)
		end
		return true
	end

	return false
end

function menu.setupLogbookInfoSubmenuRows(inputtable, inputobject, instance, isvalid)
	if (not menu.infoTablePersistentData[instance].logbookData) or (menu.infoTablePersistentData[instance].logbookData.curobject ~= inputobject) then
		local objecttext = "none", ""
		local isuseid, issector = false, false
		if isvalid then
			isuseid = true
			local macro = GetComponentData(inputobject, "macro")
			if C.IsRealComponentClass(inputobject, "ship") then
			elseif C.IsRealComponentClass(inputobject, "station") then
			elseif C.IsComponentClass(inputobject, "sector") then
				isuseid = false
				issector = true
			elseif C.IsComponentClass(inputobject, "gate") or C.IsComponentClass(inputobject, "highway") then
				isuseid = false
			elseif C.IsComponentClass(inputobject, "mine") or C.IsComponentClass(inputobject, "navbeacon") or C.IsComponentClass(inputobject, "resourceprobe") or C.IsComponentClass(inputobject, "satellite") then
			elseif C.IsComponentClass(inputobject, "asteroid") then
			elseif C.IsComponentClass(inputobject, "object") then
			end
			if isuseid then
				objecttext = ffi.string(C.GetObjectIDCode(inputobject))
			else
				objecttext = GetComponentData (inputobject, "name")
			end
		end
		menu.infoTablePersistentData[instance].logbookData = { curobject = inputobject, curPage = 1, objecttext = objecttext, searchtext = "", isuseid = isuseid, issector = issector }
	end
	-- DebugError("objecttext: " .. tostring(menu.infoTablePersistentData[instance].logbookData.objecttext) .. " isuseid: " .. tostring(menu.infoTablePersistentData[instance].logbookData.isuseid))

	local logbookData = menu.infoTablePersistentData[instance].logbookData

	local cheatsecrecy = false
	-- secrecy stuff
	local nameinfo = cheatsecrecy or C.IsInfoUnlockedForPlayer(inputobject, "name")

	--- title ---
	local row = inputtable:addRow(false, { fixed = true, bgColor = Color["row_title_background"] })
	row[1]:setColSpan(10):createText(ReadText(1001, 2427), Helper.headerRowCenteredProperties)
	local row = inputtable:addRow(false, { fixed = true, bgColor = Color["row_title_background"] })
	row[1]:setColSpan(10):createText(ReadText(1001, 5700), Helper.headerRowCenteredProperties)
	local isplayerowned = GetComponentData(inputobject, "isplayerowned")
	if not isplayerowned then
		local row = inputtable:addRow(false, { fixed = true })
		local ownername = GetComponentData(inputobject, "ownername")
		if not ownername or ownername == "" then
			if menu.infoTablePersistentData[instance].logbookData.issector then
				row[1]:setColSpan(10):createText(ReadText(1001, 11647))
			else
				row[1]:setColSpan(10):createText(ReadText(1001, 11645))
			end
		else
			if menu.infoTablePersistentData[instance].logbookData.issector then
				row[1]:setColSpan(10):createText(string.format(ReadText(1001, 11646), ownername))
			else
				row[1]:setColSpan(10):createText(string.format(ReadText(1001, 11644), ownername))
			end
		end
	end

	local objectname = Helper.unlockInfo(nameinfo, ffi.string(C.GetComponentName(inputobject)))
	--- object name ---
	local row = inputtable:addRow("info_focus", { fixed = true, bgColor = Color["row_title_background"] })
	row[10]:createButton({ width = config.mapRowHeight, cellBGColor = Color["row_background"] }):setIcon("menu_center_selection", { width = config.mapRowHeight, height = config.mapRowHeight, y = (Helper.headerRow1Height - config.mapRowHeight) / 2 })
	row[10].handlers.onClick = function () return C.SetFocusMapComponent(menu.holomap, menu.infoSubmenuObject, true) end
	if isvalid then
		row[1]:setBackgroundColSpan(9):setColSpan(7):createText(objectname, Helper.headerRow1Properties)
		row[1].properties.color = titlecolor
		if menu.infoTablePersistentData[instance].logbookData.isuseid then
			row[8]:setColSpan(2):createText(Helper.unlockInfo(nameinfo, ffi.string(C.GetObjectIDCode(inputobject))), Helper.headerRow1Properties)
		else
			row[8]:setColSpan(2):createText(" ", Helper.headerRow1Properties) -- if "" border bottom will not render
		end
		row[8].properties.halign = "right"
		row[8].properties.color = titlecolor
	else
		row[1]:setBackgroundColSpan(9):setColSpan(9):createText(objectname, Helper.headerRow1Properties)
		row[1].properties.color = titlecolor
	end

	if isvalid then
		config.infoLogbook.category = "all"
		config.infoLogbook.logbookPage = 100
		config.infoLogbook.logbookQueryLimit= 1000

		-- entries
		local numEntries = GetNumLogbook(config.infoLogbook.category)
		logbookData.logbook = {}
		for i = 1, math.ceil(numEntries / config.infoLogbook.logbookQueryLimit) do
			local offset = (i - 1) * config.infoLogbook.logbookQueryLimit
			local numQuery = math.min(config.infoLogbook.logbookQueryLimit, numEntries - offset)
			local templogbook = GetLogbook(offset + 1, numQuery, config.infoLogbook.category) or {}
			if #templogbook > 0 then
				for j, entry in ipairs(templogbook) do
					entry.index = offset + j
					if menu.infologbookSearchHelper(entry, logbookData.objecttext, logbookData.searchtext) then
						table.insert(logbookData.logbook, entry)
					end
				end
			end
		end

		numEntries = #logbookData.logbook
		local logbook
		if numEntries <= config.infoLogbook.logbookPage then
			logbookData.curPage = 1
			logbook = logbookData.logbook
		else
			local startIndex = numEntries - config.infoLogbook.logbookPage * logbookData.curPage + 1
			local endIndex = config.infoLogbook.logbookPage + startIndex - 1
			if startIndex < 1 then
				startIndex = 1
			end
			logbook = { table.unpack(logbookData.logbook, startIndex, endIndex) }
		end
		logbookData.numPages = math.max(1, math.ceil(numEntries / config.infoLogbook.logbookPage))

		local buttonsize = Helper.scaleY(config.mapRowHeight)
		local row = inputtable:addRow(true, { fixed = true })
		row[1]:setColSpan(3):createEditBox({ description = ReadText(1001, 7740), defaultText = ReadText(1001, 3250), height = Helper.subHeaderHeight }):setText(logbookData.searchtext, { halign = "left", x = Helper.standardTextOffsetx }):setHotkey("INPUT_STATE_DETAILMONITOR_0", { displayIcon = true })
		row[1].handlers.onEditBoxDeactivated = function (_, text) if text ~= logbookData.searchtext then logbookData.searchtext = text; menu.refreshInfoFrame() end end

		local buttonheight = math.max(Helper.editboxMinHeight, Helper.scaleY(Helper.subHeaderHeight))
		row[4]:createButton({ scaling = false, width = buttonsize, height = buttonheight, cellBGColor = Color["row_background"] }):setText("X", { halign = "center", font = Helper.standardFontBold })
		row[4].handlers.onClick = function () logbookData.searchtext = ""; menu.refreshInfoFrame() end

		row[5]:createButton({ scaling = false, active = logbookData.curPage > 1, width = buttonsize, height = buttonheight, cellBGColor = Color["row_background"] }):setIcon("widget_arrow_skip_left_01", { width = buttonsize, height = buttonsize, y = (row:getHeight() - buttonsize) / 2 })
		row[5].handlers.onClick = function () logbookData.curPage = 1; menu.refreshInfoFrame() end
		row[6]:createButton({ scaling = false, active = logbookData.curPage > 1, width = buttonsize, height = buttonheight, cellBGColor = Color["row_background"] }):setIcon("widget_arrow_left_01", { width = buttonsize, height = buttonsize, y = (row:getHeight() - buttonsize) / 2 })
		row[6].handlers.onClick = function () logbookData.curPage = logbookData.curPage - 1; menu.refreshInfoFrame() end
		menu.logbookPageEditBox = row[7]:setColSpan(2):createEditBox({ description = ReadText(1001, 7739) }):setText(logbookData.curPage .. " / " .. logbookData.numPages, { halign = "center" })
		row[7].handlers.onEditBoxActivated = function (widget) return menu.editboxInfoLogbookPageActivated(widget, instance) end
		row[7].handlers.onEditBoxDeactivated = function (_, text, textchanged) return menu.editboxInfoLogbookPage(instance, text, textchanged) end
		row[9]:createButton({ scaling = false, active = logbookData.curPage < logbookData.numPages, width = buttonsize, height = buttonheight, cellBGColor = Color["row_background"] }):setIcon("widget_arrow_right_01", { width = buttonsize, height = buttonsize, y = (row:getHeight() - buttonsize) / 2 })
		row[9].handlers.onClick = function () logbookData.curPage = logbookData.curPage + 1; menu.refreshInfoFrame() end
		row[10]:createButton({ scaling = false, active = logbookData.curPage < logbookData.numPages, width = buttonsize, height = buttonheight, cellBGColor = Color["row_background"] }):setIcon("widget_arrow_skip_right_01", { width = buttonsize, height = buttonsize, y = (row:getHeight() - buttonsize) / 2 })
		row[10].handlers.onClick = function () logbookData.curPage = logbookData.numPages; menu.refreshInfoFrame() end

		inputtable:addEmptyRow(Helper.standardTextHeight / 2)

		if #logbook > 0 then
			for i = #logbook, 1, -1 do
				local entry = logbook[i]
				local textcolor = entry.highlighted and Color["text_logbook_highlight"] or Color["text_normal"]
				local row = inputtable:addRow(true, { borderBelow = false })
				if entry.interaction and IsValidComponent(entry.interactioncomponent) then
					local mouseoverobject = entry.interactioncomponent
					if IsComponentClass(mouseoverobject, "zone") and not IsComponentClass(mouseoverobject, "highway") then
						mouseoverobject = GetContextByClass(mouseoverobject, "sector")
					end
					row[1]:setColSpan(9):createText(entry.title, { font = Helper.standardFontBold, color = textcolor, wordwrap = true })
					row[10]:createButton({ scaling = false, bgColor = Color["button_background_hidden"], mouseOverText = string.format(entry.interactiontext, GetComponentData(mouseoverobject, "name")), height = buttonsize }):setIcon("widget_arrow_right_01", { width = buttonsize, height = buttonsize })
					row[10].handlers.onClick = function () return menu.buttonLogbookInteraction(entry) end
				else
					row[1]:setColSpan(10):createText(entry.index .. " - " .. entry.title, { font = Helper.standardFontBold, color = textcolor, wordwrap = true })
				end

				if (entry.entityname ~= "") or (entry.factionname ~= "") then
					local row = inputtable:addRow(false, { borderBelow = false })
					if entry.entityname ~= "" then
						row[1]:setColSpan(2):createText(ReadText(1001, 5711) .. " " .. entry.entityname, { x = config.mapRowHeight })
					end
					row[3]:setColSpan(8):createText(entry.factionname, { halign = "right" })
				end

				if entry.text ~= "" then
					local row = inputtable:addRow(false, { borderBelow = false })
					row[1]:setColSpan(10):createText(entry.text, { x = config.mapRowHeight, color = textcolor, wordwrap = true })
				end

				local row = inputtable:addRow(false, {  })
				row[1]:setColSpan(2):createText(Helper.getPassedTime(entry.time), { mouseOverText = Helper.convertGameTimeToXTimeString(entry.time), x = config.mapRowHeight })
				local moneystring = ""
				if entry.money ~= 0 then
					local moneycolor = (entry.money >= 0) and Color["text_positive"] or Color["text_negative"]
					moneystring = moneystring .. Helper.convertColorToText(moneycolor) .. ((entry.bonus >= 0) and "+" or "-") .. ConvertMoneyString(entry.money, false, true, nil, true) .. " " .. ReadText(1001, 101)
				end
				if entry.bonus ~= 0 then
					local bonuscolor = (entry.bonus >= 0) and Color["text_positive"] or Color["text_negative"]
					moneystring = moneystring .. " " .. Helper.convertColorToText(bonuscolor) .. "(" .. ((entry.bonus >= 0) and "+" or "-") .. " " .. ReadText(1001, 5712) .. " " .. ConvertMoneyString(entry.bonus, false, true, nil, true) .. " " .. ReadText(1001, 101) .. ")"
				end
				row[3]:setColSpan(8):createText(moneystring, { halign = "right" })

				if i ~= 1 then
					local row = inputtable:addRow(false, { bgColor = Color["row_background_blue"] })
					row[1]:setColSpan(10):createText("", { fontsize = 1, minRowHeight = 1 })
				end
			end
		else
			local row = inputtable:addRow(false, {  })
			row[1]:setColSpan(10):createText("--- " .. ReadText(1001, 5705) .. " ---", { halign = "center" })
		end
	else
		local row = inputtable:addRow(false, { bgColor = Color["row_background_unselectable"] })
		row[2]:setColSpan(9):createText(ReadText(1001, 6526))
	end
end

-- NB: numcolumns has to match number of entries in inputrowdata.
function menu.addInfoSubmenuRow(instance, inputtable, inputrow, inputrowdata, isheader, withbutton, buttonactive, indent, indentsize, inputfont, mouseovertext, interactive)
	if not indent then
		indent = 0
	end
	if not indentsize then
		indentsize = Helper.standardIndentStep
	end

	if not inputfont then
		inputfont = Helper.standardFont
		if isheader then
			inputfont = Helper.standardFontBold
		end
	end

	local rowbgcolor = Color["row_background_blue"]
	if not isheader then
		local isselectable
		if type(inputrowdata) ~= "table" then
			isselectable = inputrowdata
		else
			isselectable = inputrowdata[1]
		end
		if isselectable then
			rowbgcolor = nil
		else
			rowbgcolor = Color["row_background_unselectable"]
		end
	end

	if not mouseovertext then
		mouseovertext = ""
	end

	if type(inputrowdata) ~= "table" then
		DebugError("menu.addInfoSubmenuRow(): inputrowdata is not a table. inputrowdata: " .. tostring(inputrowdata) .. ".")
		inputrow = inputtable:addRow(inputrowdata, { bgColor = rowbgcolor, interactive = interactive })
	else
		inputrow = inputtable:addRow(inputrowdata[1], { bgColor = rowbgcolor, interactive = interactive })
	end

	if not buttonactive then
		buttonactive = false
	end

	if withbutton then
		inputrow[1]:createButton({ height = config.mapRowHeight, active = buttonactive }):setText(function() return (buttonactive and menu.isInfoExtended(inputrowdata[1], instance)) and "-" or "+" end, { halign = "center" })
		inputrow[1].handlers.onClick = function() return menu.buttonExtendInfo(inputrowdata[1], instance) end
		inputrow[1].properties.uiTriggerID = inputrowdata[1] .. "_toggle"
	end

	for i, val in ipairs(inputrowdata) do
		if i ~= 1 and type(val) == "number" then
			inputrowdata[i] = tostring(val)
		end
	end

	local xoffset = Helper.standardTextOffsetx + (indent * indentsize)

	if type(inputrowdata) ~= "table" then
		inputrow[2]:setColSpan(7)
		inputrow[2]:createText(inputrowdata, { minRowHeight = config.mapRowHeight, fontsize = config.mapFontSize, font = inputfont, x = xoffset, mouseOverText = mouseovertext })
	else
		if #inputrowdata == 2 then
			inputrow[2]:setColSpan(7):createText(inputrowdata[2], { minRowHeight = config.mapRowHeight, fontsize = config.mapFontSize, font = inputfont, x = xoffset, mouseOverText = mouseovertext })
		elseif #inputrowdata == 3 then
			local row2span = 2
			if (type(inputrowdata[2]) ~= "function") and (type(inputrowdata[3]) ~= "function") then
				local str1width = C.GetTextWidth(inputrowdata[2], inputfont, Helper.scaleFont(inputfont, config.mapFontSize)) + Helper.scaleX(xoffset)
				local str2width = C.GetTextWidth(inputrowdata[3], inputfont, Helper.scaleFont(inputfont, config.mapFontSize))
				if (str1width > (inputrow[2]:getWidth() + inputrow[3]:getWidth() + Helper.borderSize)) and (str1width > str2width) then
					row2span = 4
				elseif str1width < inputrow[2]:getWidth() then
					row2span = 1
				end
			end
			inputrow[2]:setColSpan(row2span):createText(inputrowdata[2], { minRowHeight = config.mapRowHeight, fontsize = config.mapFontSize, font = inputfont, x = xoffset, mouseOverText = mouseovertext })
			inputrow[2 + row2span]:setColSpan(7 - row2span):createText(inputrowdata[3], { halign = "right", minRowHeight = config.mapRowHeight, fontsize = config.mapFontSize, font = inputfont, mouseOverText = mouseovertext })
		elseif #inputrowdata == 4 then
			inputrow[2]:setColSpan(2):createText(inputrowdata[2], { minRowHeight = config.mapRowHeight, fontsize = config.mapFontSize, font = inputfont, x = xoffset, mouseOverText = mouseovertext })
			inputrow[4]:setColSpan(2):createText(inputrowdata[3], { minRowHeight = config.mapRowHeight, fontsize = config.mapFontSize, font = inputfont, mouseOverText = mouseovertext })
			inputrow[6]:setColSpan(3):createText(inputrowdata[4], { halign = "right", minRowHeight = config.mapRowHeight, fontsize = config.mapFontSize, font = inputfont, mouseOverText = mouseovertext })
		elseif #inputrowdata == 5 then
			inputrow[2]:createText(inputrowdata[2], { minRowHeight = config.mapRowHeight, fontsize = config.mapFontSize, font = inputfont, x = xoffset, mouseOverText = mouseovertext })
			inputrow[3]:createText(inputrowdata[3], { minRowHeight = config.mapRowHeight, fontsize = config.mapFontSize, font = inputfont, mouseOverText = mouseovertext })
			inputrow[4]:setColSpan(2):createText(inputrowdata[4], { minRowHeight = config.mapRowHeight, fontsize = config.mapFontSize, font = inputfont, mouseOverText = mouseovertext })
			inputrow[6]:setColSpan(3):createText(inputrowdata[5], { minRowHeight = config.mapRowHeight, fontsize = config.mapFontSize, font = inputfont, mouseOverText = mouseovertext })
		else
			DebugError("menu.addInfoSubmenuRow(): inputrowdata has an invalid number of entries: " .. tostring(#inputrowdata) .. ". only up to four entries supported.")
		end
	end

	return inputrow
end

function menu.addEquipmentModInfoRow(inputtable, modclass, installedmod, name)
	local color = Helper.modQualities[installedmod.Quality].color
	local row = inputtable:addRow(true, {  })
	row[2]:createText(name .. "  \27[" .. Helper.modQualities[installedmod.Quality].icon2 .. "]")
	row[3]:setColSpan(10):createText(Helper.convertColorToText(color) .. installedmod.Name, { halign = "right" })

	-- default property
	for i, property in ipairs(Helper.modProperties[modclass]) do
		if property.key == installedmod.PropertyType then
			if installedmod[property.key] ~= property.basevalue then
				local effectcolor
				if installedmod[property.key] > property.basevalue then
					effectcolor = property.pos_effect and Color["text_positive"] or Color["text_negative"]
				else
					effectcolor = property.pos_effect and Color["text_negative"] or Color["text_positive"]
				end
				local row = inputtable:addRow(false, {  })
				row[2]:setColSpan(5):createText(property.text, { x = Helper.standardIndentStep })
				row[8]:setColSpan(5):createText(Helper.convertColorToText(effectcolor) .. property.eval(installedmod[property.key]), { halign = "right", font = Helper.standardFontBold })
			end
			break
		end
	end
	-- other properties
	for i, property in ipairs(Helper.modProperties[modclass]) do
		if property.key ~= installedmod.PropertyType then
			if installedmod[property.key] ~= property.basevalue then
				local effectcolor
				if installedmod[property.key] > property.basevalue then
					effectcolor = property.pos_effect and Color["text_positive"] or Color["text_negative"]
				else
					effectcolor = property.pos_effect and Color["text_negative"] or Color["text_positive"]
				end
				local row = inputtable:addRow(false, {  })
				row[2]:setColSpan(5):createText(property.text, { x = Helper.standardIndentStep })
				row[8]:setColSpan(5):createText(Helper.convertColorToText(effectcolor) .. property.eval(installedmod[property.key]), { halign = "right" })
			end
		end
	end

	return row
end

function menu.resetInfoSubmenu(i, instance)
	menu.infoTablePersistentData[instance].resetcrew = true
	if i then
		if menu.infoTablePersistentData[instance].cashtransferdetails.transfers[i] then
			menu.infoTablePersistentData[instance].cashtransferdetails.transfers[i].amount = 0
		end
	else
		menu.infoTablePersistentData[instance].cashtransferdetails.transfers = {}
	end
	menu.infoTablePersistentData[instance].drops = {}

	if instance == "left" then
		menu.settoprow = GetTopRow(menu.infoTable)
		menu.refreshInfoFrame()
	elseif instance == "right" then
		menu.settoprow = GetTopRow(menu.infoTableRight)
		menu.refreshInfoFrame2()
	end
end

function menu.checkTransferDetails(i, instance)
	if menu.infoTablePersistentData[instance].cashtransferdetails.transfers[i] and (menu.infoTablePersistentData[instance].cashtransferdetails.transfers[i].amount ~= 0) then
		return true
	end
	return false
end

function menu.infoSubmenuPrepareCrewInfo(instance)
	local locobject = menu.infoSubmenuObject
	if not locobject or (locobject == 0) then
		DebugError("menu.infoSubmenuPrepareCrewInfo() called with no selected object.")
		return
	elseif (not C.IsComponentClass(locobject, "ship")) and (not C.IsComponentClass(locobject, "station")) then
		DebugError("menu.infoSubmenuPrepareCrewInfo() called on " .. ffi.string(C.GetComponentName(locobject)) .. " which is not of class ship or station.")
		return
	end

	local infocrew = menu.infoTablePersistentData[instance].crew

	--infocrew = {
	--	["object"] = nil,
	--	["capacity"] = 0,
	--	["total"] = 0,
	--	["current"] = { ["total"] = 0, ["roles"] = {} },
	--	["unassigned"] = { ["total"] = 0, ["persons"] = {} },
	--	["reassigned"] = { ["total"] = 0, ["roles"] = {} }
	--}
	infocrew.object = locobject
	infocrew.current.total = 0
	infocrew.unassigned.total = 0
	infocrew.unassigned.persons = {}
	infocrew.reassigned.total = 0
	infocrew.reassigned.roles = {}
	infocrew.total = 0
	infocrew.capacity = C.GetPeopleCapacity(locobject, "", false)

	local numpeople = C.GetNumAllRoles()
	local peopletable = ffi.new("PeopleInfo[?]", numpeople)
	numpeople = C.GetPeople2(peopletable, numpeople, locobject, true)
	for i = 0, numpeople - 1 do
		infocrew.current.roles[i + 1] = { id = ffi.string(peopletable[i].id), name = ffi.string(peopletable[i].name), desc = ffi.string(peopletable[i].desc), amount = peopletable[i].amount, transferring = 0, canhire = peopletable[i].canhire, numtiers = peopletable[i].numtiers, tiers = {} }
		infocrew.reassigned.roles[i + 1] = { id = ffi.string(peopletable[i].id), name = ffi.string(peopletable[i].name), desc = ffi.string(peopletable[i].desc), amount = 0, canhire = peopletable[i].canhire, numtiers = peopletable[i].numtiers, tiers = {} }
		if ffi.string(peopletable[i].id) == "unassigned" then
			infocrew.reassigned.unassignedidx = i + 1
			infocrew.unassigned.total = peopletable[i].amount
			local locpersons = ffi.new("NPCSeed[?]", infocrew.unassigned.total)
			infocrew.unassigned.total = C.GetRoleTierNPCs(locpersons, infocrew.unassigned.total, locobject, "unassigned", 0)
			infocrew.unassigned.persons = {}
			for j = 0, infocrew.unassigned.total-1 do
				table.insert(infocrew.unassigned.persons, { ["person"] = locpersons[j], ["oldrole"] = nil })
			end
			--print(tostring(infocrew.unassigned.total) .. " unassigned people")
		end
		infocrew.current.total = infocrew.current.total + peopletable[i].amount
		infocrew.total = infocrew.current.total + infocrew.reassigned.total

		local numtiers = peopletable[i].numtiers
		local tiertable = ffi.new("RoleTierData[?]", numtiers)
		numtiers = C.GetRoleTiers(tiertable, numtiers, locobject, infocrew.current.roles[i + 1].id)
		for j = 0, numtiers - 1 do
			infocrew.current.roles[i + 1].tiers[j + 1] = { name = ffi.string(tiertable[j].name), skilllevel = tiertable[j].skilllevel, amount = tiertable[j].amount, persons = {} }
			infocrew.reassigned.roles[i + 1].tiers[j + 1] = { name = ffi.string(tiertable[j].name), skilllevel = tiertable[j].skilllevel, amount = 0, persons = {} }

			local numpersons = tiertable[j].amount
			local persontable = ffi.new("NPCSeed[?]", numpersons)
			numpersons = C.GetRoleTierNPCs(persontable, numpersons, locobject, infocrew.current.roles[i + 1].id, infocrew.current.roles[i + 1].tiers[j + 1].skilllevel)
			local numTransferScheduled = 0
			for k = 0, numpersons - 1 do
				if C.IsPersonTransferScheduled(locobject, persontable[k]) then
					numTransferScheduled = numTransferScheduled + 1
				elseif not C.HasPersonArrived(locobject, persontable[k]) then
					numTransferScheduled = numTransferScheduled + 1
				end
				table.insert(infocrew.current.roles[i + 1].tiers[j + 1].persons, persontable[k])
			end
			infocrew.current.roles[i + 1].tiers[j + 1].transferring = numTransferScheduled
			infocrew.current.roles[i + 1].transferring = infocrew.current.roles[i + 1].transferring + numTransferScheduled
		end
		if numtiers == 0 then
			infocrew.current.roles[i + 1].tiers[1] = { hidden = true, name = "temp", skilllevel = 0, amount = peopletable[i].amount, persons = {} }
			infocrew.reassigned.roles[i + 1].tiers[1] = { hidden = true, name = "temp", skilllevel = 0, amount = 0, persons = {} }

			local numpersons = peopletable[i].amount
			local persontable = ffi.new("NPCSeed[?]", numpersons)
			numpersons = C.GetRoleTierNPCs(persontable, numpersons, locobject, infocrew.current.roles[i + 1].id, 0)
			local numTransferScheduled = 0
			for k = 0, numpersons - 1 do
				if C.IsPersonTransferScheduled(locobject, persontable[k]) then
					numTransferScheduled = numTransferScheduled + 1
				elseif not C.HasPersonArrived(locobject, persontable[k]) then
					numTransferScheduled = numTransferScheduled + 1
				end
				table.insert(infocrew.current.roles[i + 1].tiers[1].persons, persontable[k])
			end
			infocrew.current.roles[i + 1].tiers[1].transferring = numTransferScheduled
			infocrew.current.roles[i + 1].transferring = infocrew.current.roles[i + 1].transferring + numTransferScheduled
		end
	end
	for i, roletable in ipairs(infocrew.current.roles) do
		for j, tiertable in ipairs(roletable.tiers) do
			--int32_t GetPersonCombinedSkill(UniverseID controllableid, NPCSeed person, const char* role, const char* postid);
			table.sort(tiertable.persons, function(a, b) return C.GetPersonCombinedSkill(menu.infoSubmenuObject, a, nil, nil) > C.GetPersonCombinedSkill(menu.infoSubmenuObject, b, nil, nil) end)
		end
	end
end

function menu.infoSubmenuCombineCrewTables(instance)
	local infocrew = menu.infoTablePersistentData[instance].crew

	-- combines infocrew.current and infocrew.reassigned into one table for display
	local result = {}
	local locobject = menu.infoSubmenuObject
	if not locobject or (locobject == 0) then
		DebugError("menu.infoSubmenuCombineCrewTables() called with no selected object.")
		return result
	elseif (not C.IsComponentClass(locobject, "ship")) and (not C.IsComponentClass(locobject, "station")) then
		DebugError("menu.infoSubmenuCombineCrewTables() called on " .. ffi.string(C.GetComponentName(locobject)) .. " which is not of class ship or station.")
		return result
	end

	local role, post
	if menu.crewRole ~= "current" then
		local type, id = string.match(menu.crewRole, "(.+):(.+)")
		if type == "post" then
			post = id
		elseif type == "role" then
			role = id
		end
	end

	local checktable = {}
	local numpeople = C.GetNumAllRoles()
	local peopletable = ffi.new("PeopleInfo[?]", numpeople)
	numpeople = C.GetPeople2(peopletable, numpeople, locobject, true)
	for i = 0, numpeople - 1 do
		local roleid = ffi.string(peopletable[i].id)
		local rolename = ffi.string(peopletable[i].name)
		local numtiers = peopletable[i].numtiers
		local tiertable = ffi.new("RoleTierData[?]", numtiers)
		numtiers = C.GetRoleTiers(tiertable, numtiers, locobject, roleid)
		for j = 0, numtiers - 1 do
			local tiername = ffi.string(tiertable[j].name)
			for _, person in ipairs(infocrew.current.roles[i + 1].tiers[j + 1].persons) do
				if C.IsPerson(person, menu.infoSubmenuObject) then
					if not checktable[person] then
						table.insert(result, {
							person = person,
							name = ffi.string(C.GetPersonName(person, menu.infoSubmenuObject)),
							currentskill = C.GetPersonCombinedSkill(menu.infoSubmenuObject, person, nil, nil),
							skill = C.GetPersonCombinedSkill(menu.infoSubmenuObject, person, role, post),
							roleid = roleid,
							rolename = rolename,
							tiername = tiername
						})
						checktable[person] = true
					end
				else
					menu.updatePeopleInfo = getElapsedTime() + 0.1
				end
			end
			for _, person in ipairs(infocrew.reassigned.roles[i + 1].tiers[j + 1].persons) do
				if C.IsPerson(person.person, menu.infoSubmenuObject) then
					if not checktable[person.person] then
						table.insert(result, {
							person = person.person,
							name = ffi.string(C.GetPersonName(person.person, menu.infoSubmenuObject)),
							currentskill = C.GetPersonCombinedSkill(menu.infoSubmenuObject, person.person, nil, nil),
							skill = C.GetPersonCombinedSkill(menu.infoSubmenuObject, person.person, role, post),
							roleid = roleid,
							rolename = rolename,
							tiername = tiername
						})
						checktable[person.person] = true
					end
				else
					menu.updatePeopleInfo = getElapsedTime() + 0.1
				end
			end
		end
		if numtiers == 0 then
			for _, person in ipairs(infocrew.current.roles[i + 1].tiers[1].persons) do
				if C.IsPerson(person, menu.infoSubmenuObject) then
					if not checktable[person] then
						table.insert(result, {
							person = person,
							name = ffi.string(C.GetPersonName(person, menu.infoSubmenuObject)),
							currentskill = C.GetPersonCombinedSkill(menu.infoSubmenuObject, person, nil, nil),
							skill = C.GetPersonCombinedSkill(menu.infoSubmenuObject, person, role, post),
							roleid = roleid,
							rolename = rolename
						})
						checktable[person] = true
					end
				else
					menu.updatePeopleInfo = getElapsedTime() + 0.1
				end
			end
			for _, person in ipairs(infocrew.reassigned.roles[i + 1].tiers[1].persons) do
				if C.IsPerson(person.person, menu.infoSubmenuObject) then
					if not checktable[person.person] then
						table.insert(result, {
							person = person.person,
							name = ffi.string(C.GetPersonName(person.person, menu.infoSubmenuObject)),
							currentskill = C.GetPersonCombinedSkill(menu.infoSubmenuObject, person.person, nil, nil),
							skill = C.GetPersonCombinedSkill(menu.infoSubmenuObject, person.person, role, post),
							roleid = roleid,
							rolename = rolename
						})
						checktable[person.person] = true
					end
				else
					menu.updatePeopleInfo = getElapsedTime() + 0.1
				end
			end
		end
	end

	if menu.crewSort == "name" then
		table.sort(result, function (a, b) return Helper.sortName(a, b, false) end)
	elseif menu.crewSort == "name_inv" then
		table.sort(result, function (a, b) return Helper.sortName(a, b, true) end)
	elseif menu.crewSort == "skill" then
		table.sort(result, function (a, b) return a.skill > b.skill end)
	elseif menu.crewSort == "skill_inv" then
		table.sort(result, function (a, b) return a.skill < b.skill end)
	elseif menu.crewSort == "role" then
		table.sort(result, function (a, b) return menu.roleSorter(a, b, false) end)
		result = menu.sortBySkillinTiers(result)
	elseif menu.crewSort == "role_inv" then
		table.sort(result, function (a, b) return menu.roleSorter(a, b, true) end)
		result = menu.sortBySkillinTiers(result)
	end

	return result
end

function menu.roleSorter(a, b, invert)
	if a.rolename == b.rolename then
		return a.currentskill > b.currentskill
	end
	if invert then
		return a.rolename > b.rolename
	else
		return a.rolename < b.rolename
	end
end

-- after current role skill was used to sort the crew by current tiers, sort the tiers by the skill according to menu.crewRole
function menu.sortBySkillinTiers(result)
	local tiergroups = {}
	for _, personentry in ipairs(result) do
		local prevrole, prevtier
		if (not prevrole) or (prevrole ~= personentry.rolename) or (prevtier ~= personentry.tiername) then
			prevrole = personentry.rolename
			prevtier = personentry.tiername

			table.insert(tiergroups, { personentry })
		else
			table.insert(tiergroups[#tiergroups], personentry)
		end
	end
	result = {}
	for _, group in ipairs(tiergroups) do
		table.sort(group, function (a, b) return a.skill > b.skill end)
		for _, personentry in ipairs(group) do
			table.insert(result, personentry)
		end
	end
	return result
end

function menu.infoSubmenuConfirmDrops(object, instance)
	local isplayeroccupiedship = (object == C.GetPlayerOccupiedShipID())
	for ware, amount in pairs(menu.infoTablePersistentData[instance].drops) do
		if amount > 0 then
			local s = (amount > 1) and "s" or ""
			if C.DropCargo(object, ware, amount) then
				--print(ffi.string(C.GetComponentName(object)) .. " successfully dropped " .. tostring(amount) .. " unit" .. s .. " of " .. tostring(ware) .. ".")
			else
				print(ffi.string(C.GetComponentName(object)) .. "'s attempt to drop " .. tostring(amount) .. " unit" .. s .. " of " .. tostring(ware) .. " was unsuccessful.")
			end
		end
	end
	menu.infoTablePersistentData[instance].drops = {}
	menu.refreshInfoFrame()
end

function menu.infoSubmenuUpdateDrops(ware, oldamount, newamount, instance)
	menu.infoTablePersistentData[instance].drops[ware] = oldamount - newamount
end

function menu.infoSubmenuUpdateCrewChanges(instance, newamount, slidertable, sliderindex, istier, tierindex, sliderupdatetable)
	local infocrew = menu.infoTablePersistentData[instance].crew

	--print("peopletype: " .. ffi.string(slidertable[sliderindex].name) .. ", current actual amount: " .. (infocrew.current.roles[slidertable[sliderindex].roleindex].amount + infocrew.reassigned.roles[slidertable[sliderindex].roleindex].amount) .. ", new amount: " .. newamount)
	local oldamount = infocrew.current.roles[slidertable[sliderindex].roleindex].amount + infocrew.reassigned.roles[slidertable[sliderindex].roleindex].amount
	if istier then
		oldamount = infocrew.current.roles[slidertable[sliderindex].roleindex].tiers[tierindex].amount + infocrew.reassigned.roles[slidertable[sliderindex].roleindex].tiers[tierindex].amount
	end
	local amountchange = newamount - oldamount
	local linkedtiers = {}
	-- TODO: review. there was a problem when reducing from tier after reducing from category and adding back from category without confirming. might get fixed after slider updating is fixed.
	--print("newamount: " .. newamount .. ", oldamount: " .. oldamount .. ", amount to change: " .. amountchange)

	if amountchange < 0 then
		-- reduce
		--print("reducing")
		local amountchanged = 0
		local done
		if infocrew.reassigned.total > 0 then
			for i, roletable in ipairs(infocrew.reassigned.roles) do
				-- can query: .id, .name, .desc, .amount, .numtiers, .canhire
				if roletable.id == slidertable[sliderindex].id then
					for j, tiertable in ipairs(roletable.tiers) do
						--print("role: " .. tostring(roletable.id) .. ", tier: " .. tostring(j))
						local go
						if istier then
							-- can query: name, skilllevel, amount
							if tiertable.skilllevel == slidertable[sliderindex].tiers[tierindex].skilllevel then
								go = true
							end
						else
							go = true
						end
						if go then
							for k = #tiertable.persons, 1, -1 do
								if amountchanged ~= amountchange then
									if type(tiertable.persons[k].person) == "table" then
										DebugError("menu.infoSubmenuUpdateCrewChanges(): person " .. k .. " from reassigned is of type table.")
									end
									--local reassignedcrew = ffi.new("CrewTransferContainer[?]", 1)
									--reassignedcrew[0].seed = tiertable.persons[k].person
									--reassignedcrew[0].newroleid = "unassigned"
									--C.ReassignPeople(menu.infoSubmenuObject, reassignedcrew, 1)
									table.insert(infocrew.unassigned.persons, { ["person"] = tiertable.persons[k].person, ["oldrole"] = roletable.id })
									infocrew.unassigned.total = infocrew.unassigned.total + 1

									table.insert(infocrew.reassigned.roles[infocrew.reassigned.unassignedidx].tiers[1].persons, { ["person"] = tiertable.persons[k].person, ["oldrole"] = roletable.id, ["newrole"] = "unassigned", ["newtier"] = 1, ["combinedskill"] = 0 })
									infocrew.reassigned.roles[infocrew.reassigned.unassignedidx].tiers[1].amount = infocrew.reassigned.roles[infocrew.reassigned.unassignedidx].tiers[1].amount + 1
									infocrew.reassigned.roles[infocrew.reassigned.unassignedidx].amount = infocrew.reassigned.roles[infocrew.reassigned.unassignedidx].amount + 1

									table.remove(infocrew.reassigned.roles[i].tiers[j].persons, k)
									infocrew.reassigned.roles[i].tiers[j].amount = infocrew.reassigned.roles[i].tiers[j].amount - 1
									infocrew.reassigned.roles[i].amount = infocrew.reassigned.roles[i].amount - 1

									if #linkedtiers > 0 then
										local linkdone
										for l, linkedtier in ipairs(linkedtiers) do
											if linkedtier.index == j then
												linkedtier.amount = linkedtier.amount - 1
												linkdone = true
												break
											end
										end
										if not linkdone then
											table.insert(linkedtiers, { index = j, amount = -1 })
										end
									else
										table.insert(linkedtiers, { index = j, amount = -1 })
									end
									amountchanged = amountchanged - 1
								else
									done = true
									break
								end
							end
							go = nil
						end
						if done then
							break
						end
					end
				end
			end
		end
		if not done then
			for i, roletable in ipairs(infocrew.current.roles) do
				-- can query: .id, .name, .desc, .amount, .numtiers, .canhire
				if roletable.id == slidertable[sliderindex].id then
					for j, tiertable in ipairs(roletable.tiers) do
						--print("role: " .. tostring(roletable.id) .. ", tier: " .. tostring(j))
						local go
						if istier then
							-- can query: name, skilllevel, amount
							if tiertable.skilllevel == slidertable[sliderindex].tiers[tierindex].skilllevel then
								go = true
							end
						else
							go = true
						end
						if go then
							for k = #tiertable.persons, 1, -1 do
								if amountchanged ~= amountchange then
									if type(tiertable.persons[k]) == "table" then
										DebugError("menu.infoSubmenuUpdateCrewChanges(): person " .. k .. " from current is of type table.")
									end
									if (not C.IsPersonTransferScheduled(menu.infoSubmenuObject, tiertable.persons[k])) and C.HasPersonArrived(menu.infoSubmenuObject, tiertable.persons[k]) then
										--local reassignedcrew = ffi.new("CrewTransferContainer[?]", 1)
										--reassignedcrew[0].seed = tiertable.persons[k]
										--reassignedcrew[0].newroleid = "unassigned"
										--C.ReassignPeople(menu.infoSubmenuObject, reassignedcrew, 1)
										table.insert(infocrew.unassigned.persons, { ["person"] = tiertable.persons[k], ["oldrole"] = roletable.id })
										infocrew.unassigned.total = infocrew.unassigned.total + 1

										table.insert(infocrew.reassigned.roles[infocrew.reassigned.unassignedidx].tiers[1].persons, { ["person"] = tiertable.persons[k], ["oldrole"] = roletable.id, ["newrole"] = "unassigned", ["newtier"] = 1, ["combinedskill"] = 0 })
										infocrew.reassigned.roles[infocrew.reassigned.unassignedidx].tiers[1].amount = infocrew.reassigned.roles[infocrew.reassigned.unassignedidx].tiers[1].amount + 1
										infocrew.reassigned.roles[infocrew.reassigned.unassignedidx].amount = infocrew.reassigned.roles[infocrew.reassigned.unassignedidx].amount + 1
										infocrew.reassigned.total = infocrew.reassigned.total + 1

										table.remove(infocrew.current.roles[i].tiers[j].persons, k)
										infocrew.current.roles[i].tiers[j].amount = infocrew.current.roles[i].tiers[j].amount - 1
										infocrew.current.roles[i].amount = infocrew.current.roles[i].amount - 1
										infocrew.current.total = infocrew.current.total - 1

										if #linkedtiers > 0 then
											local linkdone
											for l, linkedtier in ipairs(linkedtiers) do
												if linkedtier.index == j then
													linkedtier.amount = linkedtier.amount - 1
													linkdone = true
													break
												end
											end
											if not linkdone then
												table.insert(linkedtiers, { index = j, amount = -1 })
											end
										else
											table.insert(linkedtiers, { index = j, amount = -1 })
										end
										amountchanged = amountchanged - 1
									end
								else
									done = true
									break
								end
							end
							go = nil
						end
						if done then
							break
						end
					end
				end
			end
		end
	else
		-- add
		--print("adding")
		if infocrew.unassigned.total < 1 then
			DebugError("menu.infoSubmenuUpdateCrewChanges(): tried reallocating crew with none unassigned.")
		else
			for i, roletable in ipairs(infocrew.current.roles) do
				if roletable.id == slidertable[sliderindex].id then
					local amountchanged = 0
					local done
					for j = #infocrew.unassigned.persons, 1, -1 do
						if amountchanged ~= amountchange then
							local newtier = C.GetPersonTier(infocrew.unassigned.persons[j].person, roletable.id, menu.infoSubmenuObject)
							local newcombinedskill = C.GetPersonCombinedSkill(menu.infoSubmenuObject, infocrew.unassigned.persons[j].person, roletable.id, nil)
							if infocrew.reassigned.roles[i].id ~= roletable.id then
								DebugError("menu.infoSubmenuUpdateCrewChanges(): reassigned role id: " .. tostring(infocrew.reassigned.roles[i].id) .. " does not match current role id: " .. tostring(roletable.id) .. ".")
							end
							for k, tiertable in ipairs(roletable.tiers) do
								if newtier == tiertable.skilllevel then
									table.insert(infocrew.reassigned.roles[i].tiers[k].persons, { ["person"] = infocrew.unassigned.persons[j].person, ["oldrole"] = infocrew.unassigned.persons[j].oldrole, ["newrole"] = roletable.id, ["newtier"] = newtier, ["combinedskill"] = newcombinedskill })
									infocrew.reassigned.roles[i].tiers[k].amount = infocrew.reassigned.roles[i].tiers[k].amount + 1
									infocrew.reassigned.roles[i].amount = infocrew.reassigned.roles[i].amount + 1
									infocrew.reassigned.total = infocrew.reassigned.total + 1

									if #linkedtiers > 0 then
										local linkdone
										for l, linkedtier in ipairs(linkedtiers) do
											if linkedtier.index == k then
												linkedtier.amount = linkedtier.amount + 1
												linkdone = true
												break
											end
										end
										if not linkdone then
											table.insert(linkedtiers, { index = k, amount = 1 })
										end
									else
										table.insert(linkedtiers, { index = k, amount = 1 })
									end
									break
								end
							end

							--local reassignedcrew = ffi.new("CrewTransferContainer[?]", 1)
							--reassignedcrew[0].seed = infocrew.unassigned.persons[j].person
							--reassignedcrew[0].newroleid = roletable.id
							--C.ReassignPeople(menu.infoSubmenuObject, reassignedcrew, 1)
							table.remove(infocrew.unassigned.persons, j)
							infocrew.unassigned.total = infocrew.unassigned.total - 1

							amountchanged = amountchanged + 1
						else
							done = true
							break
						end
					end
					if done then
						break
					end
				end
			end
		end
	end

	-- update all linked sliders.
	--local sliderupdatetable = { ["table"] = inputtable, ["row"] = role.row, ["col"] = 2, ["tierrows"] = {}, ["text"] = role.name, ["xoffset"] = role.row[2].properties.x, ["width"] = role.row[2].properties.width }
	if type(sliderupdatetable) == "table" and #sliderupdatetable.tierrows > 0 then
		-- update linked category slider
		local linkedrows = { {["row"] = sliderupdatetable.row, ["col"] = sliderupdatetable.col, ["amount"] = sliderupdatetable.row[sliderupdatetable.col].properties.start + amountchange} }
		--local linkedrows = { {["row"] = sliderupdatetable.row, ["amount"] = newamount} }
		if not istier then
			-- update linked tier slider/s
			if linkedtiers then
				linkedrows = {}
				for i, linkedtier in ipairs(linkedtiers) do
					table.insert(linkedrows, {["row"] = sliderupdatetable.tierrows[linkedtier.index].row, ["col"] = sliderupdatetable.tierrows[linkedtier.index].col, ["amount"] = sliderupdatetable.tierrows[linkedtier.index].row[sliderupdatetable.tierrows[linkedtier.index].col].properties.start + linkedtier.amount})
				end
			end
		end
		for i, linkedrow in ipairs(linkedrows) do
			local newlinkedslidervalue = linkedrow.amount
			--print("is tier? " .. tostring(istier) .. ", linked row: " .. tostring(linkedrow.row.index) .. ", category row: " .. tostring(sliderupdatetable.row.index))
			linkedrow.row[linkedrow.col].properties.start = newlinkedslidervalue
			if istier then
				sliderupdatetable.tierrows[tierindex].row[sliderupdatetable.tierrows[tierindex].col].properties.start = newamount
			else
				sliderupdatetable.row[sliderupdatetable.col].properties.start = newamount
			end
			--linkedrow.row[linkedrow.col].properties.maxSelect = (infocrew.current.roles[slidertable[sliderindex].roleindex].amount + infocrew.reassigned.roles[slidertable[sliderindex].roleindex].amount + infocrew.unassigned.total)
			--linkedrow.row[linkedrow.col].properties.maxSelect = istier and (infocrew.current.roles[slidertable[sliderindex].roleindex].amount + infocrew.reassigned.roles[slidertable[sliderindex].roleindex].amount + infocrew.unassigned.total) or (linkedrow.row[linkedrow.col].properties.start)
			Helper.setSliderCellValue(sliderupdatetable.table.id, linkedrow.row.index, linkedrow.col, newlinkedslidervalue)
		end
	end
end

function menu.infoSubmenuConfirmCrewChanges(instance)
	local infocrew = menu.infoTablePersistentData[instance].crew

	--print("reassigning " .. infocrew.reassigned.total .. " crew members.")
	local reassignedcrew = ffi.new("CrewTransferContainer[?]", infocrew.reassigned.total)
	local crewcounter = 0
	for i, roletable in ipairs(infocrew.reassigned.roles) do
		for j, tiertable in ipairs(roletable.tiers) do
			for k, persontable in ipairs(tiertable.persons) do
				--print("evaluating person " .. k .. ": " .. tostring(persontable.person))
				crewcounter = crewcounter + 1
				reassignedcrew[crewcounter - 1].seed = persontable.person
				reassignedcrew[crewcounter - 1].newroleid = Helper.ffiNewString(persontable.newrole)
				--print(tostring(crewcounter) .. ": reassigning person " .. k .. " with seed " .. tostring(persontable.person) .. " to role " .. tostring(persontable.newrole))

				table.insert(infocrew.current.roles[i].tiers[j].persons, persontable.person)
				infocrew.current.roles[i].tiers[j].amount = infocrew.current.roles[i].tiers[j].amount + 1
				infocrew.current.roles[i].amount = infocrew.current.roles[i].amount + 1
				infocrew.current.total = infocrew.current.total + 1

				infocrew.reassigned.roles[i].tiers[j].amount = infocrew.reassigned.roles[i].tiers[j].amount - 1
				infocrew.reassigned.roles[i].amount = infocrew.reassigned.roles[i].amount - 1
				infocrew.reassigned.total = infocrew.reassigned.total - 1
			end
			infocrew.reassigned.roles[i].tiers[j].persons = {}
		end
	end
	C.ReassignPeople(menu.infoSubmenuObject, reassignedcrew, crewcounter)
	if instance == "left" then
		menu.infoTablePersistentData["right"].resetcrew = true
	elseif instance == "right" then
		menu.infoTablePersistentData["left"].resetcrew = true
	end
	menu.refreshInfoFrame()
end

function menu.infoSubmenuReplacePilot(ship, oldpilot, newpilot, checkonly, contextmenu, instance)
	if not C.IsComponentClass(ship, "controllable") then
		return false
	end

	local infocrew = menu.infoTablePersistentData[instance].crew

	local oldpilotluaid = oldpilot and ConvertStringToLuaID(tostring(oldpilot))
	local post = (oldpilot and IsValidComponent(oldpilot)) and GetComponentData(oldpilotluaid, "poststring") or "aipilot"

	if not C.CanControllableHaveControlEntity(ship, post) then
		return false
	end

	-- select best pilot from entire crew for now.
	local bestpilot = newpilot or oldpilot or nil
	local bestcombinedskill = newpilot and C.GetPersonCombinedSkill(ship, newpilot, nil, post) or ((oldpilot and IsValidComponent(oldpilot)) and GetComponentData(oldpilotluaid, "combinedskill") or -1)
	--if oldpilot then
	--	print("old pilot: " .. ffi.string(C.GetComponentName(oldpilot)) .. " (" .. tostring(oldpilot) .. ")" .. ", combined skill: " .. tostring(bestcombinedskill))
	--end
	if not newpilot then
		-- if we want to restrict pilot candidates to people with a particular role, do that here.
		for i, roletable in ipairs(infocrew.current.roles) do
			if (roletable.id == "service") or (roletable.id == "marine") then
				for j, tiertable in ipairs(roletable.tiers) do
					for k, person in ipairs(tiertable.persons) do
						local evalcombinedskill = C.GetPersonCombinedSkill(ship, person, nil, post)
						if evalcombinedskill > bestcombinedskill then
							bestpilot = person
							bestcombinedskill = evalcombinedskill
						end
					end
				end
			end
		end
	end

	--print("bestpilot: " .. tostring(bestpilot))
	if bestpilot == oldpilot then
		--print("the old pilot: " .. ffi.string(C.GetComponentName(oldpilot)) .. " is already the best pilot in the crew. nothing changed.")
		return false
	elseif checkonly then
		--print("there is a better pilot available in the crew: " .. ffi.string(C.GetPersonName(bestpilot, ship)) .. ", combined skill: " .. tostring(bestcombinedskill))
		return true
	end

	local actor = { entity = nil, personcontrollable = ship, personseed = bestpilot }
	C.AssignHiredActor(actor, ship, post, nil, false)

	menu.infoSubmenuPrepareCrewInfo(instance)

	if contextmenu then
		menu.closeContextMenu()
	end
	menu.refreshInfoFrame(nil, 0)
end

function menu.infoSubmenuCancelTransfer(controllable, person)
	C.ReleasePersonFromCrewTransfer(controllable, person)

	menu.closeContextMenu()
	menu.refreshInfoFrame()
end

function menu.infoSubmenuFireNPCConfirm(controllable, entity, person, instance)
	menu.contextMenuMode = "userquestion"
	menu.contextMenuData = { mode = "fireindividual", controllable = controllable, entity = entity, person = person, xoffset = (Helper.viewWidth - Helper.scaleX(400)) / 2, yoffset = Helper.viewHeight / 2, instance = instance }

	menu.createContextFrame(Helper.scaleX(400), nil, menu.contextMenuData.xoffset, menu.contextMenuData.yoffset)
end

function menu.infoSubmenuFireAllNPCConfirm(controllable, instance)
	menu.contextMenuMode = "userquestion"
	menu.contextMenuData = { mode = "fireall", controllable = controllable, xoffset = (Helper.viewWidth - Helper.scaleX(400)) / 2, yoffset = Helper.viewHeight / 2, instance = instance }

	menu.createContextFrame(Helper.scaleX(400), nil, menu.contextMenuData.xoffset, menu.contextMenuData.yoffset)
end

function menu.infoSubmenuFireNPC(controllable, entity, person, instance)
	if entity then
		SignalObject(ConvertStringTo64Bit(tostring(entity)), "npc__control_dismissed")
	else
		C.RemovePerson(controllable, person)
	end
	menu.closeContextMenu()
	menu.updatePeopleInfo = getElapsedTime()
end

function menu.infoSubmenuUpdateTransferAmount(instance, value, idx, containercash)
	if not value then
		DebugError("menu.infoSubmenuUpdateTransferAmount with no value")
		return
	end
	if not idx then
		DebugError("menu.infoSubmenuUpdateTransferAmount with no idx")
		return
	end
	if not containercash then
		DebugError("menu.infoSubmenuUpdateTransferAmount with no containercash")
		return
	end

	menu.infoTablePersistentData[instance].cashtransferdetails.transfers[idx].amount = value - containercash
	-- do not refresh. prevents smoothly dragging the slider.
end

function menu.infoSubmenuSetManagerAccountToEstimate(i, instance)
	local entry = menu.infoTablePersistentData[instance].cashtransferdetails.transfers[i]
	if entry then
		local containermoney, estimate, isplayerowned = GetComponentData(entry.object, "money", entry.estimatetype, "isplayerowned")
		if isplayerowned then
			if entry.supply then
				estimate = estimate + tonumber(C.GetSupplyBudget(entry.object)) / 100
			end
			if entry.tradewares then
				estimate = estimate + tonumber(C.GetTradeWareBudget(entry.object)) / 100
			end
			if C.IsComponentClass(entry.object, "station") then
				SetMaxBudget(entry.object, (estimate * 3) / 2)
				SetMinBudget(entry.object, estimate)
			end

			local amount = estimate - containermoney
			if amount > 0 then
				TransferPlayerMoneyTo(amount, entry.object)
			else
				TransferMoneyToPlayer(-amount, entry.object)
			end
			menu.infoTablePersistentData[instance].cashtransferdetails.transfers[i].amount = 0
		end
	end

	menu.refreshInfoFrame()
end

function menu.infoSubmenuUpdateManagerAccount(i, instance)
	local entry = menu.infoTablePersistentData[instance].cashtransferdetails.transfers[i]
	if entry and entry.amount ~= 0 then
		local isplayerowned = GetComponentData(entry.object, "isplayerowned")
		if isplayerowned then
			if C.IsComponentClass(entry.object, "station") then
				local newstationcash = (GetAccountData(entry.object, "money") or 0) + entry.amount
				SetMaxBudget(entry.object, (newstationcash * 3) / 2)
				SetMinBudget(entry.object, newstationcash)
			end

			TransferPlayerMoneyTo(entry.amount, entry.object)
			menu.infoTablePersistentData[instance].cashtransferdetails.transfers[i].amount = 0
		end
	end

	menu.refreshInfoFrame()
end

function menu.infoSubmenuUpdateProductionTime(object64, moduleindex)
	local productionmodules = GetProductionModules(object64)
	if not productionmodules then
		print("no production modules found.")
		return ""
	end
	local productiondata = GetProductionModuleData(productionmodules[moduleindex])
	if not productiondata then
		print("no production data found.")
		return ""
	end
	local s = productiondata.remainingcycletime
	if not s then
		print("error: remaining cycle time is: " .. tostring(s))
		return ""
	end
	local formattedtime = ConvertTimeString(s, "%h:%M:%S")
	return formattedtime
end

function menu.buttonExtendInfo(buttondata, instance)
	if menu.extendedinfo[buttondata .. instance] then
		menu.extendedinfo[buttondata .. instance] = nil
	else
		menu.extendedinfo[buttondata .. instance] = true
	end

	if instance == "left" then
		menu.settoprow = GetTopRow(menu.infoTable)
		menu.refreshInfoFrame()
	elseif instance == "right" then
		menu.settoprow = GetTopRow(menu.infoTableRight)
		menu.refreshInfoFrame2()
	end
end

function menu.isInfoExtended(buttondata, instance)
	if menu.extendedinfo[buttondata .. instance] then
		return true
	end
	return false
end

function menu.createMissionMode(frame)
	-- kuertee start: bug-fix of sideBarWidth being nil
	if menu.sideBarWidth == nil then
		menu.sideBarWidth = Helper.scaleX(Helper.sidebarWidth)
	end
	-- kuertee end: bug-fix of sideBarWidth being nil

	menu.setrow = 3
	menu.missionDoNotUpdate = true

	if menu.infoTableMode == "missionoffer" then
		menu.updateMissionOfferList()
	elseif menu.infoTableMode == "mission" then
		menu.updateMissions()

		if menu.missionMode == menu.activeMissionMode then
			if menu.highlightLeftBar[menu.infoTableMode] then
				menu.highlightLeftBar[menu.infoTableMode] = nil
				menu.refreshMainFrame = true
			end
		end
	end

	local ftable
	local isonline = Helper.isOnlineGame()
	if (menu.infoTableMode ~= "missionoffer") or (menu.missionOfferMode ~= "operation") or (not isonline) then
		ftable = frame:addTable(9 , { tabOrder = 1 })
		ftable:setDefaultCellProperties("text", { minRowHeight = config.mapRowHeight, fontsize = config.mapFontSize })
		ftable:setDefaultCellProperties("button", { height = config.mapRowHeight })
		ftable:setDefaultComplexCellProperties("button", "text", { fontsize = config.mapFontSize })

		ftable:setColWidth(1, Helper.scaleY(config.mapRowHeight), false)
		ftable:setColWidth(2, Helper.scaleY(config.mapRowHeight), false)
		-- in smaller resolutions, e.g. 1280x720, this can get negative due to different scalings used (this would be solved if we unify the scaling support as planned)
		ftable:setColWidth(3, math.max(1, menu.sideBarWidth - 2 * (Helper.scaleY(config.mapRowHeight) + Helper.borderSize)), false)
		ftable:setColWidth(4, menu.sideBarWidth / 2, false)
		ftable:setColWidth(5, menu.sideBarWidth / 2 - Helper.borderSize, false)
		ftable:setColWidth(6, menu.sideBarWidth, false)
		ftable:setColWidth(7, menu.sideBarWidth, false)
		ftable:setColWidthPercent(9, 20)

		ftable:setDefaultBackgroundColSpan(2, 8)
	end

	if not isonline then
		menu.missionOfferMode = "normal"
	end

	if menu.infoTableMode == "missionoffer" then
		if (menu.missionOfferMode == "normal") or (not isonline) then
			local found = false
			-- important
			if #menu.missionOfferList["plot"] > 0 then
				local row = ftable:addRow(nil, { bgColor = Color["row_title_background"] })
				row[1]:setColSpan(9):createText(ReadText(1001, 3340), Helper.headerRowCenteredProperties)
				for _, entry in ipairs(menu.missionOfferList["plot"]) do
					found = true
					menu.addMissionRow(ftable, entry)
				end
				if not found then
					local row = ftable:addRow("plotnone", { interactive = false })
					if menu.missionModeCurrent == "plotnone" then
						menu.setrow = row.index
					end
					row[1]:setColSpan(9):createText("--- " .. ReadText(1001, 3302) .. " ---", { halign = "center" })
				end
			end
			-- guild
			found = false
			local row = ftable:addRow(nil, { bgColor = Color["row_title_background"] })
			row[1]:setColSpan(9):createText(ReadText(1001, 3331), Helper.headerRowCenteredProperties)

			-- kuertee start: callback
			if callbacks ["createMissionMode_on_missionoffer_guild_start"] then
				for _, callback in ipairs (callbacks ["createMissionMode_on_missionoffer_guild_start"]) do
					callback (ftable)
				end
			end
			-- kuertee end: callback

			for _, data in ipairs(menu.missionOfferList["guild"]) do
				if #data.missions > 0 then
					found = true

					-- check if we need to expand for the current selected mission
					for _, entry in ipairs(data.missions) do
						if entry.ID == menu.missionModeCurrent then
							menu.expandedMissionGroups[data.id] = true
						end
					end

					if menu.expandedMissionGroups[data.id .. "offer"] == nil then
						menu.expandedMissionGroups[data.id .. "offer"] = true
					end
					local isexpanded = menu.expandedMissionGroups[data.id .. "offer"]
					local row = ftable:addRow(data.id, {  })
					if data.id == menu.missionModeCurrent then
						menu.setrow = row.index
					end
					row[1]:createButton():setText(isexpanded and "-" or "+", { halign = "center" })
					row[1].handlers.onClick = function () return menu.buttonExpandMissionGroup(data.id .. "offer", row.index) end
					row[2]:setColSpan(7):createText(data.name)
					row[9]:createText((#data.missions == 1) and ReadText(1001, 3335) or string.format(ReadText(1001, 3336), #data.missions), { halign = "right" })

					if isexpanded then
						for _, entry in ipairs(data.missions) do
							menu.addMissionRow(ftable, entry, 1)
						end
					end
				end
			end
			if not found then
				local row = ftable:addRow("guildnone", { interactive = false })
				if menu.missionModeCurrent == "guildnone" then
					menu.setrow = row.index
				end
				row[1]:setColSpan(9):createText("--- " .. ReadText(1001, 3302) .. " ---", { halign = "center" })
			end
			-- other
			found = false
			local row = ftable:addRow(nil, { bgColor = Color["row_title_background"] })
			row[1]:setColSpan(9):createText(ReadText(1001, 3332), Helper.headerRowCenteredProperties)
			for _, entry in ipairs(menu.missionOfferList["other"]) do
				found = true
				menu.addMissionRow(ftable, entry)
			end
			if not found then
				local row = ftable:addRow("othernone", { interactive = false })
				if menu.missionModeCurrent == "othernone" then
					menu.setrow = row.index
				end
				row[1]:setColSpan(9):createText("--- " .. ReadText(1001, 3302) .. " ---", { halign = "center" })
			end
		elseif menu.missionOfferMode == "operation" then
			if Helper.hasExtension("multiverse") then
				Helper.callExtensionFunction("multiverse", "registerOnlineEvents", menu)
				Helper.callExtensionFunction("multiverse", "getVentures")
				Helper.updateVenturePlatforms()
				Helper.callExtensionFunction("multiverse", "createVentureOperation", menu, menu.infoFrame, "left", config.missionOfferTabs)
			end
		end
	elseif menu.infoTableMode == "mission" then
		local found = false

		-- kuertee start: callback
		if callbacks ["createMissionMode_replaceMissionModeCurrent"] then
			local oldMissionModeCurrent = menu.missionModeCurrent
			for _, callback in ipairs (callbacks ["createMissionMode_replaceMissionModeCurrent"]) do
				menu.missionModeCurrent = callback (menu.missionModeCurrent)
				if menu.missionModeCurrent ~= oldMissionModeCurrent then
					-- break immediately if changed
					break
				end
			end
		end
		-- kuertee end: callback

		if menu.missionMode == "plot" then
			-- important
			local row = ftable:addRow(nil, { bgColor = Color["row_title_background"] })
			row[1]:setColSpan(9):createText(ReadText(1001, 3341), Helper.headerRowCenteredProperties)
			local hadThreadMission = false
			for _, entry in ipairs(menu.missionList["plot"]) do
				found = true
				if entry.threadtype ~= "" then
					hadThreadMission = true
				end
				if hadThreadMission and (entry.threadtype == "") then
					-- first non thread mission after threads
					hadThreadMission = false
					local row = ftable:addRow(false, {  })
					row[1]:setColSpan(9):createText("")
				end
				menu.addMissionRow(ftable, entry)
			end
			if not found then
				local row = ftable:addRow("plotnone", { interactive = false })
				if menu.missionModeCurrent == "plotnone" then
					menu.setrow = row.index
				end
				row[1]:setColSpan(9):createText("--- " .. ReadText(1001, 3302) .. " ---", { halign = "center" })
			end
			-- guild
			local row = ftable:addRow(nil, { bgColor = Color["row_title_background"] })
			row[1]:setColSpan(9):createText(ReadText(1001, 3333), Helper.headerRowCenteredProperties)
			found = false
			for _, data in ipairs(menu.missionList["guild"]) do
				found = true

				-- check if we need to expand for the current selected mission
				for _, entry in ipairs(data.missions) do
					if entry.ID == menu.missionModeCurrent then
						menu.expandedMissionGroups[data.id] = true
					end
					for i, submission in ipairs(entry.subMissions) do
						if submission.ID == menu.missionModeCurrent then
							menu.expandedMissionGroups[data.id] = true
							menu.expandedMissionGroups[entry.ID] = true
						end
					end
				end

				local isexpanded = menu.expandedMissionGroups[data.id]
				local row = ftable:addRow(data.id, {  })
				if data.id == menu.missionModeCurrent then
					menu.setrow = row.index
				end

				local color = Color["text_normal"]
				if data.active then
					color = Color["text_mission"]
				end

				row[1]:createButton():setText(isexpanded and "-" or "+", { halign = "center" })
				row[1].handlers.onClick = function () return menu.buttonExpandMissionGroup(data.id, row.index) end
				row[2]:setColSpan(7):createText(data.name, { color = color, font = font })
				row[9]:createText((#data.missions == 1) and ReadText(1001, 3337) or string.format(ReadText(1001, 3338), #data.missions), { halign = "right", color = color })

				if isexpanded then
					local hadThreadMission = false
					for _, entry in ipairs(data.missions) do
						if entry.threadtype ~= "" then
							hadThreadMission = true
						end
						if hadThreadMission and (entry.threadtype == "") then
							-- first non thread mission after threads
							hadThreadMission = false
							local row = ftable:addRow(false, {  })
							row[1]:setColSpan(9):createText("")
						end
						menu.addMissionRow(ftable, entry, 1)
					end
				end
			end
			if not found then
				local row = ftable:addRow("guildnone", { interactive = false })
				if menu.missionModeCurrent == "guildnone" then
					menu.setrow = row.index
				end
				row[1]:setColSpan(9):createText("--- " .. ReadText(1001, 3302) .. " ---", { halign = "center" })
			end
			-- other
			local row = ftable:addRow(nil, { bgColor = Color["row_title_background"] })
			row[1]:setColSpan(9):createText(ReadText(1001, 3334), Helper.headerRowCenteredProperties)
			found = false
			local hadThreadMission = false
			for _, entry in ipairs(menu.missionList["other"]) do
				found = true
				if entry.threadtype ~= "" then
					hadThreadMission = true
				end
				if hadThreadMission and (entry.threadtype == "") then
					-- first non thread mission after threads
					hadThreadMission = false
					local row = ftable:addRow(false, {  })
					row[1]:setColSpan(9):createText("")
				end
				menu.addMissionRow(ftable, entry)
			end
			if not found then
				local row = ftable:addRow("othernone", { interactive = false })
				if menu.missionModeCurrent == "othernone" then
					menu.setrow = row.index
				end
				row[1]:setColSpan(9):createText("--- " .. ReadText(1001, 3302) .. " ---", { halign = "center" })
			end
			found = true
			-- online
			if #menu.missionList["coalition"] > 0 then
				local row = ftable:addRow(nil, { bgColor = Color["row_title_background"] })
				row[1]:setColSpan(9):createText(ReadText(1001, 11609), Helper.headerRowCenteredProperties)
				for _, entry in ipairs(menu.missionList["coalition"]) do
					menu.addMissionRow(ftable, entry)
				end
			end
		elseif menu.missionMode == "upkeep" then
			-- title
			local row = ftable:addRow(false, { fixed = true, bgColor = Color["row_title_background"] })
			row[1]:setColSpan(9):createText(ReadText(1001, 3305), Helper.headerRowCenteredProperties)
			for containeridstring, data in pairs(menu.missionList[menu.missionMode]) do
				found = true

				-- check if we need to expand for the current selected mission
				for _, entry in ipairs(data.missions) do
					if entry.ID == menu.missionModeCurrent then
						menu.expandedMissionGroups[containeridstring] = true
					end
					for i, submission in ipairs(entry.subMissions) do
						if submission.ID == menu.missionModeCurrent then
							menu.expandedMissionGroups[containeridstring] = true
							menu.expandedMissionGroups[entry.ID] = true
						end
					end
				end

				local isexpanded = menu.expandedMissionGroups[containeridstring]
				local row = ftable:addRow(containeridstring, {  })
				if containeridstring == menu.missionModeCurrent then
					menu.setrow = row.index
				end

				local color = Color["text_normal"]
				if data.active then
					color = Color["text_mission"]
				end

				row[1]:createButton():setText(isexpanded and "-" or "+", { halign = "center" })
				row[1].handlers.onClick = function () return menu.buttonExpandMissionGroup(containeridstring, row.index) end
				local container = ConvertStringTo64Bit(containeridstring)
				row[2]:setColSpan(7):createText(ffi.string(C.GetComponentName(container)) .. " (" .. ffi.string(C.GetObjectIDCode(container)) .. ")" , { color = color })
				row[9]:createText((#data.missions == 1) and ReadText(1001, 3337) or string.format(ReadText(1001, 3338), #data.missions), { halign = "right", color = color })

				if isexpanded then
					local hadThreadMission = false
					for _, entry in ipairs(data.missions) do
						if entry.threadtype ~= "" then
							hadThreadMission = true
						end
						if hadThreadMission and (entry.threadtype == "") then
							-- first non thread mission after threads
							hadThreadMission = false
							local row = ftable:addRow(false, {  })
							row[1]:setColSpan(9):createText("")
						end
						menu.addMissionRow(ftable, entry, 1)
					end
				end
			end
		else
			local title = ""
			for _, entry in ipairs(config.missionCategories) do
				if entry.category == menu.missionMode then
					title = entry.name
					break
				end
			end
			-- title
			local row = ftable:addRow(false, { fixed = true, bgColor = Color["row_title_background"] })
			row[1]:setColSpan(9):createText(title, Helper.headerRowCenteredProperties)
			local hadThreadMission = false
			for _, entry in ipairs(menu.missionList[menu.missionMode]) do
				found = true
				if entry.threadtype ~= "" then
					hadThreadMission = true
				end
				if hadThreadMission and (entry.threadtype == "") then
					-- first non thread mission after threads
					hadThreadMission = false
					local row = ftable:addRow(false, {  })
					row[1]:setColSpan(9):createText("")
				end
				menu.addMissionRow(ftable, entry)
			end
		end
		if not found then
			local row = ftable:addRow("othernone", { interactive = false })
			if menu.missionModeCurrent == "othernone" then
				menu.setrow = row.index
			end
			row[1]:setColSpan(9):createText("--- " .. ReadText(1001, 3302) .. " ---", { halign = "center" })
		end
	end

	if (menu.infoTableMode ~= "missionoffer") or (menu.missionOfferMode ~= "operation") then
		ftable:setTopRow(menu.settoprow)
		ftable:setSelectedRow(menu.setrow)
		ftable:setSelectedCol(menu.setcol or 0)
	end
	menu.setrow = nil
	menu.settoprow = nil
	menu.setcol = nil

	if (menu.infoTableMode ~= "missionoffer") or ((menu.missionOfferMode ~= "operation") and isonline) then
		local table_header = menu.createMissionModeHeader(frame, "left")

		ftable.properties.y = table_header.properties.y + table_header:getVisibleHeight() + Helper.borderSize

		table_header:addConnection(1, 2, true)
		ftable:addConnection(2, 2)
	end
end

function menu.createMissionModeHeader(frame, instance)
	local categories = (menu.infoTableMode == "missionoffer") and config.missionOfferTabs or config.missionCategories

	local ftable
	if instance == "left" then
		menu.missionModeHeaderTableLeft = frame:addTable(#categories + 1, { tabOrder = 1 })
		ftable = menu.missionModeHeaderTableLeft
	elseif instance == "right" then
		menu.missionModeHeaderTableRight = frame:addTable(#categories + 1, { tabOrder = 1 })
		ftable = menu.missionModeHeaderTableRight
	end

	local count = 1
	for i, entry in ipairs(categories) do
		if entry.showtab ~= false then
			if entry.empty then
				ftable:setColWidth(count, menu.sideBarWidth / 2, false)
			else
				ftable:setColWidth(count, menu.sideBarWidth, false)
			end
			count = count + 1
		end
	end

	local row = ftable:addRow("tabs", { fixed = true })
	local count = 1
	for _, entry in ipairs(categories) do
		if entry.showtab ~= false then
			if not entry.empty then
				local bgcolor = Color["row_title_background"]
				local color = Color["icon_normal"]
				if menu.infoTableMode == "missionoffer" then
					if entry.category == menu.missionOfferMode then
						bgcolor = Color["row_background_selected"]
					end
					if entry.category == "operation" then
						local outcomes = GetVentureOutcomes()
						if next(outcomes) ~= nil then
							color = Color["icon_mission"]
						end
					end
				else
					if entry.category == menu.missionMode then
						bgcolor = Color["row_background_selected"]
					end
					if entry.category == menu.activeMissionMode then
						color = Color["icon_mission"]
					end
				end

				local loccount = count
				row[loccount]:createButton({ height = menu.sideBarWidth, bgColor = bgcolor, mouseOverText = entry.name, scaling = false, helpOverlayID = entry.helpOverlayID, helpOverlayText = entry.helpOverlayText }):setIcon(entry.icon, { color = color})
				if menu.infoTableMode == "missionoffer" then
					row[loccount].handlers.onClick = function () return menu.buttonMissionOfferSubMode(entry.category, loccount) end
				else
					row[loccount].handlers.onClick = function () return menu.buttonMissionSubMode(entry.category, loccount) end
				end
			end
			count = count + 1
		end
	end

	if menu.selectedRows["missionModeHeaderTable" .. instance] then
		ftable.properties.defaultInteractiveObject = true
		ftable:setSelectedRow(menu.selectedRows["missionModeHeaderTable" .. instance])
		ftable:setSelectedCol(menu.selectedCols["missionModeHeaderTable" .. instance] or 0)
		menu.selectedRows["missionModeHeaderTable" .. instance] = nil
		menu.selectedCols["missionModeHeaderTable" .. instance] = nil
	end

	return ftable
end

function menu.addMissionRow(ftable, missionentry, indented, seqidx)
	local name = missionentry.name
	if seqidx then
		name = seqidx .. ReadText(1001, 120) .. " " .. name
	end
	local icon = "\27[" .. "missiontype_" .. missionentry.type .. "]"
	local color = Color["text_normal"]
	if missionentry.active then
		color = Color["text_mission"]
	elseif missionentry.accepted then
		name = ReadText(1001, 6404) .. " - " .. name
		color = Color["text_mission"]
		missionentry.duration = 0
	elseif missionentry.expired then
		name = ReadText(1001, 6402) .. " - " .. name
		color = Color["text_inactive"]
		missionentry.duration = 0
	end
	local faction = ""
	if missionentry.faction ~= "" then
		faction = GetFactionData(missionentry.faction, "shortname")
	end
	if missionentry.faction == "player" then
		faction = ""
	end
	local reward = missionentry.rewardtext
	if missionentry.reward > 0 then
		reward = ConvertMoneyString(missionentry.reward, false, true, 7, true) .. " " .. ReadText(1001, 101)
	end
	if reward ~= "" then
		reward = ReadText(1001, 3301) .. ReadText(1001, 120) .. " " .. reward
	end
	local difficulty, difficultyMouseOverText = "", ""
	if missionentry.difficulty ~= 0 then
		difficulty, difficultyMouseOverText = ConvertMissionLevelString(missionentry.difficulty)
	end

	if menu.missionModeCurrent == nil then
		menu.missionModeCurrent = missionentry.ID
	end

	local bgColor = Color["row_background_blue"]
	if #missionentry.subMissions > 0 then
		bgColor = nil
	elseif missionentry.expired then
		bgColor = Color["row_background_unselectable"]
	elseif missionentry.ID == menu.missionModeCurrent then
		bgColor = Color["row_background_selected"]
	end

	local row = ftable:addRow((missionentry.expired or missionentry.accepted) and true or { missionentry.ID }, { bgColor = bgColor })
	row[5]:setColSpan(4)
	local font = Helper.standardFont
	if missionentry.ID == menu.missionModeCurrent then
		menu.setrow = row.index
		if #missionentry.subMissions > 0 then
			font = Helper.standardFontBold
		end
	end
	if reward ~= "" then
		local lines = GetTextLines(reward, Helper.standardFont, Helper.scaleFont(Helper.standardFont, config.mapFontSize), row[5]:getWidth())
		if reward ~= lines[1] then
			reward = utf8.sub(lines[1], 1, -3) .. "..."
		end
	end

	local missioncol = 1
	if #missionentry.subMissions > 0 then
		local isexpanded = menu.expandedMissionGroups[missionentry.ID]

		if indented == 1 then
			row[1]:setBackgroundColSpan(9)
			row[2]:createButton():setText(isexpanded and "-" or "+", { halign = "center" })
			row[2].handlers.onClick = function () return menu.buttonExpandMissionGroup(missionentry.ID, row.index, function() return menu.showMissionContext(missionentry.ID) end) end
			row[3]:setColSpan(7):createText(name, { color = color, font = font })
		else
			row[1]:setBackgroundColSpan(9):createButton():setText(isexpanded and "-" or "+", { halign = "center" })
			row[1].handlers.onClick = function () return menu.buttonExpandMissionGroup(missionentry.ID, row.index, function() return menu.showMissionContext(missionentry.ID) end) end
			row[2]:setColSpan(8):createText(name, { color = color, font = font })
		end

		if isexpanded then
			for i, submission in ipairs(missionentry.subMissions) do
				menu.addMissionRow(ftable, submission, (indented or 0) + 1, (missionentry.threadtype == "sequential") and i or nil)
			end
		end
	else
		if indented == 2 then
			row[2]:setBackgroundColSpan(1)
			row[1]:setColSpan(2)
			row[1].properties.cellBGColor = Color["row_background"]
			row[3]:setBackgroundColSpan(7):setColSpan(2):createText(icon .. "\n" .. faction, { color = color })
			row[5]:createText(name .. "\n" .. reward, { color = color })
			row[9]:createText(function () return menu.getMissionTimeAndDifficulty(missionentry.ID, difficulty) end, { color = color, halign = "right", mouseOverText = difficultyMouseOverText })
			missioncol = 3
		elseif indented == 1 then
			row[1].properties.cellBGColor = Color["row_background"]
			row[2]:setBackgroundColSpan(8):setColSpan(3):createText(icon .. "\n" .. faction, { color = color })
			row[5]:createText(name .. "\n" .. reward, { color = color })
			row[9]:createText(function () return menu.getMissionTimeAndDifficulty(missionentry.ID, difficulty) end, { color = color, halign = "right", mouseOverText = difficultyMouseOverText })
			missioncol = 2
		else
			row[1]:setColSpan(4):setBackgroundColSpan(9):createText(icon .. "\n" .. faction, { color = color })
			row[5]:createText(name .. "\n" .. reward, { color = color })
			row[9]:createText(function () return menu.getMissionTimeAndDifficulty(missionentry.ID, difficulty) end, { color = color, halign = "right", mouseOverText = difficultyMouseOverText })
		end
	end
	row[missioncol].properties.helpOverlayID = missionentry.helpOverlayID
	row[missioncol].properties.helpOverlayText = " "
	row[missioncol].properties.helpOverlayHighlightOnly = true
	row[missioncol].properties.helpOverlayUseBackgroundSpan = true
end

function menu.getMissionTimeAndDifficulty(missionid, difficulty)
	local rawduration = 0
	if menu.infoTableMode == "mission" then
		if menu.updateMissionTime ~= getElapsedTime() then
			menu.updateMissions()
		end
		local missiondetails = C.GetMissionIDDetails(ConvertStringTo64Bit(missionid))
		rawduration = (missiondetails.timeLeft and missiondetails.timeLeft > -1) and missiondetails.timeLeft or (missiondetails.duration or -1)
	else
		if menu.updateMissionOfferTime ~= getElapsedTime() then
			menu.updateMissionOfferList()
		end

		local found = false
		local expired = false
		for _, category in ipairs(config.missionOfferCategories) do
			for i, entry in ipairs(menu.missionOfferList[category.category] or {}) do
				if entry.ID == missionid then
					found = true
					expired = entry.expired or entry.accepted
					break
				end
			end
		end
		if found and (not expired) then
			local name, description, offerdifficulty, threadtype, maintype, subtype, subtypename, faction, reward, rewardtext, briefingobjectives, activebriefingstep, briefingmissions, oppfaction, licence, missiontime, offerduration, _, _, _, _, actor = GetMissionOfferDetails(ConvertStringToLuaID(missionid))
			rawduration = offerduration
		end
	end

	local duration = ""
	if rawduration > 0 then
		duration = ConvertTimeString(rawduration, (rawduration >= 3600) and "%h:%M:%S" or "%M:%S")
	end

	return duration .. "\n" .. difficulty
end

function menu.updateMissionOfferList(clear)
	menu.updateMissionOfferTime = getElapsedTime()
	if (not menu.missionOfferList) or (not next(menu.missionOfferList)) then
		clear = true
	end
	if clear then
		menu.missionOfferList = {}
		for _, entry in ipairs(config.missionOfferCategories) do
			menu.missionOfferList[entry.category] = {}
		end
		menu.missionOfferByOnlineID = {}
	end

	local missionOfferList, missionOfferIDs = {}, {}
	Helper.ffiVLA(missionOfferList, "uint64_t", C.GetNumCurrentMissionOffers, C.GetCurrentMissionOffers, true)
	for i, id in ipairs(missionOfferList) do
		missionOfferIDs[tostring(id)] = i
	end

	for _, entry in ipairs(config.missionOfferCategories) do
		if entry.category == "guild" then
			for i, data in ipairs(menu.missionOfferList[entry.category]) do
				for j = #data.missions, 1, -1 do
					if missionOfferIDs[data.missions[j].ID] then
						missionOfferIDs[menu.missionOfferList[entry.category][i].missions[j].ID] = nil
					else
						if not menu.missionOfferList[entry.category][i].missions[j].accepted then
							menu.missionOfferList[entry.category][i].missions[j].expired = true
						end
					end
				end
			end
		else
			for i = #menu.missionOfferList[entry.category], 1, -1 do
				if missionOfferIDs[menu.missionOfferList[entry.category][i].ID] then
					missionOfferIDs[menu.missionOfferList[entry.category][i].ID] = nil
				else
					if not menu.missionOfferList[entry.category][i].accepted then
						menu.missionOfferList[entry.category][i].expired = true
					end
				end
			end
		end
	end

	for id in pairs(missionOfferIDs) do
		local missionofferid64 = ConvertStringTo64Bit(id)
		local name, description, difficulty, threadtype, maintype, subtype, subtypename, faction, reward, rewardtext, briefingobjectives, activebriefingstep, briefingmissions, oppfaction, licence, missiontime, duration, _, _, _, _, actor = GetMissionOfferDetails(ConvertStringToLuaID(id))
		local missionGroup = C.GetMissionGroupDetails(missionofferid64)
		local groupID, groupName = ffi.string(missionGroup.id), ffi.string(missionGroup.name)
		local onlineinfo = C.GetMissionOnlineInfo(missionofferid64)
		local onlinechapter, onlineid = ffi.string(onlineinfo.chapter), ffi.string(onlineinfo.onlineid)
		local helpoverlayid = ffi.string(C.GetMissionHelpOverlayID(missionofferid64))
		if maintype ~= "tutorial" then
			local entry = {
				["name"] = name,
				["description"] = description,
				["difficulty"] = difficulty,
				["missionGroup"] = { id = groupID, name = groupName },
				["threadtype"] = threadtype,
				["type"] = subtype,
				["faction"] = faction or "",
				["oppfaction"] = oppfaction or "",
				["licence"] = licence,
				["reward"] = reward,
				["rewardtext"] = rewardtext,
				["briefingobjectives"] = briefingobjectives,
				["activebriefingstep"] = activebriefingstep,
				["duration"] = duration,
				["missiontime"] = missiontime,
				["ID"] = id,
				["actor"] = actor,
				["onlinechapter"] = onlinechapter,
				["onlineID"] = onlineid,
				["helpOverlayID"] = helpoverlayid,
				["subMissions"] = {},
			}

			if entry.missionGroup.id ~= "" then
				local index = 0
				for i, data in ipairs(menu.missionOfferList["guild"]) do
					if data.id == entry.missionGroup.id then
						index = i
						break
					end
				end
				if index ~= 0 then
					table.insert(menu.missionOfferList["guild"][index].missions, entry)
				else
					table.insert(menu.missionOfferList["guild"], { id = entry.missionGroup.id, name = entry.missionGroup.name, missions = { entry } })
				end
			else
				if maintype == "plot" then
					table.insert(menu.missionOfferList["plot"], entry)
				elseif onlinechapter ~= "" then
					table.insert(menu.missionOfferList["coalition"], entry)
					menu.missionOfferByOnlineID[entry.onlineID] = entry
				else
					table.insert(menu.missionOfferList["other"], entry)
				end
			end
		end
	end

	table.sort(menu.missionOfferList["guild"], Helper.sortName)
	for _, entry in ipairs(menu.missionOfferList["guild"]) do
		table.sort(entry.missions, menu.missionOfferSorter)
	end
	table.sort(menu.missionOfferList["plot"], menu.missionOfferSorter)
	table.sort(menu.missionOfferList["coalition"], menu.missionOfferSorter)
	table.sort(menu.missionOfferList["other"], menu.missionOfferSorter)
end

function menu.missionOfferSorter(a, b)
	if a.name == b.name then
		return a.ID > b.ID
	end
	return a.name < b.name
end

function menu.getMissionInfoHelper(mission)
	local missionID, name, description, difficulty, threadtype, maintype, subtype, subtypename, faction, reward, rewardtext, _, _, _, _, _, missiontime, _, abortable, disableguidance, associatedcomponent, upkeepalertlevel, hasobjective, threadmissionid = GetMissionDetails(mission)
	local missionid64 = ConvertIDTo64Bit(missionID)
	local missionGroup = C.GetMissionGroupDetails(missionid64)
	local groupID, groupName = ffi.string(missionGroup.id), ffi.string(missionGroup.name)
	local onlineinfo = C.GetMissionOnlineInfo(missionid64)
	local onlinechapter, onlineid = ffi.string(onlineinfo.chapter), ffi.string(onlineinfo.onlineid)
	local helpoverlayid = ffi.string(C.GetMissionHelpOverlayID(missionid64))
	local objectiveText, timeout, progressname, curProgress, maxProgress = GetMissionObjective(mission)
	local subMissions, buf = {}, {}
	local subactive = false
	Helper.ffiVLA(buf, "MissionID", C.GetNumMissionThreadSubMissions, C.GetMissionThreadSubMissions, missionid64)
	for _, submission in ipairs(buf) do
		local submissionEntry = menu.getMissionIDInfoHelper(submission)
		table.insert(subMissions, submissionEntry)
		if submissionEntry.active then
			subactive = true
		end
	end
	local entry = {
		["active"] = (mission == GetActiveMission()) or subactive,
		["name"] = name,
		["description"] = description,
		["difficulty"] = difficulty,
		["missionGroup"] = { id = groupID, name = groupName },
		["threadtype"] = threadtype,
		["maintype"] = maintype,
		["type"] = subtype,
		["faction"] = faction,
		["reward"] = reward,
		["rewardtext"] = rewardtext,
		["duration"] = (timeout and timeout ~= -1) and timeout or (missiontime or -1),		-- timeout can be nil, if mission has no objective
		["ID"] = tostring(missionid64),
		["associatedcomponent"] = ConvertIDTo64Bit(associatedcomponent),
		["abortable"] = abortable,
		["threadMissionID"] = ConvertIDTo64Bit(threadmissionid) or 0,
		["subMissions"] = subMissions,
		["onlinechapter"] = onlinechapter,
		["onlineID"] = onlineid,
		["helpOverlayID"] = helpoverlayid,
	}

	return entry
end

function menu.getMissionIDInfoHelper(missionID)
	local missionGroup = C.GetMissionGroupDetails(missionID)
	local groupID, groupName = ffi.string(missionGroup.id), ffi.string(missionGroup.name)
	local onlineinfo = C.GetMissionOnlineInfo(missionID)
	local onlinechapter, onlineid = ffi.string(onlineinfo.chapter), ffi.string(onlineinfo.onlineid)
	local helpoverlayid = ffi.string(C.GetMissionHelpOverlayID(missionID))
	local subMissions, buf = {}, {}
	local subactive = false
	Helper.ffiVLA(buf, "MissionID", C.GetNumMissionThreadSubMissions, C.GetMissionThreadSubMissions, missionID)
	for _, submission in ipairs(buf) do
		local submissionEntry = menu.getMissionIDInfoHelper(submission)
		table.insert(subMissions, submissionEntry)
		if submissionEntry.active then
			subactive = true
		end
	end
	local missiondetails = C.GetMissionIDDetails(missionID)
	local entry = {
		["active"] = (missionID == C.GetActiveMissionID()) or subactive,
		["name"] = ffi.string(missiondetails.missionName),
		["description"] = ffi.string(missiondetails.missionDescription),
		["difficulty"] = missiondetails.difficulty,
		["missionGroup"] = { id = groupID, name = groupName },
		["threadtype"] = ffi.string(missiondetails.threadType),
		["maintype"] = ffi.string(missiondetails.mainType),
		["type"] = ffi.string(missiondetails.subType),
		["faction"] = ffi.string(missiondetails.faction),
		["reward"] = tonumber(missiondetails.reward) / 100,
		["rewardtext"] = ffi.string(missiondetails.rewardText),
		["duration"] = (missiondetails.timeLeft and missiondetails.timeLeft > -1) and missiondetails.timeLeft or (missiondetails.duration or -1),
		["ID"] = tostring(ConvertStringTo64Bit(tostring(missionID))),
		["associatedcomponent"] = missiondetails.associatedComponent,
		["abortable"] = missiondetails.abortable,
		["threadMissionID"] = missiondetails.threadMissionID,
		["subMissions"] = subMissions,
		["onlinechapter"] = onlinechapter,
		["onlineID"] = onlineid,
		["activebriefingstep"] = missiondetails.activeBriefingStep,
		["helpOverlayID"] = helpoverlayid,
	}

	return entry
end

function menu.addMissionToList(entry)
	if entry.maintype == "upkeep" then
		if entry.associatedcomponent then
			local container = C.GetContextByRealClass(entry.associatedcomponent, "container", true)
			if container ~= 0 then
				local containeridstring = tostring(container)

				if menu.missionList["upkeep"][containeridstring] then
					if entry.active then
						menu.missionList["upkeep"][containeridstring].active = true
					end
					table.insert(menu.missionList["upkeep"][containeridstring].missions, entry)
				else
					menu.missionList["upkeep"][containeridstring] = { active = entry.active, missions = { entry } }
				end
				if entry.active then
					menu.activeMissionMode = "upkeep"
				end
			end
		end
	elseif entry.maintype == "guidance" then
		table.insert(menu.missionList["guidance"], entry)
		if entry.active then
			menu.activeMissionMode = "guidance"
		end
	elseif entry.maintype == "plot" then
		table.insert(menu.missionList["plot"], entry)
		if entry.active then
			menu.activeMissionMode = "plot"
		end
	elseif entry.onlinechapter ~= "" then
		table.insert(menu.missionList["coalition"], entry)
		menu.missionByOnlineID[entry.onlineID] = entry
	else
		if entry.missionGroup.id ~= "" then
			local index = 0
			for i, data in ipairs(menu.missionList["guild"]) do
				if data.id == entry.missionGroup.id then
					index = i
					break
				end
			end
			if index ~= 0 then
				if entry.active then
					menu.missionList["guild"][index].active = true
				end
				table.insert(menu.missionList["guild"][index].missions, entry)
			else
				table.insert(menu.missionList["guild"], { id = entry.missionGroup.id, name = entry.missionGroup.name, active = entry.active, missions = { entry } })
			end
			if entry.active then
				menu.activeMissionMode = "plot"
			end
		else
			table.insert(menu.missionList["other"], entry)
			if entry.active then
				menu.activeMissionMode = "plot"
			end
		end
	end
end

function menu.updateMissions()
	menu.updateMissionTime = getElapsedTime()
	menu.missionList = {}
	menu.missionByOnlineID = {}
	menu.activeMissionMode = nil
	for _, entry in ipairs(config.missionCategories) do
		menu.missionList[entry.category] = {}
	end

	local numMissions = GetNumMissions()
	for i = 1, numMissions do
		local entry = menu.getMissionInfoHelper(i)
		if maintype ~= "tutorial" then
			if entry.threadMissionID == 0 then
				menu.addMissionToList(entry)
			end
		end
	end

	for _, entry in ipairs(config.missionCategories) do
		if (entry.category == "guild") or (entry.category == "upkeep") then
			for _, data in pairs(menu.missionList[entry.category]) do
				table.sort(data.missions, menu.missionListSorter)
			end
		else
			table.sort(menu.missionList[entry.category], menu.missionListSorter)
		end
	end
end

function menu.missionListSorter(a, b)
	if ((a.threadtype ~= "") and (b.threadtype ~= "")) or ((a.threadtype == "") and (b.threadtype == "")) then
		if config.missionMainTypeOrder[a.maintype] == config.missionMainTypeOrder[b.maintype] then
			return a.name < b.name
		end
		return config.missionMainTypeOrder[a.maintype] < config.missionMainTypeOrder[b.maintype]
	end

	return a.threadtype ~= ""
end

function menu.createVentureSeasonHeader(frame, instance)
	local ftable
	if instance == "left" then
		menu.ventureSeasonHeaderTableLeft = frame:addTable(#config.infoCategories + 1, { tabOrder = 1 })
		ftable = menu.ventureSeasonHeaderTableLeft
	elseif instance == "right" then
		menu.ventureSeasonHeaderTableRight = frame:addTable(#config.infoCategories + 1, { tabOrder = 1 })
		ftable = menu.ventureSeasonHeaderTableRight
	end

	for i, entry in ipairs(config.seasonCategories) do
		if entry.empty then
			ftable:setColWidth(i, menu.sideBarWidth / 2, false)
		else
			ftable:setColWidth(i, menu.sideBarWidth, false)
		end
	end

	local isonline = Helper.isOnlineGame()
	local invitations = {}
	if not OnlineGetCurrentTeam().isvalid then
		invitations = Helper.callExtensionFunction("multiverse", "getTeamInvites") or {}
	end

	local row = ftable:addRow("orders_tabs", { fixed = true })
	local count = 1
	for _, entry in ipairs(config.seasonCategories) do
		if not entry.empty then
			local bgcolor = Color["row_title_background"]
			local color = Color["icon_normal"]
			if entry.category == menu.seasonMode[instance] then
				bgcolor = Color["row_background_selected"]
			end
			if entry.category == "ventureteam" then
				if not OnlineGetCurrentTeam().isvalid then
					if #invitations > 0 then
						color = Color["icon_mission"]
					end
				end
			end

			local active = (entry.category == "currentseason") or isonline
			-- TODO onlineUI
			if entry.category == "pastseasons" then
				active = false
			end

			local loccount = count
			row[loccount]:createButton({ active = active, height = menu.sideBarWidth, bgColor = bgcolor, mouseOverText = entry.name, scaling = false, helpOverlayID = entry.helpOverlayID, helpOverlayText = entry.helpOverlayText }):setIcon(entry.icon, { color = color})
			row[loccount].handlers.onClick = function () return menu.buttonVentureSeasonSubMode(entry.category, loccount, instance) end
			count = count + 1
		else
			count = count + 1
		end
	end

	if menu.selectedRows["ventureSeasonHeaderTable" .. instance] then
		ftable.properties.defaultInteractiveObject = true
		ftable:setSelectedRow(menu.selectedRows["ventureSeasonHeaderTable" .. instance])
		ftable:setSelectedCol(menu.selectedCols["ventureSeasonHeaderTable" .. instance] or 0)
		menu.selectedRows["ventureSeasonHeaderTable" .. instance] = nil
		menu.selectedCols["ventureSeasonHeaderTable" .. instance] = nil
	end

	return ftable
end

function menu.createVentureSeason(frame, instance)
	local infoTableData = menu.infoTableData[instance]
	local infoTablePersistentData = menu.infoTablePersistentData[instance]

	local numCols = 2
	local table_desc = frame:addTable(numCols, { tabOrder = 1, highlightMode = "off" })
	table_desc:setColWidthPercent(2, 33)
	table_desc:setDefaultBackgroundColSpan(1, numCols)

	local season = OnlineGetCurrentSeason()

	-- title
	local row = table_desc:addRow(nil, { fixed = true, bgColor = Color["row_title_background"] })
	row[1]:setColSpan(numCols):createText(ReadText(1001, 11322), Helper.titleTextProperties)

	-- description
	local row = table_desc:addRow(nil, { fixed = true, bgColor = Color["row_title_background"] })
	row[1]:setColSpan(numCols):createText(ReadText(1001, 11334), Helper.subHeaderTextProperties)

	local description = GetTextLines(season.description, Helper.standardFont, Helper.scaleFont(Helper.standardFont, Helper.standardFontSize), menu.infoTableWidth - 2 * Helper.scaleX(Helper.standardTextOffsetx))
	if #description > config.ventureSeasons.maxDescRows then
		-- scrollbar case
		description = GetTextLines(season.description, Helper.standardFont, Helper.scaleFont(Helper.standardFont, Helper.standardFontSize), menu.infoTableWidth - 2 * Helper.scaleX(Helper.standardTextOffsetx) - Helper.scrollbarWidth)
	end
	for linenum, descline in ipairs(description) do
		local row = table_desc:addRow(true, {  })
		row[1]:setColSpan(numCols):createText(descline)
		if linenum == config.ventureSeasons.maxDescRows then
			visibleHeight = table_desc:getFullHeight()
		end
	end

	if visibleHeight then
		table_desc.properties.maxVisibleHeight = visibleHeight
	else
		table_desc.properties.maxVisibleHeight = table_desc:getFullHeight()
	end

	if menu.selectedRows["infotable" .. instance] then
		table_desc:setSelectedRow(menu.selectedRows["infotable" .. instance])
		menu.selectedRows["infotable" .. instance] = nil
		if menu.topRows["infotable" .. instance] then
			table_desc:setTopRow(menu.topRows["infotable" .. instance])
			menu.topRows["infotable" .. instance] = nil
		end
	end
	menu.setrow = nil
	menu.settoprow = nil
	menu.setcol = nil

	local numCols = 2
	local table_info = frame:addTable(numCols, { tabOrder = 2 })
	table_info:setColWidthPercent(2, 50)
	table_info:setDefaultBackgroundColSpan(1, numCols)

	table_info:addEmptyRow(config.mapRowHeight / 2)

	-- reward
	local row = table_info:addRow(nil, { fixed = true, bgColor = Color["row_title_background"] })
	row[1]:setColSpan(numCols):createText(ReadText(1001, 11335), Helper.subHeaderTextProperties)

	local row = table_info:addRow(nil, { fixed = true })
	row[1]:setColSpan(numCols):createIcon(season.rewardicon, { scaling = false, height = math.floor(menu.infoTableWidth * 9 / 32) })

	if season.isvalid then
		local rewardlist = { { text = season.rewardtext } }
		for i, entry in ipairs(rewardlist) do
			local row = table_info:addRow(nil, { fixed = true })
			if i == 1 then
				row[1]:createText(ReadText(1001, 11338) .. ReadText(1001, 120))
			end
			row[2]:createText(entry.text, { halign = "right" })
		end

		table_info:addEmptyRow(config.mapRowHeight / 2)

		-- details
		local row = table_info:addRow(nil, { fixed = true, bgColor = Color["row_title_background"] })
		row[1]:setColSpan(numCols):createText(ReadText(1001, 11336), Helper.subHeaderTextProperties)

		local row = table_info:addRow(nil, { fixed = true })
		row[1]:createText(ReadText(1001, 11339) .. ReadText(1001, 120))
		local seasonname = ""
		if (season.seasonnumber < 1) or (season.seasonnumber > 25) then
			seasonname = string.format(ReadText(1001, 11576), season.seasonnumber)
		else
			seasonname = string.format(ReadText(1001, 11576), ReadText(20402, season.seasonnumber))
		end
		row[2]:createText(seasonname, { halign = "right" })

		local row = table_info:addRow(nil, { fixed = true })
		row[1]:createText(ReadText(1001, 11340) .. ReadText(1001, 120))
		row[2]:createText(Helper.ventureSeasonTimeLeftText(), { halign = "right" })

		-- coalition
		local row = table_info:addRow(true, { fixed = true })
		row[1]:createText(ReadText(1001, 11341) .. ReadText(1001, 120))

		local coalitionname = ""
		local currentcoalition = OnlineGetCurrentCoalition()
		if currentcoalition.isvalid then
			coalitionname = currentcoalition.name
		else
			coalitionname = ReadText(1001, 11577)
		end
		row[2]:createButton({ active = function() return (season.ispreseason or season.isrunning) and Helper.isOnlineGame() end }):setText(coalitionname, { halign = "center" })
		row[2].handlers.onClick = function () return menu.buttonVentureSeasonSubMode("coalition", 2, instance) end

		-- team
		local row = table_info:addRow(true, { fixed = true })
		row[1]:createText(ReadText(1001, 11582) .. ReadText(1001, 120))

		local teamname = ""
		local currentteam = OnlineGetCurrentTeam()
		if currentteam.isvalid then
			teamname = currentteam.name
		else
			teamname = ReadText(1001, 11583)
		end
		row[2]:createButton({ active = function () local currentcoalition = OnlineGetCurrentCoalition(); return Helper.isOnlineGame() and currentcoalition.isvalid end }):setText(teamname, { halign = "center" })
		row[2].handlers.onClick = function () return menu.buttonVentureSeasonSubMode("ventureteam", 3, instance) end

		table_info:addEmptyRow(config.mapRowHeight / 2)

		--[[
		-- progress
		local row = table_info:addRow(nil, { fixed = true, bgColor = Color["row_title_background"] })
		row[1]:setColSpan(numCols):createText(ReadText(1001, 11337), Helper.subHeaderTextProperties)

		-- TODO onlineUI
		local seasonprogress = { rank = "\27MEmperor", venturescompleted = 3210 } -- TEMPTEXT Florian
		local progresslist = {
			{ text = ReadText(1001, 11342),		value = "rank",					type = "string" },
			{ text = ReadText(1001, 11343),		value = "venturescompleted",	type = "number" },
			{ text = ReadText(1001, 11344),		value = "venturesfailed",		type = "number" },
		}
		for i, entry in ipairs(progresslist) do
			local row = table_info:addRow(nil, { fixed = true })
			row[1]:createText(entry.text .. ReadText(1001, 120))
			local value = seasonprogress[entry.value]
			if value and (entry.type == "number") then
				value = ConvertIntegerString(value, true, 0, true)
			end
			row[2]:createText(value, { halign = "right" })
		end--]]
	end

	local table_header = menu.createVentureSeasonHeader(frame, instance)

	table_desc.properties.y = table_header.properties.y + table_header:getFullHeight() + Helper.borderSize
	table_info.properties.y = table_desc.properties.y + table_desc:getVisibleHeight() + Helper.borderSize

	table_header:addConnection(1, (instance == "left") and 2 or 3, true)
	table_desc:addConnection(2, (instance == "left") and 2 or 3)
	table_info:addConnection(3, (instance == "left") and 2 or 3)
end

function menu.createCheats(frame)
	-- (cheat only)
	local cheats = {
		[1] = {
			name = "Enable All Cheats",
			info = "Reveal stations, encyclopedia, map, research and adds money and seta.",
			callback = C.EnableAllCheats,
			shortcut = {"action", 290}, -- INPUT_ACTION_DEBUG_FEATURE_3
		},
		[2] = {
			name = "Reveal map",
			callback = C.RevealMap,
		},
		[3] = {
			name = "Reveal stations",
			callback = C.RevealStations,
		},
		[4] = {
			name = "Cheat 1bn Credits",
			callback = function () return C.AddPlayerMoney(100000000000) end,
		},
		[5] = {
			name = "Cheat SETA",
			callback = function () return AddInventory(nil, "inv_timewarp", 1) end,
		},
		[6] = {
			name = "Reveal encyclopedia",
			info = "Also reveals the map and completes all research.",
			callback = C.RevealEncyclopedia,
		},
		[7] = {
			name = "Spawn CVs",
			section = "gDebug_deployCVs",
		},
		[8] = {
			name = "Fill nearby Build Storages",
			section = "gDebug_station_buildresources",
		},
		[9] = {
			name = "Inc Crew skill",
			section = "gDebug_crewskill",
		},
		[10] = {
			name = "Open Flowchart Test",
			menu = "StationOverviewMenu",
		},
		[11] = {
			name = "Cheat All Research",
			callback = menu.cheatAllResearch,
		},
		[12] = {
			name = "Cheat Docking Traffic",
			sectionparam = C.CheatDockingTraffic,
			shortcut = {"action", 291}, -- INPUT_ACTION_DEBUG_FEATURE_4
		},
		[13] = {
			name = "Cheat Live Stream View Channels",
			info = "Makes all faction channels available in Live Stream View.",
			callback = C.CheatLiveStreamViewChannels,
		},
	}

	local ftable = frame:addTable(1 , { tabOrder = 1 })
	ftable:addConnection(1, 2, true)
	ftable:setDefaultCellProperties("text", { minRowHeight = config.mapRowHeight, fontsize = config.mapFontSize })
	ftable:setDefaultCellProperties("button", { height = config.mapRowHeight })
	ftable:setDefaultComplexCellProperties("button", "text", { fontsize = config.mapFontSize })

	local row = ftable:addRow(false, { fixed = true, bgColor = Color["row_title_background"] })
	row[1]:createText("Cheats", Helper.headerRowCenteredProperties)

	for _, cheat in ipairs(cheats) do
		local row = ftable:addRow(true, { bgColor = Color["row_background_blue"] })
		local shortcut = ""
		if cheat.shortcut then
			shortcut = Helper.formatOptionalShortcut(" " .. ColorText["text_inactive"] .. "(%s)", cheat.shortcut[1], cheat.shortcut[2])
		end
		row[1]:createButton({ mouseOverText = cheat.info or "" }):setText(cheat.name .. shortcut)
		if cheat.callback then
			row[1].handlers.onClick = function () return cheat.callback() end
		elseif cheat.menu then
			row[1].handlers.onClick = function () Helper.closeMenuAndOpenNewMenu(menu, cheat.menu, {0, 0}) menu.cleanup() end
		elseif cheat.section then
			row[1].handlers.onClick = function () Helper.closeMenuForNewConversation(menu, cheat.section, ConvertStringToLuaID(tostring(C.GetPlayerComputerID())), nil, true) menu.cleanup() end
		end
	end
end

function menu.cheatAllResearch()
	local researchwares = {
		"research_module_defence",
		"research_module_habitation",
		"research_module_production",
		"research_module_storage",
		"research_module_dock",
		"research_module_build",
		"research_teleportation",
		"research_teleportation_range_01",
		"research_teleportation_range_02",
		"research_teleportation_range_03",
		"research_radioreceiver",
		"research_sensorbooster",
		"research_tradeinterface",
	}

	for _, research in ipairs(researchwares) do
		C.AddResearch(research)
	end
end

function menu.createPlayerInfo(frame, width, height, offsetx, offsety)
	local ftable = frame:addTable(3, { tabOrder = 18, width = width, height = height, x = offsetx, y = offsety, scaling = false })
	ftable:setColWidth(1, height)
	ftable:setColWidthPercent(3, 30)

	local row = ftable:addRow(true, { fixed = true, bgColor = Color["player_info_background"] })
	local icon = row[1]:setBackgroundColSpan(3):createIcon(function () local logo = C.GetCurrentPlayerLogo(); return ffi.string(logo.icon) end, { width = height, height = height, color = Helper.getPlayerLogoColor })

	local textheight = math.ceil(C.GetTextHeight(Helper.playerInfoConfigTextLeft(), Helper.standardFont, Helper.playerInfoConfig.fontsize, width - height - Helper.borderSize))

	if menu.showMultiverse then
		row[2]:createText(function (cell) return Helper.playerInfoConfigTextLeft(cell, nil, menu.showMultiverse) end, { fontsize = Helper.playerInfoConfig.fontsize, x = Helper.borderSize, y = math.max(0, (height - textheight) / 4) })
	else
		local button = row[2]:createButton({
			width = row[2]:getColSpanWidth(),
			height = Helper.scaleY(config.mapRowHeight),
			x = Helper.borderSize,
			y = Helper.borderSize,
			mouseOverText = ffi.string(C.ConvertInputString(ReadText(1026, 7911), ReadText(1026, 7902))),
			bgColor = function () return menu.allowResetView() and Color["button_background_default"] or Color["button_background_inactive"] end,
			highlightColor = function () return menu.allowResetView() and Color["button_highlight_default"] or Color["button_highlight_inactive"] end,
			helpOverlayID = "map_resetview",
			helpOverlayText = " ",
			helpOverlayHighlightOnly = true,
		})
		button:setText(function (cell) return Helper.playerInfoConfigTextLeft(cell, 0.7 * width - height - 2 * Helper.scaleY(Helper.standardTextHeight), menu.showMultiverse) end, { fontsize = Helper.playerInfoConfig.fontsize, x = Helper.borderSize, y = 0 })
		button:setText2("\27[menu_reset_view]", { halign = "right", scaling = true })
		button:setHotkey("INPUT_STATE_DETAILMONITOR_RESET_VIEW", { displayIcon = false })
		button.handlers.onClick = function () return menu.allowResetView() and menu.buttonResetView() or nil end
	end

	if OnlineIsCurrentTeamValid() then
		local button = row[3]:createButton({
			width = row[3]:getColSpanWidth(),
			height = Helper.scaleY(Helper.standardTextHeight),
			x = Helper.borderSize,
			y = Helper.borderSize,
			mouseOverText = Helper.getInputMouseOverText("INPUT_ACTION_SHOW_CHAT_WINDOW"),
		})
		button:setText(function (cell) return Helper.playerInfoConfigTextRight(cell, menu.showMultiverse) end, { fontsize = Helper.playerInfoConfig.fontsize, x = Helper.borderSize, y = 0, halign = "right" })
		button:setText2("\27[mt_chat_unread_low] " .. ReadText(1001, 11648), { scaling = true })
		button.handlers.onClick = function () return C.QuickMenuAccess("chat") end
	else
		row[3]:createText(function (cell) return Helper.playerInfoConfigTextRight(cell, menu.showMultiverse) end, { fontsize = Helper.playerInfoConfig.fontsize, halign = "right", x = Helper.borderSize, y = math.max(0, (height - textheight) / 4) })
	end
end

function menu.createSearchField(frame, width, height, offsetx, offsety, refresh)
	local editboxwidth = menu.infoTableWidth - Helper.round(2.5 * menu.editboxHeight) - Helper.borderSize

	local numCols = 7 + #config.layers
	local ftable = frame:addTable(numCols, { tabOrder = 4, width = width, height = height, x = offsetx, y = offsety, skipTabChange = true, backgroundID = "solid", backgroundColor = Color["frame_background_semitransparent"] })
	if menu.searchTableMode ~= "info" then
		ftable:addConnection(1, 3, true)
	end
	ftable:setDefaultCellProperties("text", { minRowHeight = config.mapRowHeight, fontsize = config.mapFontSize })
	ftable:setDefaultCellProperties("button", { height = config.mapRowHeight })
	ftable:setDefaultComplexCellProperties("button", "text", { fontsize = config.mapFontSize })

	ftable:setColWidth(1, Helper.scaleY(config.mapRowHeight), false)
	ftable:setColWidth(2, math.max(4, Helper.scaleY(Helper.headerRow1Height) - Helper.scaleY(config.mapRowHeight) - Helper.borderSize), false)
	ftable:setColWidth(3, menu.sideBarWidth - Helper.scaleY(Helper.headerRow1Height) - Helper.borderSize, false)
	for i = 2, #config.layers + 1 do
		ftable:setColWidth(i + 2, menu.sideBarWidth, false)
	end
	ftable:setColWidth(numCols - 1, Helper.scaleY(config.mapRowHeight), false)
	ftable:setColWidth(numCols, Helper.scaleY(config.mapRowHeight), false)

	-- search field
	local rows = {
		[1] = ftable:addRow(true, { fixed = true }),
		[2] = ftable:addRow(true, { fixed = true }),
		[3] = ftable:addRow(true, { fixed = true }),
	}

	for i, entry in ipairs(config.layers) do
		local icon = entry.icon
		local onoffcolor = Color["text_normal"]
		if not menu.getFilterOption(entry.mode, false) then
			icon = icon .. "_disabled"
			onoffcolor = Color["text_negative"]
		end
		local mouseovertext = entry.name
		local hotkeyname = Helper.getInputMouseOverText("INPUT_STATE_DETAILMONITOR_TOGGLE_FILTER_" .. i)
		if hotkeyname ~= "" then
			mouseovertext = mouseovertext .. " (" .. hotkeyname .. ")"
		end

		local button = rows[i][1]:setColSpan(5):createButton({ height = menu.editboxHeight, bgColor = bgcolor, mouseOverText = mouseovertext, scaling = false, helpOverlayID = entry.toggleHelpOverlayID, helpOverlayText = " ", helpOverlayHighlightOnly = true})
		button:setIcon(icon, { width = menu.editboxHeight, height = menu.editboxHeight })
		button:setText(entry.shortname, { x = menu.editboxHeight, fontsize = Helper.scaleFont(Helper.standardFont, config.mapFontSize) })
		button:setIcon2("menu_on_off", { width = menu.editboxHeight, height = menu.editboxHeight, x = rows[i][1]:getWidth() - menu.editboxHeight, color = onoffcolor })
		button:setHotkey("INPUT_STATE_DETAILMONITOR_TOGGLE_FILTER_" .. i, { displayIcon = false })
		button.handlers.onClick = function () return menu.buttonSetFilterLayer(entry.mode, rows[i].index, i) end
	end
	-- editbox
	rows[1][7]:setColSpan(4):createEditBox({ height = menu.editboxHeight, defaultText = ReadText(1001, 3250), scaling = false, helpOverlayID = "map_searchbar", helpOverlayText = " ", helpOverlayHighlightOnly = true, restoreInteractiveObject = true }):setText("", { x = Helper.standardTextOffsetx, scaling = true }):setHotkey("INPUT_STATE_DETAILMONITOR_0", { displayIcon = true })
	rows[1][7].handlers.onTextChanged = menu.searchTextChanged
	rows[1][7].handlers.onEditBoxDeactivated = menu.searchTextConfirmed
	menu.searchEditBoxData = {
		width = rows[1][7]:getColSpanWidth() + Helper.scrollbarWidth,
		x = offsetx + rows[1][7]:getOffsetX(),
		y = offsety + menu.editboxHeight + Helper.borderSize,
	}

	-- search terms
	local setting, warefilter = menu.getTradeWareFilter()
	__CORE_DETAILMONITOR_MAPFILTER_SAVE["searchsectors"] = __CORE_DETAILMONITOR_MAPFILTER_SAVE["searchsectors"] or {}
	local sectorfilter = __CORE_DETAILMONITOR_MAPFILTER_SAVE["searchsectors"]
	local maxsearchtermsdisplayed = 4

	local searchindex = 0
	for i = 1, math.min(maxsearchtermsdisplayed, #menu.searchtext) do
		local usedrow = rows[2]
		local col = 6 + i
		if col > 8 then
			usedrow = rows[3]
			col = col - 2
		end
		searchindex = searchindex + 1
		local untruncatedstring = menu.searchtext[i].text
		local truncatedString = TruncateText(untruncatedstring, Helper.standardFont, Helper.scaleFont(Helper.standardFont, config.mapFontSize), usedrow[col]:getWidth() - 2 * Helper.scaleX(10))

		if menu.searchtext[i].blockRemove then
			usedrow[col]:createText(untruncatedstring, { halign = "center", cellBGColor = Color["button_background_default"] })
		else
			usedrow[col]:createButton({
				height = menu.editboxHeight,
				helpOverlayID = "FilterItem" .. searchindex,
				helpOverlayText = " ",
				helpOverlayHighlightOnly = true,
				scaling = false,
				mouseOverText = (truncatedString ~= untruncatedstring) and untruncatedstring or "",
			}):setText(truncatedString, { halign = "center", fontsize = Helper.scaleFont(Helper.standardFont, config.mapFontSize) }):setText2("X", { halign = "right", fontsize = Helper.scaleFont(Helper.standardFont, config.mapFontSize) })
			usedrow[col].handlers.onClick = function () return menu.buttonRemoveSearchEntry(i) end
		end
	end

	searchindex = 0
	if #menu.searchtext < maxsearchtermsdisplayed then
		for i = 1, math.min(maxsearchtermsdisplayed - #menu.searchtext, #warefilter) do
			local usedrow = rows[2]
			local col = 6 + i + #menu.searchtext
			if col > 8 then
				usedrow = rows[3]
				col = col - 2
			end
			searchindex = searchindex + 1
			local untruncatedstring = GetWareData(warefilter[i], "name")
			local truncatedString = TruncateText(untruncatedstring, Helper.standardFont, Helper.scaleFont(Helper.standardFont, config.mapFontSize), usedrow[col]:getWidth() - 2 * Helper.scaleX(10))

			usedrow[col]:createButton({
				height = menu.editboxHeight,
				helpOverlayID = "FilterWare" .. searchindex,
				helpOverlayText = " ",
				helpOverlayHighlightOnly = true,
				scaling = false,
				mouseOverText = (truncatedString ~= untruncatedstring) and untruncatedstring or "",
			}):setText(truncatedString, { halign = "center", fontsize = Helper.scaleFont(Helper.standardFont, config.mapFontSize) }):setText2("X", { halign = "right", fontsize = Helper.scaleFont(Helper.standardFont, config.mapFontSize) }):setIcon("maptr_supply", { width = menu.editboxHeight, height = menu.editboxHeight })
			usedrow[col].handlers.onClick = function () return menu.removeFilterOption(setting, setting.id, i) end
			usedrow[col].properties.uiTriggerID = "removefilteroption"
		end
	end

	searchindex = 0
	if (#menu.searchtext + #warefilter) < maxsearchtermsdisplayed then
		for i = 1, math.min(maxsearchtermsdisplayed - #menu.searchtext - #warefilter, #sectorfilter) do
			local usedrow = rows[2]
			local col = 6 + i + #menu.searchtext + #warefilter
			if col > 8 then
				usedrow = rows[3]
				col = col - 2
			end
			searchindex = searchindex + 1
			local untruncatedstring = GetComponentData(ConvertStringToLuaID(sectorfilter[i]), "name")
			local truncatedString = TruncateText(untruncatedstring, Helper.standardFont, Helper.scaleFont(Helper.standardFont, config.mapFontSize), usedrow[col]:getWidth() - 2 * Helper.scaleX(10))

			usedrow[col]:createButton({
				height = menu.editboxHeight,
				helpOverlayID = "FilterSector" .. searchindex,
				helpOverlayText = " ",
				helpOverlayHighlightOnly = true,
				scaling = false,
				mouseOverText = (truncatedString ~= untruncatedstring) and untruncatedstring or "",
			}):setText(truncatedString, { halign = "center", fontsize = Helper.scaleFont(Helper.standardFont, config.mapFontSize) }):setText2("X", { halign = "right", fontsize = Helper.scaleFont(Helper.standardFont, config.mapFontSize) }):setIcon("maptr_hexagon", { width = menu.editboxHeight, height = menu.editboxHeight })
			usedrow[col].handlers.onClick = function () table.remove(sectorfilter, i); menu.setSectorFilter(); menu.refreshMainFrame = true end
			usedrow[col].properties.uiTriggerID = "removefilteroption"
		end
	end

	if (#menu.searchtext + #warefilter + #sectorfilter) > maxsearchtermsdisplayed then
		rows[3][numCols - 1]:setColSpan(2):createText(string.format("%+d", (#menu.searchtext + #warefilter + #sectorfilter) - maxsearchtermsdisplayed), { y = (menu.editboxHeight - Helper.standardTextHeight) / 2, scaling = false, fontsize = Helper.scaleFont(Helper.standardFont, config.mapFontSize) })
	end

	menu.infoTable2OffsetY = ftable.properties.y + ftable:getFullHeight() + Helper.borderSize

	if menu.searchTableMode then
		if menu.holomap ~= 0 then
			C.SetMapStationInfoBoxMargin(menu.holomap, "right", menu.infoTableOffsetX + menu.infoTableWidth + config.contextBorder)
		end
		if (#menu.searchtext + #warefilter) > 0 then
			local row = ftable:addRow(nil, { fixed = true })
			row[1]:createText("")
		end

		if menu.searchTableMode == "filter" then
			menu.createFilterMode(ftable, numCols)
		elseif menu.searchTableMode == "legend" then
			menu.createLegendMode(ftable, numCols)
		elseif menu.searchTableMode == "hire" then
			menu.createHireMode(ftable, numCols)
		end
	else
		if menu.holomap ~= 0 then
			C.SetMapStationInfoBoxMargin(menu.holomap, "right", 0)
		end
	end

	ftable:setTopRow(menu.topRows.filterTable)
	ftable:setSelectedRow(menu.selectedRows.filterTable)
	ftable:setSelectedCol(menu.selectedCols.filterTable or 0)

	menu.topRows.filterTable = nil
	menu.selectedRows.filterTable = nil
	menu.selectedCols.filterTable = nil

	if not refresh then
		menu.createInfoFrame2()
	end
end

function menu.allowResetView()
	if menu.holomap ~= 0 then
		local mapstate = ffi.new("HoloMapState")
		C.GetMapState(menu.holomap, mapstate)
		local radthreshold = math.rad(config.cameraResetThresholdAngle)
		-- offset rotation when camera is reset:
		--   yaw: 0
		--   pitch: -1.5533 = -179°
		--   roll: 0
		if (math.abs(mapstate.offset.yaw) > radthreshold) or (math.abs(mapstate.offset.roll) > radthreshold) or (mapstate.offset.pitch > -math.pi / 2 + radthreshold) then
			return true
		end

		return C.GetMapFocusComponent(menu.holomap) ~= C.GetPlayerObjectID()
	end
end

function menu.createInfoFrame2()
	menu.createInfoFrame2Running = true

	-- remove old data
	Helper.clearDataForRefresh(menu, config.infoFrameLayer2)

	-- infoTable
	local infoTableHeight = Helper.viewHeight - menu.infoTableOffsetY - menu.borderOffset

	menu.infoFrame2 = Helper.createFrameHandle(menu, {
		x = Helper.viewWidth - menu.infoTableOffsetX - menu.infoTableWidth,
		y = menu.infoTable2OffsetY,
		width = menu.infoTableWidth,
		height = infoTableHeight,
		layer = config.infoFrameLayer2,
		standardButtons = {},
		showBrackets = false,
		autoFrameHeight = true,
		helpOverlayID = "map_infoframe2",
	})
	menu.infoFrame2:setBackground("solid", { color = Color["frame_background_semitransparent"] })

	if (menu.searchTableMode ~= "info") and (menu.mode ~= "orderparam_object") then
		menu.infoTablePersistentData.right.cashtransferdetails = {}
		menu.infoTablePersistentData.right.drops = {}
		menu.infoTablePersistentData.right.crew.object = nil
		menu.infoTablePersistentData.right.macrostolaunch = {}
	end

	menu.infoTableData = menu.infoTableData or {}
	menu.infoTableData.right = {}
	if (not menu.showMultiverse) and (menu.searchTableMode == "info") then
		if menu.infoMode.right == "objectinfo" then
			menu.infoFrame2.properties.autoFrameHeight = false
			menu.createInfoSubmenu(menu.infoFrame2, "right")
		elseif menu.infoMode.right == "objectcrew" then
			menu.createCrewInfoSubmenu(menu.infoFrame2, "right")
		elseif menu.infoMode.right == "objectloadout" then
			menu.createLoadoutInfoSubmenu(menu.infoFrame2, "right")
		elseif menu.infoMode.right == "objectlogbook" then
			menu.createLogbookInfoSubmenu(menu.infoFrame2, "right")
		elseif menu.infoMode.right == "orderqueue" then
			menu.createOrderQueue(menu.infoFrame2, menu.infoMode.right, "right")
		elseif menu.infoMode.right == "orderqueue_advanced" then
			menu.createOrderQueue(menu.infoFrame2, menu.infoMode.right, "right")
		elseif menu.infoMode.right == "standingorders" then
			menu.createStandingOrdersMenu(menu.infoFrame2, "right")
		end
	else
		-- empty

		-- kuertee start: callback
		-- menu.infoFrame2.properties.background.icon = ""
		-- menu.infoFrame2.properties.showBrackets = false
		-- menu.infoFrame2.properties.autoFrameHeight = false
		-- menu.infoFrame2:addTable(0)

		local isCreated = false
		if callbacks ["createInfoFrame2_on_menu_infoModeRight"] then
			for _, callback in ipairs (callbacks ["createInfoFrame2_on_menu_infoModeRight"]) do
				if callback (menu.infoFrame2) then
					isCreated = true
				end
			end
		end
		if isCreated ~= true then
			menu.infoFrame2.properties.background.icon = ""
			menu.infoFrame2.properties.showBrackets = false
			menu.infoFrame2.properties.autoFrameHeight = false
			menu.infoFrame2:addTable(0)
		end
		-- kuertee end: callback

	end

	menu.infoFrame2.properties.helpOverlayText = helpOverlayText
	menu.infoFrame2:display()
end

function menu.buttonRemoveSearchEntry(index)
	Helper.cancelEditBoxInput(menu.searchField, 1, 7)

	table.remove(menu.searchtext, index)
	Helper.textArrayHelper(menu.searchtext, function (numtexts, texts) return C.SetMapFilterString(menu.holomap, numtexts, texts) end, "text")
	menu.refreshMainFrame = true

	menu.refreshInfoFrame()
end

function menu.createSideBar(firsttime, frame, width, height, offsetx, offsety)
	-- kuertee start: callback
	if callbacks ["createSideBar_on_start"] then
		for _, callback in ipairs (callbacks ["createSideBar_on_start"]) do
			callback (config)
		end
	end
	-- kuertee end: callback

	-- start Forleyor_infoCenter Callback:
	if callbacks ["ic_createSideBar"] then
		for _, callback in ipairs (callbacks ["ic_createSideBar"]) do
			callback (config)
		end
	end
	-- end Forleyor_infoCenter:

	local spacingHeight = menu.sideBarWidth / 4
	local defaultInteractiveObject = false
	if menu.showMultiverse then
		defaultInteractiveObject = menu.ventureMode == nil
	else
		defaultInteractiveObject = menu.infoTableMode == nil
	end
	local ftable = frame:addTable(1, { tabOrder = 3, width = width, height = height, x = offsetx, y = offsety, scaling = false, borderEnabled = false, reserveScrollBar = false, defaultInteractiveObject = defaultInteractiveObject })
	ftable:addConnection(1, 1, true)

	local foundselection
	local leftbar = menu.showMultiverse and config.leftBarMultiverse or config.leftBar
	local areventurescompatible = C.AreVenturesCompatible()
	for _, entry in ipairs(leftbar) do
		if (entry.condition == nil) or entry.condition() then
			if not entry.spacing then
				entry.active = true
				if menu.showMultiverse then
					if entry.mode ~= "ventureseason" then
						entry.active = areventurescompatible
					end
				else
					if menu.mode == "selectCV" then

						-- if (entry.mode ~= "objectlist") and (entry.mode ~= "propertyowned") then
						-- kuertee start:
						if (not string.find (entry.mode, "objectlist")) and (not string.find (entry.mode, "propertyowned")) then
							-- kuertee end:

							entry.active = false
						end
					elseif menu.mode == "hire" then

						-- if entry.mode ~= "propertyowned" then
						-- kuertee start:
						if not string.find (entry.mode, "propertyowned") then
							-- kuertee end:

							entry.active = false
						end
					elseif menu.mode == "orderparam_object" then

						-- if (entry.mode ~= "objectlist") and (entry.mode ~= "propertyowned") then
						-- kuertee start:
						if (not string.find (entry.mode, "objectlist")) and (not string.find (entry.mode, "propertyowned")) then
							-- kuertee end:

							entry.active = false
						end
					elseif menu.mode == "selectComponent" then

						-- if (entry.mode ~= "objectlist") and (entry.mode ~= "propertyowned") then
						-- kuertee start:
						if (not string.find (entry.mode, "objectlist")) and (not string.find (entry.mode, "propertyowned")) then
							-- kuertee end:

							entry.active = false
						end
					end
				end
				if entry.active then
					local selectedmode = false
					if type(entry.mode) == "table" then
						for _, mode in ipairs(entry.mode) do
							if menu.showMultiverse then
								if mode == menu.ventureMode then
									selectedmode = true
									break
								end
							else
								if mode == menu.infoTableMode then
									selectedmode = true
									break
								end
							end
						end
					else
						if menu.showMultiverse then
							if entry.mode == menu.ventureMode then
								selectedmode = true
							end
						else
							if entry.mode == menu.infoTableMode then
								selectedmode = true
							end
						end
					end
					if selectedmode then
						foundselection = true
					end
				end
			end
		end
	end

	for _, entry in ipairs(leftbar) do
		if (entry.condition == nil) or entry.condition() then
			if entry.spacing then
				local row = ftable:addRow(false, { fixed = true, bgColor = Color["row_background_blue"] })
				row[1]:createIcon("mapst_seperator_line", { width = menu.sideBarWidth, height = spacingHeight })
			else
				local mode = entry.mode
				if type(entry.mode) == "table" then
					mode = mode[1]
				end
				local row = ftable:addRow(true, { fixed = true, bgColor = Color["row_background_blue"] })
				local bgcolor = Color["row_title_background"]
				if type(entry.mode) == "table" then
					for _, mode in ipairs(entry.mode) do
						if menu.showMultiverse then
							if mode == menu.ventureMode then
								bgcolor = Color["row_background_selected"]
								break
							end
						else
							if mode == menu.infoTableMode then
								bgcolor = Color["row_background_selected"]
								break
							end
						end
					end
				else
					if menu.showMultiverse then
						if entry.mode == menu.ventureMode then
							bgcolor = Color["row_background_selected"]
						end
					else
						if entry.mode == menu.infoTableMode then
							bgcolor = Color["row_background_selected"]
						end
					end
				end
				local color = Color["icon_normal"]
				if menu.highlightLeftBar[mode] then
					color = Color["icon_mission"]
				end

				row[1]:createButton({ active = entry.active, height = menu.sideBarWidth, bgColor = bgcolor, mouseOverText = entry.name, helpOverlayID = entry.helpOverlayID, helpOverlayText = entry.helpOverlayText }):setIcon(entry.icon, { color = color })
				row[1].handlers.onClick = function () return menu.buttonToggleObjectList(mode) end
			end
		end
	end

	ftable:setSelectedRow(menu.selectedRows.sideBar)
	menu.selectedRows.sideBar = nil
end

function menu.createRightBar(frame, width, height, offsetx, offsety)
	-- kuertee start: callback
	if callbacks ["createRightBar_on_start"] then
		for _, callback in ipairs (callbacks ["createRightBar_on_start"]) do
			callback (config)
		end
	end
	-- kuertee end: callback

	local spacingHeight = menu.sideBarWidth / 4
	local ftable = frame:addTable(1, { tabOrder = 5, width = width, height = height, x = offsetx, y = offsety, scaling = false, borderEnabled = false, reserveScrollBar = false, skipTabChange = true })
	ftable:addConnection(1, 4, true)

	for _, entry in ipairs(config.rightBar) do
		if (entry.condition == nil) or entry.condition() then
			if entry.spacing then
				local row = ftable:addRow(false, { fixed = true, bgColor = Color["row_background_blue"] })
				row[1]:createIcon("mapst_seperator_line", { width = menu.sideBarWidth, height = spacingHeight })
			else
				local mode = entry.mode
				if type(entry.mode) == "table" then
					mode = mode[1]
				end
				local row = ftable:addRow(true, { fixed = true, bgColor = Color["row_background_blue"] })
				local active = true
				if menu.mode == "selectCV" then
					active = false
				elseif menu.mode == "hire" then
					active = false
				elseif menu.mode == "selectComponent" then
					active = false
				end
				local bgcolor = Color["row_title_background"]
				if type(entry.mode) == "table" then
					for _, mode in ipairs(entry.mode) do
						if mode == menu.searchTableMode then
							bgcolor = Color["row_background_selected"]
							break
						end
					end
				else
					if entry.mode == menu.searchTableMode then
						bgcolor = Color["row_background_selected"]
					end
				end
				row[1]:createButton({ active = active, height = menu.sideBarWidth, bgColor = bgcolor, mouseOverText = entry.name, helpOverlayID = entry.helpOverlayID, helpOverlayText = entry.helpOverlayText }):setIcon(entry.icon)
				row[1].handlers.onClick = function () return menu.buttonToggleRightBar(mode) end
			end
		end
	end

	ftable:setSelectedRow(menu.selectedRows.rightBar)
	menu.selectedRows.rightBar = nil
end

function menu.createSelectedShips(frame)
	if menu.getNumSelectedComponents() == 0 then
		-- nothing to do
		frame:addTable(1, { tabOrder = 0, width = 1, scaling = false, reserveScrollBar = false })
		return
	end

	-- sort ships
	local selectedobjects = {}
	for id, _ in pairs(menu.selectedcomponents) do
		local selectedcomponent = ConvertStringTo64Bit(id)
		if C.IsObjectKnown(selectedcomponent) then
			local class = ffi.string(C.GetComponentClass(selectedcomponent))
			local icon, primarypurpose, hullpercent, shieldpercent, isplayerowned, isenemy, ismodule, ishostile = GetComponentData(selectedcomponent, "icon", "primarypurpose", "hullpercent", "shieldpercent", "isplayerowned", "isenemy", "ismodule", "ishostile")
			if not ismodule then
				local color = "neutral"
				if isplayerowned then
					color = "player"
				elseif ishostile then
					color = "hostile"
				elseif isenemy then
					color = "enemy"
				end
				local i = menu.findEntryByShipIcon(selectedobjects, icon, color)
				if i then
					selectedobjects[i].count			= selectedobjects[i].count			+ 1
					selectedobjects[i].hullpercent		= selectedobjects[i].hullpercent	+ hullpercent
					selectedobjects[i].shieldpercent	= selectedobjects[i].shieldpercent	+ shieldpercent
				else
					table.insert(selectedobjects, { icon = icon, color = color, class = class, purpose = primarypurpose, count = 1, hullpercent = hullpercent, shieldpercent = shieldpercent })
				end
			end
		end
	end
	table.sort(selectedobjects, menu.sortShipsByClassAndPurpose)

	if #selectedobjects == 0 then
		-- nothing to do
		frame:addTable(1, { tabOrder = 0, width = 1, scaling = false, reserveScrollBar = false })
		return
	end

	local ftable
	if (#selectedobjects > 1) or (selectedobjects[1].count > 1) then
		-- display
		local numcolumns = 2 * menu.selectedShipsTableData.maxCols
		local columnwidth = math.ceil(menu.selectedShipsTableData.width / 2)
		local width = numcolumns * (columnwidth + Helper.borderSize) - Helper.borderSize
		ftable = frame:addTable(numcolumns, { tabOrder = 21, width = width, x = Helper.viewWidth / 2 - width / 2, y = 0, scaling = false, reserveScrollBar = false, skipTabChange = true, backgroundID = "solid", backgroundColor = Color["frame_background_semitransparent"] })
		for i = 1, numcolumns do
			ftable:setColWidth(i, columnwidth)
		end
		ftable:setDefaultBackgroundColSpan(1, numcolumns)
		ftable:setDefaultComplexCellProperties("icon", "text", { font = Helper.standardFontOutlined, fontsize = menu.selectedShipsTableData.fontsize })
		ftable:setDefaultComplexCellProperties("button", "text", { fontsize = menu.selectedShipsTableData.fontsize })
		ftable:setDefaultComplexCellProperties("button", "text2", { fontsize = menu.selectedShipsTableData.fontsize })

		-- title
		local titlewidth = math.ceil(C.GetTextWidth(" " .. ReadText(1001, 3251) .. " ", Helper.standardFontBold, Helper.scaleFont(Helper.standardFont, Helper.headerRow1FontSize, true)))
		local numtitlecols = math.ceil(titlewidth / (columnwidth + Helper.borderSize))
		if numtitlecols % 2 == 1 then
			numtitlecols = numtitlecols + 1
		end
		if numtitlecols > numcolumns - 2 then
			local row = ftable:addRow(false, { fixed = true, borderBelow = false, bgColor = Color["row_background_blue_opaque"], scaling = true })
			row[1]:setColSpan(numcolumns):createText(ReadText(1001, 3251), { font = Helper.headerRow1Font, fontsize = Helper.headerRow1FontSize, halign = "center" })
		else
			local numbordercols = (numcolumns - numtitlecols) / 2
			local bordericonsize = Helper.scaleX(Helper.headerRow1Height)

			local row = ftable:addRow(false, { fixed = true, borderBelow = false, scaling = true })
			row[1]:setBackgroundColSpan(numcolumns):setColSpan(numbordercols):createIcon("be_diagonal_01", { width = bordericonsize, height = bordericonsize, x = numbordercols * (columnwidth + Helper.borderSize) - bordericonsize, scaling = false, color = Color["row_background_blue_opaque"] })
			local width = numtitlecols * (columnwidth + Helper.borderSize)
			row[numbordercols + 1]:setColSpan(numtitlecols):createIcon("solid", { height = bordericonsize, width = width, scaling = false, color = Color["row_background_blue_opaque"] }):setText(ReadText(1001, 3251), { font = Helper.headerRow1Font, fontsize = Helper.scaleFont(Helper.headerRow1Font, Helper.headerRow1FontSize, true), halign = "center", x = width / 2 })
			row[numbordercols + numtitlecols + 1]:setColSpan(numbordercols):createIcon("be_diagonal_02", { width = bordericonsize, height = bordericonsize, scaling = false, color = Color["row_background_blue_opaque"] })
		end

		-- example text used
		local textheight = math.ceil(C.GetTextHeight(ReadText(1001, 42) .. "1", Helper.standardFontOutlined, menu.selectedShipsTableData.fontsize, 0))
		-- ship rows
		for i = 1, math.floor(#selectedobjects / menu.selectedShipsTableData.maxCols) + 1 do
			local numshipcolums = math.min(#selectedobjects - (i -1) * menu.selectedShipsTableData.maxCols, menu.selectedShipsTableData.maxCols)
			local row = ftable:addRow(false, { fixed = true, borderBelow = false })
			for j = 1, numshipcolums do
				local shipindex = (i - 1) * menu.selectedShipsTableData.maxCols + j
				local shipentry = selectedobjects[shipindex]
				local colindex = (j + 0.5 * (menu.selectedShipsTableData.maxCols - numshipcolums)) * 2 - 1
				local color = menu.holomapcolor.friendcolor
				if shipentry.color == "player" then
					color = menu.holomapcolor.playercolor
				elseif shipentry.color == "hostile" then
					color = menu.holomapcolor.hostilecolor
				elseif shipentry.color == "enemy" then
					color = menu.holomapcolor.enemycolor
				end
				row[colindex]:setColSpan(2):createIcon(C.IsIconValid(shipentry.icon) and shipentry.icon or "solid", { height = menu.selectedShipsTableData.height, width = menu.selectedShipsTableData.height + Helper.borderSize, color = color }):setText(ReadText(1001, 42) .. shipentry.count, { halign = "right", x = Helper.standardTextOffsetx, y = (menu.selectedShipsTableData.height - textheight) / 2 })
			end
			local row = ftable:addRow(false, { fixed = true, borderBelow = false })
			for j = 1, numshipcolums do
				local shipindex = (i - 1) * menu.selectedShipsTableData.maxCols + j
				local shipentry = selectedobjects[shipindex]
				local colindex = (j + 0.5 * (menu.selectedShipsTableData.maxCols - numshipcolums)) * 2 - 1
				row[colindex]:setColSpan(2):createShieldHullBar(shipentry.shieldpercent / shipentry.count, shipentry.hullpercent / shipentry.count, { height = 10, y = 5 })
			end
		end
	else
		local component = next(menu.selectedcomponents)
		local selectedcomponent = ConvertStringTo64Bit(component)
		local isplayerowned, isonlineobject, isenemy, ishostile = GetComponentData(selectedcomponent, "isplayerowned", "isonlineobject", "isenemy", "ishostile")
		local objecttitle = ffi.string(C.GetComponentName(selectedcomponent))
		if C.IsComponentClass(selectedcomponent, "container") then
			objecttitle = objecttitle .. " (" .. ffi.string(C.GetObjectIDCode(selectedcomponent)) .. ")"
		end
		local objecttitlewidth = math.ceil(C.GetTextWidth(objecttitle, Helper.standardFontBold, Helper.scaleFont(Helper.standardFont, Helper.headerRow1FontSize, true))) + 2 * Helper.standardTextOffsetx
		local objecticon = GetComponentData(selectedcomponent, "icon")
		if C.IsComponentClass(selectedcomponent, "highway") then
			local entrygate = GetComponentData(selectedcomponent, "entrygate")
			objecticon = GetComponentData(entrygate, "icon")
		end
		local bordericonsize = Helper.scaleX(Helper.headerRow1Height)
		local colwidth = math.ceil(objecttitlewidth / 2)
		local bordercolwidth

		local numcolumns = 7
		local width = math.max(menu.selectedShipsTableData.singleObjectWidth, 2 * colwidth + 2 * menu.selectedShipsTableData.width + 2 * bordericonsize + (numcolumns - 1) * Helper.borderSize)
		if width > Helper.viewWidth - 2 * (menu.infoTableOffsetX + menu.infoTableWidth + 2 * Helper.borderSize) then
			if width > menu.selectedShipsTableData.singleObjectWidth then
				bordercolwidth = bordericonsize
				colwidth = nil
			end
			width = Helper.viewWidth - 2 * (menu.infoTableOffsetX + menu.infoTableWidth + 2 * Helper.borderSize)
		end
		ftable = frame:addTable(numcolumns, { tabOrder = 21, width = width, x = Helper.viewWidth / 2 - width / 2, y = 0, scaling = false, reserveScrollBar = false, skipTabChange = true, backgroundID = "solid", backgroundColor = Color["frame_background_semitransparent"] })
		ftable:setColWidth(2, menu.selectedShipsTableData.width)
		ftable:setColWidth(4, 1)
		ftable:setColWidth(6, menu.selectedShipsTableData.width)
		if colwidth then
			ftable:setColWidth(3, colwidth)
			ftable:setColWidth(5, colwidth)
		end
		if bordercolwidth then
			ftable:setColWidth(1, bordercolwidth)
			ftable:setColWidth(7, bordercolwidth)
		else
			ftable:setColWidthMin(1, bordericonsize)
			ftable:setColWidthMin(7, bordericonsize)
		end
		ftable:setDefaultBackgroundColSpan(1, numcolumns)
		ftable:setDefaultCellProperties("text", { fontsize = menu.selectedShipsTableData.fontsize; minRowHeight = menu.selectedShipsTableData.textHeight })
		ftable:setDefaultComplexCellProperties("icon", "text", { fontsize = menu.selectedShipsTableData.fontsize })
		ftable:setDefaultComplexCellProperties("icon", "text2", { fontsize = menu.selectedShipsTableData.fontsize })
		ftable:setDefaultComplexCellProperties("button", "text", { fontsize = menu.selectedShipsTableData.fontsize })
		ftable:setDefaultComplexCellProperties("button", "text2", { fontsize = menu.selectedShipsTableData.fontsize })

		-- title
		local row = ftable:addRow(false, { fixed = true, borderBelow = false, scaling = true })
		row[1]:setBackgroundColSpan(numcolumns):createIcon("be_diagonal_01", { width = bordericonsize, height = bordericonsize, x = row[1]:getWidth() + Helper.borderSize - bordericonsize, scaling = false, color = Color["row_background_blue_opaque"] })
		row[2]:setColSpan(5)
		local middlewidth = row[2]:getColSpanWidth() + Helper.borderSize
		row[2]:createIcon("solid", { height = bordericonsize, width = middlewidth, scaling = false, color = Color["row_background_blue_opaque"] }):setText(ReadText(1001, 11636), { font = Helper.headerRow1Font, fontsize = Helper.scaleFont(Helper.headerRow1Font, Helper.headerRow1FontSize, true), halign = "center", x = middlewidth / 2 })
		row[7]:createIcon("be_diagonal_02", { width = bordericonsize, height = bordericonsize, scaling = false, color = Color["row_background_blue_opaque"] })

		local row = ftable:addRow(nil, { fixed = true, borderBelow = false, scaling = true })
		local color = isplayerowned and menu.holomapcolor.playercolor or menu.holomapcolor.friendcolor
		if isplayerowned then
			color = menu.holomapcolor.playercolor
			if selectedcomponent == C.GetPlayerObjectID() then
				color = menu.holomapcolor.currentplayershipcolor
			end
		elseif isonlineobject and menu.getFilterOption("layer_other", false) and menu.getFilterOption("think_diplomacy_highlightvisitor", false) then
			color = menu.holomapcolor.visitorcolor
		elseif ishostile then
			color = menu.holomapcolor.hostilecolor
		elseif isenemy then
			color = menu.holomapcolor.enemycolor
		end
		row[2]:createText("\27[" .. objecticon .. "]", { color = color, halign = "right", font = Helper.headerRow1Font, fontsize = Helper.headerRow1FontSize, x = 0 })
		row[3]:setColSpan(3):createText(objecttitle, { color = color, halign = "center", font = Helper.headerRow1Font, fontsize = Helper.headerRow1FontSize, minRowHeight = Helper.headerRow1Height })
		row[6]:createObjectShieldHullBar(selectedcomponent)

		if isplayerowned then
			if C.IsComponentClass(selectedcomponent, "ship") then
				local row = ftable:addRow(nil, { fixed = true, borderBelow = false })
				row[1]:setColSpan(3):createText(ReadText(1001, 16), { halign = "center" })
				row[4]:createText("", { x = 0 })
				row[5]:setColSpan(3):createText(ReadText(1001, 8355), { halign = "center" })
				-- line
				local row = ftable:addRow(false, { fixed = true, bgColor = Color["row_separator_white"] })
				row[1]:setColSpan(3):createText("", { height = 2 })
				row[4]:createText("", { height = 2, cellBGColor = Color["row_background"], x = 0 })
				row[5]:setColSpan(3):createText("", { height = 2 })

				local sideorder = { "left", "right" }
				local rows = {
					left = {},
					right = {},
				}
				-- order
				local _, _, _, name, _, _, _, targetname = menu.getOrderInfo(selectedcomponent, true)
				table.insert(rows.left, { entrytype = "text", text = name .. ((targetname ~= "") and (ReadText(1001, 120) .. " " .. targetname) or ""), properties = { halign = "center", color = menu.holomapcolor.playercolor } })
				-- failed orders
				local hasloop = ffi.new("bool[1]", 0)
				C.GetOrderQueueFirstLoopIdx(selectedcomponent, hasloop)
				hasloop = hasloop[0]
				local n = C.GetNumOrderFailures(selectedcomponent, hasloop == true)
				if n > 0 then
					table.insert(rows.left, { entrytype = "text", text = ReadText(1001, 11621) .. ReadText(1001, 120), properties = { halign = "center", color = Color["text_warning"] } })

					local buf = ffi.new("OrderFailure[?]", n)
					n = C.GetOrderFailures(buf, n, selectedcomponent, hasloop == true)
					local failure = buf[0]

					local orderdefid = ffi.string(failure.orderdef)
					local orderfailuredef
					local found = false
					for _, orderdef in ipairs(menu.orderdefs) do
						if orderdef.id == orderdefid then
							orderfailuredef = orderdef
							found = true
							break
						end
					end
					if not found then
						DebugError("Order failure of '" .. tostring(selectedcomponent) .. "' is of unknown definition '" .. orderdefid .. "' [Florian]")
					end

					table.insert(rows.left, { entrytype = "text", text = orderfailuredef and orderfailuredef.name or "", properties = { halign = "center", color = Color["text_warning"] } })
					table.insert(rows.left, { entrytype = "text", text = ffi.string(failure.message), properties = { halign = "center", color = Color["text_warning"] } })
					if n > 2 then
						table.insert(rows.left, { entrytype = "text", text = string.format(ReadText(1001, 11631), n - 1), properties = { halign = "center", color = Color["text_warning"] } })
					elseif n > 1 then
						table.insert(rows.left, { entrytype = "text", text = ReadText(1001, 11630), properties = { halign = "center", color = Color["text_warning"] } })
					end
				else
					local failure = ffi.new("OrderFailure")
					if C.GetDefaultOrderFailure(failure, selectedcomponent) then
						table.insert(rows.left, { entrytype = "text", text = ReadText(1001, 11621) .. ReadText(1001, 120), properties = { halign = "center", color = Color["text_warning"] } })

						local orderdefid = ffi.string(failure.orderdef)
						local orderfailuredef
						local found = false
						for _, orderdef in ipairs(menu.orderdefs) do
							if orderdef.id == orderdefid then
								orderfailuredef = orderdef
								found = true
								break
							end
						end
						if not found then
							DebugError("Default order failure of '" .. tostring(selectedcomponent) .. "' is of unknown definition '" .. orderdefid .. "' [Florian]")
						end

						table.insert(rows.left, { entrytype = "text", text = orderfailuredef and orderfailuredef.name or "", properties = { halign = "center", color = Color["text_warning"] } })
						table.insert(rows.left, { entrytype = "text", text = ffi.string(failure.message), properties = { halign = "center", color = Color["text_warning"] } })
					end
				end

				-- capacity
				local numtransporttypes = C.GetNumCargoTransportTypes(selectedcomponent, true)
				local currenttransporttypes = ffi.new("StorageInfo[?]", numtransporttypes)
				numtransporttypes = C.GetCargoTransportTypes(currenttransporttypes, numtransporttypes, selectedcomponent, true, false)
				local futuretransporttypes = ffi.new("StorageInfo[?]", numtransporttypes)
				numtransporttypes = C.GetCargoTransportTypes(futuretransporttypes, numtransporttypes, selectedcomponent, true, true)
				for i = 0, numtransporttypes - 1 do
					table.insert(rows.right, { entrytype = "capacity", text = ReadText(1001, 1402) .. " (" .. ffi.string(futuretransporttypes[i].name) .. ")" .. ReadText(1001, 120), currentused = currenttransporttypes[i].spaceused, futureused = futuretransporttypes[i].spaceused, capacity = futuretransporttypes[i].capacity })
				end
				-- cargo
				local cargo = GetComponentData(selectedcomponent, "cargo")
				local futurecargo = GetCargoAfterTradeOrders(selectedcomponent, true)
				local wares = {}
				for ware, amount in pairs(cargo) do
					table.insert(wares, { ware = ware, name = GetWareData(ware, "name"), current = amount, future = futurecargo[ware] or 0 })
				end
				for ware, amount in pairs(futurecargo) do
					if not cargo[ware] then
						table.insert(wares, { ware = ware, name = GetWareData(ware, "name"), current = 0, future = amount })
					end
				end
				table.sort(wares, function (a, b) return a.future > b.future end)
				local setting, list = menu.getTradeWareFilter(true)
				for i, entry in ipairs(wares) do
					local color, script = menu.getWareButtonColorAndScript(list, setting, entry.ware)
					table.insert(rows.right, { entrytype = "ware", text = entry.name, current = entry.current, future = entry.future, max = GetWareCapacity(selectedcomponent, entry.ware), color = color, script = script })
				end
				-- display rows
				for i = 1, 5 do
					local row
					for _, side in ipairs(sideorder) do
						if rows[side][i] then
							local entry = rows[side][i]
							if not row then
								row = ftable:addRow(true, { fixed = true })
							end
							if entry.entrytype == "text" then
								row[(side == "left") and 1 or 5]:setColSpan(3):createText(entry.text, entry.properties)
								if (side == "right") or (not rows["right"][i]) then
									row[4]:createText("", { height = 2, cellBGColor = Color["row_background"], x = 0 })
								end
							elseif entry.entrytype == "capacity" then
								if side == "right" then
									row[5]:setColSpan(3)

									local mouseovertext
									local amounttext = menu.formatWareAmount(entry.currentused, entry.futureused, entry.capacity)
									local text = TruncateText(entry.text, Helper.standardFont, menu.selectedShipsTableData.fontsize, row[5]:getWidth() - menu.getAmountTextWidth(amounttext))
									if text ~= entry.text then
										mouseovertext = entry.text .. " " .. amounttext
									end

									local xoffset = 1 + Helper.borderSize
									local width = row[5]:getColSpanWidth()
									row[4]:createStatusBar({ current = entry.futureused, start = entry.currentused, max = entry.capacity, cellBGColor = Color["row_background"], valueColor = Color["slider_value"], posChangeColor = Color["flowchart_slider_diff2"], negChangeColor = Color["flowchart_slider_diff1"], markerColor = Color["statusbar_marker_hidden"], width = width, x = xoffset, scaling = false })
									row[5]:createIcon("solid", { color = Color["icon_transparent"], height = menu.selectedShipsTableData.textHeight, mouseOverText = mouseovertext })
									row[5]:setText(text)
									row[5]:setText2(amounttext, { halign = "right", x = Helper.standardTextOffsetx })
								end
							elseif entry.entrytype == "ware" then
								if side == "right" then
									row[5]:setColSpan(3)
									local xoffset = 1 + Helper.borderSize
									local width = row[5]:getColSpanWidth()
									row[4]:createStatusBar({ current = entry.future, start = entry.current, max = entry.max, cellBGColor = Color["row_background"], valueColor = Color["slider_value"], posChangeColor = Color["flowchart_slider_diff2"], negChangeColor = Color["flowchart_slider_diff1"], markerColor = Color["statusbar_marker_hidden"], width = width, x = xoffset, scaling = false })
									row[5]:createButton({ bgColor = Color["button_background_hidden"], height = menu.selectedShipsTableData.textHeight })
									row[5]:setText(entry.text, { color = entry.color })
									row[5]:setText2(menu.formatWareAmount(entry.current, entry.future), { halign = "right", color = entry.color })
									row[5].handlers.onClick = entry.script
								end
							end
						end
					end
				end
				if #rows.right > 5 then
					local row = ftable:addRow(nil, { fixed = true })
					row[4]:createText("", { height = 2, cellBGColor = Color["row_background"], x = 0 })
					row[5]:setColSpan(3):createText(string.format("%+d %s", #rows.right - 5, ((#rows.right - 5) > 1) and ReadText(1001, 46) or ReadText(1001, 45)))
				end
			elseif C.IsComponentClass(selectedcomponent, "station") then
				local row = ftable:addRow(nil, { fixed = true, borderBelow = false })
				row[1]:setColSpan(3):createText(ReadText(1001, 3305), { halign = "center" })
				row[4]:createText("", { x = 0 })
				row[5]:setColSpan(3):createText(ReadText(1001, 63), { halign = "center" })
				-- line
				local row = ftable:addRow(false, { fixed = true, bgColor = Color["row_separator_white"] })
				row[1]:setColSpan(3):createText("", { height = 2 })
				row[4]:createText("", { height = 2, cellBGColor = Color["row_background"], x = 0 })
				row[5]:setColSpan(3):createText("", { height = 2 })

				local sideorder = { "left", "right" }
				local rows = {
					left = {},
					right = {},
				}
				-- upkeep missions
				local upkeepMissions = {}
				if menu.upkeepMissionData[tostring(selectedcomponent)] then
					for _, entry in ipairs(menu.upkeepMissionData[tostring(selectedcomponent)]) do
						table.insert(upkeepMissions, { alertLevel = entry.alertLevel, name = entry.name })
					end
				end
				table.sort(upkeepMissions, function (a, b) return a.alertLevel > b.alertLevel end)

				for i, entry in ipairs(upkeepMissions) do
					local color = Color["text_normal"]
					if entry.alertLevel == 1 then
						color = menu.holomapcolor.lowalertcolor
					elseif entry.alertLevel == 2 then
						color = menu.holomapcolor.mediumalertcolor
					else
						color = menu.holomapcolor.highalertcolor
					end
					table.insert(rows.left, { entrytype = "text", text = entry.name, properties = { halign = "center", color = color } })
				end

				-- ware reservations
				local reservationscapacity = menu.getReservationsVolumeByTransportType(selectedcomponent)
				local reservationscargo = menu.getReservationsAmountByWareType(selectedcomponent)

				-- capacity
				local numtransporttypes = C.GetNumCargoTransportTypes(selectedcomponent, true)
				local currenttransporttypes = ffi.new("StorageInfo[?]", numtransporttypes)
				numtransporttypes = C.GetCargoTransportTypes(currenttransporttypes, numtransporttypes, selectedcomponent, true, false)

				for i = 0, numtransporttypes - 1 do
					local storagename = ffi.string(currenttransporttypes[i].name)
					local futureamount = currenttransporttypes[i].spaceused
					if reservationscapacity[string.lower(storagename)] then
						futureamount = futureamount + reservationscapacity[string.lower(storagename)]
					end

					table.insert(rows.right, { entrytype = "capacity", text = ReadText(1001, 1402) .. " (" .. storagename .. ")" .. ReadText(1001, 120), currentused = currenttransporttypes[i].spaceused, futureused = futureamount, capacity = currenttransporttypes[i].capacity })
				end
				-- cargo
				local cargo = GetComponentData(selectedcomponent, "cargo")
				local wares = {}
				for ware, amount in pairs(cargo) do
					local futureamount = amount
					if reservationscargo[ware] then
						futureamount = futureamount + reservationscargo[ware]
					end

					table.insert(wares, { ware = ware, name = GetWareData(ware, "name"), current = amount, future = futureamount })
				end
				table.sort(wares, function (a, b) return a.future > b.future end)
				local setting, list = menu.getTradeWareFilter(true)
				for i, entry in ipairs(wares) do
					local color, script = menu.getWareButtonColorAndScript(list, setting, entry.ware)
					local productionlimit = GetWareProductionLimit(selectedcomponent, entry.ware)
					table.insert(rows.right, { entrytype = "ware", text = entry.name, current = entry.current, future = entry.future, max = math.max(entry.current, productionlimit), color = color, script = script })
				end
				-- display rows
				for i = 1, 5 do
					local row
					for _, side in ipairs(sideorder) do
						if rows[side][i] then
							local entry = rows[side][i]
							if not row then
								row = ftable:addRow(true, { fixed = true })
							end
							if entry.entrytype == "text" then
								row[(side == "left") and 1 or 5]:setColSpan(3):createText(entry.text, entry.properties)
								if (side == "right") or (not rows["right"][i]) then
									row[4]:createText("", { height = 2, cellBGColor = Color["row_background"], x = 0 })
								end
							elseif entry.entrytype == "capacity" then
								if side == "right" then
									row[5]:setColSpan(3)

									local mouseovertext
									local amounttext = menu.formatWareAmount(entry.currentused, entry.futureused, entry.capacity)
									local widthdelta = row[5]:getWidth() - menu.getAmountTextWidth(amounttext)
									local text = ""
									if widthdelta > 0 then
										text = TruncateText(entry.text, Helper.standardFont, menu.selectedShipsTableData.fontsize, widthdelta)
									end
									if text ~= entry.text then
										mouseovertext = entry.text .. " " .. amounttext
									end

									local xoffset = 1 + Helper.borderSize
									local width = row[5]:getColSpanWidth()
									row[4]:createStatusBar({ current = entry.futureused, start = entry.currentused, max = entry.capacity, cellBGColor = Color["row_background"], valueColor = Color["slider_value"], posChangeColor = Color["flowchart_slider_diff2"], negChangeColor = Color["flowchart_slider_diff1"], markerColor = Color["statusbar_marker_hidden"], width = width, x = xoffset, scaling = false })
									row[5]:createIcon("solid", { color = Color["icon_transparent"], height = menu.selectedShipsTableData.textHeight, mouseOverText = mouseovertext })
									row[5]:setText(text)
									row[5]:setText2(amounttext, { halign = "right", x = Helper.standardTextOffsetx })
								end
							elseif entry.entrytype == "ware" then
								if side == "right" then
									row[5]:setColSpan(3)
									local barxoffset = 1 + Helper.borderSize
									local width = row[5]:getColSpanWidth()
									row[4]:createStatusBar({ current = entry.future, start = entry.current, max = entry.max, cellBGColor = Color["row_background"], valueColor = Color["slider_value"], posChangeColor = Color["flowchart_slider_diff2"], negChangeColor = Color["flowchart_slider_diff1"], markerColor = Color["statusbar_marker_hidden"], width = width, x = barxoffset, scaling = false })
									row[5]:createButton({ bgColor = Color["button_background_hidden"], height = menu.selectedShipsTableData.textHeight })
									row[5]:setText(entry.text, { color = entry.color, x = Helper.standardIndentStep })
									row[5]:setText2(menu.formatWareAmount(entry.current, entry.future), { halign = "right", color = entry.color })
									row[5].handlers.onClick = entry.script
								end
							end
						end
					end
				end
				if (#rows.left > 5) or (#rows.right > 5) then
					local row = ftable:addRow(nil, { fixed = true })
					row[4]:createText("", { height = 2, cellBGColor = Color["row_background"], x = 0 })
					if #rows.left > 5 then
						row[1]:setColSpan(3):createText(string.format("%+d %s", #rows.left - 5, ((#rows.left - 5) > 1) and ReadText(1001, 5702) or ReadText(1001, 5702)))
					end
					if #rows.right > 5 then
						row[5]:setColSpan(3):createText(string.format("%+d %s", #rows.right - 5, ((#rows.right - 5) > 1) and ReadText(1001, 46) or ReadText(1001, 45)))
					end
				end
			end
		end
	end

	ftable.properties.y = Helper.viewHeight - ftable:getFullHeight() - menu.borderOffset
end

function menu.sortShipsByClassAndPurpose(a, b)
	local aclass = config.classOrder[a.class] or 0
	local bclass = config.classOrder[b.class] or 0
	if aclass == bclass then
		local apurpose = (a.purpose ~= "") and config.purposeOrder[a.purpose] or 0
		local bpurpose = (b.purpose ~= "") and config.purposeOrder[b.purpose] or 0
		return apurpose < bpurpose
	else
		return aclass < bclass
	end
end

function menu.sortShipsByClassAndPurposeReverse(a, b)
	local apurpose = (a.purpose ~= "") and config.purposeOrder[a.purpose] or 0
	local bpurpose = (b.purpose ~= "") and config.purposeOrder[b.purpose] or 0
	if apurpose == bpurpose then
		local aclass = config.classOrder[a.class] or 0
		local bclass = config.classOrder[b.class] or 0
		return aclass < bclass
	else
		return apurpose > bpurpose
	end
end

function menu.findEntryByShipIcon(array, icon, color)
	for i, entry in ipairs(array) do
		if (entry.icon == icon) and (entry.color == color) then
			return i
		end
	end
end

function menu.createTopLevel(frame)
	if (menu.mode == "hire") or (menu.mode == "selectCV") or (menu.mode == "orderparam_object") or (menu.mode == "selectComponent") then
		local width = 400
		local ftable = frame:addTable(1, {
			tabOrder = 20,
			width = width,
			x = Helper.viewWidth / 2 - width / 2,
			y = Helper.topLevelConfig.y,
			scaling = false,
			reserveScrollBar = false,
			skipTabChange = true,
			backgroundID = "solid",
			backgroundColor = Color["frame_background_semitransparent"],
		})
		local row = ftable:addRow(false, { fixed = true, bgColor = Color["row_background_blue"] })

		local title = ""
		if menu.mode == "hire" then
			title = (menu.modeparam[3] ~= 0) and ReadText(1001, 3500) or ReadText(1001, 3264)
		elseif menu.mode == "selectCV" then
			title = ReadText(1001, 7942)
		elseif menu.mode == "orderparam_object" then
			local sectorallowed, onlysectorallowed = false, false
			if menu.modeparam[2].inputparams.class then
				if type(menu.modeparam[2].inputparams.class) == "table" then
					for _, class in ipairs(menu.modeparam[2].inputparams.class) do
						if class == "sector" then
							sectorallowed = true
							onlysectorallowed = #menu.modeparam[2].inputparams.class == 1
							break
						end
					end
				else
					DebugError("Order parameter '" .. menu.modeparam[2].name .. "' - input parameter class is not a list. [Florian]")
				end
			end

			if onlysectorallowed then
				title = ReadText(1001, 11238)
			elseif sectorallowed then
				title = ReadText(1001, 11239)
			else
				title = ReadText(1001, 8325)
			end
		elseif menu.mode == "selectComponent" then
			title = menu.modeparam[5] or ReadText(1001, 8325)
		end

		row[1]:createText(title, Helper.titleTextProperties)
		row[1].properties.scaling = true

		local infotext
		if menu.mode == "hire" then
			infotext = function() return menu.selectModeInfoText(ReadText(1001, 11613)) end
		elseif menu.mode == "orderparam_object" then
			local sectorallowed = false
			if menu.modeparam[2].inputparams.class then
				if type(menu.modeparam[2].inputparams.class) == "table" then
					for _, class in ipairs(menu.modeparam[2].inputparams.class) do
						if class == "sector" then
							sectorallowed = true
							break
						end
					end
				else
					DebugError("Order parameter '" .. menu.modeparam[2].name .. "' - input parameter class is not a list. [Florian]")
				end
			end
			infotext = function() return menu.selectModeInfoText(sectorallowed and ReadText(1001, 11635) or ReadText(1001, 11634)) end
		end

		if infotext then
			local row = ftable:addRow(false, { fixed = true })
			row[1]:createText(infotext, { wordwrap = true, scaling = true })
		end
	else
		menu.topLevelHeight = Helper.createTopLevelTab(menu, menu.showMultiverse and "multiversemap" or "map", frame, (menu.mode == "tradecontext") and ReadText(1001, 7104) or "", menu.conversationMenu, true)
	end
end

function menu.selectModeInfoText(text)
	local mode = GetControllerInfo()
	if (mode == "gamepad") or (mode == "joystick") then
		return string.format(text, Helper.getInputMouseOverText("INPUT_STATE_CONTROLLERMOUSEBUTTON_RIGHT"))
	else
		return string.format(text, ReadText(1019, 3))
	end
end

function menu.onTabScroll(direction)
	menu.closeContextMenu()
	if direction == "right" then
		Helper.scrollTopLevel(menu, menu.showMultiverse and "multiversemap" or "map", 1)
	elseif direction == "left" then
		Helper.scrollTopLevel(menu, menu.showMultiverse and "multiversemap" or "map", -1)
	end
end

function menu.onInputModeChanged(_, mode)
	if not menu.noupdate then
		menu.refreshMainFrame = true
	else
		menu.inputModeHasChanged = true
	end
end

function menu.createNewOrderContext(frame, instance)
	local ftable = frame:addTable(1, { tabOrder = 3, x = Helper.borderSize, y = Helper.borderSize, width = menu.contextMenuData.width, highlightMode = "off" })

	local aipilot = GetComponentData(menu.infoSubmenuObject, "assignedaipilot")
	local adjustedskill = aipilot and math.floor(C.GetEntityCombinedSkill(ConvertIDTo64Bit(aipilot), nil, "aipilot")) or -1

	-- title
	local row = ftable:addRow(false, { fixed = true, bgColor = Color["row_background_blue"] })
	row[1]:createText(menu.contextMenuData.default and ReadText(1001, 8321) or ReadText(1001, 3238), Helper.headerRowCenteredProperties)

	for category, orderdefs in Helper.orderedPairs(menu.orderdefsbycategory) do
		if category ~= "internal" then
			if (not menu.contextMenuData.default) or (category ~= "coordination") then
				local header = false
				for _, orderdef in ipairs(orderdefs) do
					if (menu.contextMenuData.default and orderdef.infinite) or ((not menu.contextMenuData.default) and ((not menu.infoTableData[instance].hasloop) or orderdef.loopable)) then
						if not header then
							local row = ftable:addRow(false, {  })
							row[1]:createText(orderdef.categoryname, Helper.headerRowCenteredProperties)
							header = true
						end

						local row = ftable:addRow(true, {  })
						local button = row[1]:createButton({ active = C.IsOrderSelectableFor(orderdef.id, menu.infoSubmenuObject), helpOverlayID = "map_order_" .. orderdef.id, helpOverlayText = " ", helpOverlayHighlightOnly = true, bgColor = Color["button_background_hidden"], mouseOverText = orderdef.description }):setText(orderdef.name)
						if menu.contextMenuData.default then
							local printedSkillReq = math.floor(orderdef.requiredSkill * 15 / 100)
							button.properties.active = button.properties.active and (orderdef.requiredSkill <= adjustedskill)
							button:setText2(Helper.displaySkill(printedSkillReq), { halign = "right", color = Color["text_skills"] })
						end
						row[1].handlers.onClick = function () return menu.buttonNewOrder(orderdef.id, menu.contextMenuData.default, instance) end
						row[1].properties.uiTriggerID = orderdef.id
					end
				end
			end
		end
	end

	if menu.contextMenuData.default then
		local row = ftable:addRow(false, {  })
		row[1]:createText(ReadText(1001, 11266), Helper.headerRowCenteredProperties)

		local row = ftable:addRow(true, {  })
		local button = row[1]:createButton({ bgColor = Color["button_background_hidden"], mouseOverText = ReadText(1026, 3269) }):setText(ReadText(1001, 11267))
		if menu.contextMenuData.default then
			button.properties.active = button.properties.active and (math.floor(menu.orderloopskill * 100 / 15) <= adjustedskill)
			button:setText2(Helper.displaySkill(menu.orderloopskill), { halign = "right", color = Color["text_skills"] })
		end
		row[1].handlers.onClick = function () return menu.buttonNewOrder("loop", menu.contextMenuData.default, instance) end
		row[1].properties.uiTriggerID = "looporders"
	end
end

function menu.createOrderparamWareContext(frame, instance)
	local param
	if menu.contextMenuData.order == "default" then
		param = menu.infoTableData[instance].defaultorder.params[menu.contextMenuData.param]
	elseif menu.contextMenuData.order == "planneddefault" then
		param = menu.infoTableData[instance].planneddefaultorder.params[menu.contextMenuData.param]
	else
		param = menu.infoTableData[instance].orders[menu.contextMenuData.order].params[menu.contextMenuData.param]
	end

	menu.contextMenuData.wares = {}

	if param.inputparams.mining then
		local sector = ConvertIDTo64Bit(param.inputparams.mining[1])
		local pos = param.inputparams.mining[2]
		local nummineables = C.GetNumMineablesAtSectorPos(sector, pos)
		local mineables = ffi.new("YieldInfo[?]", nummineables)
		nummineables = C.GetMineablesAtSectorPos(mineables, nummineables, sector, pos)
		for i = 0, nummineables - 1 do
			table.insert(menu.contextMenuData.wares, ffi.string(mineables[i].wareid))
		end
	elseif param.inputparams.cargoof then
		local buf = GetComponentData(param.inputparams.cargoof, "cargo")
		for ware in pairs(buf) do
			table.insert(menu.contextMenuData.wares, ware)
		end
	elseif param.inputparams.soldby then
		local buf = GetComponentData(param.inputparams.soldby, "products")
		for _, ware in ipairs(buf) do
			table.insert(menu.contextMenuData.wares, ware)
		end
	elseif param.inputparams.boughtby then
		local buf = GetComponentData(param.inputparams.boughtby, "allresources")
		for _, ware in ipairs(buf) do
			table.insert(menu.contextMenuData.wares, ware)
		end
	else
		for name, ware in pairs(menu.economyWares) do
			table.insert(menu.contextMenuData.wares, ware)
		end
	end
	if param.inputparams.cancarry then
		for i = #menu.contextMenuData.wares, 1, -1 do
			local ware = menu.contextMenuData.wares[i]
			if GetWareCapacity(param.inputparams.cancarry, ware, true) == 0 then
				table.remove(menu.contextMenuData.wares, i)
			end
		end
	end
	if param.inputparams.isminable then
		for i = #menu.contextMenuData.wares, 1, -1 do
			local ware = menu.contextMenuData.wares[i]
			if GetWareData(ware, "isminable") ~= (param.inputparams.isminable == 1) then
				table.remove(menu.contextMenuData.wares, i)
			end
		end
	end

	if (param.type == "list") then
		menu.contextMenuData.selectedWares = {}
		menu.contextMenuData.origSelectedWares = {}
		if param.value then
			for _, ware in ipairs(param.value) do
				menu.contextMenuData.selectedWares[ware] = true
				menu.contextMenuData.origSelectedWares[ware] = true
			end
		end
	end

	table.sort(menu.contextMenuData.wares, Helper.sortWareName)

	-- do this first so we still have a table row for the buttons before the list can use them all up
	local buttontable
	if param.type == "list" then
		if #menu.contextMenuData.wares > 0 then
			buttontable = frame:addTable(2, { tabOrder = 4, x = Helper.borderSize, y = Helper.borderSize, width = menu.contextMenuData.width })

			local row = buttontable:addRow(true, { fixed = true })
			row[1]:createButton({ active = function () return ((not param.required) or (next(menu.contextMenuData.selectedWares) ~= nil)) and menu.isWareSelectionChanged() end }):setText(ReadText(1001, 14), { halign = "center" })
			row[1].handlers.onClick = function () return menu.buttonSetOrderParam(menu.contextMenuData.order, menu.contextMenuData.param, menu.contextMenuData.index, menu.contextMenuData.selectedWares, instance) end
			row[2]:createButton({  }):setText(ReadText(1001, 64), { halign = "center" })
			row[2].handlers.onClick = function () return menu.onCloseElement("back") end
		end
	end

	local ftable = frame:addTable(3, { tabOrder = 3, x = Helper.borderSize, y = Helper.borderSize, width = menu.contextMenuData.width })
	ftable:setColWidth(1, config.mapRowHeight)
	ftable:setColWidthPercent(3, 50)

	if param.type == "list" then
		-- title
		local row = ftable:addRow(true, { fixed = true })
		row[1]:createCheckBox(function () local count = 0; for _ in pairs(menu.contextMenuData.selectedWares) do count = count + 1 end; return #menu.contextMenuData.wares == count end, { height = config.mapRowHeight })
		row[1].handlers.onClick = function (_, checked) return menu.checkboxToggleWareList(checked) end
		row[2]:setColSpan(2):createText(ReadText(1001, 8376), Helper.headerRowCenteredProperties)

		if #menu.contextMenuData.wares > 0 then
			for _, ware in ipairs(menu.contextMenuData.wares) do
				local row = ftable:addRow(true, {  })
				row[1]:createCheckBox(function () return menu.contextMenuData.selectedWares[ware] or false end, { height = config.mapRowHeight })
				row[1].handlers.onClick = function (_, checked) return menu.checkboxSetWareList(ware, checked) end
				row[2]:setColSpan(2):createText(GetWareData(ware, "name"))
			end

			local waresheight = ftable:getFullHeight()
			local buttonheight = buttontable:getFullHeight()
			if frame.properties.y + ftable.properties.y + waresheight + buttonheight + Helper.frameBorder > Helper.viewHeight then
				buttontable.properties.y = Helper.viewHeight - frame.properties.y - Helper.frameBorder - buttonheight
				ftable.properties.maxVisibleHeight = buttontable.properties.y - Helper.borderSize - ftable.properties.y
			else
				buttontable.properties.y = ftable.properties.y + waresheight + Helper.borderSize
			end

			ftable:addConnection(1, 3, true)
			buttontable:addConnection(2, 3)
		else
			local row = ftable:addRow(false, {  })
			row[1]:setColSpan(3):createText("--- " .. ReadText(1001, 32) .. " ---", { halign = "center" })
		end
	else
		-- title
		local row = ftable:addRow(false, { fixed = true, bgColor = Color["row_background_blue"] })
		row[1]:setColSpan(3):createText(ReadText(1001, 8306), Helper.headerRowCenteredProperties)

		if #menu.contextMenuData.wares > 0 then
			for _, ware in ipairs(menu.contextMenuData.wares) do
				local row = ftable:addRow(true, {  })
				row[1]:setColSpan(3):createButton({ bgColor = Color["button_background_hidden"], height = config.mapRowHeight }):setText(GetWareData(ware, "name"))
				row[1].handlers.onClick = function () return menu.buttonSetOrderParam(menu.contextMenuData.order, menu.contextMenuData.param, menu.contextMenuData.index, ware, instance) end
			end
		else
			local row = ftable:addRow(false, {  })
			row[1]:setColSpan(3):createText("--- " .. ReadText(1001, 32) .. " ---", { halign = "center" })
		end
	end
end

function menu.isWareSelectionChanged()
	for ware in pairs(menu.contextMenuData.selectedWares) do
		if not menu.contextMenuData.origSelectedWares[ware] then
			return true
		end
	end
	for ware in pairs(menu.contextMenuData.origSelectedWares) do
		if not menu.contextMenuData.selectedWares[ware] then
			return true
		end
	end
	return false
end

function menu.createOrderparamSectorContext(frame, instance)
	local param
	if menu.contextMenuData.order == "default" then
		param = menu.infoTableData[instance].defaultorder.params[menu.contextMenuData.param]
	elseif menu.contextMenuData.order == "planneddefault" then
		param = menu.infoTableData[instance].planneddefaultorder.params[menu.contextMenuData.param]
	else
		param = menu.infoTableData[instance].orders[menu.contextMenuData.order].params[menu.contextMenuData.param]
	end

	local ftable = frame:addTable(3, { tabOrder = 3, x = Helper.borderSize, y = Helper.borderSize, width = menu.contextMenuData.width })
	ftable:setColWidth(1, config.mapRowHeight)
	ftable:setColWidthPercent(3, 50)

	menu.contextMenuData.sectors = {}

	if param.inputparams.hasresources then
		local neededresources = {}
		for _, ware in ipairs(param.inputparams.hasresources) do
			neededresources[ware] = true
		end

		local clusters = GetClusters(true)
		for _, cluster in ipairs(clusters) do
			local sectors = GetSectors(cluster)
			for _, sector in ipairs(sectors) do
				local sector64 = ConvertIDTo64Bit(sector)
				local resources = {}
				local n = C.GetNumDiscoveredSectorResources(sector64)
				local buf = ffi.new("WareYield[?]", n)
				n = C.GetDiscoveredSectorResources(buf, n, sector64)
				for i = 0, n - 1 do
					if neededresources[ffi.string(buf[i].ware)] then
						table.insert(menu.contextMenuData.sectors, sector64)
						break
					end
				end
			end
		end
	else
		local clusters = GetClusters(true)
		for _, cluster in ipairs(clusters) do
			local sectors = GetSectors(cluster)
			for _, sector in ipairs(sectors) do
				table.insert(menu.contextMenuData.sectors, ConvertIDTo64Bit(sector))
			end
		end
	end

	if (param.type == "list") then
		menu.contextMenuData.selectedSectors = {}
		menu.contextMenuData.origSelectedSectors = {}
		if param.value then
			for _, sector in ipairs(param.value) do
				menu.contextMenuData.selectedSectors[tostring(ConvertIDTo64Bit(sector))] = true
				menu.contextMenuData.origSelectedSectors[tostring(ConvertIDTo64Bit(sector))] = true
			end
		end
	end

	table.sort(menu.contextMenuData.sectors, Helper.sortComponentName)

	if param.type == "list" then
		-- title
		local row = ftable:addRow(true, { fixed = true })
		row[1]:createCheckBox(function () local count = 0; for _ in pairs(menu.contextMenuData.selectedSectors) do count = count + 1 end; return #menu.contextMenuData.sectors == count end, { height = config.mapRowHeight })
		row[1].handlers.onClick = function (_, checked) return menu.checkboxToggleSectorList(checked) end
		row[2]:setColSpan(2):createText(ReadText(1001, 9177), Helper.headerRowCenteredProperties)

		if #menu.contextMenuData.sectors > 0 then
			for _, sector in ipairs(menu.contextMenuData.sectors) do
				local row = ftable:addRow(true, {  })
				row[1]:createCheckBox(function () return menu.contextMenuData.selectedSectors[tostring(sector)] or false end, { height = config.mapRowHeight })
				row[1].handlers.onClick = function (_, checked) return menu.checkboxSetSectorList(sector, checked) end
				row[2]:setColSpan(2):createText(GetComponentData(sector, "name"))
			end

			local buttontable = frame:addTable(2, { tabOrder = 4, x = Helper.borderSize, y = Helper.borderSize, width = menu.contextMenuData.width })

			local row = buttontable:addRow(true, { fixed = true })
			row[1]:createButton({ active = function () return ((not param.required) or (next(menu.contextMenuData.selectedSectors) ~= nil)) and menu.isSectorSelectionChanged() end }):setText(ReadText(1001, 14), { halign = "center" })
			row[1].handlers.onClick = function () return menu.buttonSetOrderParam(menu.contextMenuData.order, menu.contextMenuData.param, menu.contextMenuData.index, menu.contextMenuData.selectedSectors, instance) end
			row[2]:createButton({  }):setText(ReadText(1001, 64), { halign = "center" })
			row[2].handlers.onClick = function () return menu.onCloseElement("back") end

			local sectorsheight = ftable:getFullHeight()
			local buttonheight = buttontable:getFullHeight()
			if frame.properties.y + ftable.properties.y + sectorsheight + buttonheight + Helper.frameBorder > Helper.viewHeight then
				buttontable.properties.y = Helper.viewHeight - frame.properties.y - Helper.frameBorder - buttonheight
				ftable.properties.maxVisibleHeight = buttontable.properties.y - Helper.borderSize - ftable.properties.y
			else
				buttontable.properties.y = ftable.properties.y + sectorsheight + Helper.borderSize
			end

			ftable:addConnection(1, 3, true)
			buttontable:addConnection(2, 3)
		else
			local row = ftable:addRow(false, {  })
			row[1]:setColSpan(3):createText("--- " .. ReadText(1001, 32) .. " ---", { halign = "center" })
		end
	else
		-- title
		local row = ftable:addRow(false, { fixed = true, bgColor = Color["row_background_blue"] })
		row[1]:setColSpan(3):createText(ReadText(1001, 11238), Helper.headerRowCenteredProperties)

		if #menu.contextMenuData.sectors > 0 then
			for _, sector in ipairs(menu.contextMenuData.sectors) do
				local row = ftable:addRow(true, {  })
				row[1]:setColSpan(3):createButton({ bgColor = Color["button_background_hidden"], height = config.mapRowHeight }):setText(GetComponentData(sector, "name"))
				row[1].handlers.onClick = function () return menu.buttonSetOrderParam(menu.contextMenuData.order, menu.contextMenuData.param, menu.contextMenuData.index, sector, instance) end
			end
		else
			local row = ftable:addRow(false, {  })
			row[1]:setColSpan(3):createText("--- " .. ReadText(1001, 32) .. " ---", { halign = "center" })
		end
	end
end

function menu.isSectorSelectionChanged()
	for sector in pairs(menu.contextMenuData.selectedSectors) do
		if not menu.contextMenuData.origSelectedSectors[sector] then
			return true
		end
	end
	for sector in pairs(menu.contextMenuData.origSelectedSectors) do
		if not menu.contextMenuData.selectedSectors[sector] then
			return true
		end
	end
	return false
end

function menu.createFilterparamWareContext(frame)
	local buttontable = frame:addTable(2, { tabOrder = 4, x = Helper.borderSize, y = Helper.borderSize, width = menu.contextMenuData.width })

	local row = buttontable:addRow(true, { fixed = true })
	row[1]:createButton({ active = menu.isWareSelectionChanged }):setText(ReadText(1001, 14), { halign = "center" })
	row[1].handlers.onClick = function () return menu.setFilterOption(menu.displayedFilterLayer, menu.contextMenuData.setting, menu.contextMenuData.setting.id, menu.contextMenuData.selectedWares) end
	row[2]:createButton({  }):setText(ReadText(1001, 64), { halign = "center" })
	row[2].handlers.onClick = function () return menu.onCloseElement("back") end

	local ftable = frame:addTable(3, { tabOrder = 3, x = Helper.borderSize, y = Helper.borderSize, width = menu.contextMenuData.width })
	ftable:setColWidth(1, config.mapRowHeight)
	ftable:setColWidthPercent(3, 50)

	menu.contextMenuData.wares = menu.contextMenuData.setting.listOptions()
	menu.contextMenuData.selectedWares = {}
	menu.contextMenuData.origSelectedWares = {}
	local list = menu.getFilterOption(menu.contextMenuData.setting.id, menu.contextMenuData.setting.savegame) or {}
	for _, ware in ipairs(list) do
		menu.contextMenuData.selectedWares[ware] = true
		menu.contextMenuData.origSelectedWares[ware] = true
	end
	table.sort(menu.contextMenuData.wares, Helper.sortWareName)

	-- title
	local row = ftable:addRow(true, { fixed = true })
	row[1]:createCheckBox(function () local count = 0; for _ in pairs(menu.contextMenuData.selectedWares) do count = count + 1 end; return #menu.contextMenuData.wares == count end, { height = config.mapRowHeight })
	row[1].handlers.onClick = function (_, checked) return menu.checkboxToggleWareList(checked) end
	row[2]:setColSpan(2):createText(ReadText(1001, 8376), Helper.headerRowCenteredProperties)

	if #menu.contextMenuData.wares > 0 then
		for _, ware in ipairs(menu.contextMenuData.wares) do
			local row = ftable:addRow(true, {  })
			row[1]:createCheckBox(function () return menu.contextMenuData.selectedWares[ware] or false end, { height = config.mapRowHeight })
			row[1].handlers.onClick = function (_, checked) return menu.checkboxSetWareList(ware, checked) end
			row[2]:setColSpan(2):createText(GetWareData(ware, "name"))
		end
	else
		local row = ftable:addRow(false, {  })
		row[1]:setColSpan(3):createText("--- " .. ReadText(1001, 32) .. " ---", { halign = "center" })
	end

	local waresheight = ftable:getFullHeight()
	local buttonheight = buttontable:getFullHeight()
	if frame.properties.y + ftable.properties.y + waresheight + buttonheight + Helper.frameBorder > Helper.viewHeight then
		buttontable.properties.y = Helper.viewHeight - frame.properties.y - Helper.frameBorder - buttonheight
		ftable.properties.maxVisibleHeight = buttontable.properties.y - Helper.borderSize - ftable.properties.y
	else
		buttontable.properties.y = ftable.properties.y + waresheight + Helper.borderSize
	end

	ftable:addConnection(1, 3, true)
	buttontable:addConnection(2, 3)
end

function menu.createOrderparamFormationShapeContext(frame, instance)
	local param
	if menu.contextMenuData.order == "default" then
		param = menu.infoTableData[instance].defaultorder.params[menu.contextMenuData.param]
	elseif menu.contextMenuData.order == "planneddefault" then
		param = menu.infoTableData[instance].planneddefaultorder.params[menu.contextMenuData.param]
	else
		param = menu.infoTableData[instance].orders[menu.contextMenuData.order].params[menu.contextMenuData.param]
	end

	local ftable = frame:addTable(1, { tabOrder = 3, x = Helper.borderSize, y = Helper.borderSize, width = menu.contextMenuData.width, highlightMode = "off" })

	-- title
	local row = ftable:addRow(false, { fixed = true, bgColor = Color["row_background_blue"] })
	row[1]:createText(ReadText(1001, 8307), Helper.headerRowCenteredProperties)

	menu.contextMenuData.formationshapes = {}
	local n = C.GetNumFormationShapes()
	local buf = ffi.new("UIFormationInfo[?]", n)
	n = C.GetFormationShapes(buf, n)
	for i = 0, n - 1 do
		table.insert(menu.contextMenuData.formationshapes, { name = ffi.string(buf[i].name), shape = ffi.string(buf[i].shape) })
	end

	table.sort(menu.contextMenuData.formationshapes, Helper.sortName)

	for _, formation in ipairs(menu.contextMenuData.formationshapes) do
		local row = ftable:addRow(true, {  })
		row[1]:createButton({ bgColor = Color["button_background_hidden"] }):setText(formation.name)
		row[1].handlers.onClick = function () return menu.buttonSetOrderParam(menu.contextMenuData.order, menu.contextMenuData.param, menu.contextMenuData.index, formation.shape, instance) end
	end
end

function menu.defaultInteraction(component, posrot, posrotvalid, offsetx, offsety)
	local occupiedship = C.GetPlayerOccupiedShipID()
	if C.IsComponentClass(component, "sector") then
		local playerprecise = (#menu.selectedcomponents == 1)
		for id, _ in pairs(menu.selectedcomponents) do
			local selectedcomponent = ConvertStringTo64Bit(id)
			local hasloop = ffi.new("bool[1]", 0)
			C.GetOrderQueueFirstLoopIdx(selectedcomponent, hasloop)
			if (selectedcomponent ~= occupiedship) and GetComponentData(selectedcomponent, "assignedpilot") and ((not hasloop[0]) or menu.orderdefbyid["MoveWait"].loopable) then
				if GetComponentData(selectedcomponent, "isplayerowned") then
					menu.orderMoveWait(selectedcomponent, component, posrot, playerprecise, false)
				end
			end
		end
	elseif GetComponentData(ConvertStringToLuaID(tostring(component)), "isenemy") then
		for id, _ in pairs(menu.selectedcomponents) do
			local selectedcomponent = ConvertStringTo64Bit(id)
			local hasloop = ffi.new("bool[1]", 0)
			C.GetOrderQueueFirstLoopIdx(selectedcomponent, hasloop)
			if (selectedcomponent ~= occupiedship) and GetComponentData(selectedcomponent, "assignedpilot") and ((not hasloop[0]) or menu.orderdefbyid["Attack"].loopable) then
				if GetComponentData(selectedcomponent, "isplayerowned") then
					menu.orderAttack(selectedcomponent, component, false)
				end
			end
		end
	elseif C.IsComponentClass(component, "station") then
		local issingleloopship
		if menu.getNumSelectedComponents() == 1 then
			local component = next(menu.selectedcomponents)
			local selectedcomponent = ConvertStringTo64Bit(component)
			local hasloop = ffi.new("bool[1]", 0)
			C.GetOrderQueueFirstLoopIdx(selectedcomponent, hasloop)
			issingleloopship = hasloop[0]
		end

		if not issingleloopship then
			menu.contextMenuMode = "trade"
			menu.contextMenuData = { component = ConvertStringTo64Bit(tostring(component)), orders = {} }

			local numwarerows, numinforows = menu.initTradeContextData()
			menu.updateTradeContextDimensions(numwarerows, numinforows)

			local width = menu.tradeContext.width
			local height = menu.tradeContext.shipheight + menu.tradeContext.buttonheight + 1 * Helper.borderSize

			if offsetx + width > Helper.viewWidth - Helper.frameBorder then
				offsetx = Helper.viewWidth - width - Helper.frameBorder
			end
			if offsety + height > Helper.viewHeight - Helper.frameBorder then
				offsety = Helper.viewHeight - height - Helper.frameBorder
			end
			menu.createContextFrame(width, height, offsetx, offsety)
		end
	end
	if (menu.infoTableMode == "info") and ((menu.infoMode.left == "orderqueue") or (menu.infoMode.left == "orderqueue_advanced")) then
		menu.refreshInfoFrame()
	elseif (menu.infoTableMode == "mission") then
		menu.refreshIF = getElapsedTime()
	end
	if (menu.searchTableMode == "info") and ((menu.infoMode.right == "orderqueue") or (menu.infoMode.right == "orderqueue_advanced")) then
		menu.refreshInfoFrame2()
	end
end

function menu.getTransportTagsFromString(s)
	local types = {}
	while string.len(s) > 0 do
		local pos = string.find(s, " ", 1, true)
		if not pos then
			types[s] = true
			break
		elseif pos > 1 then
			types[string.sub(s, 1, pos - 1)] = true
		end
		s = string.sub(s, pos + 1)
	end
	return types
end

function menu.getCargoTransportTypes(container, aftertradeorders)
	local transporttypes = { }
	local n = C.GetNumCargoTransportTypes(container, true)
	local buf = ffi.new("StorageInfo[?]", n)
	n = C.GetCargoTransportTypes(buf, n, container, true, aftertradeorders)

	-- Fill transporttypes list
	for i = 0, n - 1 do
		local tags = menu.getTransportTagsFromString(ffi.string(buf[i].transport))
		local name
		if tags.container and tags.solid and tags.liquid then -- no not add Condensate Storage!
			name = ReadText(20109, 801)		-- Universal Storage
		elseif tags.container then
			name = ReadText(20109, 101)		-- Container Storage
		elseif tags.solid then
			name = ReadText(20109, 301)		-- Solid Storage
		elseif tags.liquid then
			name = ReadText(20109, 601)		-- Liquid Storage
		elseif tags.condensate then
			name = ReadText(20109, 9801)	-- Condensate Storage
		else
			name = ffi.string(buf[i].name)	-- Should never happen
		end
		table.insert(transporttypes, { name = name, tags = tags, initialstored = 0, stored = 0, capacity = buf[i].capacity })
	end
	-- Sort transport types (first container, then solid, then liquid, then condensate, then universal, then anything else)
	-- NOTE: Universal storage isn't supposed to be mixed with container, solid, liquid or condensate storage, but if it is, then the order is important,
	-- so that the storage visualisation doesn't break completely (fill container/solid/liquid/condensate storage instead of universal storage)
	table.sort(transporttypes,
		function (a, b)
			if a.tags.condensate ~= b.tags.condensate then
				return not a.tags.condensate
			elseif a.tags.liquid ~= b.tags.liquid then
				return not a.tags.liquid
			elseif a.tags.solid ~= b.tags.solid then
				return not a.tags.solid
			elseif a.tags.container ~= b.tags.container then
				return not a.tags.container
			else
				return a.name < b.name
			end
		end)

	-- initialize initialstored
	menu.getTradeContextInitialStorageData(container, transporttypes, aftertradeorders)

	return transporttypes
end

function menu.initTradeContextData()
	local convertedTradeOfferContainer = ConvertStringToLuaID(tostring(menu.contextMenuData.component))

	-- Ships
	local occupiedship = C.GetPlayerOccupiedShipID()
	menu.contextMenuData.isoccupiedshipdocked = false
	if occupiedship ~= 0 then
		menu.contextMenuData.isoccupiedshipdocked = C.GetCommonContext(occupiedship, menu.contextMenuData.component, true, true, C.GetContextByClass(occupiedship, "zone", false), false) ~= 0
	end
	menu.contextMenuData.ships = menu.getShipList(menu.contextMenuData.isoccupiedshipdocked, false)
	for i, ship in ipairs(menu.contextMenuData.ships) do
		if ConvertIDTo64Bit(ship.shipid) == menu.contextMenuData.component then
			table.remove(menu.contextMenuData.ships, i)
			break
		end
	end
	local convertedCurrentShip
	if not menu.contextMenuData.currentShip then
		for id, _ in pairs(menu.selectedcomponents) do
			local selectedcomponent = ConvertStringTo64Bit(id)
			if menu.contextMenuData.isoccupiedshipdocked or (selectedcomponent ~= occupiedship) then
				local isplayerowned, isdeployable = GetComponentData(selectedcomponent, "isplayerowned", "isdeployable")
				if isplayerowned and C.IsComponentClass(selectedcomponent, "ship") and (not isdeployable) then
					menu.contextMenuData.currentShip = selectedcomponent
					convertedCurrentShip = ConvertStringToLuaID(id)
					break
				end
			end
		end
		if not menu.contextMenuData.currentShip then
			if #menu.contextMenuData.ships > 0 then
				if menu.contextMenuData.isoccupiedshipdocked then
					for _, ship in ipairs(menu.contextMenuData.ships) do
						if ConvertIDTo64Bit(ship.shipid) == occupiedship then
							menu.contextMenuData.currentShip = ConvertIDTo64Bit(ship.shipid)
							convertedCurrentShip = ship.shipid
							break
						end
					end
				end
				if not menu.contextMenuData.currentShip then
					menu.contextMenuData.currentShip = ConvertIDTo64Bit(menu.contextMenuData.ships[1].shipid)
					convertedCurrentShip = menu.contextMenuData.ships[1].shipid
				end
			else
				menu.contextMenuData.currentShip = 0
				convertedCurrentShip = nil
			end
		end
	else
		convertedCurrentShip = ConvertStringToLuaID(tostring(menu.contextMenuData.currentShip))
	end

	local currentship64 = ConvertIDTo64Bit(convertedCurrentShip)
	local iscurrentshipdocked = currentship64 and C.GetCommonContext(currentship64, menu.contextMenuData.component, true, true, C.GetContextByClass(currentship64, "zone", false), false) ~= 0
	menu.contextMenuData.immediate = false
	if menu.contextMenuData.isoccupiedshipdocked and (menu.contextMenuData.currentShip == occupiedship) then
		-- occupied ship wants to trade with tradeoffercontainer, use trade computer
		menu.contextMenuData.immediate = true
		menu.contextMenuData.immediateObject = menu.contextMenuData.currentShip
	elseif iscurrentshipdocked then
		if not GetComponentData(convertedCurrentShip, "aipilot") then
			-- current ship has common context with tradeoffercontainer and no ai pilot, use trade computer
			menu.contextMenuData.immediate = true
			menu.contextMenuData.immediateObject = menu.contextMenuData.currentShip
		elseif C.IsComponentClass(menu.contextMenuData.component, "ship") and (not GetComponentData(convertedTradeOfferContainer, "aipilot")) then
			-- current ship has common context with tradeoffercontainer and the tradeoffercontainer is a ship and has no ai pilot, use trade computer on that ship
			menu.contextMenuData.immediate = true
			menu.contextMenuData.immediateObject = menu.contextMenuData.component
		end
	end
	menu.contextMenuData.playerMoney = GetPlayerMoney()

	-- virtual cargo mode
	if convertedCurrentShip then
		local numtradecomputertrades = tonumber(C.GetNumTradeComputerOrders(menu.contextMenuData.currentShip))
		SetVirtualCargoMode(convertedCurrentShip, true, menu.contextMenuData.immediate and numtradecomputertrades or -1)
	end
	if menu.contextMenuData.wareexchange then
		if C.IsComponentOperational(menu.contextMenuData.component) then
			SetVirtualCargoMode(convertedTradeOfferContainer, true, -1)
			menu.contextMenuData.currentothercargo = GetCargoAfterTradeOrders(convertedTradeOfferContainer)
			menu.contextMenuData.currentotherammo = GetAmmoCountAfterTradeOrders(convertedTradeOfferContainer)
		end
	end

	menu.contextMenuData.currentcargo = convertedCurrentShip and GetCargoAfterTradeOrders(convertedCurrentShip) or {}
	menu.contextMenuData.currentammo = convertedCurrentShip and GetAmmoCountAfterTradeOrders(convertedCurrentShip) or {}

	-- Trade offers
	menu.contextMenuData.buyoffers = {}
	menu.contextMenuData.selloffers = {}
	menu.contextMenuData.missionoffers = {}
	menu.contextMenuData.buywares = {}
	menu.contextMenuData.sellwares = {}
	menu.contextMenuData.missionwares = {}
	menu.contextMenuData.buyammowares = {}
	menu.contextMenuData.sellammowares = {}
	menu.contextMenuData.missionoffersbyid = {}

	local tradeoffers, nontradeoffers = {}, {}
	if menu.contextMenuData.wareexchange then
		tradeoffers = GetWareExchangeTradeList(convertedCurrentShip, convertedTradeOfferContainer)
		-- Mark any equipment wares as such (only relevant for ware exchange)
		for _, tradedata in pairs(tradeoffers) do
			if tradedata.ware then
				tradedata.ammotypename = menu.getAmmoTypeNameByWare(tradedata.ware)
			end
		end
	else
		tradeoffers = GetTradeList(convertedTradeOfferContainer, convertedCurrentShip)
		nontradeoffers = GetTradeList(convertedTradeOfferContainer, convertedCurrentShip, false)
	end
	for _, tradedata in pairs(tradeoffers) do
		if tradedata.ware and ((not menu.contextMenuData.shadyOnly) or tradedata.isshady) then
			local currentwares = tradedata.ammotypename and menu.contextMenuData.currentammo or menu.contextMenuData.currentcargo
			local currentotherwares = tradedata.ammotypename and menu.contextMenuData.currentotherammo or menu.contextMenuData.currentothercargo	-- may be nil
			local buywares = tradedata.ammotypename and menu.contextMenuData.buyammowares or menu.contextMenuData.buywares
			local sellwares = tradedata.ammotypename and menu.contextMenuData.sellammowares or menu.contextMenuData.sellwares

			if tradedata.isbuyoffer then
				tradedata.active = convertedCurrentShip and currentwares[tradedata.ware] and CanTradeWith(tradedata.id, convertedCurrentShip, tradedata.minamount)
				if tradedata.ismissionoffer then
					table.insert(menu.contextMenuData.missionoffers, tradedata)
					menu.contextMenuData.missionoffersbyid[ConvertIDTo64Bit(tradedata.id)] = true
					if menu.contextMenuData.missionwares[tradedata.ware] then
						table.insert(menu.contextMenuData.missionwares[tradedata.ware], tradedata)
					else
						menu.contextMenuData.missionwares[tradedata.ware] = { tradedata }
					end
				else
					table.insert(menu.contextMenuData.buyoffers, tradedata)
					if not buywares[tradedata.ware] then
						buywares[tradedata.ware] = { tradedata }
					else
						table.insert(buywares[tradedata.ware], tradedata)
					end
				end
				if tradedata.active and currentotherwares then
					currentotherwares[tradedata.ware] = currentotherwares[tradedata.ware] or 0
				end
			elseif tradedata.isselloffer then
				tradedata.active = convertedCurrentShip and CanTradeWith(tradedata.id, convertedCurrentShip, tradedata.minamount, true)
				if tradedata.ismissionoffer then
					table.insert(menu.contextMenuData.missionoffers, tradedata)
					menu.contextMenuData.missionoffersbyid[ConvertIDTo64Bit(tradedata.id)] = true
					if menu.contextMenuData.missionwares[tradedata.ware] then
						table.insert(menu.contextMenuData.missionwares[tradedata.ware], tradedata)
					else
						menu.contextMenuData.missionwares[tradedata.ware] = { tradedata }
					end
				else
					table.insert(menu.contextMenuData.selloffers, tradedata)
					if not sellwares[tradedata.ware] then
						sellwares[tradedata.ware] = { tradedata }
					else
						table.insert(sellwares[tradedata.ware], tradedata)
					end
				end
				if tradedata.active then
					currentwares[tradedata.ware] = currentwares[tradedata.ware] or 0
				end
			end
		end
	end
	for _, tradedata in pairs(nontradeoffers) do
		if tradedata.ware and ((not menu.contextMenuData.shadyOnly) or tradedata.isshady) then
			local currentwares = tradedata.ammotypename and menu.contextMenuData.currentammo or menu.contextMenuData.currentcargo
			local currentotherwares = tradedata.ammotypename and menu.contextMenuData.currentotherammo or menu.contextMenuData.currentothercargo	-- may be nil
			local buywares = tradedata.ammotypename and menu.contextMenuData.buyammowares or menu.contextMenuData.buywares
			local sellwares = tradedata.ammotypename and menu.contextMenuData.sellammowares or menu.contextMenuData.sellwares

			if tradedata.isbuyoffer then
				if tradedata.ismissionoffer then
					if not menu.contextMenuData.missionoffersbyid[ConvertIDTo64Bit(tradedata.id)] then
						tradedata.active = convertedCurrentShip and currentwares[tradedata.ware] and CanTradeWith(tradedata.id, convertedCurrentShip, tradedata.minamount)
						table.insert(menu.contextMenuData.missionoffers, tradedata)
						menu.contextMenuData.missionoffersbyid[ConvertIDTo64Bit(tradedata.id)] = true
						if menu.contextMenuData.missionwares[tradedata.ware] then
							table.insert(menu.contextMenuData.missionwares[tradedata.ware], tradedata)
						else
							menu.contextMenuData.missionwares[tradedata.ware] = { tradedata }
						end
						if tradedata.active and currentotherwares then
							currentotherwares[tradedata.ware] = currentotherwares[tradedata.ware] or 0
						end
					end
				elseif not buywares[tradedata.ware] then
					tradedata.active = false
					tradedata.stale = true
					table.insert(menu.contextMenuData.buyoffers, tradedata)
					buywares[tradedata.ware] = { tradedata }
				end
			elseif tradedata.isselloffer then
				if tradedata.ismissionoffer then
					if not menu.contextMenuData.missionoffersbyid[ConvertIDTo64Bit(tradedata.id)] then
						tradedata.active = convertedCurrentShip and CanTradeWith(tradedata.id, convertedCurrentShip, tradedata.minamount)
						table.insert(menu.contextMenuData.missionoffers, tradedata)
						menu.contextMenuData.missionoffersbyid[ConvertIDTo64Bit(tradedata.id)] = true
						if menu.contextMenuData.missionwares[tradedata.ware] then
							table.insert(menu.contextMenuData.missionwares[tradedata.ware], tradedata)
						else
							menu.contextMenuData.missionwares[tradedata.ware] = { tradedata }
						end
						if tradedata.active then
							currentwares[tradedata.ware] = currentwares[tradedata.ware] or 0
						end
					end
				elseif not sellwares[tradedata.ware] then
					tradedata.active = false
					tradedata.stale = true
					table.insert(menu.contextMenuData.selloffers, tradedata)
					sellwares[tradedata.ware] = { tradedata }
				end
			end
		end
	end

	-- Distribute cargo to transport type capacities
	menu.contextMenuData.transporttypes = (menu.contextMenuData.currentShip ~= 0) and menu.getCargoTransportTypes(menu.contextMenuData.currentShip, true) or {}
	menu.contextMenuData.othershiptransporttypes = (menu.contextMenuData.wareexchange and menu.contextMenuData.component ~= 0) and menu.getCargoTransportTypes(menu.contextMenuData.component, true) or {}

	menu.contextMenuData.ammotypes = { }
	if menu.contextMenuData.wareexchange and menu.contextMenuData.component ~= 0 then
		-- ammo is only relevant and visible in ware exchange case
		local missilecapacity1, countermeasurecapacity1, deployablecapacity1 = GetComponentData(convertedCurrentShip, "missilecapacity", "countermeasurecapacity", "deployablecapacity")
		local missilecapacity2, countermeasurecapacity2, deployablecapacity2 = GetComponentData(convertedTradeOfferContainer, "missilecapacity", "countermeasurecapacity", "deployablecapacity")
		local unitcapacity1 = GetUnitStorageData(convertedCurrentShip).capacity
		local unitcapacity2 = GetUnitStorageData(convertedTradeOfferContainer).capacity
		-- missiles
		if missilecapacity1 > 0 or missilecapacity2 > 0 then
			table.insert(menu.contextMenuData.ammotypes, { name = ReadText(1001, 1304), type = "missile", stored = 0, otherstored = 0, capacity = missilecapacity1, othercapacity = missilecapacity2 })
		end
		-- countermeasures
		if countermeasurecapacity1 > 0 or countermeasurecapacity2 > 0 then
			table.insert(menu.contextMenuData.ammotypes, { name = ReadText(1001, 8063), type = "countermeasure", stored = 0, otherstored = 0, capacity = countermeasurecapacity1, othercapacity = countermeasurecapacity2 })
		end
		-- units
		if unitcapacity1 > 0 or unitcapacity2 > 0 then
			table.insert(menu.contextMenuData.ammotypes, { name = ReadText(1001, 8), type = "unit", stored = 0, otherstored = 0, capacity = unitcapacity1, othercapacity = unitcapacity2 })
		end
		-- units
		if deployablecapacity1 > 0 or deployablecapacity2 > 0 then
			table.insert(menu.contextMenuData.ammotypes, { name = ReadText(1001, 8064), type = "deployable", stored = 0, otherstored = 0, capacity = deployablecapacity1, othercapacity = deployablecapacity2 })
		end
	end

	-- cost
	menu.contextMenuData.totalbuyprofit = 0
	menu.contextMenuData.totalsellcost = 0
	menu.contextMenuData.referenceprofit = 0

	-- Merge selloffers and buyoffers into waredatalist
	local waredatatable = {}
	local waredatalist = {}
	for _, tradedata in ipairs(menu.contextMenuData.selloffers) do
		if not menu.contextMenuData.wareexchange then
			AddKnownItem("wares", tradedata.ware)
		end
		local waredata = { ware = tradedata.ware, active = tradedata.active, sell = tradedata, stale = tradedata.stale }
		waredatatable[tradedata.ware] = waredata
		table.insert(waredatalist, waredata)
	end
	for _, tradedata in ipairs(menu.contextMenuData.buyoffers) do
		local waredata = waredatatable[tradedata.ware]
		if (not waredata) or tradedata.issupply then
			if not menu.contextMenuData.wareexchange then
				AddKnownItem("wares", tradedata.ware)
			end
			waredata = { ware = tradedata.ware, stale = tradedata.stale, issupply = tradedata.issupply }
			waredatatable[tradedata.ware] = waredata
			table.insert(waredatalist, waredata)
		end
		waredata.buy = tradedata
		waredata.active = waredata.active or tradedata.active
		waredata.stale = waredata.stale and tradedata.stale
	end
	for _, tradedata in ipairs(menu.contextMenuData.missionoffers) do
		if not menu.contextMenuData.wareexchange then
			AddKnownItem("wares", tradedata.ware)
		end
		local waredata = { ware = tradedata.ware, active = tradedata.active, mission = ConvertIDTo64Bit(tradedata.mission), stale = tradedata.stale }
		if tradedata.isbuyoffer then
			waredata.buy = tradedata
		else
			waredata.sell = tradedata
		end
		table.insert(waredatalist, waredata)
	end
	-- Sort wares: First by cargo/ammo type, then active before inactive, then sorted by name
	table.sort(waredatalist,
		function (a, b)
			local aidx, bidx = menu.getAmmoDataIdxByWare(a.ware), menu.getAmmoDataIdxByWare(b.ware)
			if aidx ~= bidx then
				return aidx < bidx
			elseif (not a.active) ~= (not b.active) then
				return not b.active
			else
				return Helper.sortWareName(a.ware, b.ware)
			end
		end)

	-- Store waredatalist so we always know how many lines there are in the shiptable
	menu.contextMenuData.waredatalist = waredatalist

	-- If no wares, there is still a line displayed ("No known offers" / "No wares")
	local numwarerows = math.max(1, #menu.contextMenuData.waredatalist)
	local numinforows = math.max(#menu.contextMenuData.transporttypes, #menu.contextMenuData.othershiptransporttypes) + #menu.contextMenuData.ammotypes
	if not menu.contextMenuData.wareexchange and numinforows < 2 then
		numinforows = 2			-- reserve space for "Profits from sales" and "Transaction value"
	end
	return numwarerows, numinforows
end

function menu.sortByActiveAndName(a, b)
	if a.active == b.active then
		return Helper.sortName(a, b)
	end
	return a.active
end

function menu.sortByActiveAndWareName(a, b)
	if a.active == b.active then
		return GetWareData(a.ware, "name") < GetWareData(b.ware, "name")
	end
	return a.active
end

function menu.getAmmoTypeNameByWare(ware)
	local transport, macro = GetWareData(ware, "transport", "component")
	if transport == "equipment" and macro ~= "" then
		if IsMacroClass(macro, "missile") then
			return "missile"
		elseif IsMacroClass(macro, "countermeasure") then
			return "countermeasure"
		elseif GetMacroData(macro, "isunit") then
			return "unit"
		elseif GetMacroData(macro, "isdeployable") then
			return "deployable"
		end
	end
	return nil
end

function menu.getAmmoDataIdxByWare(ware)
	local ammotypename = menu.getAmmoTypeNameByWare(ware)
	if ammotypename then
		for idx, equipmentdata in ipairs(menu.contextMenuData.ammotypes) do
			if equipmentdata.type == ammotypename then
				return idx
			end
		end
	end
	return 0
end

function menu.getAmmoDataByWare(ware)
	local idx = menu.getAmmoDataIdxByWare(ware)
	if idx > 0 then
		return menu.contextMenuData.ammotypes[idx]
	end
	return nil
end

function menu.updateTradeCost()
	local convertedCurrentShip = ConvertStringToLuaID(tostring(menu.contextMenuData.currentShip))
	local convertedTradeOfferContainer = ConvertStringToLuaID(tostring(menu.contextMenuData.component))
	local isplayertradeoffercontainer = GetComponentData(convertedTradeOfferContainer, "isplayerowned")

	for _, transporttype in ipairs(menu.contextMenuData.transporttypes) do
		transporttype.stored = 0
	end
	for ware, amount in pairs(menu.contextMenuData.currentcargo) do
		local transport, volume = GetWareData(ware, "transport", "volume")
		for _, transporttype in ipairs(menu.contextMenuData.transporttypes) do
			if transporttype.tags[transport] then
				local orderamount = menu.getCargoOrderAmountByWare(ware)
				transporttype.stored = transporttype.stored + (amount - orderamount) * volume
				break
			end
		end
	end

	for _, ammotype in ipairs(menu.contextMenuData.ammotypes) do
		ammotype.stored = 0
		ammotype.otherstored = 0
	end
	for ware, amount in pairs(menu.contextMenuData.currentammo) do
		local ammotype = menu.getAmmoDataByWare(ware)
		if ammotype then
			ammotype.stored = ammotype.stored + amount - menu.getAmmoOrderAmountByWare(ware)
		end
	end

	if menu.contextMenuData.wareexchange then
		for _, transporttype in ipairs(menu.contextMenuData.othershiptransporttypes) do
			transporttype.stored = transporttype.initialstored
		end
		for ware, amount in pairs(menu.contextMenuData.currentothercargo) do
			local transport, volume = GetWareData(ware, "transport", "volume")
			-- below is done to handle trade partners that have more than one storage module type with a particular storage type (ex: solid and universal)
			local leftover = 0
			local orderamount = menu.getCargoOrderAmountByWare(ware)
			if orderamount ~= 0 then
				for _, transporttype in ipairs(menu.contextMenuData.othershiptransporttypes) do
					--print("init stored: " .. tostring(transporttype.stored))
					if transporttype.tags[transport] then
						local volumechange = orderamount * volume
						if leftover > 0 then
							volumechange = leftover * volume
							--print("1.1 ware: " .. tostring(ware) .. ", volumechange: " .. tostring(volumechange) .. ", transporttype.capacity: " .. tostring(transporttype.capacity))
						end

						--print(tostring(_) .. ": 2.0 ware: " .. tostring(ware) .. ", orderamount: " .. tostring(orderamount) .. ", volumechange: " .. tostring(volumechange) .. ", transporttype.capacity: " .. tostring(transporttype.capacity))
						if (transporttype.stored + volumechange) > transporttype.capacity then
							local evalamount = orderamount
							local evalvolume = transporttype.stored + volumechange
							while evalvolume > transporttype.capacity do
								evalamount = evalamount - 1
								evalvolume = transporttype.stored + evalamount * volume
							end
							transporttype.stored = evalvolume
							leftover = orderamount - evalamount
							--print("2.1 ware: " .. tostring(ware) .. ", leftover volume: " .. tostring(leftover * volume))
						else
							leftover = 0
							transporttype.stored = transporttype.stored + volumechange
							--print("2.2 ware: " .. tostring(ware) .. ", total stored: " .. tostring(transporttype.stored) .. ", capacity: " .. tostring(transporttype.capacity))
							break
						end
					end
				end
			end
		end
		for ware, amount in pairs(menu.contextMenuData.currentotherammo) do
			local ammotype = menu.getAmmoDataByWare(ware)
			if ammotype then
				ammotype.otherstored = ammotype.otherstored + amount + menu.getAmmoOrderAmountByWare(ware)
			end
		end
	end

	menu.contextMenuData.totalbuyprofit = 0
	menu.contextMenuData.totalsellcost = 0
	menu.contextMenuData.referenceprofit = 0
	if not isplayertradeoffercontainer then
		for id, amount in pairs(menu.contextMenuData.orders) do
			local tradeoffer = menu.getTradeOfferByID(ConvertStringToLuaID(tostring(id)))
			local price = tradeoffer and tradeoffer.price or 0
			if amount < 0 then
				-- station sells
				menu.contextMenuData.totalsellcost = menu.contextMenuData.totalsellcost + RoundTotalTradePrice(price * -amount)
			elseif amount > 0 then
				-- station buys
				menu.contextMenuData.totalbuyprofit = menu.contextMenuData.totalbuyprofit + RoundTotalTradePrice(price * amount)
			end
			if price ~= 0 and amount ~= 0 then
				local defaultrefprofit = GetReferenceProfit(convertedCurrentShip, tradeoffer.ware, price, 0) or 0
				local newrefprofit = GetReferenceProfit(convertedCurrentShip, tradeoffer.ware, price, amount) or 0
				menu.contextMenuData.referenceprofit = menu.contextMenuData.referenceprofit + newrefprofit - defaultrefprofit
			end
		end
	end
end

function menu.getCargoOrderAmountByWare(ware)
	local result = 0
	if menu.contextMenuData.buywares[ware] then
		for _, buyoffer in ipairs(menu.contextMenuData.buywares[ware]) do
			result = result + (menu.contextMenuData.orders[ConvertIDTo64Bit(buyoffer.id)] or 0)
		end
	end
	if menu.contextMenuData.sellwares[ware] then
		for _, selloffer in ipairs(menu.contextMenuData.sellwares[ware]) do
			result = result + (menu.contextMenuData.orders[ConvertIDTo64Bit(selloffer.id)] or 0)
		end
	end
	local missionoffers = menu.contextMenuData.missionwares[ware]
	if missionoffers then
		for _, missionoffer in ipairs(missionoffers) do
			result = result + (menu.contextMenuData.orders[ConvertIDTo64Bit(missionoffer.id)] or 0)
		end
	end
	return result
end

function menu.getAmmoOrderAmountByWare(ware)
	local result = 0
	local buyoffer = menu.contextMenuData.buyammowares[ware]
	if buyoffer then
		result = result + (menu.contextMenuData.orders[ConvertIDTo64Bit(buyoffer.id)] or 0)
	end
	local selloffer = menu.contextMenuData.sellammowares[ware]
	if selloffer then
		result = result + (menu.contextMenuData.orders[ConvertIDTo64Bit(selloffer.id)] or 0)
	end
	return result
end

function menu.getTradeOfferByID(id)
	for _, tradedata in ipairs(menu.contextMenuData.buyoffers) do
		if IsSameTrade(tradedata.id, id) then
			return tradedata
		end
	end
	for _, tradedata in ipairs(menu.contextMenuData.selloffers) do
		if IsSameTrade(tradedata.id, id) then
			return tradedata
		end
	end
	for _, tradedata in ipairs(menu.contextMenuData.missionoffers) do
		if IsSameTrade(tradedata.id, id) then
			return tradedata
		end
	end

	return nil
end

function menu.getTradeContextStorableAmountAfterTradeOrders(ship, ware, ammotypename)
	if ammotypename == "missile" then
		return C.GetFreeMissileStorageAfterTradeOrders(ship)
	elseif ammotypename == "countermeasure" then
		return C.GetFreeCountermeasureStorageAfterTradeOrders(ship)
	elseif ammotypename == "unit" then
		return GetFreeUnitStorageAfterTradeOrders(ConvertStringToLuaID(tostring(ship)))
	elseif ammotypename == "deployable" then
		return C.GetFreeDeployableStorageAfterTradeOrders(ship)
	end
	return GetFreeCargoAfterTradeOrders(ConvertStringToLuaID(tostring(ship)), ware)
end

function menu.getTradeContextRowContent(waredata)
	local convertedCurrentShip = ConvertStringTo64Bit(tostring(menu.contextMenuData.currentShip))
	local nonVirtualShipCargo = {}
	if menu.contextMenuData.currentShip ~= 0 then
		nonVirtualShipCargo = GetComponentData(convertedCurrentShip, "cargo")
	end
	local convertedTradeOfferContainer = ConvertStringTo64Bit(tostring(menu.contextMenuData.component))
	local isplayertradeoffercontainer, hastradesubscription = GetComponentData(convertedTradeOfferContainer, "isplayerowned", "tradesubscription")
	local name = GetWareData(waredata.ware, "name")
	local activecolor = (waredata.active and Color["text_normal"] or Color["text_inactive"])
	local color = activecolor
	local mouseovertext = ""

	if waredata.mission then
		name = ColorText["text_mission"] .. "\027[menu_mission_trade]\027X" .. name
		local mission = menu.getMissionIDInfoHelper(waredata.mission)
		mouseovertext = ColorText["text_mission"] .. mission.name .. "\027X"
	elseif waredata.issupply then
		name = "\027[maptr_supply]" .. name
	end

	local numillegalfactions = C.GetNumIllegalToFactions(waredata.ware)
	if numillegalfactions > 0 then
		local buf = ffi.new("const char*[?]", numillegalfactions)
		numillegalfactions = C.GetIllegalToFactions(buf, numillegalfactions, waredata.ware)
		local factions = {}
		for i = 0, numillegalfactions - 1 do
			table.insert(factions, ffi.string(buf[i]))
		end

		local first = true
		for _, faction in ipairs(factions) do
			if IsKnownItem("factions", faction) then
				if first then
					name = "\027[workshop_error]" .. name
					color = waredata.active and Color["text_illegal"] or Color["text_illegal_inactive"]
					if mouseovertext ~= "" then
						mouseovertext = mouseovertext .. "\n"
					end
					mouseovertext = mouseovertext .. ColorText["text_illegal"] .. ReadText(1001, 2437) .. ReadText(1001, 120)
					first = false
				end
				mouseovertext = mouseovertext .. "\n" .. GetFactionData(faction, "name")
			end
		end
	end

	local warnings, optionalsellwarnings, optionalbuywarnings = {}, {}, {}
	local pricemodifiers = {}
	local hassellamount, hasbuyamount = false, false

	local buyoffer_curorder = 0
	if waredata.buy then
		buyoffer_curorder = math.max(0, menu.contextMenuData.orders[ConvertIDTo64Bit(waredata.buy.id)] or 0)
	end

	local selloffer_max, selloffer_maxselect, selloffer_curorder = 0, 0, 0
	if waredata.sell then
		if waredata.sell.amount > 0 then
			hassellamount = true
		end
		selloffer_curorder = math.min(0, menu.contextMenuData.orders[ConvertIDTo64Bit(waredata.sell.id)] or 0)
		local affordableamount = isplayertradeoffercontainer and waredata.sell.amount or GetNumAffordableTradeItems(GetPlayerMoney() - menu.contextMenuData.totalsellcost + RoundTotalTradePrice(-(menu.contextMenuData.orders[ConvertIDTo64Bit(waredata.sell.id)] or 0) * waredata.sell.price), waredata.sell.price)
		local storableamount = (menu.contextMenuData.currentShip ~= 0) and menu.getTradeContextStorableAmountAfterTradeOrders(menu.contextMenuData.currentShip, waredata.ware, waredata.sell.ammotypename) or 0
		-- curorder was already added to virtual cargo, don't count it twice
		-- if curorder is currently buying, we need to deduct this amount from the storage amount, too
		storableamount = storableamount - selloffer_curorder - buyoffer_curorder
		selloffer_max = waredata.sell.amount
		selloffer_maxselect = math.min(waredata.sell.amount, affordableamount, storableamount)

		if menu.contextMenuData.currentShip ~= 0 then
			if selloffer_maxselect == 0 then
				if not CheckSuitableTransportType(menu.contextMenuData.currentShip, waredata.ware) then
					warnings[1] = ReadText(1001, 2969)
				elseif storableamount < waredata.sell.amount and storableamount < affordableamount then
					warnings[1] = ReadText(1001, 8337)
				elseif affordableamount < waredata.sell.amount and affordableamount < storableamount then
					warnings[2] = ReadText(1001, 8338)
				end
			else
				if not CheckSuitableTransportType(menu.contextMenuData.currentShip, waredata.ware) then
					optionalsellwarnings[1] = ReadText(1001, 2969)
				elseif storableamount < waredata.sell.amount and storableamount < affordableamount then
					optionalsellwarnings[1] = ReadText(1001, 8337)
				elseif affordableamount < waredata.sell.amount and affordableamount < storableamount then
					optionalsellwarnings[2] = ReadText(1001, 8338)
				end
			end
		end

		if not waredata.sell.active then
			selloffer_max, selloffer_maxselect, selloffer_curorder = 0, 0, 0
		end
	end

	local buyoffer_max, buyoffer_maxselect = 0, 0
	local hasdesiredbuyamount = false
	if waredata.buy then
		if waredata.buy.amount > 0 then
			hasbuyamount = true
		end
		if waredata.buy.desiredamount > 0 then
			hasdesiredbuyamount = true
		end
		local availableamount = (waredata.buy.ammotypename and menu.contextMenuData.currentammo[waredata.ware] or ((menu.contextMenuData.currentcargo[waredata.ware] or 0) - menu.getCargoOrderAmountByWare(waredata.ware) + buyoffer_curorder)) or 0
		buyoffer_maxselect = math.min(waredata.buy.amount, availableamount)
		buyoffer_max = waredata.buy.amount

		local othershipstorableamount
		if menu.contextMenuData.wareexchange then
			othershipstorableamount = menu.getTradeContextStorableAmountAfterTradeOrders(menu.contextMenuData.component, waredata.ware, waredata.buy.ammotypename)
			-- curorder was already added to virtual cargo, don't count it twice
			othershipstorableamount = othershipstorableamount + buyoffer_curorder
			buyoffer_maxselect = math.min(buyoffer_maxselect, othershipstorableamount)
		end

		if menu.contextMenuData.currentShip ~= 0 then
			if buyoffer_maxselect == 0 then
				if menu.contextMenuData.wareexchange and othershipstorableamount < waredata.buy.amount and othershipstorableamount < availableamount then
					warnings[3] = ReadText(1001, 8339)
				elseif availableamount < waredata.buy.amount then
					warnings[4] = ((nonVirtualShipCargo[waredata.ware] or 0) > 0) and ReadText(1001, 8375) or ReadText(1001, 8340)
				end
			else
				if menu.contextMenuData.wareexchange and othershipstorableamount < waredata.buy.amount and othershipstorableamount < availableamount then
					optionalbuywarnings[3] = ReadText(1001, 8339)
				elseif availableamount < waredata.buy.amount then
					optionalbuywarnings[4] = ((nonVirtualShipCargo[waredata.ware] or 0) > 0) and ReadText(1001, 8375) or ReadText(1001, 8340)
				end
			end
		end

		if not waredata.buy.active then
			buyoffer_max, buyoffer_maxselect, buyoffer_curorder = 0, 0, 0
		end
	end

	if not hastradesubscription then
		warnings[6] = ReadText(1001, 11602)
	elseif (not hassellamount) and (not hasbuyamount) then
		if hasdesiredbuyamount then
			warnings[5] = ReadText(1001, 11213)
		else
			warnings[5] = ReadText(1001, 8341)
		end
	end

	-- In case both selloffer and buyoffer exist, we can show both offer amounts, but all other columns can only show data for one offer.
	-- In that case prefer selloffer data (for buying - change to buyoffer when player attempts to sell)
	local tradedata = waredata.sell
	if waredata.buy then
		if (buyoffer_curorder ~= 0) or ((not waredata.sell) or (waredata.sell.amount == 0)) then
			tradedata = waredata.buy
		end
	end

	local avgprice = GetWareData(waredata.ware, "avgprice")
	local adjustment = avgprice ~= 0 and (tradedata.price / avgprice - 1) or 0
	local pricecolor = Helper.interpolatePriceColor(waredata.ware, tradedata.price, tradedata == waredata.sell, activecolor)

	local strquantitybonustype = ""
	if tradedata.quantityfactor > 1 then
		strquantitybonustype = tradedata.isselloffer and ReadText(1001, 2929) or ReadText(1001, 2905)
	else
		strquantitybonustype = tradedata.isselloffer and ReadText(1001, 2904) or ReadText(1001, 2930)
	end
	pricemodifiers[1] = { text = strquantitybonustype, amount = Helper.diffpercent(((tradedata.quantityfactor - 1) * 100) or 0, tradedata.isbuyoffer) .. " %" }

	if tradedata.pricemodifiers and #tradedata.pricemodifiers ~= 0 then
		local modifiersum = 0
		for i, p in ipairs(tradedata.pricemodifiers) do
			if tradedata.isselloffer then
				modifiersum = modifiersum - p.amount
			else
				modifiersum = modifiersum + p.amount
			end
		end

		for i, p in ipairs(tradedata.pricemodifiers) do
			local amount = p.amount
			if tradedata.isselloffer then
				amount = -amount
			end
			if modifiersum ~= 0 then
				amount = amount * math.floor(modifiersum + 0.5) / modifiersum
			end

			table.insert(pricemodifiers, {
				text = p.name .. (p.expire >= 0 and " (" .. Helper.timeDuration(p.expire) .. ")" or ""),
				amount = Helper.diffpercent(Helper.round(amount), tradedata.isbuyoffer) .. " %"
			})
		end
	end
	table.insert(pricemodifiers, { text = ReadText(1001, 11212), amount = Helper.diffpercent(adjustment * 100, tradedata.isbuyoffer) .. " %" })

	local movedamount = -(selloffer_curorder < 0 and selloffer_curorder or buyoffer_curorder)
	local shipamount = (menu.contextMenuData.currentcargo[waredata.ware] or menu.contextMenuData.currentammo[waredata.ware] or 0) + movedamount
	local shipamountcolor = (movedamount > 0 and Color["text_positive"]) or (movedamount < 0 and Color["text_negative"]) or color

	local othershipamount = (menu.contextMenuData.currentothercargo and (menu.contextMenuData.currentothercargo[waredata.ware] or menu.contextMenuData.currentotherammo[waredata.ware]) or 0) - movedamount
	local othershipamountcolor = (movedamount > 0 and Color["text_negative"]) or (movedamount < 0 and Color["text_positive"]) or color

	local scale = {
		--min       = waredata.buy and waredata.buy.ammotypename and -buyoffer_max or -buyoffer_maxselect, -- use real max only for ammo
		min       = -buyoffer_maxselect, --TODO: max
		minselect = -buyoffer_maxselect,
		--max       = waredata.sell and waredata.sell.ammotypename and selloffer_max or selloffer_maxselect, -- use real max only for ammo
		max       = selloffer_maxselect, --TODO: max
		maxselect = selloffer_maxselect,
		start     = movedamount,
		step      = 1,
		suffix    = "",
		fromcenter = true,
		righttoleft = true
	}

	local shiptargetamount = (menu.contextMenuData.currentShip ~= 0) and GetWareProductionLimit(menu.contextMenuData.currentShip, waredata.ware) or 0
	local othershiptargetamount = GetWareProductionLimit(ConvertStringTo64Bit(tostring(menu.contextMenuData.component)), waredata.ware)
	local othershipreserved = C.GetWareReservationsForWare(menu.contextMenuData.component, waredata.ware, false)

	local content = { {}, {}, {}, {}, nil, {}, {}, warnings, optionalsellwarnings, optionalbuywarnings, pricemodifiers }
	-- name
	content[1].text = name
	content[1].color = color
	content[1].mouseover = mouseovertext
	-- price
	if not menu.contextMenuData.wareexchange then
		content[2].text = (not waredata.stale) and ((isplayertradeoffercontainer and "-" or ConvertMoneyString(Helper.round(tradedata.price, 2), true, true, 0, true)) .. " " .. ReadText(1001, 101)) or ""
		content[2].color = pricecolor
		content[2].mouseover = (not waredata.stale) and (isplayertradeoffercontainer and "" or (Helper.diffpercent(adjustment * 100, tradedata.isbuyoffer) .. ReadText(1001, 8304))) or ""
	end
	-- amount
	content[3].text = ConvertIntegerString(shipamount, true, 0, true) .. ((shiptargetamount > 0) and (" (" .. ConvertIntegerString(shiptargetamount, true, 2, true, true) .. ")") or "")
	content[3].color = shipamountcolor
	-- slidercell
	content[4].scale = scale
	content[4].color = color
	if menu.contextMenuData.wareexchange then
		-- other ship amount
		content[6].text = ConvertIntegerString(othershipamount, true, 0, true) .. ((othershiptargetamount > 0) and (" (" .. ConvertIntegerString(othershiptargetamount, true, 2, true, true) .. ")") or "")
		content[6].color = othershipamountcolor
		if othershipreserved > 0 then
			content[6].mouseover = string.format(ReadText(1026, 3266), ConvertIntegerString(othershipreserved, true, 0, true))
		end
	else
		-- sell offer
		content[6].text = (waredata.sell and (not waredata.sell.stale)) and ConvertIntegerString(waredata.sell.amount - math.max(movedamount, 0), true, 0, true) or ""
		content[6].color = color
		-- buy offer
		content[7].text = (waredata.buy and (not waredata.buy.stale)) and (hasbuyamount and ConvertIntegerString(waredata.buy.amount - math.max(-movedamount, 0), true, 0, true) or (hasdesiredbuyamount and ConvertIntegerString(waredata.buy.desiredamount - math.max(-movedamount, 0), true, 0, true) or "")) or ""
		content[7].color = color
	end
	return content
end

-- Only use this to get initial storage data. If we use this with every virtual storage change, we have to reset virtual cargo every time wares are removed from virtual cargo of othercontainer in the menu. Otherwise, this will result in a mismatch between the storage data in the menu and after the actual trade because each change is treated as a separate trade in virtual cargo.
-- For example: If we add A, add B, then remove A; virtual cargo treats this as three separate transactions and will fill storage accordingly; but the actual trade will only have one transaction: add B.
function menu.getTradeContextInitialStorageData(container, transporttypes, aftertradeorders)
	local numtransporttypes = C.GetNumCargoTransportTypes(container, true)
	local virtualtransporttypes = ffi.new("StorageInfo[?]", numtransporttypes)
	numtransporttypes = C.GetCargoTransportTypes(virtualtransporttypes, numtransporttypes, container, true, aftertradeorders)

	--typedef struct {
	--	const char* name;
	--	const char* transport;
	--	uint32_t spaceused;
	--	uint32_t capacity;
	--} StorageInfo;

	for _, transporttype in ipairs(transporttypes) do
		for j = 0, numtransporttypes - 1 do
			local tags = menu.getTransportTagsFromString(ffi.string(virtualtransporttypes[j].transport))

			local invalid = false
			for tag, _ in pairs(tags) do
				if not transporttype.tags[tag] then invalid = true; break end
			end
			if not invalid then
				for tag, _ in pairs(transporttype.tags) do
					if not tags[tag] then invalid = true; break end
				end
			end
			if not invalid then
				transporttype.initialstored = virtualtransporttypes[j].spaceused
				break
			end
		end
	end
end

function menu.getTradeContextShipStorageContent(othership)
	local storagecontent = {}

	for i, transporttype in ipairs(othership and menu.contextMenuData.othershiptransporttypes or menu.contextMenuData.transporttypes) do
		if i > menu.tradeContext.numinforows then
			break
		end
		local spaceused = transporttype.stored
		spaceused = math.max(0, math.min(spaceused, transporttype.capacity))
		table.insert(storagecontent, {
			name = transporttype.name,
			color = Color["text_normal"],
			scale = {
				min       = 0,
				max       = transporttype.capacity,
				start     = spaceused,
				step      = 1,
				suffix    = ReadText(1001, 110),
				readonly  = true
			}
		})
	end

	-- add empty line if one ship has ammo of a type, but other doesn't
	for _, ammotype in ipairs(menu.contextMenuData.ammotypes) do
		if #storagecontent >= menu.tradeContext.numinforows then
			break
		end
		local spaceused = othership and ammotype.otherstored or ammotype.stored
		local capacity = othership and ammotype.othercapacity or ammotype.capacity
		spaceused = math.max(0, math.min(spaceused, capacity))
		table.insert(storagecontent, {
			name = ammotype.name,
			color = Color["text_normal"],
			scale = {
				min       = 0,
				max       = capacity,
				start     = spaceused,
				step      = 1,
				suffix    = "     ",
				readonly  = true
			}
		})
	end

	return storagecontent
end

function menu.createTradeContext(frame)
	menu.skipTradeRowChange = true

	local convertedTradeOfferContainer = ConvertStringTo64Bit(tostring(menu.contextMenuData.component))
	local isplayertradeoffercontainer = GetComponentData(convertedTradeOfferContainer, "isplayerowned")

	AddUITriggeredEvent(menu.name, "trade_context", ConvertStringToLuaID(convertedTradeOfferContainer))

	menu.updateTradeCost()
	local convertedCurrentShip = ConvertStringTo64Bit(tostring(menu.contextMenuData.currentShip))

	-- menu setup
	local width = menu.contextMenuData.width
	local amountcolumnwidth = 100
	local pricecolumnwidth = 100

	local columnwidth_ware   -- calculated below
	local columnwidth_price			= math.floor(width * 12 / 100)
	local columnwidth_shipstorage	= math.floor(width * 12 / 100)
	local columnwidth_sliderleft	= math.floor(width * 15 / 100)
	local columnwidth_sliderright	= math.floor(width * 15 / 100)
	local columnwidth_selloffer		= math.floor(width * 12 / 100)
	local columnwidth_buyoffer		= math.floor(width * 12 / 100)
	local columnwidth_reservation	= Helper.scaleY(config.mapRowHeight)
	if menu.contextMenuData.wareexchange then
		-- nearly symmetrical menu layout in ware exchange case:
		--   price column = only a dummy in this case, always included in colspan.
		--   selloffer column = other ship storage
		--   buyoffer column = unused (almost same width as ware column)
		columnwidth_price = 1
		local remainingwidth = width - 6 * Helper.borderSize
			- columnwidth_price
			- columnwidth_shipstorage
			- columnwidth_sliderleft
			- columnwidth_sliderright
			- columnwidth_selloffer
		-- nearly symmetrical menu layout:
		columnwidth_ware = math.ceil(remainingwidth / 2)
		columnwidth_buyoffer = remainingwidth - columnwidth_ware
	else
		-- regular trade case
		columnwidth_ware = width - 6 * Helper.borderSize
			- columnwidth_price
			- columnwidth_shipstorage
			- columnwidth_sliderleft
			- columnwidth_sliderright
			- columnwidth_selloffer
			- columnwidth_buyoffer
	end

	-- ship
	local shiptable = frame:addTable(9, { tabOrder = 2, maxVisibleHeight = menu.tradeContext.shipheight, x = Helper.borderSize, y = Helper.borderSize, width = menu.contextMenuData.width, reserveScrollBar = false })
	shiptable:setColWidth(1, columnwidth_ware, false)
	shiptable:setColWidth(2, columnwidth_price, false)
	shiptable:setColWidth(3, columnwidth_shipstorage, false)
	shiptable:setColWidth(4, columnwidth_sliderleft, false)
	shiptable:setColWidth(5, columnwidth_sliderright, false)
	shiptable:setColWidth(6, columnwidth_reservation, false)
	shiptable:setColWidth(7, columnwidth_selloffer - columnwidth_reservation - Helper.borderSize, false)
	shiptable:setColWidth(8, columnwidth_reservation, false)
	shiptable:setColWidth(9, columnwidth_buyoffer - columnwidth_reservation - Helper.borderSize, false)
	shiptable:setDefaultBackgroundColSpan(1, 9)

	local shipOptions = {}
	local curShipOption = tostring(convertedCurrentShip)

	local sortedShips = {}
	local found = false
	for _, ship in ipairs(menu.contextMenuData.ships) do
		local shipid = ConvertIDTo64Bit(ship.shipid)
		if shipid == convertedCurrentShip then
			found = true
		end

		local class = ffi.string(C.GetComponentClass(ConvertStringTo64Bit(tostring(ship.shipid))))
		local icon, primarypurpose = GetComponentData(ship.shipid, "icon", "primarypurpose")
		local i = menu.findEntryByShipIcon(sortedShips, icon)
		if i then
			table.insert(sortedShips[i].ships, { shipid = shipid, name = ship.name })
		else
			table.insert(sortedShips, { icon = icon, class = class, purpose = primarypurpose, ships = { { shipid = shipid, name = ship.name } } })
		end
	end
	if (not found) and (menu.contextMenuData.currentShip ~= 0) then
		local ship = { shipid = convertedCurrentShip, name = ffi.string(C.GetComponentName(menu.contextMenuData.currentShip)) }

		local class = ffi.string(C.GetComponentClass(menu.contextMenuData.currentShip))
		local icon, primarypurpose = GetComponentData(ship.shipid, "icon", "primarypurpose")
		local i = menu.findEntryByShipIcon(sortedShips, icon)
		if i then
			table.insert(sortedShips[i].ships, ship)
		else
			table.insert(sortedShips, { icon = icon, class = class, purpose = primarypurpose, ships = { ship } })
		end
	end
	table.sort(sortedShips, menu.sortShipsByClassAndPurposeReverse)

	for _, data in ipairs(sortedShips) do
		table.sort(data.ships, Helper.sortName)
		for _, ship in ipairs(data.ships) do
			table.insert(shipOptions, { id = tostring(ship.shipid), text = "\27[" .. data.icon .. "] " .. ship.name .. " (" .. ffi.string(C.GetObjectIDCode(ship.shipid)) .. ")", icon = "", displayremoveoption = false })
		end
	end

	local iscapship = IsComponentClass(convertedCurrentShip, "ship_l") or IsComponentClass(convertedCurrentShip, "ship_xl")
	local ispartnersmallship = IsComponentClass(convertedTradeOfferContainer, "ship_m") or IsComponentClass(convertedTradeOfferContainer, "ship_s")
	local missingdrones = true
	if iscapship and (not ispartnersmallship) then
		local shipunits = GetUnitStorageData(convertedCurrentShip, "transport")
		local stationunits = GetUnitStorageData(convertedTradeOfferContainer, "transport")
		for _, unit in ipairs(shipunits) do
			if unit.amount > 0 then
				missingdrones = false
				break
			end
		end
		if missingdrones then
			for _, unit in ipairs(stationunits) do
				if unit.amount > 0 then
					missingdrones = false
					break
				end
			end
		end
	else
		missingdrones = false
	end
	local candock = true
	if convertedCurrentShip and (convertedCurrentShip ~= 0) then
		if (not menu.contextMenuData.wareexchange) or IsComponentClass(convertedTradeOfferContainer, "station") then
			candock = IsDockingPossible(convertedCurrentShip, convertedTradeOfferContainer, nil, true)
		end
	end
	local isplayertraderestricted = isplayertradeoffercontainer and C.IsContainerTradingWithFactionRescricted(menu.contextMenuData.component, "player")

	local shipsectorname, blacklistgroup = "", "civilian"
	if convertedCurrentShip and (convertedCurrentShip ~= 0) then
		shipsectorname, blacklistgroup = GetComponentData(convertedCurrentShip, "sector", "blacklistgroup")
	end
	local stationsector = ConvertIDTo64Bit(GetComponentData(convertedTradeOfferContainer, "sectorid"))

	-- title
	local row = shiptable:addRow(true, { fixed = true, bgColor = Color["row_title_background"] })
	row[1]:setBackgroundColSpan(4):setColSpan(4):createDropDown(shipOptions, { startOption = curShipOption, height = Helper.headerRow1Height, helpOverlayID = "trade_context_shipOptions", helpOverlayText = " ", helpOverlayHighlightOnly = true,  }):setTextProperties({ halign = "center", font = Helper.headerRow1Font, fontsize = Helper.headerRow1FontSize, color = Color["text_player"] })
	row[1].handlers.onDropDownConfirmed = menu.dropdownShip

	local name = Helper.unlockInfo(IsInfoUnlockedForPlayer(convertedTradeOfferContainer, "name"), ffi.string(C.GetComponentName(menu.contextMenuData.component)) .. " (" .. ffi.string(C.GetObjectIDCode(menu.contextMenuData.component)) .. ")")
	local color = Color["text_normal"]
	if isplayertradeoffercontainer then
		color = Color["text_player"]
	end
	local mouseovertext
	if C.IsComponentBlacklisted(convertedTradeOfferContainer, "objectactivity", blacklistgroup, convertedCurrentShip) then
		color = Color["text_warning"]
		if convertedCurrentShip and (convertedCurrentShip ~= 0) then
			mouseovertext = ColorText["text_warning"] .. ReadText(1026, 3257)
		else
			mouseovertext = ColorText["text_warning"] .. ReadText(1026, 3256)
		end
	end
	if mouseovertext then
		if convertedCurrentShip and (convertedCurrentShip ~= 0) then
			mouseovertext = mouseovertext .. "\27X\n" .. ReadText(1026, 3258)
		end
	end
	row[5]:setColSpan(5):createText(name, { halign = "center", color = color, font = Helper.headerRow1Font, fontsize = Helper.headerRow1FontSize, x = Helper.headerRow1Offsetx, y = Helper.headerRow1Offsety, mouseOverText = mouseovertext })

	-- locations
	local row = shiptable:addRow(true, { fixed = true, bgColor = Color["row_background_unselectable"] })
	row[1]:setBackgroundColSpan(4):setColSpan(4):createText(shipsectorname, { halign = "center" })

	local color = Color["text_normal"]
	local mouseovertext
	if C.IsComponentBlacklisted(stationsector, "sectortravel", blacklistgroup, convertedCurrentShip) then
		color = Color["text_warning"]
		if convertedCurrentShip and (convertedCurrentShip ~= 0) then
			mouseovertext = ColorText["text_warning"] .. ReadText(1026, 3253)
		else
			mouseovertext = ColorText["text_warning"] .. ReadText(1026, 3252)
		end
	end
	if C.IsComponentBlacklisted(stationsector, "sectoractivity", blacklistgroup, convertedCurrentShip) then
		color = Color["text_warning"]
		if mouseovertext then
			mouseovertext = mouseovertext .. "\n"
		else
			mouseovertext = ""
		end
		if convertedCurrentShip and (convertedCurrentShip ~= 0) then
			mouseovertext = mouseovertext .. ColorText["text_warning"] .. ReadText(1026, 3255)
		else
			mouseovertext = mouseovertext .. ColorText["text_warning"] .. ReadText(1026, 3254)
		end
	end
	if mouseovertext then
		if convertedCurrentShip and (convertedCurrentShip ~= 0) then
			mouseovertext = mouseovertext .. "\27X\n" .. ReadText(1026, 3258)
		end
	end
	row[5]:setColSpan(5):createText(ffi.string(C.GetComponentName(stationsector)), { halign = "center", color = color, mouseOverText = mouseovertext })

	-- table header
	local hasshiptargetamounts = false
	local hasothershipttargetamounts = false
	for i, waredata in ipairs(menu.contextMenuData.waredatalist) do
		local shiptargetamount = 0
		if menu.contextMenuData.currentShip ~= 0 then
			shiptargetamount = GetWareProductionLimit(menu.contextMenuData.currentShip, waredata.ware)
		end
		if shiptargetamount > 0 then
			hasshiptargetamounts = true
			if hasothershipttargetamounts then
				break
			end
		end
		local othershiptargetamount = GetWareProductionLimit(ConvertStringTo64Bit(tostring(menu.contextMenuData.component)), waredata.ware)
		if othershiptargetamount > 0 then
			hasothershipttargetamounts = true
			if hasshiptargetamounts then
				break
			end
		end
	end

	local row = shiptable:addRow(nil, { fixed = true, bgColor = Color["row_background_unselectable"] })
	if menu.contextMenuData.wareexchange then
		row[1]:setColSpan(2):setBackgroundColSpan(1):createText(ReadText(1001, 45), { font = Helper.standardFontBold })
		row[3]:setColSpan(3):createText(ReadText(1001, 5) .. (hasshiptargetamounts and (" (" .. ReadText(1001, 2903) .. ")") or ""), { font = Helper.standardFontBold })
		row[6]:setColSpan(4):createText(((C.IsComponentClass(menu.contextMenuData.component, "ship") and ReadText(1001, 5)) or (C.IsComponentClass(menu.contextMenuData.component, "station") and ReadText(1001, 3)) or ReadText(1001, 9426)) .. (hasothershipttargetamounts and (" (" .. ReadText(1001, 2903) .. ")") or ""), { font = Helper.standardFontBold })
	else
		row[1]:setBackgroundColSpan(1):createText(ReadText(1001, 45), { font = Helper.standardFontBold })
		row[2]:createText(ReadText(1001, 2808), { font = Helper.standardFontBold })
		row[3]:setColSpan(2):createText(ReadText(1001, 5) .. (hasshiptargetamounts and (" (" .. ReadText(1001, 2903) .. ")") or ""), { font = Helper.standardFontBold })
		row[6]:setColSpan(2):createText(ReadText(1001, 8308), { font = Helper.standardFontBold })
		row[8]:setColSpan(2):createText(ReadText(1001, 8309), { font = Helper.standardFontBold })
	end

	-- line
	local row = shiptable:addRow(nil, { fixed = true, bgColor = Color["row_separator"] })
	row[1]:setColSpan(9):createText("", { fontsize = 1, height = 1 })

	-- ware list
	local warningcontent = {}
	local pricemodifiers = {}
	local warningcolor = Color["text_error"]

	local maxVisibleHeight

	if #menu.contextMenuData.waredatalist == 0 then
		menu.selectedTradeWare = nil
		local row = shiptable:addRow(nil, {  })
		row[1]:setColSpan(9):createText(menu.contextMenuData.wareexchange and ReadText(1001, 8310) or ReadText(1001, 8311))
	else
		-- check selectedTradeWare
		local tradewarefound = false
		if menu.selectedTradeWare then
			for i, waredata in ipairs(menu.contextMenuData.waredatalist) do
				if (waredata.ware == menu.selectedTradeWare.ware) and (waredata.mission == menu.selectedTradeWare.mission) then
					tradewarefound = true
					break
				end
			end
			if not tradewarefound then
				menu.selectedTradeWare = nil
			end
		end

		local reservations, missionreservations = {}, {}
		local n = C.GetNumContainerWareReservations2(menu.contextMenuData.component, true, true, true)
		local buf = ffi.new("WareReservationInfo2[?]", n)
		n = C.GetContainerWareReservations2(buf, n, menu.contextMenuData.component, true, true, true)
		for i = 0, n - 1 do
			if (buf[i].missionid ~= 0) or (not buf[i].isvirtual) then
				local ware = ffi.string(buf[i].ware)
				local buyflag = buf[i].isbuyreservation and "selloffer" or "buyoffer" -- sic! Reservation to buy -> container is selling
				local invbuyflag = buf[i].isbuyreservation and "buyoffer" or "selloffer"
				local reservationref = (buf[i].missionid ~= 0) and missionreservations or reservations
				if reservationref[ware] then
					table.insert(reservationref[ware][buyflag], { reserver = buf[i].reserverid, amount = buf[i].amount, eta = buf[i].eta, mission = buf[i].missionid })
				else
					reservationref[ware] = { [buyflag] = { { reserver = buf[i].reserverid, amount = buf[i].amount, eta = buf[i].eta, mission = buf[i].missionid } }, [invbuyflag] = {} }
				end
			end
		end
		for _, data in pairs(reservations) do
			table.sort(data.buyoffer, menu.etaSorter)
			table.sort(data.selloffer, menu.etaSorter)
		end
		for _, data in pairs(missionreservations) do
			table.sort(data.buyoffer, menu.etaSorter)
			table.sort(data.selloffer, menu.etaSorter)
		end

		for i, waredata in ipairs(menu.contextMenuData.waredatalist) do
			local content = menu.getTradeContextRowContent(waredata)

			local row = shiptable:addRow({ ware = waredata.ware, mission = waredata.mission }, {  })
			local callback = menu.getAmmoTypeNameByWare(waredata.ware) and menu.slidercellShipAmmo or menu.slidercellShipCargo
			if menu.contextMenuData.wareexchange then
				row[1]:setColSpan(2):createText(content[1].text, { color = content[1].color })
				row[3]:createText(content[3].text, { color = content[3].color, halign = "right" })
				row[4]:setColSpan(2):createSliderCell({ start = content[4].scale.start, min = content[4].scale.min, minSelect = content[4].scale.minselect, max = content[4].scale.max, maxSelect = content[4].scale.maxselect, step = content[4].scale.step, suffix = content[4].scale.suffix, fromCenter = content[4].scale.fromcenter, rightToLeft = content[4].scale.righttoleft, height = Helper.standardTextHeight })
				row[4].handlers.onSliderCellChanged = function (_, value) return callback(waredata.sell and waredata.sell.id, waredata.buy and waredata.buy.id, waredata.ware, 0, value) end
				row[4].handlers.onSliderCellConfirm = function () return menu.slidercellTradeConfirmed(waredata.ware) end
				waredata.sellcol = 6
				row[6]:setColSpan(2):createText(content[6].text, { color = content[6].color, halign = "right", mouseOverText = content[6].mouseover })
			else
				row[1]:createText(content[1].text, { color = content[1].color, mouseOverText = content[1].mouseover })
				row[2]:createText(content[2].text, { color = content[2].color, halign = "right", mouseOverText = content[2].mouseover })
				row[3]:createText(content[3].text, { color = content[3].color, halign = "right" })
				row[4]:setColSpan(2):createSliderCell({ start = content[4].scale.start, min = content[4].scale.min, minSelect = content[4].scale.minselect, max = content[4].scale.max, maxSelect = content[4].scale.maxselect, step = content[4].scale.step, suffix = content[4].scale.suffix, fromCenter = content[4].scale.fromcenter, rightToLeft = content[4].scale.righttoleft, height = Helper.standardTextHeight })
				row[4].handlers.onSliderCellChanged = function (_, value) return callback(waredata.sell and waredata.sell.id, waredata.buy and waredata.buy.id, waredata.ware, 0, value) end
				row[4].handlers.onSliderCellConfirm = function () return menu.slidercellTradeConfirmed(waredata.ware) end

				local reservationref = waredata.mission and missionreservations or reservations
				local colspan = 2
				if reservationref[waredata.ware] and (#reservationref[waredata.ware].selloffer > 0) then
					local mouseovertext = ""
					for i, reservation in ipairs(reservationref[waredata.ware].selloffer) do
						if (not waredata.mission) or (waredata.mission == reservation.mission) then
							local isplayerowned = GetComponentData(ConvertStringTo64Bit(tostring(reservation.reserver)), "isplayerowned")
							if isplayerowned or isplayertradeoffercontainer then
								if mouseovertext ~= "" then
									mouseovertext = mouseovertext .. "\n"
								end
								local name = (isplayerowned and ColorText["text_player"] or "") .. ffi.string(C.GetComponentName(reservation.reserver)) .. " (" .. ffi.string(C.GetObjectIDCode(reservation.reserver)) .. ")\27X"
								mouseovertext = mouseovertext .. name .. " - " .. (waredata.mission and ColorText["text_mission"] or "") .. ReadText(1001, 1202) .. ReadText(1001, 120) .. " " .. ConvertIntegerString(reservation.amount, true, 0, true) .. "\27X"
							end
						end
					end
					if mouseovertext ~= "" then
						colspan = 1
						mouseovertext = ReadText(1001, 7946) .. ReadText(1001, 120) .. "\n" .. mouseovertext
						row[6]:createIcon("menu_hourglass", { color = waredata.mission and Color["text_mission"] or nil, height = config.mapRowHeight, mouseOverText = mouseovertext })
					end
				end
				waredata.sellcol = 8 - colspan
				row[8 - colspan]:setColSpan(colspan):createText(content[6].text, { color = content[6].color, halign = "right", mouseOverText = content[6].mouseover })
				colspan = 2
				if reservationref[waredata.ware] and (#reservationref[waredata.ware].buyoffer > 0) then
					local mouseovertext = ""
					for i, reservation in ipairs(reservationref[waredata.ware].buyoffer) do
						if (not waredata.mission) or (waredata.mission == reservation.mission) then
							local isplayerowned = GetComponentData(ConvertStringTo64Bit(tostring(reservation.reserver)), "isplayerowned")
							if isplayerowned or isplayertradeoffercontainer then
								if mouseovertext ~= "" then
									mouseovertext = mouseovertext .. "\n"
								end
								local name = (isplayerowned and ColorText["text_player"] or "") .. ffi.string(C.GetComponentName(reservation.reserver)) .. " (" .. ffi.string(C.GetObjectIDCode(reservation.reserver)) .. ")\27X"
								mouseovertext = mouseovertext .. name .. " - " .. (waredata.mission and ColorText["text_mission"] or "") .. ReadText(1001, 1202) .. ReadText(1001, 120) .. " " .. ConvertIntegerString(reservation.amount, true, 0, true) .. "\27X"
							end
						end
					end
					if mouseovertext ~= "" then
						colspan = 1
						mouseovertext = ReadText(1001, 7946) .. ReadText(1001, 120) .. "\n" .. mouseovertext
						row[8]:createIcon("menu_hourglass", { color = waredata.mission and Color["text_mission"] or nil, height = config.mapRowHeight, mouseOverText = mouseovertext })
					end
				end
				waredata.buycol = 10 - colspan
				row[10 - colspan]:setColSpan(colspan):createText(content[7].text, { color = content[7].color, halign = "right" })
			end

			if not menu.selectedRows.contextshiptable then
				if (waredata.sell and IsSameTrade(waredata.sell.id, menu.contextMenuData.tradeid)) or (waredata.buy and IsSameTrade(waredata.buy.id, menu.contextMenuData.tradeid)) then
					menu.selectedTradeWare = { ware = waredata.ware, mission = waredata.mission }
					menu.topRows.contextshiptable = math.min(4 + i, 4 + #menu.contextMenuData.waredatalist - (menu.tradeContext.warescrollwindowsize - 1))
					shiptable:setSelectedRow(row.index)
				end
			end
			if not menu.selectedTradeWare then
				menu.selectedTradeWare = { ware = waredata.ware, mission = waredata.mission }
			end
			if (waredata.ware == menu.selectedTradeWare.ware) and (waredata.mission == menu.selectedTradeWare.mission) then
				warningcontent = content[8]
				if waredata.ware == menu.showOptionalWarningWare then
					if (content[4].scale.start ~= 0) and (content[4].scale.start == content[4].scale.maxselect) then
						warningcontent = content[9]
						warningcolor = Color["text_warning"]
					elseif (content[4].scale.start ~= 0) and (content[4].scale.start == content[4].scale.minselect) then
						warningcontent = content[10]
						warningcolor = Color["text_warning"]
					else
						menu.showOptionalWarningWare = nil
					end
				end

				pricemodifiers = content[11]
			end

			if i == menu.tradeContext.warescrollwindowsize then
				maxVisibleHeight = shiptable:getFullHeight()
			end
		end
	end

	shiptable.properties.maxVisibleHeight = maxVisibleHeight or shiptable:getFullHeight()

	shiptable:setTopRow(menu.topRows.contextshiptable)
	if menu.selectedRows.contextshiptable then
		shiptable:setSelectedRow(menu.selectedRows.contextshiptable)
	end
	menu.topRows.contextshiptable = nil
	menu.selectedRows.contextshiptable = nil

	-- info and buttons
	-- the button table is split into left and right side below the "zero" position of the sliders
	local columnwidth_bottomleft		= columnwidth_ware + columnwidth_price + columnwidth_shipstorage + columnwidth_sliderleft + 3 * Helper.borderSize
	local columnwidth_bottomright		= columnwidth_sliderright + columnwidth_selloffer + columnwidth_buyoffer + 2 * Helper.borderSize
	-- trade menu case:
	-- split bottom right twice: Once into 2/3 + 1/3 for money output, and 1/2 + 1/2 for the buttons
	-- A-----------------------------------------B------------C----D--------E
	-- | Ship storage details  (bottomleft)      | Profits:        | 100 Cr |
	-- +-----------------------------------------+------------+----+--------+
	-- |                                         | LeftButton | RightButton |
	-- +-----------------------------------------+------------+----+--------+
	local columnwidth_br_leftoutput		= math.floor((columnwidth_bottomright - Helper.borderSize) * 2 / 3)			-- BD
	local columnwidth_br_rightoutput	= columnwidth_bottomright - columnwidth_br_leftoutput - Helper.borderSize	-- DE
	local columnwidth_br_leftbutton		= math.floor((columnwidth_bottomright - Helper.borderSize) / 2)				-- BC
	local columnwidth_br_rightbutton	= columnwidth_bottomright - columnwidth_br_leftbutton - Helper.borderSize	-- CE
	local columnwidth_br_bottomoverlap	= columnwidth_bottomright - columnwidth_br_leftbutton - columnwidth_br_rightoutput - 2 * Helper.borderSize			-- CD
	-- ware exchange menu case:
	-- "zero" position is in the center. Split bottom right twice, so that each button occupies ca. 20% of the width (40% together)
	-- A-----------------------------------B-----C------------D-------------E
	-- | Ship storage details (bottomleft) | Other ship storage details     |
	-- +-----------------------------------+-----+------------+-------------+
	-- |                                         | LeftButton | RightButton |
	-- +-----------------------------------+-----+------------+-------------+
	local columnwidth_wx_br_leftbutton	= math.floor((columnwidth_bottomright - 2 * Helper.borderSize) * 2 / 5)		-- CD
	local columnwidth_wx_br_rightbutton	= columnwidth_wx_br_leftbutton												-- DE
	local columnwidth_wx_br_leftspacing	= columnwidth_bottomright - columnwidth_wx_br_leftbutton - columnwidth_wx_br_rightbutton - 2 * Helper.borderSize	-- BC

	local showdiscountinfo = (not menu.contextMenuData.wareexchange) and (not isplayertradeoffercontainer)
	local numcols = showdiscountinfo and 6 or 4
	local coloffset = showdiscountinfo and 2 or 0
	menu.tradeContext.coloffset = coloffset
	local buttontable = frame:addTable(numcols, { tabOrder = 3, x = Helper.borderSize, y = shiptable.properties.y + shiptable:getVisibleHeight() + Helper.borderSize, width = menu.contextMenuData.width, reserveScrollBar = false })
	if showdiscountinfo then
		buttontable:setColWidth(1, 2 * math.floor(columnwidth_bottomleft / 3), false)
		buttontable:setColWidth(2, math.floor(0.6 * columnwidth_bottomleft / 3) - 2 * Helper.borderSize, false)
		buttontable:setColWidth(3, math.floor(0.4 * columnwidth_bottomleft / 3), false)
		buttontable:setColWidth(4, columnwidth_br_leftbutton,     false)
		buttontable:setColWidth(5, columnwidth_br_bottomoverlap,  false)
		buttontable:setColWidth(6, columnwidth_br_rightoutput,    false)
		buttontable:setDefaultBackgroundColSpan(2, 2)
		buttontable:setDefaultBackgroundColSpan(4, 3)
	elseif menu.contextMenuData.wareexchange then
		buttontable:setColWidth(1, columnwidth_bottomleft, false)
		buttontable:setColWidth(2, columnwidth_wx_br_leftspacing, false)
		buttontable:setColWidth(3, columnwidth_wx_br_leftbutton,  false)
		buttontable:setColWidth(4, columnwidth_wx_br_rightbutton, false)
		buttontable:setDefaultBackgroundColSpan(2, 3)
	else
		buttontable:setColWidth(1, columnwidth_bottomleft, false)
		buttontable:setColWidth(2, columnwidth_br_leftbutton,     false)
		buttontable:setColWidth(3, columnwidth_br_bottomoverlap,  false)
		buttontable:setColWidth(4, columnwidth_br_rightoutput,    false)
		buttontable:setDefaultBackgroundColSpan(2, 3)
	end

	-- line
	local row = buttontable:addRow(nil, { fixed = true, bgColor = Color["row_separator"] })
	row[1]:setColSpan(numcols):createText("", { fontsize = 1, height = 1 })

	-- rows
	local headerrow = buttontable:addRow(nil, { fixed = true, bgColor = Color["row_background_unselectable"] })
	local inforows = {}
	local warningrows = {}
	for i = 1, menu.tradeContext.numinforows do
		inforows[i] = buttontable:addRow(nil, { fixed = true })
	end
	local headerrow2 = buttontable:addRow(nil, { fixed = true })
	for i = 1, menu.tradeContext.numwarningrows do
		warningrows[i] = buttontable:addRow(i == menu.tradeContext.numwarningrows, { fixed = true })
	end

	-- storage details
	local storagecontent = menu.getTradeContextShipStorageContent()
	local storageheader = #storagecontent > 0 and ReadText(1001,8312) or ReadText(1001,8313)
	for i, content in ipairs(storagecontent) do
		if i <= menu.tradeContext.numinforows then
			inforows[i][1]:createSliderCell({ min = content.scale.min, max = content.scale.max, start = content.scale.start, step = content.scale.step, suffix = content.scale.suffix, readOnly = content.scale.readonly, height = Helper.standardTextHeight }):setText(content.name, { color = content.color })
		end
	end

	-- warnings
	local i = 0
	if not candock then
		i = i + 1
		if i <= menu.tradeContext.numwarningrows then
			warningrows[i][1]:createText(ReadText(1001, 6211), { color = Color["text_error"] })
		end
	end
	if missingdrones then
		i = i + 1
		if i <= menu.tradeContext.numwarningrows then
			warningrows[i][1]:createText(ReadText(1001, 2978), { color = Color["text_error"] })
		end
	end

	for _, content in pairs(warningcontent) do
		i = i + 1
		if i <= menu.tradeContext.numwarningrows then
			warningrows[i][1]:createText(content, { color = warningcolor, wordwrap = true })
		end
	end

	if isplayertraderestricted then
		i = i + 1
		if i <= menu.tradeContext.numwarningrows then
			warningrows[i][1]:createText(ReadText(1001, 6212), { color = Color["text_warning"] })
		end
	end

	local confirmbuttonactive = false
	if candock and (not missingdrones) then
		for _, amount in pairs(menu.contextMenuData.orders) do
			if amount ~= 0 then
				confirmbuttonactive = true
				break
			end
		end
	end

	if menu.contextMenuData.wareexchange then
		local otherstoragecontent = menu.getTradeContextShipStorageContent(true)
		local otherstorageheader = #otherstoragecontent > 0 and
			(
				(C.IsComponentClass(menu.contextMenuData.component, "ship") and ReadText(1001, 8312))
				or (C.IsComponentClass(menu.contextMenuData.component, "station") and ReadText(1001, 8314))
				or ReadText(1001,8316)
			)
			or (
				(C.IsComponentClass(menu.contextMenuData.component, "ship") and ReadText(1001, 8313))
				or (C.IsComponentClass(menu.contextMenuData.component, "station") and ReadText(1001, 8315))
				or ReadText(1001,8317)
			)

		-- header
		headerrow[1]:createText(storageheader, { halign = "center", font = Helper.standardFontBold })
		headerrow[2]:setColSpan(3):createText(otherstorageheader, { halign = "center", font = Helper.standardFontBold })

		-- other ship info
		for i = 1, menu.tradeContext.numinforows do
			local content = otherstoragecontent[i]
			if content then
				inforows[i][2]:setColSpan(3):createSliderCell({ min = content.scale.min, max = content.scale.max, start = content.scale.start, step = content.scale.step, suffix = content.scale.suffix, readOnly = content.scale.readonly, height = Helper.standardTextHeight }):setText(content.name, { color = content.color })
			end
		end

		-- warning header
		headerrow2[1]:createText(next(warningcontent) and ReadText(1001, 8342) or "", { halign = "center", font = Helper.standardFontBold })

		-- buttons
		warningrows[menu.tradeContext.numwarningrows][3]:createButton({ active = confirmbuttonactive, height = Helper.standardTextHeight }):setText(ReadText(1001, 2821), { halign = "center" })
		warningrows[menu.tradeContext.numwarningrows][3].handlers.onClick = menu.buttonConfirmTrade
		warningrows[menu.tradeContext.numwarningrows][3].properties.uiTriggerID = "confirmtrade"
		warningrows[menu.tradeContext.numwarningrows][4]:createButton({ height = Helper.standardTextHeight }):setText(ReadText(1001, 64), { halign = "center" })
		warningrows[menu.tradeContext.numwarningrows][4].handlers.onClick = menu.buttonCancelTrade
		warningrows[menu.tradeContext.numwarningrows][4].properties.uiTriggerID = "canceltrade"
	else
		-- profits from sales
		local profit = menu.contextMenuData.referenceprofit
		local profitcolor = Color["text_normal"]
		if profit < 0 then
			profitcolor = Color["text_negative"]
		elseif profit > 0 then
			profitcolor = Color["text_positive"]
		end
		inforows[menu.tradeContext.numinforows - 1][2 + coloffset]:createText(ReadText(1001, 8305) .. ReadText(1001, 120))
		inforows[menu.tradeContext.numinforows - 1][3 + coloffset]:setColSpan(2):createText(ConvertMoneyString(profit, false, true, nil, true) .. " " .. ReadText(1001, 101), { halign = "right", color = profitcolor })

		-- transaction value
		local total = menu.contextMenuData.totalbuyprofit - menu.contextMenuData.totalsellcost
		local transactioncolor = Color["text_normal"]
		if total < 0 then
			transactioncolor = Color["text_negative"]
		elseif total > 0 then
			transactioncolor = Color["text_positive"]
		end
		inforows[menu.tradeContext.numinforows][2 + coloffset]:createText(ReadText(1001, 2005) .. ReadText(1001, 120)) -- Transaction value, :
		inforows[menu.tradeContext.numinforows][3 + coloffset]:setColSpan(2):createText(ConvertMoneyString(total, false, true, nil, true) .. " " .. ReadText(1001, 101), { halign = "right", color = transactioncolor })

		-- pricing details
		if showdiscountinfo and (#pricemodifiers > 0) then
			for i, entry in ipairs(pricemodifiers) do
				if i < #pricemodifiers then
					local row
					if i <= menu.tradeContext.numinforows then
						row = inforows[i]
					elseif i == menu.tradeContext.numinforows + 1 then
						row = headerrow2
					elseif i <= menu.tradeContext.numinforows + 1 + menu.tradeContext.numwarningrows - 1 then
						row = warningrows[i - menu.tradeContext.numinforows - 1]
					end
					if row then
						row[2]:createText(entry.text, { x = config.tradeContextMenuInfoBorder })
						row[3]:createText(entry.amount, { x = config.tradeContextMenuInfoBorder, halign = "right" })
					end
				end
			end
			local y = math.max(0, warningrows[menu.tradeContext.numwarningrows]:getHeight() - Helper.scaleY(Helper.standardTextHeight))
			warningrows[menu.tradeContext.numwarningrows][2]:createText(pricemodifiers[#pricemodifiers].text, { scaling = false, fontsize = Helper.scaleFont(Helper.standardFont, Helper.standardFontSize), x = Helper.scaleX(config.tradeContextMenuInfoBorder), y = y })
			warningrows[menu.tradeContext.numwarningrows][3]:createText(pricemodifiers[#pricemodifiers].amount, { scaling = false, fontsize = Helper.scaleFont(Helper.standardFont, Helper.standardFontSize), x = Helper.scaleX(config.tradeContextMenuInfoBorder), y = y, halign = "right" })
		end

		-- header
		headerrow[1]:createText(storageheader, { halign = "center", font = Helper.standardFontBold })
		if showdiscountinfo then
			headerrow[2]:setColSpan(2):createText(ReadText(1001, 11211), { halign = "center", font = Helper.standardFontBold })
		end
		headerrow[2 + coloffset]:setColSpan(3):createText(ReadText(1001, 2006), { halign = "center", font = Helper.standardFontBold })

		-- warning header
		headerrow2[1]:createText(next(warningcontent) and ReadText(1001, 8342) or "", { halign = "center", font = Helper.standardFontBold })

		-- buttons
		local y = math.max(0, warningrows[menu.tradeContext.numwarningrows]:getHeight() - Helper.scaleY(Helper.standardTextHeight))
		if (not GetComponentData(menu.contextMenuData.component, "tradesubscription")) and (#menu.contextMenuData.missionoffers == 0) then
			warningrows[menu.tradeContext.numwarningrows][2 + coloffset]:createButton({ active = (menu.contextMenuData.currentShip ~= 0) and C.IsOrderSelectableFor("Player_DockToTrade", menu.contextMenuData.currentShip), scaling = false, height = Helper.scaleY(Helper.standardTextHeight), y = y }):setText(ReadText(1001, 7858), { scaling = true, halign = "center" })
			warningrows[menu.tradeContext.numwarningrows][2 + coloffset].handlers.onClick = menu.buttonDockToTrade
		else
			warningrows[menu.tradeContext.numwarningrows][2 + coloffset]:createButton({ active = confirmbuttonactive, helpOverlayID = "map_confirmtrade", helpOverlayText = " ", helpOverlayHighlightOnly = true, scaling = false, height = Helper.scaleY(Helper.standardTextHeight), y = y }):setText(ReadText(1001, 2821), { scaling = true, halign = "center" })
			warningrows[menu.tradeContext.numwarningrows][2 + coloffset].handlers.onClick = menu.buttonConfirmTrade
			warningrows[menu.tradeContext.numwarningrows][2 + coloffset].properties.uiTriggerID = "confirmtrade"
		end
		warningrows[menu.tradeContext.numwarningrows][3 + coloffset]:setColSpan(2):createButton({ scaling = false, height = Helper.scaleY(Helper.standardTextHeight), y = y }):setText(ReadText(1001, 64), { scaling = true, halign = "center" })
		warningrows[menu.tradeContext.numwarningrows][3 + coloffset].handlers.onClick = menu.buttonCancelTrade
		warningrows[menu.tradeContext.numwarningrows][3 + coloffset].properties.uiTriggerID = "canceltrade"
	end

	if buttontable.properties.y + buttontable:getFullHeight() > Helper.viewHeight - frame.properties.y then
		frame.properties.y = Helper.viewHeight - buttontable.properties.y - buttontable:getFullHeight() - Helper.frameBorder
	end

	shiptable.properties.nextTable = buttontable.index
	buttontable.properties.prevTable = shiptable.index
end

function menu.createTradeLoopContext(frame)
	local shiptable = frame:addTable(3, { tabOrder = 2, x = Helper.borderSize, y = Helper.borderSize, width = menu.contextMenuData.width, highlightMode = "off" })

	-- title
	local row = shiptable:addRow(nil, { fixed = true })
	row[1]:setColSpan(3):createText(ReadText(1001, 11273), Helper.headerRowCenteredProperties)

	local row = shiptable:addRow(nil, { fixed = true })
	local name, color = "", Color["text_normal"]
	if C.IsComponentClass(menu.contextMenuData.component, "container") then
		name, color = menu.getContainerNameAndColors(menu.contextMenuData.component, 0, false, false)
		row[1]:setColSpan(3):createText(ReadText(1001, (menu.contextMenuData.loop == "SingleBuy") and 11110 or 11111) .. ReadText(1001, 120) .. " " .. Helper.convertColorToText(color) .. name, Helper.headerRowCenteredProperties)
	else
		name = ffi.string(C.GetComponentName(menu.contextMenuData.component))
		row[1]:setColSpan(3):createText(ReadText(1001, (menu.contextMenuData.loop == "SingleBuy") and 11112 or 11113) .. ReadText(1001, 120) .. " " .. Helper.convertColorToText(color) .. name, Helper.headerRowCenteredProperties)
	end

	-- ware list
	local row = shiptable:addRow(nil, { fixed = true })
	row[1]:setColSpan(3):createText(ReadText(1001, 11276) .. ReadText(1001, 120))

	local waresinloop = {}
	local maxbought, minsold = {}, {}
	local n = C.GetNumOrders(menu.contextMenuData.currentShip)
	local buf = ffi.new("Order[?]", n)
	n = C.GetOrders(buf, n, menu.contextMenuData.currentShip)
	for i = 0, n - 1 do
		if ffi.string(buf[i].orderdef) == "SingleBuy" then
			local orderparams = GetOrderParams(ConvertStringTo64Bit(tostring(menu.contextMenuData.currentShip)), i + 1)
			if next(orderparams) then
				local ware
				if orderparams[1].type == "ware" then
					ware = orderparams[1].value
				end
				local maxamount = 0
				if orderparams[5].type == "number" then
					maxamount = math.floor(orderparams[5].value)
				end
				if ware then
					if not waresinloop[ware] then
						waresinloop[ware] = GetWareData(ware, "name")
					end
					if maxbought[ware] then
						maxbought[ware] = math.max(maxamount, maxbought[ware])
					else
						maxbought[ware] = maxamount
					end
				end
			end
		elseif ffi.string(buf[i].orderdef) == "SingleSell" then
			local orderparams = GetOrderParams(ConvertStringTo64Bit(tostring(menu.contextMenuData.currentShip)), i + 1)
			if next(orderparams) then
				local ware
				if orderparams[1].type == "ware" then
					ware = orderparams[1].value
				end
				local maxamount = 0
				if orderparams[5].type == "number" then
					maxamount = math.floor(orderparams[5].value)
				end
				if ware then
					if not waresinloop[ware] then
						waresinloop[ware] = GetWareData(ware, "name")
					end
					if minsold[ware] then
						minsold[ware] = math.min(maxamount, minsold[ware])
					else
						minsold[ware] = maxamount
					end
				end
			end
		end
	end

	local sortedwares = {}
	for ware, name in pairs(waresinloop) do
		table.insert(sortedwares, { ware = ware, name = name })
	end
	table.sort(sortedwares, Helper.sortName)
	if #sortedwares > 0 then
		for i, entry in ipairs(sortedwares) do
			local row = shiptable:addRow(true, {  })
			row[1]:setColSpan(2):createText("   " .. entry.name)
			local availableamount = 0
			if minsold[entry.ware] then
				if maxbought[entry.ware] then
					if minsold[entry.ware] > maxbought[entry.ware] then
						availableamount = maxbought[entry.ware]
					else
						availableamount = minsold[entry.ware]
					end
				end
			elseif maxbought[entry.ware] then
				availableamount = maxbought[entry.ware]
			end
			row[3]:createText(availableamount, { halign = "right" })
			if i == 5 then
				shiptable.properties.maxVisibleHeight = shiptable:getFullHeight()
			end
		end
	else
		local row = shiptable:addRow(true, {  })
		row[1]:setColSpan(2):createText("   ---")
	end

	-- info & buttons
	local buttontable = frame:addTable(4, { tabOrder = 1, x = Helper.borderSize, y = shiptable.properties.y + shiptable:getVisibleHeight(), width = menu.contextMenuData.width })
	local colwidth = math.floor((menu.contextMenuData.width - 2 * Helper.borderSize) / 3)
	local checkboxwidth = Helper.scaleY(Helper.standardTextHeight)
	buttontable:setColWidth(1, checkboxwidth, false)
	buttontable:setColWidth(2, colwidth - checkboxwidth, false)

	-- cargo
	local cargo = GetComponentData(menu.contextMenuData.currentShip, "cargo")
	local extrawares = {}
	for ware, amount in pairs(cargo) do
		if not maxbought[ware] then
			extrawares[ware] = amount
		elseif amount > maxbought[ware] then
			extrawares[ware] = amount - maxbought[ware]
		end
	end

	local transportypes = menu.getCargoTransportTypes(menu.contextMenuData.currentShip, false)
	for _, transporttype in ipairs(transportypes) do
		transporttype.usedcargocapacity = 0
		for ware, amount in pairs(maxbought) do
			local transport, volume = GetWareData(ware, "transport", "volume")
			if transporttype.tags[transport] then
				transporttype.usedcargocapacity = transporttype.usedcargocapacity + amount * volume
			end
		end
		for ware, amount in pairs(extrawares) do
			local transport, volume = GetWareData(ware, "transport", "volume")
			if transporttype.tags[transport] then
				transporttype.usedcargocapacity = transporttype.usedcargocapacity + amount * volume
			end
		end
		transporttype.usedcargocapacity = math.max(0, math.min(transporttype.capacity, transporttype.usedcargocapacity))
		local row = buttontable:addRow(nil, { fixed = true })
		row[1]:setColSpan(4):createSliderCell({ min = 0, max = transporttype.capacity, start = transporttype.usedcargocapacity, step = 1, suffix = ReadText(1001, 110), readOnly = true, height = Helper.standardTextHeight }):setText(ReadText(1001, 11277))
	end

	if menu.contextMenuData.loop == "SingleBuy" then
		-- use ware reservations
		local row = buttontable:addRow(true, { fixed = true })
		menu.contextMenuData.reservecargo = C.GetShipTradeLoopCargoReservationSetting(menu.contextMenuData.currentShip)
		row[1]:createCheckBox(menu.contextMenuData.reservecargo, { height = Helper.standardTextHeight, width = Helper.standardTextHeight, mouseOverText = ReadText(1026, 3275) })
		row[1].handlers.onClick = function () C.SetShipTradeLoopCargoReservationOverride(menu.contextMenuData.currentShip, not menu.contextMenuData.reservecargo); menu.refreshContextFrame() end
		row[2]:setColSpan(3):createText(ReadText(1001, 11641), { mouseOverText = ReadText(1026, 3275) })
	end

	buttontable:addEmptyRow(config.mapRowHeight / 2)

	-- destination
	local row = buttontable:addRow(nil, { fixed = true })
	row[1]:setColSpan(2):createText(ReadText(1001, 11278))
	row[3]:setColSpan(2):createText(name, { halign = "center" })

	local tradewares, foundwares, currentwareactive = {}, {}
	local tradeoffers = GetTradeList(menu.contextMenuData.component, menu.contextMenuData.currentShip, false)
	for _, tradedata in pairs(tradeoffers) do
		if ((menu.contextMenuData.loop == "SingleBuy") and tradedata.isselloffer) or ((menu.contextMenuData.loop == "SingleSell") and tradedata.isbuyoffer) then
			if not foundwares[tradedata.ware] then
				foundwares[tradedata.ware] = true

				local name, transport = GetWareData(tradedata.ware, "name", "transport")
				local active = C.CanContainerTransport(menu.contextMenuData.currentShip, transport)
				if (tradedata.ware == menu.contextMenuData.ware) and active then
					currentwareactive = true
				end
				table.insert(tradewares, { id = tradedata.ware, text = name, icon = "", displayremoveoption = false, active = active, mouseovertext = active and "" or ReadText(1001, 2969) })
			end
		end
	end
	table.sort(tradewares, function (a, b) return a.text < b.text end)
	if not currentwareactive then
		menu.contextMenuData.ware = nil
	end

	if menu.contextMenuData.loop == "SingleBuy" then
		-- buy ware
		local row = buttontable:addRow(true, { fixed = true })
		row[1]:setColSpan(2):createText(ReadText(1001, 11279))
		row[3]:setColSpan(2):createDropDown(tradewares, { startOption = menu.contextMenuData.ware, height = config.mapRowHeight }):setTextProperties({ halign = "center" })
		row[3].handlers.onDropDownConfirmed = function (_, ware) menu.contextMenuData.ware = ware; menu.contextMenuData.amount = nil; menu.contextMenuData.price = nil; menu.refreshContextFrame() end

		-- buy up to
		local row = buttontable:addRow(true, { fixed = true })
		row[1]:setColSpan(2):createText(ReadText(1001, 11281))
		menu.contextMenuData.max = 1
		if menu.contextMenuData.ware then
			local volume, transport = GetWareData(menu.contextMenuData.ware, "volume", "transport")
			for _, transporttype in ipairs(transportypes) do
				if transporttype.tags[transport] then
					local capacity = transporttype.capacity
					if menu.contextMenuData.reservecargo then
						capacity = capacity - transporttype.usedcargocapacity
					end
					menu.contextMenuData.max = math.floor(capacity / volume)
					if menu.contextMenuData.reservecargo then
						menu.contextMenuData.max = menu.contextMenuData.max + (maxbought[menu.contextMenuData.ware] or 0)
					end
				end
			end
		end
		local minselect = 1
		if menu.contextMenuData.max == 0 then
			minselect = 0
			menu.contextMenuData.amount = 0
		elseif menu.contextMenuData.amount then
			menu.contextMenuData.amount = math.max(minselect, menu.contextMenuData.amount)
		end
		local start = menu.contextMenuData.amount or menu.contextMenuData.max
		start = math.min(start, menu.contextMenuData.max)
		row[3]:setColSpan(2):createSliderCell({ min = 0, minSelect = minselect, max = menu.contextMenuData.max, start = start, step = 1, height = Helper.standardTextHeight })
		row[3].handlers.onSliderCellChanged = function (_, value) menu.contextMenuData.amount = value end

		-- max price
		local row = buttontable:addRow(true, { fixed = true })
		row[1]:setColSpan(2):createText(ReadText(1041, 10059))
		local avgprice, minprice, maxprice = 0, 0, 0
		if menu.contextMenuData.ware then
			avgprice, minprice, maxprice = GetWareData(menu.contextMenuData.ware, "avgprice", "minprice", "maxprice")
		end
		row[3]:setColSpan(2):createSliderCell({ min = minprice, max = maxprice, start = menu.contextMenuData.price or avgprice, step = 1, height = Helper.standardTextHeight, suffix = ReadText(1001, 101), hideMaxValue = true })
		row[3].handlers.onSliderCellChanged = function (_, value) menu.contextMenuData.price = value end
	else
		-- sell ware
		local row = buttontable:addRow(true, { fixed = true })
		row[1]:setColSpan(2):createText(ReadText(1001, 11280))
		row[3]:setColSpan(2):createDropDown(tradewares, { startOption = menu.contextMenuData.ware, height = config.mapRowHeight }):setTextProperties({ halign = "center" })
		row[3].handlers.onDropDownConfirmed = function (_, ware) menu.contextMenuData.ware = ware; menu.contextMenuData.amount = nil; menu.contextMenuData.price = nil; menu.refreshContextFrame() end

		-- sell all but
		local row = buttontable:addRow(true, { fixed = true })
		row[1]:setColSpan(2):createText(ReadText(1001, 11601))
		menu.contextMenuData.max = 0
		if menu.contextMenuData.ware then
			menu.contextMenuData.max = GetWareCapacity(menu.contextMenuData.currentShip, menu.contextMenuData.ware)
		end
		row[3]:setColSpan(2):createSliderCell({ min = 0, max = menu.contextMenuData.max, start = menu.contextMenuData.amount or 0, step = 1, height = Helper.standardTextHeight })
		row[3].handlers.onSliderCellChanged = function (_, value) menu.contextMenuData.amount = value end

		-- min price
		local row = buttontable:addRow(true, { fixed = true })
		row[1]:setColSpan(2):createText(ReadText(1041, 10070))
		local avgprice, minprice, maxprice = 0, 0, 0
		if menu.contextMenuData.ware then
			avgprice, minprice, maxprice = GetWareData(menu.contextMenuData.ware, "avgprice", "minprice", "maxprice")
		end
		row[3]:setColSpan(2):createSliderCell({ min = minprice, max = maxprice, start = menu.contextMenuData.price or avgprice, step = 1, height = Helper.standardTextHeight, suffix = ReadText(1001, 101), hideMaxValue = true })
		row[3].handlers.onSliderCellChanged = function (_, value) menu.contextMenuData.price = value end
	end

	buttontable:addEmptyRow(config.mapRowHeight / 2)

	local row = buttontable:addRow(true, { fixed = true })
	local active = true
	local mouseovertext = ""
	if menu.contextMenuData.ware == nil then
		active = false
		mouseovertext = ReadText(1026, 3260)
	elseif (menu.contextMenuData.loop == "SingleBuy") and (menu.contextMenuData.amount == 0) then
		active = false
		mouseovertext = ColorText["text_error"] .. ReadText(1001, 1605)
	end
	row[1]:setColSpan(2):createButton({ active = active, mouseOverText = mouseovertext }):setText(ReadText(1001, 2821), { halign = "center" })
	row[1].handlers.onClick = menu.buttonConfirmTradeLoop
	row[4]:createButton({  }):setText(ReadText(1001, 64), { halign = "center" })
	row[4].handlers.onClick = function () return menu.closeContextMenu("back") end

	if menu.contextselectedrow then
		buttontable:setSelectedRow(menu.contextselectedrow)
		menu.contextselectedrow = nil
	end

	shiptable.properties.nextTable = buttontable.index
	buttontable.properties.prevTable = shiptable.index

	-- adjust frame position
	if frame.properties.x + menu.contextMenuData.width > Helper.viewWidth then
		frame.properties.x = Helper.viewWidth - menu.contextMenuData.width - Helper.frameBorder
	end
	local neededheight = buttontable.properties.y + buttontable:getVisibleHeight()
	if frame.properties.y + neededheight > Helper.viewHeight then
		menu.contextMenuData.yoffset = Helper.viewHeight - neededheight - Helper.frameBorder
		frame.properties.y = menu.contextMenuData.yoffset
	end
end

function menu.initCrewTransferData()
	menu.contextMenuData.crew = { left = { total = 0, moved = 0, capacity = C.GetPeopleCapacity(menu.contextMenuData.leftShip, "", false), transferList = {} }, right = { total = 0, moved = 0, capacity = C.GetPeopleCapacity(menu.contextMenuData.rightShip, "", false), transferList = {} }, exchangeCaptains = false }
	menu.contextMenuData.crew.right.isplayerowned = true
	if C.IsComponentClass(menu.contextMenuData.rightShip, "station") then
		local isshipyard, iswharf, isequipmentdock, isplayerowned = GetComponentData(menu.contextMenuData.rightShip, "isshipyard", "iswharf", "isequipmentdock", "isplayerowned")
		menu.contextMenuData.crew.right.isstation = true
		menu.contextMenuData.crew.right.isplayerowned = isplayerowned
		if isshipyard or iswharf or isequipmentdock then
			menu.contextMenuData.crew.right.hasshiptraderpost = true
		end
		menu.contextMenuData.crew.right.canhavetrainees = C.CanControllableHaveAnyTrainees(menu.contextMenuData.rightShip)
	end
	local isrightassignmentrestricted = GetComponentData(menu.contextMenuData.rightShip, "isnpcassignmentrestricted")
	menu.contextMenuData.crew.right.canassignpilot = (not menu.contextMenuData.crew.right.isstation) and (not isrightassignmentrestricted)

	local missionnpcrequirements = {}
	menu.contextMenuData.rightMissionOffers = {}
	local numskills = C.GetNumSkills()
	if menu.contextMenuData.crew.right.isstation and (not menu.contextMenuData.crew.right.isplayerowned) then
		-- mission npc requirements
		local n = C.GetNumRequestedMissionNPCs(menu.contextMenuData.rightShip)
		local buf = ffi.new("MissionNPCInfo[?]", n)
		for i = 0, n - 1 do
			buf[i].numskills = numskills
			buf[i].skills = Helper.ffiNewHelper("SkillInfo[?]", numskills)
		end
		n = C.GetRequestedMissionNPCs(buf, n, menu.contextMenuData.rightShip)
		for i = 0, n - 1 do
			local skills = {}
			for j = 0, buf[i].numskills - 1 do
				table.insert(skills, { id = ffi.string(buf[i].skills[j].id), value = buf[i].skills[j].value })
			end
			local missionid = ConvertStringTo64Bit(tostring(buf[i].missionid))
			local amount = buf[i].amount
			table.insert(missionnpcrequirements, { missionid = missionid, amount = amount, requiredskills = skills })
			menu.contextMenuData.rightMissionOffers[tostring(missionid)] = { amount = amount, transferred = 0 }
		end
	end

	-- virtual crew
	local leftvirtualpeople = {}
	local n = C.GetNumPeopleAfterOrders(menu.contextMenuData.leftShip, 0)
	local buf = ffi.new("NPCInfo[?]", n)
	n = C.GetPeopleAfterOrders(buf, n, menu.contextMenuData.leftShip, 0)
	for i = 0, n - 1 do
		local seed = buf[i].seed
		local role = ffi.string(buf[i].roleid)
		local tier = buf[i].tierid
		local name = ffi.string(buf[i].name)
		local skill = math.floor(buf[i].combinedskill * 15 / 100)
		local arrived = C.HasPersonArrived(menu.contextMenuData.leftShip, seed) and (not C.IsPersonTransferScheduled(menu.contextMenuData.leftShip, seed))
		local missionids = menu.checkMissionNPCRequirement(missionnpcrequirements, menu.contextMenuData.leftShip, seed, numskills)

		if menu.contextMenuData.crew.right.isplayerowned or (#missionids > 0) then
			if leftvirtualpeople[role] then
				if leftvirtualpeople[role][tier] then
					table.insert(leftvirtualpeople[role][tier], { seed = seed, name = name, skill = skill, arrived = arrived, missionids = missionids })
					if arrived then
						leftvirtualpeople[role][tier].numarrived = leftvirtualpeople[role][tier].numarrived + 1
					end
				else
					leftvirtualpeople[role][tier] = { numarrived = arrived and 1 or 0, { seed = seed, name = name, skill = skill, arrived = arrived, missionids = missionids } }
				end
			else
				leftvirtualpeople[role] = { [tier] = { numarrived = arrived and 1 or 0, { seed = seed, name = name, skill = skill, arrived = arrived, missionids = missionids } } }
			end
		end
	end
	local rightvirtualpeople = {}
	local n = C.GetNumPeopleAfterOrders(menu.contextMenuData.rightShip, 0)
	local buf = ffi.new("NPCInfo[?]", n)
	n = C.GetPeopleAfterOrders(buf, n, menu.contextMenuData.rightShip, 0)
	for i = 0, n - 1 do
		local seed = buf[i].seed
		local name = ffi.string(buf[i].name)
		local role = ffi.string(buf[i].roleid)
		local tier = buf[i].tierid
		local skill = math.floor(buf[i].combinedskill * 15 / 100)
		if menu.contextMenuData.crew.right.canhavetrainees and (role == "trainee_group") then
			role = "marine"
			tier = C.GetPersonTier(seed, role, menu.contextMenuData.rightShip)
			skill = math.floor(C.GetPersonCombinedSkill(menu.contextMenuData.rightShip, seed, role, nil) * 15 / 100)
		end
		local arrived = C.HasPersonArrived(menu.contextMenuData.rightShip, seed) and (not C.IsPersonTransferScheduled(menu.contextMenuData.rightShip, seed))

		if rightvirtualpeople[role] then
			if rightvirtualpeople[role][tier] then
				table.insert(rightvirtualpeople[role][tier], { seed = seed, name = name, skill = skill, arrived = arrived })
				if arrived then
					rightvirtualpeople[role][tier].numarrived = rightvirtualpeople[role][tier].numarrived + 1
				end
			else
				rightvirtualpeople[role][tier] = { numarrived = arrived and 1 or 0, { seed = seed, name = name, skill = skill, arrived = arrived } }
			end
		else
			rightvirtualpeople[role] = { [tier] = { numarrived = arrived and 1 or 0, { seed = seed, name = name, skill = skill, arrived = arrived } } }
		end
	end

	-- left crew
	local numroles = C.GetNumAllRoles()
	local peopletable = ffi.new("PeopleInfo[?]", numroles)
	numroles = C.GetPeople2(peopletable, numroles, menu.contextMenuData.leftShip, true)
	local index = 1
	for i = 0, numroles - 1 do
		local role = ffi.string(peopletable[i].id)
		local numtiers = peopletable[i].numtiers
		if numtiers > 0 then
			menu.contextMenuData.crew[index] = { id = role, name = ffi.string(peopletable[i].name), tiers = {} }

			local tiertable = ffi.new("RoleTierData[?]", numtiers)
			numtiers = C.GetRoleTiers(tiertable, numtiers, menu.contextMenuData.leftShip, role)
			for j = 0, numtiers - 1 do
				local virtualpeopleentry = leftvirtualpeople[role] and (leftvirtualpeople[role][tiertable[j].skilllevel] or { numarrived = 0 }) or { numarrived = 0 }

				menu.contextMenuData.crew[index].tiers[j + 1] = { name = ffi.string(tiertable[j].name), skilllevel = tiertable[j].skilllevel, left = { amount = virtualpeopleentry.numarrived, persons = {}, moved = {} }, right = { amount = 0, persons = {}, moved = {} } }
				menu.contextMenuData.crew.left.total = menu.contextMenuData.crew.left.total + #virtualpeopleentry

				for k, entry in ipairs(virtualpeopleentry) do
					table.insert(menu.contextMenuData.crew[index].tiers[j + 1].left.persons, entry)
				end
			end

			index = index + 1
		elseif role == "unassigned" then
			local name = ffi.string(peopletable[i].name)
			menu.contextMenuData.crew[index] = { id = role, name = name, tiers = {} }

			local virtualpeopleentry = leftvirtualpeople[role] and (leftvirtualpeople[role][0] or { numarrived = 0 }) or { numarrived = 0 }

			menu.contextMenuData.crew[index].tiers[1] = { name = name, skilllevel = 0, left = { amount = virtualpeopleentry.numarrived, persons = {}, moved = {} }, right = { amount = 0, persons = {}, moved = {} } }
			menu.contextMenuData.crew.left.total = menu.contextMenuData.crew.left.total + #virtualpeopleentry

			for k, entry in ipairs(virtualpeopleentry) do
				table.insert(menu.contextMenuData.crew[index].tiers[1].left.persons, entry)
			end

			index = index + 1
		else
			local virtualpeopleentry = leftvirtualpeople[role] and (leftvirtualpeople[role][0] or { numarrived = 0 }) or { numarrived = 0 }
			menu.contextMenuData.crew.left.total = menu.contextMenuData.crew.left.total + #virtualpeopleentry
		end
	end
	-- right crew
	numroles = C.GetPeople2(peopletable, numroles, menu.contextMenuData.rightShip, true)
	index = 1
	for i = 0, numroles - 1 do
		local role = ffi.string(peopletable[i].id)
		local numtiers = peopletable[i].numtiers
		if numtiers > 0 then
			role = menu.contextMenuData.crew[index].id
			local tiertable = ffi.new("RoleTierData[?]", numtiers)
			numtiers = C.GetRoleTiers(tiertable, numtiers, menu.contextMenuData.rightShip, role)
			for j = 0, numtiers - 1 do
				local virtualpeopleentry = rightvirtualpeople[role] and (rightvirtualpeople[role][tiertable[j].skilllevel] or { numarrived = 0 }) or { numarrived = 0 }

				menu.contextMenuData.crew[index].tiers[j + 1].right.amount = virtualpeopleentry.numarrived
				menu.contextMenuData.crew.right.total = menu.contextMenuData.crew.right.total + #virtualpeopleentry

				for k, entry in ipairs(virtualpeopleentry) do
					table.insert(menu.contextMenuData.crew[index].tiers[j + 1].right.persons, entry)
				end
			end

			index = index + 1
		elseif role == "unassigned" then
			local virtualpeopleentry = rightvirtualpeople[role] and (rightvirtualpeople[role][0] or { numarrived = 0 }) or { numarrived = 0 }

			menu.contextMenuData.crew[index].tiers[1].right.amount = virtualpeopleentry.numarrived
			menu.contextMenuData.crew.right.total = menu.contextMenuData.crew.right.total + #virtualpeopleentry

			for k, entry in ipairs(virtualpeopleentry) do
				table.insert(menu.contextMenuData.crew[index].tiers[1].right.persons, entry)
			end

			index = index + 1
		else
			local virtualpeopleentry = rightvirtualpeople[role] and (rightvirtualpeople[role][0] or { numarrived = 0 }) or { numarrived = 0 }
			menu.contextMenuData.crew.right.total = menu.contextMenuData.crew.right.total + #virtualpeopleentry
		end
	end
	-- sorting
	for i, roleentry in ipairs(menu.contextMenuData.crew) do
		for j, tierentry in ipairs(roleentry.tiers) do
			table.sort(tierentry.left.persons, menu.crewTransferSorter)
			table.sort(tierentry.right.persons, menu.crewTransferSorter)
		end
	end
end

function menu.createCrewTransferContext(frame)
	local numberwidth = 50
	local separatorwidth = 2
	local namewidth = 0.35 * menu.contextMenuData.width - 2 * Helper.scaleY(Helper.standardTextHeight) - Helper.scaleX(numberwidth) - separatorwidth / 2 - 5 * Helper.borderSize
	local numListRows = 8

	-- warnings and buttons
	local buttontable = frame:addTable(3, { tabOrder = 3, x = Helper.borderSize, width = menu.contextMenuData.width })
	buttontable:setColWidthPercent(2, 25)
	buttontable:setColWidthPercent(3, 25)

	local leftname, lefticon =  GetComponentData(menu.contextMenuData.leftShip, "name", "icon")
	local rightname, righticon =  GetComponentData(menu.contextMenuData.rightShip, "name", "icon")

	local row = buttontable:addRow(nil, { fixed = true })
	row[1]:setColSpan(3):createText(function () return menu.crewTransferWarningText(leftname, rightname, 1) end, { halign = "right", color = Color["text_error"] })
	local row = buttontable:addRow(nil, { fixed = true })
	row[1]:setColSpan(3):createText(function () return menu.crewTransferWarningText(leftname, rightname, 2) end, { halign = "right", color = Color["text_error"] })

	local row = buttontable:addRow(true, { fixed = true })
	row[2]:createButton({ active = menu.crewTransferAllowed }):setText(ReadText(1001, 2821), { halign = "center" })
	row[2].handlers.onClick = menu.buttonCrewTransferConfirm
	row[3]:createButton({  }):setText(ReadText(1001, 64), { halign = "center" })
	row[3].handlers.onClick = function () return menu.closeContextMenu("back") end

	local shiptable = frame:addTable(11, { tabOrder = 2, x = Helper.borderSize, y = Helper.borderSize, width = menu.contextMenuData.width })
	shiptable:setColWidth(1, Helper.scaleY(Helper.standardTextHeight), false)
	shiptable:setColWidth(2, namewidth, false)
	shiptable:setColWidth(3, numberwidth)
	shiptable:setColWidthPercent(4, 15)
	shiptable:setColWidth(5, Helper.scaleY(Helper.standardTextHeight), false)
	shiptable:setColWidth(6, separatorwidth, false)
	shiptable:setColWidth(7, Helper.scaleY(Helper.standardTextHeight), false)
	shiptable:setColWidthPercent(8, 15)
	shiptable:setColWidth(9, numberwidth)
	shiptable:setColWidth(11, Helper.scaleY(Helper.standardTextHeight), false)

	-- title
	local row = shiptable:addRow(nil, { fixed = true })
	row[1]:setColSpan(11):createText(ReadText(1001, 8385), Helper.headerRowCenteredProperties)

	-- ships
	local row = shiptable:addRow(nil, { fixed = true })
	local leftShipName = "\27[" .. lefticon .. "] " .. leftname .. " (" .. ffi.string(C.GetObjectIDCode(menu.contextMenuData.leftShip)) .. ")"
	row[1]:setColSpan(5):createText(leftShipName, { halign = "center", color = Color["text_player"], font = Helper.headerRow1Font, fontsize = Helper.headerRow1FontSize, x = Helper.headerRow1Offsetx, y = Helper.headerRow1Offsety })
	local rightShipName = "\27[" .. righticon .. "] " .. rightname .. " (" .. ffi.string(C.GetObjectIDCode(menu.contextMenuData.rightShip)) .. ")"
	row[7]:setColSpan(5):createText(rightShipName, { halign = "center", color = menu.contextMenuData.crew.right.isplayerowned and Color["text_player"] or Color["text_normal"], font = Helper.headerRow1Font, fontsize = Helper.headerRow1FontSize, x = Helper.headerRow1Offsetx, y = Helper.headerRow1Offsety })

	shiptable:addEmptyRow(config.mapRowHeight / 2)

	menu.contextMenuData.crew.left.captain = GetComponentData(menu.contextMenuData.leftShip, "assignedaipilot")
	if menu.contextMenuData.crew.left.captain then
		menu.contextMenuData.crew.left.captain = ConvertIDTo64Bit(menu.contextMenuData.crew.left.captain)
	end

	if menu.contextMenuData.crew.right.isplayerowned then
		-- captain
		local row = shiptable:addRow(nil, { fixed = true })
		if menu.contextMenuData.crew.right.isstation then
			row[1]:setColSpan(5):createText(ReadText(20208, 30101), Helper.subHeaderTextProperties)
			row[1].properties.halign = "center"
			row[7]:setColSpan(5):createText(ReadText(20208, 30301), Helper.subHeaderTextProperties)
			row[7].properties.halign = "center"
		else
			row[1]:setColSpan(11):createText(ReadText(20208, 30101), Helper.subHeaderTextProperties)
			row[1].properties.halign = "center"
		end

		if menu.contextMenuData.crew.right.isstation then
			local tradenpc, shiptrader = GetComponentData(menu.contextMenuData.rightShip, "tradenpc", "shiptrader")
			menu.contextMenuData.crew.right.manager = tradenpc
			if menu.contextMenuData.crew.right.manager then
				menu.contextMenuData.crew.right.manager = ConvertIDTo64Bit(menu.contextMenuData.crew.right.manager)
			end
			if menu.contextMenuData.crew.right.hasshiptraderpost then
				menu.contextMenuData.crew.right.shiptrader = shiptrader
				if menu.contextMenuData.crew.right.shiptrader then
					menu.contextMenuData.crew.right.shiptrader = ConvertIDTo64Bit(menu.contextMenuData.crew.right.shiptrader)
				end
			end
		else
			menu.contextMenuData.crew.right.captain = GetComponentData(menu.contextMenuData.rightShip, "assignedaipilot")
			if menu.contextMenuData.crew.right.captain then
				menu.contextMenuData.crew.right.captain = ConvertIDTo64Bit(menu.contextMenuData.crew.right.captain)
			end
		end

		-- current captains
		local row = shiptable:addRow(nil, { fixed = true })
		if menu.contextMenuData.crew.left.captain then
			row[1]:setColSpan(3):createText(ffi.string(C.GetComponentName(menu.contextMenuData.crew.left.captain)), { color = Color["text_inactive"] })
			row[4]:createText(Helper.displaySkill(C.GetEntityCombinedSkill(menu.contextMenuData.crew.left.captain, nil, "aipilot") * 15 / 100), { halign = "right", color = Color["text_inactive"] })
		else
			row[1]:setColSpan(3):createText(ReadText(1001, 11232), { color = Color["text_inactive"] })
		end

		row[6]:createText("", { cellBGColor = Color["row_separator_white"], x = 0 })

		if menu.contextMenuData.crew.right.isstation then
			if menu.contextMenuData.crew.right.manager then
				row[8]:setColSpan(2):createText(Helper.displaySkill(C.GetEntityCombinedSkill(menu.contextMenuData.crew.right.manager, nil, "manager") * 15 / 100), { color = Color["text_inactive"] })
				row[10]:setColSpan(2):createText(ffi.string(C.GetComponentName(menu.contextMenuData.crew.right.manager)), { halign = "right", color = Color["text_inactive"] })
			else
				row[10]:setColSpan(2):createText(ReadText(1001, 11255), { halign = "right", color = Color["text_inactive"] })
			end
		else
			if menu.contextMenuData.crew.right.captain then
				row[8]:setColSpan(2):createText(Helper.displaySkill(C.GetEntityCombinedSkill(menu.contextMenuData.crew.right.captain, nil, "aipilot") * 15 / 100), { color = Color["text_inactive"] })
				row[10]:setColSpan(2):createText(ffi.string(C.GetComponentName(menu.contextMenuData.crew.right.captain)), { halign = "right", color = Color["text_inactive"] })
			else
				row[10]:setColSpan(2):createText(ReadText(1001, 11232), { halign = "right", color = Color["text_inactive"] })
			end
		end
		-- reassign captains
		local row = shiptable:addRow(true, { fixed = true })
		if not menu.contextMenuData.crew.right.isstation and menu.contextMenuData.crew.right.canassignpilot then
			row[1]:createCheckBox(function () return menu.contextMenuData.crew.left.replaceCaptain or false end, { height = Helper.standardTextHeight, width = Helper.standardTextHeight, active = (not menu.contextMenuData.crew.exchangeCaptains) or (not menu.contextMenuData.crew.right.captain) })
			row[1].handlers.onClick = function () return menu.checkboxAssignCaptain("left") end
			row[2]:setColSpan(4):createText(menu.contextMenuData.crew.left.captain and ReadText(1001, 11234) or ReadText(1001, 11233))
		end

		row[6]:createText("", { cellBGColor = Color["row_separator_white"], x = 0 })

		if menu.contextMenuData.crew.right.isstation then
			if not menu.contextMenuData.crew.right.manager then
				row[7]:setColSpan(4):createText(ReadText(1001, 11256), { halign = "right" })
				row[11]:createCheckBox(function () return menu.contextMenuData.crew.right.replaceCaptain or false end, { height = Helper.standardTextHeight, width = Helper.standardTextHeight })
				row[11].handlers.onClick = function (id) menu.contextMenuData.crew.right.replaceCaptain = not menu.contextMenuData.crew.right.replaceCaptain; menu.checkForNewCaptains() end
			end
		elseif menu.contextMenuData.crew.right.canassignpilot then
			row[7]:setColSpan(4):createText(menu.contextMenuData.crew.right.captain and ReadText(1001, 11234) or ReadText(1001, 11233), { halign = "right" })
			row[11]:createCheckBox(function () return menu.contextMenuData.crew.right.replaceCaptain or false end, { height = Helper.standardTextHeight, width = Helper.standardTextHeight, active = (not menu.contextMenuData.crew.exchangeCaptains) or (not menu.contextMenuData.crew.left.captain) })
			row[11].handlers.onClick = function () return menu.checkboxAssignCaptain("right") end
		end
		-- new captain
		local row = shiptable:addRow(nil, { fixed = true })
		if menu.contextMenuData.crew.exchangeCaptains and menu.contextMenuData.crew.right.captain then
			-- sic! New captain on the left comes from the right ship!
			row[1]:setColSpan(3):createText(ffi.string(C.GetComponentName(menu.contextMenuData.crew.right.captain)), { color = Color["text_positive"] })
			row[4]:createText(Helper.displaySkill(C.GetEntityCombinedSkill(menu.contextMenuData.crew.right.captain, nil, "aipilot") * 15 / 100), { halign = "right", color = Color["text_positive"] })
		elseif menu.contextMenuData.crew.left.newCaptain then
			-- sic! New captain on the left comes from the right ship!
			row[1]:setColSpan(3):createText(function () return menu.contextMenuData.crew.left.replaceCaptain and ffi.string(C.GetPersonName(menu.contextMenuData.crew.left.newCaptain, menu.contextMenuData.rightShip)) or "" end, { color = Color["text_positive"] })
			row[4]:createText(function () return menu.contextMenuData.crew.left.replaceCaptain and Helper.displaySkill(C.GetPersonCombinedSkill(menu.contextMenuData.rightShip, menu.contextMenuData.crew.left.newCaptain, nil, "aipilot") * 15 / 100) or "" end, { halign = "right", color = Color["text_positive"] })
		else
			row[1]:setColSpan(5):createText(function () return menu.contextMenuData.crew.left.replaceCaptain and ReadText(1001, 11235) or "" end, { color = Color["text_negative"] })
		end

		row[6]:createText("", { cellBGColor = Color["row_separator_white"], x = 0 })

		if menu.contextMenuData.crew.exchangeCaptains and menu.contextMenuData.crew.left.captain then
			-- sic! New captain on the right comes from the left ship!
			row[8]:setColSpan(2):createText(Helper.displaySkill(C.GetEntityCombinedSkill(menu.contextMenuData.crew.left.captain, nil, "aipilot") * 15 / 100), { color = Color["text_positive"] })
			row[10]:setColSpan(2):createText(ffi.string(C.GetComponentName(menu.contextMenuData.crew.left.captain)), { halign = "right", color = Color["text_positive"] })
		elseif menu.contextMenuData.crew.right.newCaptain then
			-- sic! New captain on the right comes from the left ship!
			row[8]:setColSpan(2):createText(function () return menu.contextMenuData.crew.right.replaceCaptain and Helper.displaySkill(C.GetPersonCombinedSkill(menu.contextMenuData.leftShip, menu.contextMenuData.crew.right.newCaptain, nil, menu.contextMenuData.crew.right.isstation and "manager" or "aipilot") * 15 / 100) or "" end, { color = Color["text_positive"] })
			row[10]:setColSpan(2):createText(function () return menu.contextMenuData.crew.right.replaceCaptain and ffi.string(C.GetPersonName(menu.contextMenuData.crew.right.newCaptain, menu.contextMenuData.leftShip)) or "" end, { halign = "right", color = Color["text_positive"] })
		else
			row[7]:setColSpan(5):createText(function () return menu.contextMenuData.crew.right.replaceCaptain and ReadText(1001, 11235) or "" end, { halign = "right", color = Color["text_negative"] })
		end
		if ((menu.contextMenuData.crew.left.captain ~= nil) or (menu.contextMenuData.crew.right.captain ~= nil)) and (not menu.contextMenuData.crew.right.isstation) and menu.contextMenuData.crew.right.canassignpilot then
			-- exchange captains
			local row = shiptable:addRow(true, { fixed = true })
			row[1]:createCheckBox(menu.contextMenuData.crew.exchangeCaptains, {  })
			row[1].handlers.onClick = menu.checkboxCrewExchangeCaptains
			row[2]:setColSpan(4):createText(ReadText(1001, 11639))
		end

		-- shiptrader
		if menu.contextMenuData.crew.right.hasshiptraderpost then
			local row = shiptable:addRow(nil, { fixed = true })
			row[7]:setColSpan(5):createText(ReadText(20208, 30501), Helper.subHeaderTextProperties)
			row[7].properties.halign = "center"
			-- current ship trader
			local row = shiptable:addRow(nil, { fixed = true })
			row[6]:createText("", { cellBGColor = Color["row_separator_white"], x = 0 })
			if menu.contextMenuData.crew.right.shiptrader then
				row[8]:setColSpan(2):createText(Helper.displaySkill(C.GetEntityCombinedSkill(menu.contextMenuData.crew.right.shiptrader, nil, "shiptrader") * 15 / 100), { color = Color["text_inactive"] })
				row[10]:setColSpan(2):createText(ffi.string(C.GetComponentName(menu.contextMenuData.crew.right.shiptrader)), { halign = "right", color = Color["text_inactive"] })
			else
				row[10]:setColSpan(2):createText(ReadText(1001, 11260), { halign = "right", color = Color["text_inactive"] })
			end
			-- reassign ship trader
			local row = shiptable:addRow(true, { fixed = true })
			row[6]:createText("", { cellBGColor = Color["row_separator_white"], x = 0 })
			if not menu.contextMenuData.crew.right.shiptrader then
				row[7]:setColSpan(4):createText(ReadText(1001, 11261), { halign = "right" })
				row[11]:createCheckBox(function () return menu.contextMenuData.crew.right.replaceShiptrader or false end, { height = Helper.standardTextHeight, width = Helper.standardTextHeight })
				row[11].handlers.onClick = function (id) menu.contextMenuData.crew.right.replaceShiptrader = not menu.contextMenuData.crew.right.replaceShiptrader; menu.checkForNewCaptains() end
			end
			-- new ship trader
			local row = shiptable:addRow(nil, { fixed = true })
			row[6]:createText("", { cellBGColor = Color["row_separator_white"], x = 0 })
			if menu.contextMenuData.crew.right.newShiptrader then
				-- sic! New ship trader on the right comes from the left ship!
				row[8]:setColSpan(2):createText(function () return menu.contextMenuData.crew.right.replaceShiptrader and Helper.displaySkill(C.GetPersonCombinedSkill(menu.contextMenuData.leftShip, menu.contextMenuData.crew.right.newShiptrader, nil, "shiptrader") * 15 / 100) or "" end, { color = Color["text_positive"] })
				row[10]:setColSpan(2):createText(function () return menu.contextMenuData.crew.right.replaceShiptrader and ffi.string(C.GetPersonName(menu.contextMenuData.crew.right.newShiptrader, menu.contextMenuData.leftShip)) or "" end, { halign = "right", color = Color["text_positive"] })
			else
				row[7]:setColSpan(5):createText(function () return menu.contextMenuData.crew.right.replaceShiptrader and ReadText(1001, 11235) or "" end, { halign = "right", color = Color["text_negative"] })
			end
		end

		-- roles
		if (not menu.contextMenuData.crew.right.isstation) or menu.contextMenuData.crew.right.canhavetrainees then
			for i, roleentry in ipairs(menu.contextMenuData.crew) do
				-- title
				local row = shiptable:addRow(nil, { fixed = true })
				if menu.contextMenuData.crew.right.canhavetrainees then
					row[1]:setColSpan(5):createText(roleentry.name, Helper.subHeaderTextProperties)
					row[1].properties.halign = "center"
					row[7]:setColSpan(5):createText(ReadText(20208, 20503), Helper.subHeaderTextProperties)
					row[7].properties.halign = "center"
				else
					row[1]:setColSpan(11):createText(roleentry.name, Helper.subHeaderTextProperties)
					row[1].properties.halign = "center"
				end

				-- tiers
				for j, tierentry in ipairs(roleentry.tiers) do
					local color = Color["text_normal"]
					if (tierentry.left.amount == 0) and (tierentry.right.amount == 0) then
						color = Color["text_inactive"]
					end

					local row = shiptable:addRow(true, { fixed = true })
					row[1]:setColSpan(2):createText(tierentry.name, { color = color })
					row[3]:createText(function () return tierentry.left.amount - #tierentry.left.moved + #tierentry.right.moved end, { halign = "right", color = function () return menu.crewTransferColorHelper("left", tierentry, color) end })
					row[4]:setColSpan(5):createSliderCell({ start = #tierentry.right.moved - #tierentry.left.moved, min = -tierentry.left.amount, max = tierentry.right.amount, step = 1, fromCenter = true, rightToLeft = true, height = Helper.standardTextHeight })
					row[4].handlers.onSliderCellChanged = function (_, value) return menu.slidercellCrewTransfer(i, j, value) end
					row[4].handlers.onSliderCellConfirm = menu.checkForNewCaptains
					row[9]:createText(function () return tierentry.right.amount - #tierentry.right.moved + #tierentry.left.moved end, { halign = "right", color = function () return menu.crewTransferColorHelper("right", tierentry, color) end })
				end
			end

			shiptable:addEmptyRow(config.mapRowHeight / 2)

			-- total
			local row = shiptable:addRow(nil, { fixed = true })
			row[1]:setColSpan(2):createText(ReadText(1001, 2637))
			row[3]:createText(function () return menu.contextMenuData.crew.left.total - menu.contextMenuData.crew.left.moved + menu.contextMenuData.crew.right.moved end, { halign = "right", color = function () return menu.crewTransferTotalColor("left") end })
			row[4]:setColSpan(5):createText("/ " .. menu.contextMenuData.crew.left.capacity, { x = 0 })
			row[9]:createText(function () return menu.contextMenuData.crew.right.total - menu.contextMenuData.crew.right.moved + menu.contextMenuData.crew.left.moved end, { halign = "right", color = function () return menu.crewTransferTotalColor("right") end })
			row[10]:setColSpan(2):createText("/ " .. menu.contextMenuData.crew.right.capacity, { x = 0 })

			shiptable:addEmptyRow(config.mapRowHeight / 2)

			-- full list toggle
			local row = shiptable:addRow(true, { fixed = true })
			row[1]:setColSpan(3):createButton({  }):setText(menu.contextMenuData.fullshown and ReadText(1001, 8387) or ReadText(1001, 8388), { halign = "center" })
			row[1].handlers.onClick = menu.buttonCrewTransferToggleList
		end
	else
		local row = shiptable:addRow(nil, { fixed = true })
		row[1]:setColSpan(5):createText(ReadText(20208, 30101), Helper.subHeaderTextProperties)
		row[1].properties.halign = "center"

		-- current captain
		local row = shiptable:addRow(nil, { fixed = true })
		if menu.contextMenuData.crew.left.captain then
			row[1]:setColSpan(3):createText(ffi.string(C.GetComponentName(menu.contextMenuData.crew.left.captain)), { color = Color["text_inactive"] })
			row[4]:createText(Helper.displaySkill(C.GetEntityCombinedSkill(menu.contextMenuData.crew.left.captain, nil, "aipilot") * 15 / 100), { halign = "right", color = Color["text_inactive"] })
		else
			row[1]:setColSpan(3):createText(ReadText(1001, 11232), { color = Color["text_inactive"] })
		end

		local row = shiptable:addRow(nil, { fixed = true })
		row[1]:setColSpan(5):createText(ReadText(1001, 11299), { wordwrap = true })
	end

	if menu.contextMenuData.fullshown or (menu.contextMenuData.crew.right.isstation and (not menu.contextMenuData.crew.right.canhavetrainees)) then
		-- title
		local row = shiptable:addRow(nil, { fixed = true })
		row[1]:setColSpan(11):createText(ReadText(1001, 8386), Helper.headerRowCenteredProperties)

		local rowcount = 0
		for i, roleentry in ipairs(menu.contextMenuData.crew) do
			-- roles
			local row = shiptable:addRow(nil, {  })
			if menu.contextMenuData.crew.right.canhavetrainees then
				row[1]:setColSpan(5):createText(roleentry.name, Helper.subHeaderTextProperties)
				row[1].properties.halign = "center"
				row[7]:setColSpan(5):createText(ReadText(20208, 20503), Helper.subHeaderTextProperties)
				row[7].properties.halign = "center"
			else
				row[1]:setColSpan(11):createText(roleentry.name, Helper.subHeaderTextProperties)
				row[1].properties.halign = "center"
			end
			rowcount = rowcount + 1
			if rowcount == numListRows then
				shiptable.properties.maxVisibleHeight = shiptable:getFullHeight()
			end

			-- tiers
			for j, tierentry in ipairs(roleentry.tiers) do
				local isextended = menu.contextMenuData.extendedTier[i .. j]

				local row = shiptable:addRow(true, {  })
				row[1]:createButton({ active = function () return #tierentry.left.persons + #tierentry.left.moved + #tierentry.right.persons + #tierentry.right.moved > 0 end }):setText(isextended and "-" or "+", { halign = "center" })
				row[1].handlers.onClick = function () return menu.buttonCrewTransferExtend(i, j) end
				row[2]:setColSpan(9):createText(tierentry.name, { color = color })
				rowcount = rowcount + 1
				if rowcount == numListRows then
					shiptable.properties.maxVisibleHeight = shiptable:getFullHeight()
				end

				if isextended then
					local personpool = {}
					for _, person in ipairs(tierentry.left.persons) do
						table.insert(personpool, person)
					end
					for _, person in ipairs(tierentry.left.moved) do
						table.insert(personpool, person)
					end
					table.sort(personpool, menu.crewTransferSorter)
					for _, person in ipairs(personpool) do
						local row = shiptable:addRow(true, {  })
						row[2]:setColSpan(2):createText("   " .. person.name, { color = function () return ((not person.arrived) or menu.contextMenuData.crew.left.transferList[person.seed]) and Color["text_inactive"] or Color["text_normal"] end, mouseOverText = (not person.arrived) and ReadText(1026, 3247) or "" })
						row[4]:createText(Helper.displaySkill(person.skill), { halign = "right", color = function () return menu.contextMenuData.crew.left.transferList[person.seed] and Color["text_skills"] or Color["text_skills_irrelevant"] end })
						row[5]:createCheckBox(function () return not menu.contextMenuData.crew.left.transferList[person.seed] end, { height = Helper.standardTextHeight, active = person.arrived, mouseOverText = (not person.arrived) and ReadText(1026, 3247) or "" })
						row[5].handlers.onClick = function (id) return menu.checkboxCrewTransfer(id, i, j, "left", person.seed, true) end
						row[6]:createText("", { cellBGColor = Color["text_normal"], x = 0 })
						row[7]:createCheckBox(function () return menu.contextMenuData.crew.left.transferList[person.seed] or false end, { height = Helper.standardTextHeight, active = menu.isPersonTransferPossible(person), mouseOverText = (not person.arrived) and ReadText(1026, 3247) or "" })
						row[7].handlers.onClick = function (id) return menu.checkboxCrewTransfer(id, i, j, "left", person.seed, false) end
						if menu.contextMenuData.crew.right.isplayerowned then
							row[8]:createText(function () return menu.contextMenuData.crew.left.transferList[person.seed] and Helper.displaySkill(person.skill) or "" end, { color = Color["text_positive"] })
							row[9]:setColSpan(3):createText(function () return menu.personName(person, "left", "right") end, { halign = "right", color = Color["text_positive"] })
						elseif menu.contextMenuData.crew.left.transferList[person.seed] then
							if #person.missionids == 1 then
								local mission = menu.getMissionIDInfoHelper(person.missionids[1])
								row[8]:setColSpan(2):createText(mission.name, { color = Color["text_mission"] })
							else
								local missions = {}
								for _, missionid in ipairs(person.missionids) do
									local mission = menu.getMissionIDInfoHelper(missionid)
									local active = (person.selectedmissionid == missionid) or (menu.contextMenuData.rightMissionOffers[tostring(missionid)].amount > menu.contextMenuData.rightMissionOffers[tostring(missionid)].transferred)
									table.insert(missions, { id = tostring(missionid), text = mission.name, icon = "", displayremoveoption = false, active = active, mouseovertext = active and "" or ReadText(1026, 3250) })
								end
								row[8]:setColSpan(2):createDropDown(missions, { startOption = tostring(person.selectedmissionid), height = config.mapRowHeight, optionWidth = 2 * row[8]:getColSpanWidth() }):setTextProperties({ color = Color["text_mission"] })
								row[8].handlers.onDropDownConfirmed = function (_, missionid) return menu.dropdownCrewTransferSelectMission(person, missionid) end
							end
							row[10]:setColSpan(2):createText(function () return menu.personName(person, "left", "right") end, { halign = "right", color = Color["text_positive"] })
						end

						rowcount = rowcount + 1
						if rowcount == numListRows then
							shiptable.properties.maxVisibleHeight = shiptable:getFullHeight()
						end
					end

					if menu.contextMenuData.crew.right.isplayerowned then
						personpool = {}
						for _, person in ipairs(tierentry.right.persons) do
							table.insert(personpool, person)
						end
						for _, person in ipairs(tierentry.right.moved) do
							table.insert(personpool, person)
						end
						table.sort(personpool, menu.crewTransferSorter)
						for _, person in ipairs(personpool) do
							local row = shiptable:addRow(true, {  })
							row[2]:setColSpan(2):createText(function () return menu.personName(person, "right", "left") end, { color = Color["text_positive"] })
							row[4]:createText(function () return menu.contextMenuData.crew.right.transferList[person.seed] and Helper.displaySkill(person.skill) or "" end, { halign = "right", color = Color["text_positive"] })
							row[5]:createCheckBox(function () return menu.contextMenuData.crew.right.transferList[person.seed] or false end, { height = Helper.standardTextHeight, active = person.arrived, mouseOverText = (not person.arrived) and ReadText(1026, 3247) or "" })
							row[5].handlers.onClick = function (id) return menu.checkboxCrewTransfer(id, i, j, "right", person.seed, false) end
							row[6]:createText("", { cellBGColor = Color["text_normal"], x = 0 })
							row[7]:createCheckBox(function () return not menu.contextMenuData.crew.right.transferList[person.seed] end, { height = Helper.standardTextHeight, active = person.arrived, mouseOverText = (not person.arrived) and ReadText(1026, 3247) or "" })
							row[7].handlers.onClick = function (id) return menu.checkboxCrewTransfer(id, i, j, "right", person.seed, true) end
							row[8]:createText(Helper.displaySkill(person.skill), { color = function () return (not menu.contextMenuData.crew.right.transferList[person.seed]) and Color["text_skills"] or Color["text_skills_irrelevant"] end })
							row[9]:setColSpan(3):createText(person.name, { halign = "right", color = function () return ((not person.arrived) or menu.contextMenuData.crew.right.transferList[person.seed]) and Color["text_inactive"] or Color["text_normal"] end, mouseOverText = (not person.arrived) and ReadText(1026, 3247) or "" })

							rowcount = rowcount + 1
							if rowcount == numListRows then
								shiptable.properties.maxVisibleHeight = shiptable:getFullHeight()
							end
						end
					end
				end
			end
		end
	end

	if menu.contexttoprow then
		shiptable:setTopRow(menu.contexttoprow)
		menu.contexttoprow = nil
	end
	if menu.contextselectedrow then
		shiptable:setSelectedRow(menu.contextselectedrow)
		menu.contextselectedrow = nil
	end

	buttontable.properties.y = shiptable.properties.y + shiptable:getVisibleHeight()

	shiptable.properties.nextTable = buttontable.index
	buttontable.properties.prevTable = shiptable.index

	-- adjust frame position
	local neededheight = buttontable.properties.y + buttontable:getVisibleHeight()
	if frame.properties.y + neededheight > Helper.viewHeight then
		menu.contextMenuData.yoffset = Helper.viewHeight - neededheight - Helper.frameBorder
		frame.properties.y = menu.contextMenuData.yoffset
	end
end

function menu.isPersonTransferPossible(person)
	if menu.contextMenuData.crew.right.isstation then
		if person.missionids and (#person.missionids > 0) then
			local ispossible = false
			for _, missionid in ipairs(person.missionids) do
				if menu.contextMenuData.rightMissionOffers[tostring(missionid)] and (menu.contextMenuData.rightMissionOffers[tostring(missionid)].amount > menu.contextMenuData.rightMissionOffers[tostring(missionid)].transferred) then
					ispossible = true
					break
				end
			end
			return person.arrived and ispossible
		else
			local missingmanager = false
			if (menu.contextMenuData.crew.right.replaceCaptain == true) and (not menu.contextMenuData.crew.right.newCaptain) then
				missingmanager = true
			end
			local missingshiptrader = false
			if menu.contextMenuData.crew.right.hasshiptraderpost then
				if (menu.contextMenuData.crew.right.replaceShiptrader == true) and (not menu.contextMenuData.crew.right.newShiptrader) then
					missingshiptrader = true
				end
			end
			return person.arrived and ((missingmanager or missingshiptrader) or menu.contextMenuData.crew.right.canhavetrainees)
		end
	else
		return person.arrived
	end
end

function menu.personName(person, origin, target)
	local name = ""
	if menu.contextMenuData.crew[origin].transferList[person.seed] then
		name = person.name
	end
	if menu.contextMenuData.crew[target].replaceCaptain and (menu.contextMenuData.crew[target].newCaptain == person.seed) then
		name = name .. " [" .. (menu.contextMenuData.crew[target].isstation and ReadText(1001, 11258) or ReadText(1001, 11236)) .. "]"
	end
	if menu.contextMenuData.crew[target].replaceShiptrader and (menu.contextMenuData.crew[target].newShiptrader == person.seed) then
		name = name .. " [" .. ReadText(1001, 11263) .. "]"
	end
	return name
end

function menu.checkMissionNPCRequirement(missionnpcrequirements, controllable, seed, numskills)
	local missionids = {}

	local skills = {}
	local buf = ffi.new("SkillInfo[?]", numskills)
	local n = C.GetPersonSkills3(buf, numskills, seed, controllable)
	for i = 0, n - 1 do
		local id = ffi.string(buf[i].id)
		skills[id] = buf[i].value
	end

	for _, entry in ipairs(missionnpcrequirements) do
		local matchesrequirement = true
		for _, requiredskill in ipairs(entry.requiredskills) do
			if requiredskill.value > skills[requiredskill.id] then
				matchesrequirement = false
				break
			end
		end
		if matchesrequirement then
			table.insert(missionids, entry.missionid)
		end
	end

	return missionids
end

function menu.crewTransferSorter(a, b)
	if a.skill == b.skill then
		return a.name < b.name
	end
	return a.skill > b.skill
end

function menu.slidercellCrewTransfer(i, j, value)
	local roleentry = menu.contextMenuData.crew[i]
	local tierentry = roleentry.tiers[j]

	local current = #tierentry.right.moved - #tierentry.left.moved
	if value ~= current then
		local change = value - current
		if change > 0 then
			if #tierentry.left.moved > 0 then
				local moveAmount = math.min(change, #tierentry.left.moved)
				for count = 1, moveAmount do
					menu.unmovePerson("left", i, j)
				end
				change = change - moveAmount
			end
			if change > 0 then
				for count = 1, change do
					menu.movePerson("right", i, j)
				end
			end
		elseif change < 0 then
			if #tierentry.right.moved > 0 then
				local moveAmount = math.min(-change, #tierentry.right.moved)
				for count = 1, moveAmount do
					menu.unmovePerson("right", i, j)
				end
				change = change + moveAmount
			end
			if change < 0 then
				for count = 1, -change do
					menu.movePerson("left", i, j)
				end
			end
		end

		table.sort(tierentry.left.persons, menu.crewTransferSorter)
		table.sort(tierentry.right.persons, menu.crewTransferSorter)
	end
end

function menu.checkForNewCaptains(forcerefresh)
	local changedcaptain
	if menu.contextMenuData.crew.left.replaceCaptain then
		local currentskill
		-- sic! New captain on the left comes from the right ship!
		if menu.contextMenuData.crew.left.newCaptain then
			if menu.contextMenuData.crew.right.transferList[menu.contextMenuData.crew.left.newCaptain] then
				currentskill = C.GetPersonCombinedSkill(menu.contextMenuData.rightShip, menu.contextMenuData.crew.left.newCaptain, nil, "aipilot")
			else
				menu.contextMenuData.crew.left.newCaptain = nil
				changedcaptain = true
			end
		end
		if next(menu.contextMenuData.crew.right.transferList) then
			for seed in pairs(menu.contextMenuData.crew.right.transferList) do
				local skill = C.GetPersonCombinedSkill(menu.contextMenuData.rightShip, seed, nil, "aipilot")
				if (not menu.contextMenuData.crew.left.newCaptain) or (skill > currentskill) then
					menu.contextMenuData.crew.left.newCaptain = seed
					currentskill = skill
					changedcaptain = true
				end
			end
		end
	else
		menu.contextMenuData.crew.left.newCaptain = nil
	end

	if menu.contextMenuData.crew.right.replaceCaptain then
		local currentskill
		-- sic! New captain on the right comes from the left ship!
		if menu.contextMenuData.crew.right.newCaptain then
			if menu.contextMenuData.crew.left.transferList[menu.contextMenuData.crew.right.newCaptain] then
				currentskill = C.GetPersonCombinedSkill(menu.contextMenuData.leftShip, menu.contextMenuData.crew.right.newCaptain, nil, menu.contextMenuData.crew.right.isstation and "manager" and "aipilot")
			else
				menu.contextMenuData.crew.right.newCaptain = nil
				changedcaptain = true
			end
		end
		if next(menu.contextMenuData.crew.left.transferList) then
			for seed in pairs(menu.contextMenuData.crew.left.transferList) do
				local skill = C.GetPersonCombinedSkill(menu.contextMenuData.leftShip, seed, nil, menu.contextMenuData.crew.right.isstation and "manager" and "aipilot")
				if (not menu.contextMenuData.crew.right.newCaptain) or (skill > currentskill) then
					menu.contextMenuData.crew.right.newCaptain = seed
					currentskill = skill
					changedcaptain = true
				end
			end
		end
		if menu.contextMenuData.crew.right.newCaptain == menu.contextMenuData.crew.right.newShiptrader then
			menu.contextMenuData.crew.right.newShiptrader = nil
		end
	else
		if menu.contextMenuData.crew.right.isstation and menu.contextMenuData.crew.right.newCaptain then
			menu.unmoveNewPostNPCHelper(menu.contextMenuData.crew.right.newCaptain, "left")
		end
		menu.contextMenuData.crew.right.newCaptain = nil
	end
	if menu.contextMenuData.crew.right.replaceShiptrader then
		local currentskill
		-- sic! New ship trader on the right comes from the left ship!
		if menu.contextMenuData.crew.right.newShiptrader then
			if menu.contextMenuData.crew.left.transferList[menu.contextMenuData.crew.right.newShiptrader] then
				currentskill = C.GetPersonCombinedSkill(menu.contextMenuData.leftShip, menu.contextMenuData.crew.right.newShiptrader, nil, "shiptrader")
			else
				menu.contextMenuData.crew.right.newShiptrader = nil
				changedcaptain = true
			end
		end
		if next(menu.contextMenuData.crew.left.transferList) then
			for seed in pairs(menu.contextMenuData.crew.left.transferList) do
				-- choose best npc for captain/manager and skip them for shiptrader
				if seed ~= menu.contextMenuData.crew.right.newCaptain then
					local skill = C.GetPersonCombinedSkill(menu.contextMenuData.leftShip, seed, nil, "shiptrader")
					if (not menu.contextMenuData.crew.right.newShiptrader) or (skill > currentskill) then
						menu.contextMenuData.crew.right.newShiptrader = seed
						currentskill = skill
						changedcaptain = true
					end
				end
			end
		end
	else
		if menu.contextMenuData.crew.right.isstation and menu.contextMenuData.crew.right.newShiptrader then
			menu.unmoveNewPostNPCHelper(menu.contextMenuData.crew.right.newShiptrader, "left")
		end
		menu.contextMenuData.crew.right.newShiptrader = nil
	end

	if forcerefresh or changedcaptain or menu.contextMenuData.crew.right.isstation then
		menu.refreshContextFrame()
	end
end

function menu.unmoveNewPostNPCHelper(seed, origin)
	for i, roleentry in ipairs(menu.contextMenuData.crew) do
		for j, tierentry in ipairs(roleentry.tiers) do
			for k, person in ipairs(tierentry[origin].moved) do
				if person.seed == seed then
					menu.unmovePerson(origin, i, j, person, k)
					return
				end
			end
		end
	end
end

function menu.movePerson(origin, i, j, person, k)
	local roleentry = menu.contextMenuData.crew[i]
	local tierentry = roleentry.tiers[j]

	if person then
		table.remove(tierentry[origin].persons, k)
	else
		for i, possibleperson in ipairs(tierentry[origin].persons) do
			if possibleperson.arrived then
				person = possibleperson
				table.remove(tierentry[origin].persons, i)
				break
			end
		end
	end
	table.insert(tierentry[origin].moved, person)
	menu.contextMenuData.crew[origin].moved = menu.contextMenuData.crew[origin].moved + 1
	menu.contextMenuData.crew[origin].transferList[person.seed] = true
	if person.missionids and (#person.missionids > 0) then
		for _, missionid in ipairs(person.missionids) do
			if menu.contextMenuData.rightMissionOffers[tostring(missionid)] and (menu.contextMenuData.rightMissionOffers[tostring(missionid)].amount > menu.contextMenuData.rightMissionOffers[tostring(missionid)].transferred) then
				person.selectedmissionid = missionid
				break
			end
		end
		if menu.contextMenuData.rightMissionOffers[tostring(person.selectedmissionid)] then
			menu.contextMenuData.rightMissionOffers[tostring(person.selectedmissionid)].transferred = menu.contextMenuData.rightMissionOffers[tostring(person.selectedmissionid)].transferred + 1
		end
	end
end

function menu.unmovePerson(origin, i, j, person, k)
	local roleentry = menu.contextMenuData.crew[i]
	local tierentry = roleentry.tiers[j]

	if person then
		table.remove(tierentry[origin].moved, k)
	else
		for i = #tierentry[origin].moved, 1, -1 do
			local possibleperson = tierentry[origin].moved[i]
			if possibleperson.arrived then
				person = possibleperson
				table.remove(tierentry[origin].moved, i)
				break
			end
		end
	end
	table.insert(tierentry[origin].persons, person)
	menu.contextMenuData.crew[origin].moved = menu.contextMenuData.crew[origin].moved - 1
	menu.contextMenuData.crew[origin].transferList[person.seed] = nil
	if person.missionids and (#person.missionids > 0) then
		if menu.contextMenuData.rightMissionOffers[tostring(person.selectedmissionid)] then
			menu.contextMenuData.rightMissionOffers[tostring(person.selectedmissionid)].transferred = menu.contextMenuData.rightMissionOffers[tostring(person.selectedmissionid)].transferred - 1
			person.selectedmissionid = nil
		end
	end
end

function menu.crewTransferColorHelper(origin, tierentry, basecolor)
	if (#tierentry.left.moved > 0) or (#tierentry.right.moved > 0) then
		if #tierentry.left.moved == #tierentry.right.moved then
			return Color["crew_transfer"]
		elseif #tierentry.right.moved > #tierentry.left.moved then
			if origin == "left" then
				return Color["text_positive"]
			else
				return Color["text_negative"]
			end
		else
			if origin == "left" then
				return Color["text_negative"]
			else
				return Color["text_positive"]
			end
		end
	end
	return basecolor
end

function menu.crewTransferWarningText(leftname, rightname, row)
	local count = 0
	local warning = ""
	if menu.contextMenuData.crew.right.isplayerowned then
		if menu.contextMenuData.crew.left.total - menu.contextMenuData.crew.left.moved + menu.contextMenuData.crew.right.moved > menu.contextMenuData.crew.left.capacity then
			count = count + 1
			if count == row then
				return string.format(ReadText(1001, 8389), leftname)
			end
		elseif menu.contextMenuData.crew.right.total - menu.contextMenuData.crew.right.moved + menu.contextMenuData.crew.left.moved > menu.contextMenuData.crew.right.capacity then
			count = count + 1
			if count == row then
				return string.format(ReadText(1001, 8389), rightname)
			end
		end
		if menu.contextMenuData.crew.left.replaceCaptain and (not menu.contextMenuData.crew.left.newCaptain) then
			count = count + 1
			if count == row then
				return string.format(ReadText(1001, 11237), leftname)
			end
		end
		if menu.contextMenuData.crew.right.replaceCaptain and (not menu.contextMenuData.crew.right.newCaptain) then
			count = count + 1
			if count == row then
				return string.format(menu.contextMenuData.crew.right.isstation and ReadText(1001, 11259) or ReadText(1001, 11237), rightname)
			end
		end
		if menu.contextMenuData.crew.right.replaceShiptrader and (not menu.contextMenuData.crew.right.newShiptrader) then
			count = count + 1
			if count == row then
				return string.format(ReadText(1001, 11264), rightname)
			end
		end
		local valid, reason = menu.performCrewExchange(true)
		if not valid then
			count = count + 1
			if count == row then
				return menu.hireReasonLookup(reason, true)
			end
		end
	else
		local availablecrew = 0
		for i, roleentry in ipairs(menu.contextMenuData.crew) do
			for j, tierentry in ipairs(roleentry.tiers) do
				availablecrew = availablecrew + #tierentry.left.persons + #tierentry.left.moved
			end
		end
		if availablecrew == 0 then
			count = count + 1
			if count == row then
				return ReadText(1001, 11265)
			end
		end
	end
	return warning
end

function menu.crewTransferTotalColor(origin)
	if menu.contextMenuData.crew[origin].total - menu.contextMenuData.crew[origin].moved + menu.contextMenuData.crew[(origin == "left") and "right" or "left"].moved > menu.contextMenuData.crew[origin].capacity then
		return Color["text_error"]
	end
	return Color["text_normal"]
end

function menu.dropdownCrewTransferSelectMission(person, missionid)
	menu.contextMenuData.rightMissionOffers[tostring(person.selectedmissionid)].transferred = menu.contextMenuData.rightMissionOffers[tostring(person.selectedmissionid)].transferred - 1
	person.selectedmissionid = ConvertStringTo64Bit(missionid)
	menu.contextMenuData.rightMissionOffers[tostring(person.selectedmissionid)].transferred = menu.contextMenuData.rightMissionOffers[tostring(person.selectedmissionid)].transferred + 1

	menu.refreshContextFrame()
end

function menu.crewTransferAllowed()
	if not menu.contextMenuData.crew.right.isplayerowned then
		return menu.contextMenuData.crew.left.moved > 0
	end
	if menu.contextMenuData.crew.left.replaceCaptain and (not menu.contextMenuData.crew.left.newCaptain) then
		return false
	end
	if menu.contextMenuData.crew.right.replaceCaptain and (not menu.contextMenuData.crew.right.newCaptain) then
		return false
	end
	if menu.contextMenuData.crew.right.replaceShiptrader and (not menu.contextMenuData.crew.right.newShiptrader) then
		return false
	end
	if (menu.contextMenuData.crew.left.moved > 0) or (menu.contextMenuData.crew.right.moved > 0) or menu.contextMenuData.crew.exchangeCaptains then
		if (menu.contextMenuData.crew.left.total - menu.contextMenuData.crew.left.moved + menu.contextMenuData.crew.right.moved <= menu.contextMenuData.crew.left.capacity) and
			(menu.contextMenuData.crew.right.total - menu.contextMenuData.crew.right.moved + menu.contextMenuData.crew.left.moved <= menu.contextMenuData.crew.right.capacity) then
				return menu.performCrewExchange(true)
		end
	end
	return false
end

function menu.getMissionInfoFromPerson(seed, origin)
	for i, roleentry in ipairs(menu.contextMenuData.crew) do
		for j, tierentry in ipairs(roleentry.tiers) do
			for k, person in ipairs(tierentry[origin].moved) do
				if person.seed == seed then
					return person.selectedmissionid
				end
			end
		end
	end
end

function menu.buttonCrewTransferConfirm()
	if not menu.contextMenuData.crew.right.isplayerowned then
		for seed in pairs(menu.contextMenuData.crew.left.transferList) do
			C.SignalObjectWithNPCSeedAndMissionID(menu.contextMenuData.rightShip, "npctemplate_mission_delivery", menu.getMissionInfoFromPerson(seed, "left"), seed, menu.contextMenuData.leftShip)
		end
	else
		if menu.contextMenuData.crew.right.isstation then
			if menu.contextMenuData.crew.right.replaceCaptain and menu.contextMenuData.crew.right.newCaptain then
				-- sic! New manager on the right comes from the left ship!
				local actor = { entity = nil, personcontrollable = menu.contextMenuData.leftShip, personseed = menu.contextMenuData.crew.right.newCaptain }
				C.AssignHiredActor(actor, menu.contextMenuData.rightShip, "manager", nil, false)
				-- need to clean this up in case we will transfer further npcs as trainees
				menu.contextMenuData.crew.left.transferList[menu.contextMenuData.crew.right.newCaptain] = nil
				menu.contextMenuData.crew.left.moved = menu.contextMenuData.crew.left.moved - 1
				menu.contextMenuData.crew.right.newCaptain = nil
				menu.contextMenuData.crew.right.replaceCaptain = nil
			end
			if menu.contextMenuData.crew.right.replaceShiptrader and menu.contextMenuData.crew.right.newShiptrader then
				-- sic! New ship trader on the right comes from the left ship!
				local actor = { entity = nil, personcontrollable = menu.contextMenuData.leftShip, personseed = menu.contextMenuData.crew.right.newShiptrader }
				C.AssignHiredActor(actor, menu.contextMenuData.rightShip, "shiptrader", nil, false)
				-- need to clean this up in case we will transfer further npcs as trainees
				menu.contextMenuData.crew.left.transferList[menu.contextMenuData.crew.right.newShiptrader] = nil
				menu.contextMenuData.crew.left.moved = menu.contextMenuData.crew.left.moved - 1
				menu.contextMenuData.crew.right.newShiptrader = nil
				menu.contextMenuData.crew.right.replaceShiptrader = nil
			end
			if menu.contextMenuData.crew.right.canhavetrainees then
				menu.performCrewExchange(false)
			end
		else
			menu.performCrewExchange(false)
		end
	end
	menu.updatePeopleInfo = getElapsedTime()
	menu.closeContextMenu("back")
end

function menu.performCrewExchange(checkonly)
	local exchangecaptains = menu.contextMenuData.crew.exchangeCaptains
	local captainfromleft = menu.contextMenuData.crew.right.replaceCaptain and menu.contextMenuData.crew.right.newCaptain or 0
	local captainfromright = menu.contextMenuData.crew.left.replaceCaptain and menu.contextMenuData.crew.left.newCaptain or 0
	local hascaptainfromleft, hascaptainfromright

	if menu.contextMenuData.crew.left.moved < 0 then
		DebugError("Invalid amount of moved crew, aborting")
		print(TraceBack())
		return false, "invalid"
	end
	if menu.contextMenuData.crew.right.moved < 0 then
		DebugError("Invalid amount of moved crew, aborting")
		print(TraceBack())
		return false, "invalid"
	end

	if exchangecaptains and ((menu.contextMenuData.crew.left.captain and (captainfromleft ~= 0)) or (menu.contextMenuData.crew.right.captain and (captainfromright ~= 0))) then
		return false, "invalid"
	end

	local i = 0
	local leftnpcs = ffi.new("NPCSeed[?]", menu.contextMenuData.crew.left.moved)
	for seed in pairs(menu.contextMenuData.crew.left.transferList) do
		leftnpcs[i] = seed
		if seed == captainfromleft then
			hascaptainfromleft = true
		end
		i = i + 1
	end
	i = 0
	local rightnpcs = ffi.new("NPCSeed[?]", menu.contextMenuData.crew.right.moved)
	for seed in pairs(menu.contextMenuData.crew.right.transferList) do
		rightnpcs[i] = seed
		if seed == captainfromright then
			hascaptainfromright = true
		end
		i = i + 1
	end

	if (hascaptainfromleft or (captainfromleft == 0)) and (hascaptainfromright or (captainfromright == 0)) then
		local result = C.PerformCrewExchange2(menu.contextMenuData.leftShip, menu.contextMenuData.rightShip, leftnpcs, menu.contextMenuData.crew.left.moved, rightnpcs, menu.contextMenuData.crew.right.moved, captainfromleft, captainfromright, exchangecaptains, checkonly)
		local reason = ffi.string(result.reason)
		return reason == "", reason;
	end
	return false, "invalid"
end

function menu.buttonCrewTransferToggleList()
	menu.contextMenuData.fullshown = not menu.contextMenuData.fullshown
	menu.refreshContextFrame()
end

function menu.buttonCrewTransferExtend(i, j)
	if menu.contextMenuData.extendedTier[i .. j] then
		menu.contextMenuData.extendedTier[i .. j] = nil
	else
		menu.contextMenuData.extendedTier[i .. j] = true
	end
	menu.refreshContextFrame()
end

function menu.checkboxCrewTransfer(id, i, j, origin, seed, isorigin)
	local roleentry = menu.contextMenuData.crew[i]
	local tierentry = roleentry.tiers[j]

	local person, personidx
	if isorigin then
		for k, personentry in ipairs(tierentry[origin].moved) do
			if personentry.seed == seed then
				person = personentry
				personidx = k
				break
			end
		end
	else
		for k, personentry in ipairs(tierentry[origin].persons) do
			if personentry.seed == seed then
				person = personentry
				personidx = k
				break
			end
		end
	end

	if person then
		if menu.contextMenuData.crew[origin].transferList[person.seed] and isorigin then
			menu.unmovePerson(origin, i, j, person, personidx)
		elseif (not menu.contextMenuData.crew[origin].transferList[person.seed]) and (not isorigin) then
			menu.movePerson(origin, i, j, person, personidx)
		end
		table.sort(tierentry[origin].persons, menu.crewTransferSorter)
		if not menu.contextMenuData.crew.right.isstation then
			Helper.setSliderCellValue(menu.contexttable, 5 + 4 * i + j, 4, #tierentry.right.moved - #tierentry.left.moved)
		end
	else
		C.SetCheckBoxChecked2(id, true, true)
	end

	menu.checkForNewCaptains()
end

function menu.checkboxCrewExchangeCaptains()
	menu.contextMenuData.crew.exchangeCaptains = not menu.contextMenuData.crew.exchangeCaptains
	-- If we have a captain on the left ship, we cannot replace the captain on the right ship with another crewmember anymore
	if menu.contextMenuData.crew.left.captain then
		menu.contextMenuData.crew.right.newCaptain = nil
		menu.contextMenuData.crew.right.replaceCaptain = nil
	end
	-- If we have a captain on the right ship, we cannot replace the captain on the left ship with another crewmember anymore
	if menu.contextMenuData.crew.right.captain then
		menu.contextMenuData.crew.left.newCaptain = nil
		menu.contextMenuData.crew.left.replaceCaptain = nil
	end

	menu.refreshContextFrame()
end

function menu.checkboxAssignCaptain(origin)
	menu.contextMenuData.crew[origin].replaceCaptain = not menu.contextMenuData.crew[origin].replaceCaptain
	local refresh = false
	if not menu.contextMenuData.crew[origin].captain then
		if menu.contextMenuData.crew[origin].replaceCaptain then
			menu.contextMenuData.crew[origin].capacity = menu.contextMenuData.crew[origin].capacity + 1
		else
			menu.contextMenuData.crew[origin].capacity = menu.contextMenuData.crew[origin].capacity - 1
		end
		refresh = true
	end
	menu.checkForNewCaptains(refresh)
end

function menu.createRenameContext(frame)
	local title = menu.contextMenuData.fleetrename and ReadText(1001, 7895) or ReadText(1001, 1114)
	local startname = menu.contextMenuData.fleetrename and ffi.string(C.GetFleetName(menu.contextMenuData.component)) or ffi.string(C.GetComponentName(menu.contextMenuData.component))

	-- [UniTrader's Advanced Renaming] Forleyor start: callback
	if callbacks ["utRenaming_createRenameContext_get_startname"] then
		for _, callback in ipairs (callbacks ["utRenaming_createRenameContext_get_startname"]) do
			uix_startname = callback (frame)
			if uix_startname then
				startname = uix_startname
				break
			end
		end
	end
	-- [UniTrader's Advanced Renaming] Forleyor end: callback

	local shiptable = frame:addTable(2, { tabOrder = 2, x = Helper.borderSize, y = Helper.borderSize, width = menu.contextMenuData.width, highlightMode = "off" })

	-- title
	local row = shiptable:addRow(nil, { fixed = true })
	row[1]:setColSpan(2):createText(title, Helper.headerRowCenteredProperties)

	local row = shiptable:addRow(true, { fixed = true })
	menu.contextMenuData.nameEditBox = row[1]:setColSpan(2):createEditBox({ height = config.mapRowHeight, description = title }):setText(startname)
	row[1].handlers.onTextChanged = function (_, text, textchanged) menu.contextMenuData.newtext = text end
	row[1].handlers.onEditBoxDeactivated = menu.buttonRenameConfirm

	local row = shiptable:addRow(true, { fixed = true })
	row[1]:createButton({  }):setText(ReadText(1001, 2821), { halign = "center" })
	row[1].handlers.onClick = menu.buttonRenameConfirm
	row[2]:createButton({  }):setText(ReadText(1001, 64), { halign = "center" })
	row[2].handlers.onClick = function () return menu.closeContextMenu("back") end

	-- [UniTrader's Advanced Renaming] Forleyor start: callback
	if callbacks ["utRenaming_createRenameContext_on_after_confirm_button"] then
		for _, callback in ipairs (callbacks ["utRenaming_createRenameContext_on_after_confirm_button"]) do
			startname = callback (frame, shiptable)
		end
	end
	-- [UniTrader's Advanced Renaming] Forleyor end: callback

	-- adjust frame position
	local neededheight = shiptable.properties.y + shiptable:getVisibleHeight()
	if frame.properties.y + neededheight + Helper.frameBorder > Helper.viewHeight then
		menu.contextMenuData.yoffset = Helper.viewHeight - neededheight - Helper.frameBorder
		frame.properties.y = menu.contextMenuData.yoffset
	end
end

function menu.createChangeLogoContext(frame)
	local title = ReadText(1001, 11133)

	local colwidth = math.floor((menu.contextMenuData.width - 4 * Helper.borderSize) / 5)
	local logotable = frame:addTable(5, { tabOrder = 2, x = Helper.borderSize, y = Helper.borderSize, width = 5 * (colwidth + Helper.borderSize) - Helper.borderSize, highlightMode = "off" })

	-- title
	local row = logotable:addRow(nil, { fixed = true })
	row[1]:setColSpan(5):createText(title, Helper.headerRowCenteredProperties)

	local logooptiondata = { {{}, ReadText(1001, 9126)}, {{}, ReadText(1001, 9127)} }

	local numlogos = C.GetNumPlayerLogos(true, false)
	local logos = ffi.new("UILogo[?]", numlogos)
	numlogos = C.GetPlayerLogos(logos, numlogos, true, false)
	for i = 0, numlogos - 1 do
		table.insert(logooptiondata[1][1], { file = ffi.string(logos[i].file), icon = ffi.string(logos[i].icon), ispersonal = logos[i].ispersonal })
	end

	numlogos = C.GetNumPlayerLogos(false, true)
	logos = ffi.new("UILogo[?]", numlogos)
	numlogos = C.GetPlayerLogos(logos, numlogos, false, true)
	for i = 0, numlogos - 1 do
		table.insert(logooptiondata[2][1], { file = ffi.string(logos[i].file), icon = ffi.string(logos[i].icon), ispersonal = logos[i].ispersonal })
	end

	local row
	for _, logodata in ipairs(logooptiondata) do
		row = logotable:addRow(nil, { bgColor = Color["player_info_background"] })
		row[1]:setColSpan(5):createText(logodata[2], Helper.headerRowCenteredProperties)

		if #logodata[1] > 0 then
			for i, logo in ipairs(logodata[1]) do
				local loccol = i % 5
				if loccol == 0 then
					loccol = 5
				end
				if loccol == 1 then
					row = logotable:addRow("logos", {  })
				end

				row[loccol]:createButton({ height = colwidth, scaling = false }):setIcon(logo.icon):setIcon2(function() return menu.contextChangeLogoButtonIcon2(logo) end, { color = function() return menu.contextChangeLogoButtonIcon2Color(logo) end })
				row[loccol].handlers.onClick = function() return menu.buttonContextSetLogo(logo) end

				if (logo.icon == menu.contextMenuData.origlogo.icon) and (logo.ispersonal == menu.contextMenuData.origlogo.ispersonal) then
					logotable:setSelectedRow(row.index)
					logotable:setSelectedCol(loccol)
				end
			end
		else
			row = logotable:addRow("logos", {  })
			row[1]:setColSpan(5):createText("--- " .. ReadText(1001, 9132) .. " ---")
		end
	end

	local buttontable = frame:addTable(3, { tabOrder = 3, x = Helper.borderSize, y = Helper.borderSize, width = 5 * (colwidth + Helper.borderSize) - Helper.borderSize, highlightMode = "off" })
	buttontable:addEmptyRow()
	local row = buttontable:addRow(true, { fixed = true })
	row[1]:createButton({  }):setText(ReadText(1001, 2821), { halign = "center" })
	row[1].handlers.onClick = function () menu.contextMenuData.origlogo = nil; return menu.closeContextMenu("back") end
	row[2]:createButton({  }):setText(ReadText(1001, 64), { halign = "center" })
	row[2].handlers.onClick = menu.buttonChangeLogoCancel
	row[3]:createButton({ active = function () return menu.contextMenuData.currentlogo.file ~= "" end }):setText(ReadText(1001, 11640), { halign = "center" })
	row[3].handlers.onClick = function () menu.contextMenuData.currentlogo = { file = "", icon = "", ispersonal = false}; return C.SetFleetLogo(menu.contextMenuData.component, menu.contextMenuData.currentlogo) end

	local buttonheight = buttontable:getFullHeight()
	if logotable:getFullHeight() + buttonheight + Helper.borderSize > Helper.viewHeight - 2 * Helper.frameBorder then
		logotable.properties.maxVisibleHeight = Helper.viewHeight - 2 * Helper.frameBorder - buttonheight - Helper.borderSize
	end
	buttontable.properties.y = logotable.properties.y + logotable:getVisibleHeight() + Helper.borderSize

	-- adjust frame position
	local neededheight = logotable.properties.y + logotable:getVisibleHeight() + Helper.borderSize + buttonheight
	if frame.properties.y + neededheight + Helper.frameBorder > Helper.viewHeight then
		menu.contextMenuData.yoffset = Helper.viewHeight - neededheight - Helper.frameBorder
		frame.properties.y = menu.contextMenuData.yoffset
	end
end

function menu.contextChangeLogoButtonIcon2(logo)
	if (logo.icon == menu.contextMenuData.currentlogo.icon) and (logo.ispersonal == menu.contextMenuData.currentlogo.ispersonal) then
		return "be_upgrade_installed"
	end
	if (logo.icon == menu.contextMenuData.origlogo.icon) and (logo.ispersonal == menu.contextMenuData.origlogo.ispersonal) then
		return "be_upgrade_uninstalled"
	end
	return "solid"
end

function menu.contextChangeLogoButtonIcon2Color(logo)
	if (logo.icon == menu.contextMenuData.currentlogo.icon) and (logo.ispersonal == menu.contextMenuData.currentlogo.ispersonal) then
		return Color["text_positive"]
	end
	if (logo.icon == menu.contextMenuData.origlogo.icon) and (logo.ispersonal == menu.contextMenuData.origlogo.ispersonal) then
		return Color["text_negative"]
	end
	return Color["icon_hidden"]
end

function menu.createHireContext(frame)
	local isplayerowned = GetComponentData(menu.contextMenuData.hireObject, "isplayerowned")

	local ftable = frame:addTable(2, { tabOrder = 2, x = Helper.borderSize, y = Helper.borderSize, width = menu.contextMenuData.width, highlightMode = "off" })

	local npcseed = C.ConvertStringTo64Bit(tostring(menu.modeparam[4]))
	local npc, object
	if npcseed ~= 0 then
		object = ConvertIDTo64Bit(menu.modeparam[2])
	else
		npc = ConvertIDTo64Bit(menu.modeparam[2])
	end
	local ishiring = menu.modeparam[3] ~= 0

	-- title
	local row = ftable:addRow(nil, { fixed = true })

	local name = ffi.string(C.GetComponentName(menu.contextMenuData.hireObject))
	local idcode = " (" .. ffi.string(C.GetObjectIDCode(menu.contextMenuData.hireObject)) .. ")"

	local halign = "center"
	if math.ceil(C.GetTextWidth(name .. idcode, Helper.headerRow1Font, Helper.scaleFont(Helper.headerRow1Font, Helper.headerRow1FontSize))) > menu.contextMenuData.width - 2 * Helper.scaleX(Helper.standardButtonWidth) then
		halign = "left"
		local idcodewidth = math.ceil(C.GetTextWidth(idcode, Helper.headerRow1Font, Helper.scaleFont(Helper.headerRow1Font, Helper.headerRow1FontSize)))
		name = TruncateText(name, Helper.headerRow1Font, Helper.scaleFont(Helper.headerRow1Font, Helper.headerRow1FontSize), menu.contextMenuData.width - Helper.scaleX(Helper.standardTextOffsetx) - idcodewidth - Helper.scaleX(Helper.standardButtonWidth))
	end

	row[1]:setColSpan(2):createText(name .. idcode, Helper.headerRowCenteredProperties)
	row[1].properties.halign = halign
	if isplayerowned then
		row[1].properties.color = menu.holomapcolor.playercolor
	end

	-- Possible Roles
	local row = ftable:addRow(false, { fixed = true })
	row[1]:setColSpan(2):createText(ReadText(1001, 3259))
	local row = ftable:addRow(true, { fixed = true, bgColor = Color["row_background_blue"] })
	local actor = { entity = npc, personcontrollable = object, personseed = npcseed }

	local roleOptions = {}
	if isplayerowned then
		-- posts
		local n, buf
		if npc then
			n = C.GetNumSuitableControlPosts(menu.contextMenuData.hireObject, npc, false)
			buf = ffi.new("ControlPostInfo[?]", n)
			n = C.GetSuitableControlPosts(buf, n, menu.contextMenuData.hireObject, npc, false)
		else
			n = C.GetNumPersonSuitableControlPosts(menu.contextMenuData.hireObject, object, npcseed, false)
			buf = ffi.new("ControlPostInfo[?]", n)
			n = C.GetPersonSuitableControlPosts(buf, n, menu.contextMenuData.hireObject, object, npcseed, false)
		end
		for i = 0, n - 1 do
			local postid = ffi.string(buf[i].id)
			local reason = ffi.string(C.AssignHiredActor(actor, menu.contextMenuData.hireObject, postid, "", true))
			local active = reason == ""
			local mouseovertext
			if reason ~= "" then
				mouseovertext = menu.hireReasonLookup(reason)
			end

			table.insert(roleOptions, { id = "post:" .. postid, text = ffi.string(buf[i].name), icon = "", displayremoveoption = false, active = active, mouseovertext = mouseovertext })
		end
		if C.IsComponentClass(menu.contextMenuData.hireObject, "ship") then
			-- service
			local servicereason = ffi.string(C.AssignHiredActor(actor, menu.contextMenuData.hireObject, "", "service", true))
			local active = servicereason == ""
			local mouseovertext
			if servicereason ~= "" then
				mouseovertext = menu.hireReasonLookup(servicereason)
			end
			table.insert(roleOptions, { id = "role:service", text = ReadText(20208, 20103), icon = "", displayremoveoption = false, active = active, mouseovertext = mouseovertext })
			-- marines
			local marinereason = ffi.string(C.AssignHiredActor(actor, menu.contextMenuData.hireObject, "", "marine", true))
			local active = marinereason == ""
			local mouseovertext
			if marinereason ~= "" then
				mouseovertext = menu.hireReasonLookup(marinereason)
			end
			table.insert(roleOptions, { id = "role:marine",  text = ReadText(20208, 20203), icon = "", displayremoveoption = false, active = active, mouseovertext = mouseovertext })
		end
		if C.CanControllableHaveAnyTrainees(menu.contextMenuData.hireObject) then
			-- group trainee
			local grouptraineereason = ffi.string(C.AssignHiredActor(actor, menu.contextMenuData.hireObject, "", "trainee_group", true))
			local active = grouptraineereason == ""
			local mouseovertext
			if grouptraineereason ~= "" then
				mouseovertext = menu.hireReasonLookup(grouptraineereason)
			end
			table.insert(roleOptions, { id = "role:trainee_group", text = ReadText(20208, 20503), icon = "", displayremoveoption = false, active = active, mouseovertext = mouseovertext })
		end
	end

	-- skills
	local numskills = C.GetNumSkills()
	local skills = {}
	if npc then
		local skilltable = GetComponentData(npc, "skills")
		for _, entry in ipairs(skilltable) do
			skills[entry.name] = entry.value
		end
	else
		local buf = ffi.new("SkillInfo[?]", numskills)
		local n = C.GetPersonSkills3(buf, numskills, npcseed, object)
		for i = 0, n - 1 do
			local id = ffi.string(buf[i].id)
			skills[id] = buf[i].value
		end
	end
	-- mission npc requirements
	local n = C.GetNumRequestedMissionNPCs(menu.contextMenuData.hireObject)
	local buf = ffi.new("MissionNPCInfo[?]", n)
	for i = 0, n - 1 do
		buf[i].numskills = numskills
		buf[i].skills = Helper.ffiNewHelper("SkillInfo[?]", numskills)
	end
	n = C.GetRequestedMissionNPCs(buf, n, menu.contextMenuData.hireObject)
	for i = 0, n - 1 do
		if buf[i].amount > 0 then
			local matchesrequirement = true
			for j = 0, buf[i].numskills - 1 do
				local id = ffi.string(buf[i].skills[j].id)
				if buf[i].skills[j].value > skills[id] then
					matchesrequirement = false
					break
				end
			end

			local mission = menu.getMissionIDInfoHelper(buf[i].missionid)
			table.insert(roleOptions, { id = "mission:" .. tostring(buf[i].missionid), text = ColorText["text_mission"] .. mission.name, icon = "", displayremoveoption = false, active = matchesrequirement, mouseovertext = matchesrequirement and "" or ReadText(1026, 3251) })
		end
	end

	table.sort(roleOptions, function (a, b) return a.text < b.text end)

	if #roleOptions > 0 then
		local startOption = ""
		if menu.contextMenuData.hireIsMission then
			startOption = "mission:" .. menu.contextMenuData.hireRole
		elseif menu.contextMenuData.hireRole then
			startOption = (menu.contextMenuData.hireIsPost and "post:" or "role:") .. menu.contextMenuData.hireRole
		end
		row[1]:setColSpan(2):createDropDown(roleOptions, { startOption = startOption, height = config.mapRowHeight, helpOverlayID = "assign_staff_role", helpOverlayText = " " }):setTextProperties({ halign = "center" })
		row[1].handlers.onDropDownConfirmed = menu.dropdownHireRole
		row[1].properties.uiTriggerID = "npcrole"
		row[1].handlers.onDropDownActivated = function () menu.noupdate = true end
	else
		row[1]:setColSpan(2):createText(string.format(ReadText(1001, 3260), ffi.string(C.GetComponentName(menu.contextMenuData.hireObject))), { halign = "center", color = Color["text_error"] })
	end
	-- warnings
	local warningtext = ""
	if npc and GetComponentData(npc, "isplayerowned") then
		if not GetComponentData(menu.contextMenuData.hireObject, "assignedpilot") then
			if menu.contextMenuData.hireRole and (not menu.contextMenuData.hireIsPost) then
				local inventory = GetInventory(npc)
				if next(inventory) then
					warningtext = ReadText(1001, 8384)
				end
			end
		end
	end
	if warningtext ~= "" then
		local row = ftable:addRow(false, { fixed = true })
		row[1]:setColSpan(2):createText(warningtext, { color = Color["text_error"], wordwrap = true })
	end

	menu.hiringdiscounts = GetComponentData(GetContextByClass(npc or object, "container", true), "hiringdiscounts")
	menu.hiringdiscounts.totalfactor = 1
	for _, entry in ipairs(menu.hiringdiscounts) do
		menu.hiringdiscounts.totalfactor = menu.hiringdiscounts.totalfactor - entry.amount / 100
	end

	local fee
	if ishiring and npc then
		fee = GetNPCBlackboard(npc, "$HiringFee")
	end
	local balance = GetPlayerMoney()
	if fee then
		balance = GetPlayerMoney() - fee
	end
	if ishiring then
		-- discounts
		if #menu.hiringdiscounts > 0 then
			local row = ftable:addRow(false, { fixed = true })
			row[1]:createText(ReadText(1001, 3502))
			row[2]:createText(ConvertMoneyString(fee, false, true, nil, true) .. " " .. ReadText(1001, 101), { halign = "right" })

			ftable:addEmptyRow(config.mapRowHeight / 4)

			local row = ftable:addRow(nil, { fixed = true })
			row[1]:setColSpan(2):createText(ReadText(1001, 2819))
			for _, entry in ipairs(menu.hiringdiscounts) do
				local row = ftable:addRow(nil, { fixed = true })
				row[1]:createText("   " .. entry.name)
				row[2]:createText(entry.amount .. " %", { halign = "right" })
			end
			ftable:addEmptyRow(config.mapRowHeight / 4)
		end
		if fee then
			-- Fee
			local row = ftable:addRow(false, { fixed = true })
			row[1]:createText((#menu.hiringdiscounts > 0) and ReadText(1001, 3503) or ReadText(1001, 3501))
			row[2]:createText(ConvertMoneyString(fee * menu.hiringdiscounts.totalfactor, false, true, nil, true) .. " " .. ReadText(1001, 101), { halign = "right" })
		end
		-- Final Balance
		local row = ftable:addRow(false, { fixed = true })
		row[1]:createText(ReadText(1001, 2004))
		row[2]:createText(ConvertMoneyString(balance, false, true, nil, true) .. " " .. ReadText(1001, 101), { halign = "right", color = (balance < 0) and Color["text_negative"] or Color["text_normal"] })
	end
	-- Buttons
	local row = ftable:addRow(true, { fixed = true })
	local mouseovertext = ""
	if not menu.contextMenuData.hireRole then
		mouseovertext = ReadText(1026, 3221)
	elseif ishiring and (balance < 0) then
		mouseovertext = ReadText(1026, 3222)
	end
	row[1]:createButton({ active = (menu.contextMenuData.hireRole ~= nil) and ((not ishiring) or (balance >= 0)), mouseOverText = mouseovertext, helpOverlayID = "assign_staff_hire_ok", helpOverlayText = " " }):setText(ishiring and ReadText(1001, 3262) or ReadText(1001, 3263), { halign = "center" })
	row[1].handlers.onClick = menu.buttonHire
	row[1].properties.uiTriggerID = "hire_ok"

	row[2]:createButton({helpOverlayID = "assign_staff_hire_cancel", helpOverlayText = " " }):setText(ReadText(1001, 64), { halign = "center"})
	row[2].handlers.onClick = function () return menu.onCloseElement("back") end
	row[2].properties.uiTriggerID = "hire_cancel"

	-- adjust frame position
	local neededheight = ftable.properties.y + ftable:getVisibleHeight()
	if frame.properties.y + neededheight + Helper.frameBorder > Helper.viewHeight then
		menu.contextMenuData.yoffset = Helper.viewHeight - neededheight - Helper.frameBorder
		frame.properties.y = menu.contextMenuData.yoffset
	end
end

function menu.createSearchFieldContext(frame)
	local ftable = frame:addTable(1, { tabOrder = 2, x = 0, y = 0, width = menu.contextMenuData.width, highlightMode = "off" })

	local founditems_prio = {}
	local founditems = {}
	for name, ware in Helper.orderedPairs(menu.economyWares) do
		local index = utf8.find(utf8.lower(name), menu.searchFieldContextText)
		if index then
			if index == 1 then
				table.insert(founditems_prio, { ware = ware, name = name })
			else
				table.insert(founditems, { ware = ware, name = name })
			end
		end
	end
	for name, sector in Helper.orderedPairs(menu.knownSectors) do
		local index = utf8.find(utf8.lower(name), menu.searchFieldContextText)
		if index then
			if index == 1 then
				table.insert(founditems_prio, { sector = sector, name = name })
			else
				table.insert(founditems, { sector = sector, name = name })
			end
		end
	end

	local maxVisibleHeight

	table.sort(founditems_prio, Helper.sortName)
	for i, item in ipairs(founditems_prio) do
		if (i > 10) and (not maxVisibleHeight) then
			maxVisibleHeight = ftable:getFullHeight()
		end
		local row = ftable:addRow(true, { borderBelow = false })
		row[1]:createButton({ bgColor = Color["row_background"], height = menu.editboxHeight, scaling = false }):setText(item.ware and ("\27[maptr_supply] " .. GetWareData(item.ware, "name")) or (item.sector and ("\27[maptr_hexagon] " .. GetComponentData(item.sector, "name")) or ""), { scaling = true, x = 2 })
		row[1].handlers.onClick = function () return menu.searchTextConfirmed(_, item.name, true) end
	end

	table.sort(founditems, Helper.sortName)
	for i, item in ipairs(founditems) do
		if (i > (10 - #founditems_prio)) and (not maxVisibleHeight) then
			maxVisibleHeight = ftable:getFullHeight()
		end
		local row = ftable:addRow(true, { borderBelow = false })
		row[1]:createButton({ bgColor = Color["row_background"], height = menu.editboxHeight, scaling = false }):setText(item.ware and ("\27[maptr_supply] " .. GetWareData(item.ware, "name")) or (item.sector and ("\27[maptr_hexagon] " .. GetComponentData(item.sector, "name")) or ""), { scaling = true, x = 2 })
		row[1].handlers.onClick = function () return menu.searchTextConfirmed(_, item.name, true) end
	end

	if maxVisibleHeight then
		ftable.properties.maxVisibleHeight = maxVisibleHeight
	end
end

function menu.createUserQuestionContext(frame)
	local useSaveOption = false
	if (menu.contextMenuData.mode == "markashostile") then
		useSaveOption = true
	end
	local numCols = useSaveOption and 6 or 5
	local ftable = frame:addTable(numCols, { tabOrder = 5, reserveScrollBar = false, highlightMode = "off" })
	if useSaveOption then
		ftable:setColWidth(1, Helper.scaleY(Helper.standardButtonHeight), false)
		ftable:setColWidthPercent(5, 25, false)
		ftable:setColWidthPercent(6, 25, false)
	end

	if menu.contextMenuData.mode == "fireindividual" then
		local row = ftable:addRow(false, { fixed = true })
		if menu.contextMenuData.entity then
			row[1]:setColSpan(numCols):createText(string.format(ReadText(1001, 11202), ffi.string(C.GetComponentName(menu.contextMenuData.entity))), Helper.headerRowCenteredProperties)
		else
			row[1]:setColSpan(numCols):createText(string.format(ReadText(1001, 11202), ffi.string(C.GetPersonName(menu.contextMenuData.person, menu.contextMenuData.controllable))), Helper.headerRowCenteredProperties)
		end

		local row = ftable:addRow(false, { fixed = true })
		row[1]:setColSpan(numCols):createText(ReadText(1001, 11201))
	elseif menu.contextMenuData.mode == "fireall" then
		local row = ftable:addRow(false, { fixed = true })
		row[1]:setColSpan(numCols):createText(ReadText(1001, 11250), Helper.headerRowCenteredProperties)

		local row = ftable:addRow(false, { fixed = true })
		row[1]:setColSpan(numCols):createText(ReadText(1001, 11249))

		local count = #menu.infoTablePersistentData[menu.contextMenuData.instance].crew.unassigned.persons
		for i, entry in ipairs(menu.infoTablePersistentData[menu.contextMenuData.instance].crew.unassigned.persons) do
			local adjustedskill = math.floor(C.GetPersonCombinedSkill(menu.contextMenuData.controllable, entry.person, entry.oldrole, nil) * 15 / 100)

			local row = ftable:addRow(false, { fixed = true })
			row[1]:setColSpan(3):createText("    · " .. ffi.string(C.GetPersonName(entry.person, menu.contextMenuData.controllable)))
			row[4]:setColSpan(2):createText(Helper.displaySkill(adjustedskill), { halign = "right", color = Color["text_skills"] })

			if i == 10 then
				break
			end
		end

		if count > 10 then
			local row = ftable:addRow(false, { fixed = true })
			row[1]:setColSpan(3):createText("    · ... (+" .. count - 10 .. ")")
		end
	elseif menu.contextMenuData.mode == "markashostile" then
		local row = ftable:addRow(false, { fixed = true })
		row[1]:setColSpan(numCols):createText(ReadText(1001, 11114), Helper.headerRowCenteredProperties)

		local row = ftable:addRow(false, { fixed = true })
		row[1]:setColSpan(numCols):createText(ReadText(1001, 9710), { wordwrap = true })
	elseif menu.contextMenuData.mode == "clearlogbook" then
		local row = ftable:addRow(false, { fixed = true })
		row[1]:setColSpan(numCols):createText(ReadText(1001, 5722), Helper.headerRowCenteredProperties)

		local row = ftable:addRow(false, { fixed = true })
		row[1]:setColSpan(numCols):createText(ReadText(1001, 5725), { wordwrap = true })
	elseif menu.contextMenuData.mode == "discardplanneddefaultbehaviour" then
		local row = ftable:addRow(false, { fixed = true })
		row[1]:setColSpan(numCols):createText(ReadText(1001, 8320), Helper.headerRowCenteredProperties)

		local row = ftable:addRow(false, { fixed = true })
		row[1]:setColSpan(numCols):createText(ReadText(1001, 11611), { wordwrap = true })
	end


	local row = ftable:addRow(false, { fixed = true })
	row[1]:setColSpan(numCols):createText("")

	if useSaveOption then
		local row = ftable:addRow(true, { fixed = true })
		row[1]:createCheckBox(function () return menu.contextMenuData.saveOption end, { height = Helper.standardButtonHeight })
		row[1].handlers.onClick = function () menu.contextMenuData.saveOption = not menu.contextMenuData.saveOption end
		row[2]:setColSpan(3):createButton({ bgColor = Color["button_background_hidden"] }):setText(ReadText(1001, 9709))
		row[2].handlers.onClick = function () menu.contextMenuData.saveOption = not menu.contextMenuData.saveOption end
		row[5]:createButton({ helpOverlayID = "custom_" .. menu.contextMenuData.mode .. "_confirm", helpOverlayText = " ", helpOverlayHighlightOnly = true }):setText(ReadText(1001, 2821), { halign = "center" })
		row[5].handlers.onClick = menu.buttonConfirmUserQuestion
		row[6]:createButton({ helpOverlayID = "custom_" .. menu.contextMenuData.mode .. "_cancel", helpOverlayText = " ", helpOverlayHighlightOnly = true }):setText(ReadText(1001, 64), { halign = "center" })
		row[6].handlers.onClick = menu.closeContextMenu
		ftable:setSelectedCol(6)
	else
		local row = ftable:addRow(true, { fixed = true })
		row[2]:createButton():setText(ReadText(1001, 2617), { halign = "center" })
		if menu.contextMenuData.mode == "fireindividual" then
			row[2].handlers.onClick = function () return menu.infoSubmenuFireNPC(menu.contextMenuData.controllable, menu.contextMenuData.entity, menu.contextMenuData.person, menu.contextMenuData.instance) end
		elseif menu.contextMenuData.mode == "fireall" then
			row[2].handlers.onClick = function () return menu.buttonFireCrew(menu.contextMenuData.instance, menu.contextMenuData.controllable) end
		elseif menu.contextMenuData.mode == "clearlogbook" then
			row[2].handlers.onClick = function () return menu.buttonInfoLogbookClear(menu.contextMenuData.instance) end
		elseif menu.contextMenuData.mode == "discardplanneddefaultbehaviour" then
			row[2].handlers.onClick = menu.contextMenuData.callback
			row[2].handlers.onClick = menu.contextMenuData.callback
		end
		row[4]:createButton():setText(ReadText(1001, 2618), { halign = "center" })
		row[4].handlers.onClick = menu.closeContextMenu
		ftable:setSelectedCol(4)
	end
end

function menu.createOnlineModeContext(frame)
	local ftable = frame:addTable(2, { tabOrder = 1, reserveScrollBar = false, highlightMode = "off", x = (Helper.viewWidth - menu.onlineModeHintWidth) / 2, y = Helper.viewHeight / 2 - frame.properties.y, width = menu.onlineModeHintWidth - Helper.borderSize, backgroundID = "solid", backgroundColor = Color["frame_background_notification"] })
	ftable:setDefaultColSpan(1, 2)

	local counter = 1

	local hassession = OnlineHasSession()
	local hasdocks = false
	local hasmultipledocksperplatform = false
	for _, entry in ipairs(Helper.ventureplatforms) do
		if #entry.docks > 0 then
			hasdocks = true
			if #entry.docks > 1 then
				hasmultipledocksperplatform = true
			end
		end
	end

	ftable:addEmptyRow(Helper.standardTextHeight / 2)

	if menu.contextMenuData.confirmoverwrite then
		local row = ftable:addRow(nil, {  })
		row[1]:createText(ReadText(1001, 11332), Helper.titleTextProperties)

		local row = ftable:addRow(nil, {  })
		row[1]:createText(ReadText(1001, 11329), { fontsize = 10, x = 3 * Helper.standardTextOffsetx, wordwrap = true, color = Color["text_warning"] })

		local row = ftable:addRow(true, {  })
		row[1]:setColSpan(1):createButton({ active = function () return IsOnlineSavePossible() end }):setText(ReadText(1001, 14), { fontsize = 10, halign = "center" })
		row[1].handlers.onClick = menu.buttonConvertVentureSave

		row[2]:createButton({  }):setText(ReadText(1001, 64), { fontsize = 10, halign = "center" })
		row[2].handlers.onClick = menu.buttonToggleMultiverseMap
		ftable:setSelectedCol(2)
	elseif hassession and hasdocks and (not hasmultipledocksperplatform) then
		local row = ftable:addRow(nil, {  })
		row[1]:createText(ReadText(1001, 11332), Helper.titleTextProperties)

		local row = ftable:addRow(nil, {  })
		row[1]:createText(ReadText(1001, 11328), { fontsize = 10, x = 3 * Helper.standardTextOffsetx, wordwrap = true })

		local savegames = GetSaveList(Helper.validSaveFilenames)
		local hasonlinesave = false
		for _, save in ipairs(savegames) do
			if save.isonline and (save.filename == "online_save") then
				hasonlinesave = true
				break
			end
		end
		if hasonlinesave then
			ftable:addEmptyRow()

			local row = ftable:addRow(nil, {  })
			row[1]:createText(ReadText(1001, 11361), { fontsize = 10, x = 3 * Helper.standardTextOffsetx, wordwrap = true, color = Color["text_warning"] })
		end

		ftable:addEmptyRow()

		local row = ftable:addRow(nil, {  })
		row[1]:createText(ReadText(1001, 11362), { fontsize = 10, x = 3 * Helper.standardTextOffsetx, wordwrap = true })

		ftable:addEmptyRow()

		while not C.IsSaveListLoadingComplete() do
			-- wait until loading the savegame list is complete
		end
		local savegames = GetSaveList(Helper.validSaveFilenames)
		local onlinesave = false
		for _, save in ipairs(savegames) do
			if save.isonline then
				onlinesave = true
				break
			end
		end

		local row = ftable:addRow(nil, {  })
		row[1]:createText(ReadText(1001, 11331), { fontsize = 10, x = 3 * Helper.standardTextOffsetx, wordwrap = true })

		local row = ftable:addRow(true, {  })
		row[1]:setColSpan(1):createButton({ active = function () return IsOnlineSavePossible() end }):setText(ReadText(1001, 11333), { fontsize = 10, halign = "center" })
		row[1].handlers.onClick = onlinesave and menu.buttonConfirmConvertVentureSave or menu.buttonConvertVentureSave

		row[2]:createButton({  }):setText(ReadText(1001, 64), { fontsize = 10, halign = "center" })
		row[2].handlers.onClick = menu.buttonToggleMultiverseMap
		ftable:setSelectedCol(2)
	else
		local row = ftable:addRow(nil, {  })
		row[1]:createText(ReadText(1001, 11306), Helper.titleTextProperties)

		local completed = hassession
		local row = ftable:addRow(nil, {  })
		row[1]:createText((completed and ColorText["text_positive"] or "") .. counter .. ". " .. ReadText(1001, 11301) .. (completed and " \27[widget_tick_01]" or ""), { fontsize = 10, x = 3 * Helper.standardTextOffsetx, wordwrap = true })
		counter = counter + 1

		completed = C.GetVentureDLCStatus() == 0
		local row = ftable:addRow(nil, {  })
		row[1]:createText((completed and ColorText["text_positive"] or "") .. counter .. ". " .. ReadText(1001, 11358) .. (completed and " \27[widget_tick_01]" or ""), { fontsize = 10, x = 3 * Helper.standardTextOffsetx, wordwrap = true })
		counter = counter + 1

		completed = true
		local row = ftable:addRow(nil, {  })
		row[1]:createText((completed and ColorText["text_positive"] or "") .. counter .. ". " .. ReadText(1001, 11302) .. (completed and " \27[widget_tick_01]" or ""), { fontsize = 10, x = 3 * Helper.standardTextOffsetx, wordwrap = true })
		counter = counter + 1

		completed = hasdocks
		local row = ftable:addRow(nil, {  })
		row[1]:createText((completed and ColorText["text_positive"] or "") .. counter .. ". " .. ReadText(1001, 11573) .. (completed and " \27[widget_tick_01]" or ""), { fontsize = 10, x = 3 * Helper.standardTextOffsetx, wordwrap = true })
		counter = counter + 1

		if hasmultipledocksperplatform then
			completed = false
			local row = ftable:addRow(nil, {  })
			row[1]:createText((completed and ColorText["text_positive"] or "") .. counter .. ". " .. ReadText(1001, 11597) .. (completed and " \27[widget_tick_01]" or ""), { fontsize = 10, x = 3 * Helper.standardTextOffsetx, wordwrap = true })
			counter = counter + 1
		end

		completed = false
		local row = ftable:addRow(nil, {  })
		row[1]:createText((completed and ColorText["text_positive"] or "") .. counter .. ". " .. ReadText(1001, 11574) .. (completed and " \27[widget_tick_01]" or ""), { fontsize = 10, x = 3 * Helper.standardTextOffsetx, wordwrap = true })
		counter = counter + 1
	end

	ftable:addEmptyRow(Helper.standardTextHeight / 2)

	ftable.properties.y = ftable.properties.y - ftable:getFullHeight() / 2

	return ftable
end

function menu.buttonRenameConfirm()
	-- kuertee start: multi-rename
	local uix_isMultiRename = menu.contextMenuData.uix_multiRename_objects and #menu.contextMenuData.uix_multiRename_objects > 1 and (not menu.contextMenuData.fleetrename)
	if uix_isMultiRename then
		local newtext = menu.contextMenuData.newtext
		if not newtext then
			newtext = GetComponentData(menu.contextMenuData.uix_multiRename_objects[1], "name")
		end
		if callbacks ["buttonRenameConfirm_onMultiRename_on_before_rename"] then
			for _, callback in ipairs (callbacks ["buttonRenameConfirm_onMultiRename_on_before_rename"]) do
				callback ()
			end
		end
		table.sort(menu.contextMenuData.uix_multiRename_objects, function (a, b) return menu.sortDanger(a, b, true) end)
		for uix_index, uix_object in ipairs(menu.contextMenuData.uix_multiRename_objects) do
			local isplayerowned = GetComponentData(ConvertStringTo64Bit(tostring(uix_object)), "isplayerowned")
			if isplayerowned then
				local uix_name = menu.uix_multiRename_formatName(uix_object, newtext, uix_index)
				SetComponentName(uix_object, uix_name)
				-- local dpsTable = ffi.new("DPSData[?]", 6)
				-- C.GetDefensibleDPS(dpsTable, uix_object, true, true, true, false, true, false, false)
				-- Helper.debugText_forced(ffi.string(C.GetObjectIDCode(uix_object)), dpsTable[0].dps)
				-- Helper.debugText_forced("    ", dpsTable[1].dps)
				-- Helper.debugText_forced("    ", dpsTable[2].dps)
				-- Helper.debugText_forced("    ", dpsTable[3].dps)
				-- Helper.debugText_forced("    ", dpsTable[4].dps)
				-- Helper.debugText_forced("    ", dpsTable[5].dps)
			end
		end
		if callbacks ["buttonRenameConfirm_onMultiRename_on_after_rename"] then
			for _, callback in ipairs (callbacks ["buttonRenameConfirm_onMultiRename_on_after_rename"]) do
				callback ()
			end
		end

		-- [UniTrader's Advanced Renaming] Forleyor start: callback
		if callbacks ["utRenaming_buttonRenameConfirm"] then
			for _, callback in ipairs (callbacks ["utRenaming_buttonRenameConfirm"]) do
				callback ()
			end
		end
		-- [UniTrader's Advanced Renaming] Forleyor end: callback
	-- kuertee end: multi-rename

	-- kuertee start: multi-rename
	-- if menu.contextMenuData.newtext then
	elseif menu.contextMenuData.newtext then
	-- kuertee end: multi-rename

		if menu.contextMenuData.fleetrename then
			C.SetFleetName(menu.contextMenuData.component, menu.contextMenuData.newtext)
		else
			local uix_name_old = GetComponentData(menu.contextMenuData.component, "name")
			local uix_idcode = C.GetObjectIDCode(menu.contextMenuData.component)
			Helper.debugText_forced(menu.contextMenuData.component, uix_name_old .. tostring(uix_idcode))
			Helper.debugText_forced("newtext", menu.contextMenuData.newtext)

			SetComponentName(menu.contextMenuData.component, menu.contextMenuData.newtext)

			-- [UniTrader's Advanced Renaming] Forleyor start: callback
			if callbacks ["utRenaming_buttonRenameConfirm"] then
				for _, callback in ipairs (callbacks ["utRenaming_buttonRenameConfirm"]) do
					callback ()
				end
			end
			-- [UniTrader's Advanced Renaming] Forleyor end: callback

		end
	end
	menu.noupdate = false
	menu.refreshInfoFrame()
	menu.closeContextMenu("back")
end

-- kuertee start: multi-rename
function menu.uix_multiRename_formatName(object, newName, uix_index)
	local uix_name = newName
	if string.find(uix_name, "$name") then
		uix_name = string.gsub(uix_name, "%$name", GetComponentData(object, "name"))
	end
	if string.find(uix_name, "$name_UTAR") then
		local editName
		-- start: from utrenaming.lua utRenaming.setupInfoSubmenuRows() --
		local editNames = GetNPCBlackboard(ConvertStringTo64Bit(tostring(C.GetPlayerID())) , "$unformatted_names")
		if editNames then
			for k,v in pairs(editNames) do
				--DebugError(tostring(k))
				--DebugError("ID: "..tostring(inputobject))
				if tostring(k) == "ID: "..tostring(station) then
					editName = v
					--DebugError(editName)
					break
				end
			end
		end
		uix_name = string.gsub(uix_name, "%$name_UTAR", GetComponentData(object, "editName"))
	end
	if string.find(uix_name, "$i") then
		uix_name = string.gsub(uix_name, "%$i", uix_index)
	end
	return uix_name
end
-- kuertee end: multi-rename

function menu.initializeBoardingData(target)
	menu.boardingData = {
							target = target, ships = {}, shipdata = {}, selectedship = nil,
							marinelevels = {}, casualties = {0, 0, 0},
							currentphase = "setup", phaseindices = {}, phasedata = {}, progresslevels = {},
							risk1 = nil, risk2 = nil, risklevels = {}, riskleveldata = {},
							shipactions = {},
							changed = false, iscapturable = GetComponentData(target, "iscapturable")
						}
	local numtiers = C.GetNumTiersOfRole("marine")
	local tierdata = ffi.new("RoleTierData[?]", numtiers)
	numtiers = C.GetTiersOfRole(tierdata, numtiers, "marine")
	for i = 0, numtiers - 1 do
		table.insert(menu.boardingData.marinelevels, { skilllevel = tierdata[i].skilllevel, text = ffi.string(tierdata[i].name) })
	end

	local numphases = C.GetNumAllBoardingPhases()
	local phases = ffi.new("BoardingPhase[?]", numphases)
	numphases = C.GetAllBoardingPhases(phases, numphases)
	for i = 0, numphases-1 do
		if ffi.string(phases[i].id) ~= "" then
			local phaseid = ffi.string(phases[i].id)
			menu.boardingData.phaseindices[phaseid] = (i+1)
			if phaseid == "approach" or phaseid == "infiltration" or phaseid == "internalfight" then
				table.insert(menu.boardingData.phasedata, { text = ffi.string(phases[i].text), state = "waiting", mouseOverText = "" })
			end
		end
	end
	menu.boardingData.phasedata[1].mouseOverText = ReadText(1026, 8201)		-- Destroy turrets to improve chances of boarding pods arriving safely.
	menu.boardingData.phasedata[2].mouseOverText = ReadText(1026, 8202)		-- Damage hull to reduce the time needed to breach the target.
	menu.boardingData.phasedata[3].mouseOverText = ReadText(1026, 8203)		-- Send more or better marines to improve chances of success.

	menu.boardingData.phasedata[1].helpOverlayID = "boarding_stage1"
	menu.boardingData.phasedata[2].helpOverlayID = "boarding_stage2"
	menu.boardingData.phasedata[3].helpOverlayID = "boarding_stage3"

	menu.boardingData.phasedata[1].helpOverlayText = " "
	menu.boardingData.phasedata[2].helpOverlayText = " "
	menu.boardingData.phasedata[3].helpOverlayText = " "

	menu.boardingData.phasedata[1].helpOverlayHighlightOnly = true
	menu.boardingData.phasedata[2].helpOverlayHighlightOnly = true
	menu.boardingData.phasedata[3].helpOverlayHighlightOnly = true

	menu.boardingData.progresslevels = { -- Stage not started, Stage in progress, Stage completed
		waiting = {text = ReadText(1001, 9510), color = Color["text_boarding_waiting"]},
		started = {text = ReadText(1001, 9511), color = Color["text_boarding_started"]},
		done	= {text = ReadText(1001, 9512), color = Color["text_boarding_done"]},
	}

	menu.boardingData.risklevels = { "verylow", "low", "medium", "high", "veryhigh" }
	menu.boardingData.riskleveldata = {
		verylow		= { index = 1, text = ReadText(1037, 3001), textlower = ReadText(1037, 4001), threshold = 20, hulldescription = ReadText(1037, 5001), color = Color["text_boarding_risk_verylow"] },
		low			= { index = 2, text = ReadText(1037, 3002), textlower = ReadText(1037, 4002), threshold = 30, hulldescription = ReadText(1037, 5002), color = Color["text_boarding_risk_low"] },
		medium		= { index = 3, text = ReadText(1037, 3003), textlower = ReadText(1037, 4003), threshold = 50, hulldescription = ReadText(1037, 5003), color = Color["text_boarding_risk_medium"] },
		high		= { index = 4, text = ReadText(1037, 3004), textlower = ReadText(1037, 4004), threshold = 80, hulldescription = ReadText(1037, 5004), color = Color["text_boarding_risk_high"] },
		veryhigh	= { index = 5, text = ReadText(1037, 3005), textlower = ReadText(1037, 4005), threshold = 100, hulldescription = ReadText(1037, 5005), color = Color["text_boarding_risk_veryhigh"] },
		impossible	= { index = 6, text = ReadText(1037, 3006), textlower = ReadText(1037, 4006), threshold = 120, hulldescription = ReadText(1037, 5005), color = Color["text_boarding_risk_impossible"] },
	}
	if not menu.boardingData.risk1 then
		-- Approach risk threshold. default: low
		menu.boardingData.risk1 = menu.boardingData.risklevels[2]
	end
	if not menu.boardingData.risk2 then
		-- Infiltrate risk threshold. default: high (marines don't die while drilling through anymore, but it does increase risk for them in the assault phase since defenders have more time to organize.)
		menu.boardingData.risk2 = menu.boardingData.risklevels[4]
	end

	local numactions = C.GetNumAllBoardingBehaviours()
	local actions = ffi.new("BoardingBehaviour[?]", numactions)
	numactions = C.GetAllBoardingBehaviours(actions, numactions)
	for i = 0, numactions-1 do
		if ffi.string(actions[i].id) ~= "" then
			table.insert(menu.boardingData.shipactions, { id = ffi.string(actions[i].id), text = ffi.string(actions[i].text) })
		end
	end
end

function menu.createBoardingContext(frame, target, boarders)
	if not menu.boardingData or not menu.boardingData.target then
		menu.initializeBoardingData(target)
	end

	local activeop = C.IsDefensibleBeingBoardedBy(target, "player")
	local unknowntext = ReadText(1001, 3210)
	local unknowncolor = Color["text_negative"]
	local boardingcheatsecrecy = false

	-- if op is already running, add all ships that are already assigned to the boarding operation.
	if activeop then
		menu.boardingData.currentphase = ffi.string(C.GetCurrentBoardingPhase(target, "player"))
		-- get risk thresholds
		local rawriskthresholds = ffi.new("BoardingRiskThresholds")
		rawriskthresholds = C.GetBoardingRiskThresholds(target, "player")
		--print("rawrisk1: " .. tostring(rawriskthresholds[0]) .. ", rawrisk2: " .. tostring(rawriskthresholds[1]))
		local found1, found2 = nil
		for _, risklevel in ipairs(menu.boardingData.risklevels) do
			if not found1 and rawriskthresholds.approach <= menu.boardingData.riskleveldata[risklevel].threshold then
				menu.boardingData.risk1 = risklevel
				found1 = true
			end
			if not found2 and rawriskthresholds.insertion <= menu.boardingData.riskleveldata[risklevel].threshold then
				menu.boardingData.risk2 = risklevel
				found2 = true
			end
			if found1 and found2 then
				break
			end
		end
		--print("retrieved risk levels. approach: " .. tostring(menu.boardingData.riskleveldata[menu.boardingData.risk1].text) .. ", insertion: " .. tostring(menu.boardingData.riskleveldata[menu.boardingData.risk2].text))

		local numattackers = C.GetNumAttackersOfBoardingOperation(target, "player")
		local attackers = ffi.new("UniverseID[?]", numattackers)
		numattackers = C.GetAttackersOfBoardingOperation(attackers, numattackers, target, "player")
		--print("num attackers: " .. tostring(numattackers) .. ". attackers: ")
		for i = 0, numattackers-1 do
			local boarder = ConvertStringTo64Bit(tostring(attackers[i]))
			--print(" " .. ffi.string(C.GetComponentName(boarder)))

			if not menu.boardingData.shipdata[boarder] then
				table.insert(menu.boardingData.ships, boarder)
				menu.boardingData.shipdata[boarder] = { assignedmarines = {}, marines = {}, assignedgroupmarines = {}, groupmarines = {}, subordinates = {}, isprimaryboarder = true, issubordinate = false, action = ffi.string(C.GetBoardingActionOfAttacker(target, boarder, "player")) }

				-- only update assignedmarines if shipdata is to be reset.
				local numtiers = #menu.boardingData.marinelevels
				local marinetieramounts = ffi.new("uint32_t[?]", numtiers)
				local marineskilllevellist = ffi.new("uint32_t[?]", numtiers)
				for j, leveldata in ipairs(menu.boardingData.marinelevels) do
					marineskilllevellist[j-1] = leveldata.skilllevel
				end
				C.GetBoardingMarineTierAmountsFromAttacker(marinetieramounts, marineskilllevellist, numtiers, target, boarder, "player")
				for j, leveldata in ipairs(menu.boardingData.marinelevels) do
					menu.boardingData.shipdata[boarder].assignedmarines[leveldata.skilllevel] = marinetieramounts[j-1]
					menu.boardingData.shipdata[boarder].assignedgroupmarines[leveldata.skilllevel] = marinetieramounts[j-1]
					--print("retrieving. index: " .. tostring(j-1) .. ", num marines: " .. tostring(marinetieramounts[j-1]) .. ", skill level: " .. tostring(leveldata.skilllevel))
				end
			end
		end
	end

	-- add all boarders that were passed in and are not yet listed to menu.boardingData.ships and initialize menu.boardingData.shipdata for them.
	for _, ship in ipairs(boarders) do
		if not menu.boardingData.shipdata[ship] then
			--print("adding " .. ffi.string(C.GetComponentName(ship)) .. " to boarding operation.")
			table.insert(menu.boardingData.ships, ship)
			menu.boardingData.shipdata[ship] = { assignedmarines = {}, marines = {}, assignedgroupmarines = {}, groupmarines = {}, subordinates = {}, isprimaryboarder = true, issubordinate = false, action = menu.boardingData.shipactions[2].id }
		end
	end

	-- populate marine and subordinate data for menu.boardingData.ships in menu.boardingData.shipdata
	for _, ship in ipairs(menu.boardingData.ships) do
		local numpeople = C.GetNumAllRoles()
		local peopledata = ffi.new("PeopleInfo[?]", numpeople)
		numpeople = C.GetPeople2(peopledata, numpeople, ship, false)
		local numtiers = #menu.boardingData.marinelevels
		local tierdata = ffi.new("RoleTierData[?]", numtiers)
		numtiers = C.GetRoleTiers2(tierdata, numtiers, ship, "marine", false)
		for i = 0, numtiers - 1 do
			menu.boardingData.shipdata[ship].marines[tierdata[i].skilllevel] = tierdata[i].amount
			menu.boardingData.shipdata[ship].groupmarines[tierdata[i].skilllevel] = tierdata[i].amount
		end

		local subordinates = GetSubordinates(ship, nil, true)
		--print("found " .. tostring(#subordinates) .. " subordinates")
		for _, subordinate in ipairs(subordinates) do
			local subordinate = ConvertIDTo64Bit(subordinate)
			if not C.IsUnit(subordinate) then
				if not menu.boardingData.shipdata[subordinate] then
					menu.boardingData.shipdata[subordinate] = { assignedmarines = {}, marines = {}, assignedgroupmarines = {}, groupmarines = {}, subordinates = {}, isprimaryboarder = false, issubordinate = true, action = menu.boardingData.shipactions[2].id }

					local alreadylisted = false
					for _, evalsubordinate in ipairs(menu.boardingData.shipdata[ship].subordinates) do
						if subordinate == evalsubordinate then
							alreadylisted = true
							break
						end
					end
					if not alreadylisted then
						--print("adding subordinate " .. ffi.string(C.GetComponentName(subordinate)) .. " to boarding operation.")
						table.insert(menu.boardingData.shipdata[ship].subordinates, subordinate)
					end
				else
					menu.boardingData.shipdata[subordinate].issubordinate = true
				end

				if not menu.boardingData.shipdata[subordinate].isprimaryboarder then
					numpeople = C.GetNumAllRoles()
					peopledata = ffi.new("PeopleInfo[?]", numpeople)
					numpeople = C.GetPeople2(peopledata, numpeople, subordinate, false)
					numtiers = #menu.boardingData.marinelevels
					tierdata = ffi.new("RoleTierData[?]", numtiers)
					numtiers = C.GetRoleTiers2(tierdata, numtiers, subordinate, "marine", false)
					for i = 0, numtiers - 1 do
						if tierdata[i].amount > 0 then
							--print("subordinate: " .. ffi.string(C.GetComponentName(subordinate)) .. ": adding " .. tierdata[i].amount .. " marines with skill " .. tostring(tierdata[i].skilllevel) .. " to entry of " .. ffi.string(C.GetComponentName(ship)))
							menu.boardingData.shipdata[subordinate].marines[tierdata[i].skilllevel] = tierdata[i].amount
							menu.boardingData.shipdata[subordinate].groupmarines[tierdata[i].skilllevel] = tierdata[i].amount
							menu.boardingData.shipdata[ship].groupmarines[tierdata[i].skilllevel] = menu.boardingData.shipdata[ship].groupmarines[tierdata[i].skilllevel] + tierdata[i].amount
						end
					end
				end

				for _, tierdata in ipairs(menu.boardingData.marinelevels) do
					if not menu.boardingData.shipdata[subordinate].assignedmarines[tierdata.skilllevel] then
						menu.boardingData.shipdata[subordinate].assignedmarines[tierdata.skilllevel] = 0
					end
					if not menu.boardingData.shipdata[subordinate].assignedgroupmarines[tierdata.skilllevel] then
						menu.boardingData.shipdata[subordinate].assignedgroupmarines[tierdata.skilllevel] = 0
					end
				end
			end
		end
		for _, tierdata in ipairs(menu.boardingData.marinelevels) do
			if not menu.boardingData.shipdata[ship].assignedmarines[tierdata.skilllevel] then
				menu.boardingData.shipdata[ship].assignedmarines[tierdata.skilllevel] = 0
			end
			if not menu.boardingData.shipdata[ship].assignedgroupmarines[tierdata.skilllevel] then
				menu.boardingData.shipdata[ship].assignedgroupmarines[tierdata.skilllevel] = 0
			end
		end
	end

	local targetname, targetowner, hullpercentage = GetComponentData(target, "name", "ownername", "hullpercent")

	local numoperationalturrets = 0
	local numtotalturrets = 0
	local numpotentialturrets = 0
	local numslots = tonumber(C.GetNumUpgradeSlots(target, "", "turret"))
	for i = 1, numslots do
		numpotentialturrets = numpotentialturrets + 1
		local currentcomponent = ConvertStringTo64Bit(tostring(C.GetUpgradeSlotCurrentComponent(target, "turret", i)))
		if currentcomponent and currentcomponent ~= 0 then
			numtotalturrets = numtotalturrets + 1
			if IsComponentOperational(currentcomponent) then
				numoperationalturrets = numoperationalturrets + 1
			end
		end
	end

	local targetcrewcapacity = C.GetPeopleCapacity(target, "", false)

	local currentboardingresistance = GetComponentData(target, "boardingresistance")
	local numdefendingcrew = menu.getNumDefendingCrew(target)

	-- tally total assigned marines and fill in empty marine tier entries.
	local totalassignedmarines = 0
	if activeop then
		totalassignedmarines = totalassignedmarines + C.GetNumBoardingMarinesFromOperation(target, "player")
	else
		for _, boarder in ipairs(menu.boardingData.ships) do
			for _, tierdata in ipairs(menu.boardingData.marinelevels) do
				if not menu.boardingData.shipdata[boarder].assignedmarines[tierdata.skilllevel] then
					menu.boardingData.shipdata[boarder].assignedmarines[tierdata.skilllevel] = 0
				end
				if not menu.boardingData.shipdata[boarder].assignedgroupmarines[tierdata.skilllevel] then
					menu.boardingData.shipdata[boarder].assignedgroupmarines[tierdata.skilllevel] = 0
				end
				totalassignedmarines = totalassignedmarines + menu.boardingData.shipdata[boarder].assignedgroupmarines[tierdata.skilllevel]
				--print("assigned marines: adding " .. menu.boardingData.shipdata[boarder].assignedgroupmarines[tierdata.skilllevel] .. " " .. tostring(tierdata.text) .. " marines from " .. ffi.string(C.GetComponentName(boarder)) .. " " .. tostring(boarder) .. " to total tally.\n total: " .. tostring(totalassignedmarines))
			end
		end
	end

	if not menu.boardingData.selectedship or not menu.boardingData.shipdata[menu.boardingData.selectedship] then
		menu.boardingData.selectedship = menu.boardingData.ships[1]
	end

	local boardingstrength = 0
	if activeop then
		boardingstrength = boardingstrength + C.GetBoardingStrengthFromOperation(target, "player")
	else
		for i, ship in ipairs(menu.boardingData.ships) do
			local locnumtiers = #menu.boardingData.marinelevels
			local locmarinetieramounts = ffi.new("uint32_t[?]", locnumtiers)
			local locmarineskilllevels = ffi.new("uint32_t[?]", locnumtiers)
			for j, level in ipairs(menu.boardingData.marinelevels) do
				locmarinetieramounts[j-1] = menu.boardingData.shipdata[ship].assignedmarines[level.skilllevel]
				locmarineskilllevels[j-1] = level.skilllevel
				--print("tier: " .. j .. " num tiers: " .. locnumtiers .. " tier amount: " .. tostring(menu.boardingData.shipdata[ship].assignedmarines[level.skilllevel]) .. " skill level: " .. level.skilllevel)
			end
			boardingstrength = boardingstrength + C.GetBoardingStrengthOfControllableTierAmounts(ship, locmarinetieramounts, locmarineskilllevels, locnumtiers)
			if #menu.boardingData.shipdata[ship].subordinates > 0 then
				for _, subordinate in ipairs(menu.boardingData.shipdata[ship].subordinates) do
					for j, level in ipairs(menu.boardingData.marinelevels) do
						locmarinetieramounts[j-1] = menu.boardingData.shipdata[subordinate].assignedmarines[level.skilllevel]
						locmarineskilllevels[j-1] = level.skilllevel
						--print("subordinate. tier: " .. j .. " num tiers: " .. locnumtiers .. " tier amount: " .. tostring(menu.boardingData.shipdata[subordinate].assignedmarines[level.skilllevel]) .. " skill level: " .. level.skilllevel)
					end
					boardingstrength = boardingstrength + C.GetBoardingStrengthOfControllableTierAmounts(subordinate, locmarinetieramounts, locmarineskilllevels, locnumtiers)
				end
			end
			--print("calculating boarding strength. num ships evaluated: " .. i .. " boarding strength: " .. boardingstrength)
		end
	end

	-- max potential boarding resistance: only for comparison with boardingstrength to be expressed as an adjective for crew strength estimate in stage III. always use potential? that would tend to make the approximation safer if very conservative.
	-- we're now using combinedskill to calculate boarding strength, so max potential is max number of crew * maxcombinedskill
	--local maxpotentialboardingresistance = targetcrewcapacity * 100
	local maxpotentialboardingresistance = numdefendingcrew * 100

	-- NB: risk numbers will be updated every time the text widgets that use them are.
	local risk = {}
	-- chance that launched marines will get to target compared to target ship type with maximum loadout
	table.insert(risk, ((numoperationalturrets / math.max(numtotalturrets, 1)) * 100))
	--table.insert(risk, ((numoperationalturrets / numpotentialturrets) * 100))
	-- chance that assaulting marines will survive entry
	table.insert(risk, hullpercentage)
	-- chance that attacking ships will accidentally destroy target
	table.insert(risk, 100 - risk[2])
	-- chance that assaulting marines will defeat opposition within the ship
	table.insert(risk, ((1.0 - math.min((boardingstrength / math.max(currentboardingresistance, 1.0)), 1.0)) * 100))
	--print("risk 1: " .. tostring(risk[1]) .. "\nrisk 2: " .. tostring(risk[2]) .. "\nrisk 3: " .. tostring(risk[3]))

	-- Boarding
	local table_header = frame:addTable(1, { x = Helper.borderSize, y = Helper.borderSize, width = menu.contextMenuData.width })

	local row = table_header:addRow(false, { fixed = true, bgColor = Color["row_background_blue"] })
	row[1]:createText(ReadText(1001, 9500), Helper.headerRowCenteredProperties)		-- Boarding

	-- Boarding Plan
	local table_bottom = frame:addTable(9, { tabOrder = 5, x = Helper.borderSize, y = menu.contextMenuData.height * 3 / 4 + Helper.borderSize, width = menu.contextMenuData.width, highlightMode = "column" })
	table_bottom:setColWidthPercent(2, 5)
	table_bottom:setColWidthPercent(3, 10)
	table_bottom:setColWidthPercent(5, 5)
	table_bottom:setColWidthPercent(6, 10)
	table_bottom:setColWidthPercent(8, 5)
	table_bottom:setColWidthPercent(9, 10)

	row = table_bottom:addRow(false, { fixed = true, bgColor = Color["row_background_blue"] })
	row[1]:setColSpan(9):createText(ReadText(1001, 9501), Helper.headerRowCenteredProperties)		-- Boarding Plan

	row = table_bottom:addRow(false, { fixed = true, bgColor = Color["row_background_unselectable"] })
	for i, phase in ipairs(menu.boardingData.phasedata) do
		row[3*i-2]:setColSpan(3):createText(phase.text, { font = Helper.standardFontBold, halign = "center", mouseOverText = phase.mouseOverText,  helpOverlayID = phase.helpOverlayID, helpOverlayText = phase.helpOverlayText, helpOverlayHighlightOnly = phase.helpOverlayHighlightOnly})
	end

	if activeop then
		row = table_bottom:addRow(false, {  })

		for i, phase in ipairs(menu.boardingData.phasedata) do
			row[3*i-2]:createText((ReadText(1001, 9513) .. ReadText(1001, 120)), { mouseOverText = phase.mouseOverText })		-- Progress, :
			row[3*i-1]:setColSpan(2):createText(function()
					if C.IsDefensibleBeingBoardedBy(target, "player") then
						-- get current phase. updated here to dynamically update the phase for this section of the menu.
						menu.boardingData.currentphase = ffi.string(C.GetCurrentBoardingPhase(target, "player"))
					else
						-- this is for displaying the state of each phase so "succeeded" or "failed" doesn't really matter as long as its index is > that of all of the other phases.
						menu.boardingData.currentphase = "succeeded"
					end

					-- update phase data depending on current phase.
					if i == 1 then
						phase.state = (menu.boardingData.phaseindices[menu.boardingData.currentphase] > menu.boardingData.phaseindices.approach and "done") or "started"
					elseif i == 2 then
						phase.state = (menu.boardingData.phaseindices[menu.boardingData.currentphase] < menu.boardingData.phaseindices.pre_infiltration and "waiting") or (menu.boardingData.phaseindices[menu.boardingData.currentphase] < menu.boardingData.phaseindices.internalfight and "started") or "done"
					elseif i == 3 then
						phase.state = (menu.boardingData.phaseindices[menu.boardingData.currentphase] < menu.boardingData.phaseindices.internalfight and "waiting") or (menu.boardingData.phaseindices[menu.boardingData.currentphase] == menu.boardingData.phaseindices.internalfight and "started") or "done"
					end
					return menu.boardingData.progresslevels[phase.state].text
				end, { halign = "right", color = function() return menu.boardingData.progresslevels[phase.state].color end, mouseOverText = phase.mouseOverText })
		end
	end

	row = table_bottom:addRow(false, {  })

	row[1]:setColSpan(2):createText((ReadText(1001, 9514) .. ReadText(1001, 120)), { mouseOverText = menu.boardingData.phasedata[1].mouseOverText })		-- Risk, :
	row[3]:createText(function() return (boardingcheatsecrecy or C.IsInfoUnlockedForPlayer(target, "defence_status")) and menu.boardingData.riskleveldata[menu.boardingData.risk1].text or unknowntext end, { halign = "right", mouseOverText = menu.boardingData.phasedata[1].mouseOverText, color = function() return (boardingcheatsecrecy or C.IsInfoUnlockedForPlayer(target, "defence_status")) and menu.boardingData.riskleveldata[menu.boardingData.risk1].color or unknowncolor end })

	row[4]:setColSpan(2):createText((ReadText(1001, 9515) .. ReadText(1001, 120)), { mouseOverText = menu.boardingData.phasedata[2].mouseOverText })		-- Risk of destroying target, :
	row[6]:createText(function() return (boardingcheatsecrecy or C.IsInfoUnlockedForPlayer(target, "defence_status")) and menu.boardingData.riskleveldata[menu.boardingData.risklevels[6 - menu.boardingData.riskleveldata[menu.boardingData.risk2].index]].text or unknowntext end, { halign = "right", mouseOverText = menu.boardingData.phasedata[2].mouseOverText, color = function() return (boardingcheatsecrecy or C.IsInfoUnlockedForPlayer(target, "defence_status")) and menu.boardingData.riskleveldata[menu.boardingData.risklevels[6 - menu.boardingData.riskleveldata[menu.boardingData.risk2].index]].color or unknowncolor end })

	row[7]:setColSpan(2):createText((ReadText(1001, 9516) .. ReadText(1001, 120)), { mouseOverText = menu.boardingData.phasedata[3].mouseOverText })		-- Defending crew, :
	row[9]:createText(function()
			local locnumdefendingcrew = menu.getNumDefendingCrew(target)
			return (boardingcheatsecrecy or C.IsInfoUnlockedForPlayer(target, "operator_details")) and (locnumdefendingcrew .. " / " .. targetcrewcapacity) or unknowntext
		end, { halign = "right", mouseOverText = menu.boardingData.phasedata[3].mouseOverText, color = function() return (boardingcheatsecrecy or C.IsInfoUnlockedForPlayer(target, "operator_details")) and Color["text_normal"] or unknowncolor end })

	row = table_bottom:addRow(false, {  })

	row[1]:setColSpan(2):createText((ReadText(1001, 9517) .. ReadText(1001, 120)), { x = Helper.standardTextOffsetx * 2, mouseOverText = menu.boardingData.phasedata[1].mouseOverText })		-- Target combat effectiveness, :
	row[3]:createText(function()
			local locnumoperationalturrets = menu.getNumOperationalTurrets(target, numtotalturrets)
			risk[1] = ((locnumoperationalturrets / math.max(numtotalturrets, 1)) * 100)
			local risktext = ""
			for i = 1, #menu.boardingData.risklevels do
				if risk[1] <= menu.boardingData.riskleveldata[menu.boardingData.risklevels[i]].threshold then
					risktext = menu.boardingData.riskleveldata[menu.boardingData.risklevels[i]].hulldescription
					break
				end
			end
			return (boardingcheatsecrecy or C.IsInfoUnlockedForPlayer(target, "defence_status")) and risktext or unknowntext
		end, { halign = "right", mouseOverText = menu.boardingData.phasedata[1].mouseOverText, color = function() return (boardingcheatsecrecy or C.IsInfoUnlockedForPlayer(target, "defence_status")) and Color["text_normal"] or unknowncolor end })

	row[4]:setColSpan(2):createText((ReadText(1001, 9518) .. ReadText(1001, 120)), { mouseOverText = menu.boardingData.phasedata[2].mouseOverText })		-- Risk to marines, :
	row[6]:createText(function() return (boardingcheatsecrecy or C.IsInfoUnlockedForPlayer(target, "defence_status")) and menu.boardingData.riskleveldata[menu.boardingData.risklevels[menu.boardingData.riskleveldata[menu.boardingData.risk2].index]].text or unknowntext end, { halign = "right", mouseOverText = menu.boardingData.phasedata[2].mouseOverText, color = function() return (boardingcheatsecrecy or C.IsInfoUnlockedForPlayer(target, "defence_status")) and menu.boardingData.riskleveldata[menu.boardingData.risklevels[menu.boardingData.riskleveldata[menu.boardingData.risk2].index]].color or unknowncolor end })

	row[7]:setColSpan(2):createText((ReadText(1001, 9519) .. ReadText(1001, 120)), { mouseOverText = menu.boardingData.phasedata[3].mouseOverText })		-- Attacking marines, :
	row[9]:createText(function()
		local loctotalassignedmarines = totalassignedmarines
		if activeop then
			loctotalassignedmarines = C.GetNumBoardingMarinesFromOperation(target, "player")
		end
		return loctotalassignedmarines .. " / " .. targetcrewcapacity end, { halign = "right", mouseOverText = menu.boardingData.phasedata[3].mouseOverText })

	row = table_bottom:addRow(false, {  })

	row[1]:setColSpan(3):createText("", { mouseOverText = menu.boardingData.phasedata[1].mouseOverText })

	row[4]:setColSpan(2):createText((ReadText(1001, 9520) .. ReadText(1001, 120)), { x = Helper.standardTextOffsetx * 2, mouseOverText = menu.boardingData.phasedata[2].mouseOverText })		-- Target hull, :
	row[6]:createText(function()
			risk[2] = GetComponentData(target, "hullpercent")
			local hulldescription = ""
			for i = 1, #menu.boardingData.risklevels do
				if risk[2] <= menu.boardingData.riskleveldata[menu.boardingData.risklevels[i]].threshold then
					hulldescription = menu.boardingData.riskleveldata[menu.boardingData.risklevels[i]].hulldescription
					break
				end
			end
			return (boardingcheatsecrecy or C.IsInfoUnlockedForPlayer(target, "defence_status")) and hulldescription or unknowntext
		end, { halign = "right", mouseOverText = menu.boardingData.phasedata[2].mouseOverText, color = function() return (boardingcheatsecrecy or C.IsInfoUnlockedForPlayer(target, "defence_status")) and Color["text_normal"] or unknowncolor end })

	row[7]:setColSpan(2):createText((ReadText(1001, 9514) .. ReadText(1001, 120)), { mouseOverText = menu.boardingData.phasedata[3].mouseOverText })		-- Risk, :
	row[9]:createText(function()
			local risktext = ""
			local isimpossible = nil
			if menu.boardingData.iscapturable then
				local loccurrentboardingresistance = GetComponentData(target, "boardingresistance")
				risk[4] = ((2.0 - math.min((boardingstrength / math.max(loccurrentboardingresistance, 1.0)), 2.0)) * 100) / 2
				for i = 1, #menu.boardingData.risklevels do
					if risk[4] <= menu.boardingData.riskleveldata[menu.boardingData.risklevels[i]].threshold then
						--print("risk: " .. tostring(risk[4]) .. ". strength: " .. tostring(boardingstrength) .. ", resistance: " .. tostring(loccurrentboardingresistance) .. ", current threshold: " .. tostring(menu.boardingData.riskleveldata[menu.boardingData.risklevels[i]].threshold))
						risktext = menu.boardingData.riskleveldata[menu.boardingData.risklevels[i]].text
						break
					end
				end
			else
				risktext = menu.boardingData.riskleveldata.impossible.text
				isimpossible = true
			end
			return (boardingcheatsecrecy or isimpossible or C.IsInfoUnlockedForPlayer(target, "operator_details")) and risktext or unknowntext
		end, { halign = "right", mouseOverText = menu.boardingData.phasedata[3].mouseOverText, color = function()
			local riskcolor = nil
			local isimpossible = nil
			if menu.boardingData.iscapturable then
				local loccurrentboardingresistance = GetComponentData(target, "boardingresistance")
				risk[4] = ((2.0 - math.min((boardingstrength / math.max(loccurrentboardingresistance, 1.0)), 2.0)) * 100) / 2
				for i = 1, #menu.boardingData.risklevels do
					if risk[4] <= menu.boardingData.riskleveldata[menu.boardingData.risklevels[i]].threshold then
						riskcolor = menu.boardingData.riskleveldata[menu.boardingData.risklevels[i]].color
						break
					end
				end
			else
				riskcolor = menu.boardingData.riskleveldata.impossible.color
				isimpossible = true
			end
			return (boardingcheatsecrecy or isimpossible or C.IsInfoUnlockedForPlayer(target, "operator_details")) and riskcolor or unknowncolor
		end })

	row = table_bottom:addRow(false, {  })

	row[1]:setColSpan(3):createText((ReadText(1001, 9521) .. ReadText(1001, 120)), { mouseOverText = menu.boardingData.phasedata[1].mouseOverText })		-- Launch pods at combat effectiveness, :

	row[4]:setColSpan(3):createText((ReadText(1001, 9522) .. ReadText(1001, 120)), { mouseOverText = menu.boardingData.phasedata[2].mouseOverText })		-- Start breaching at hull strength, :

	row[7]:setColSpan(2):createText((ReadText(1001, 1325) .. ReadText(1001, 120)), { x = Helper.standardTextOffsetx * 2, mouseOverText = menu.boardingData.phasedata[3].mouseOverText })		-- Boarding Attack Strength, :
	row[9]:createText(function()
			local locboardingstrength = boardingstrength
			if activeop then
				locboardingstrength = C.GetBoardingStrengthFromOperation(target, "player")
			end
			return locboardingstrength
		end, { halign = "right", mouseOverText = menu.boardingData.phasedata[3].mouseOverText })

	local dropdowndata = {}
	for _, levelid in ipairs(menu.boardingData.risklevels) do
		table.insert(dropdowndata, {id = levelid, text = menu.boardingData.riskleveldata[levelid].hulldescription, icon = "", displayremoveoption = false})
	end
	row = table_bottom:addRow(true, {  })

	-- TODO: make dropdown being active dependent on current phase (certainly inactive after phase this applies to is done, but also while the phase is currently active?)
	row[1]:setColSpan(3):createDropDown(dropdowndata, {startOption = menu.boardingData.risk1, height = config.mapRowHeight, mouseOverText = menu.boardingData.phasedata[1].mouseOverText, active = not activeop})
	row[1].handlers.onDropDownConfirmed = function(_, newrisklevel) return menu.dropdownBoardingSetRisk(newrisklevel, 1) end
	row[4]:setColSpan(3):createDropDown(dropdowndata, {startOption = menu.boardingData.risk2, height = config.mapRowHeight, mouseOverText = menu.boardingData.phasedata[2].mouseOverText, active = not activeop})
	row[4].handlers.onDropDownConfirmed = function(_, newrisklevel) return menu.dropdownBoardingSetRisk(newrisklevel, 2) end

	row[7]:setColSpan(2):createText((ReadText(1001, 1324) .. ReadText(1001, 120)), { x = Helper.standardTextOffsetx * 2, mouseOverText = menu.boardingData.phasedata[3].mouseOverText })		-- Boarding Resistance, :
	row[9]:createText(function() return (boardingcheatsecrecy or C.IsInfoUnlockedForPlayer(target, "operator_details")) and tostring(GetComponentData(target, "boardingresistance")) or unknowntext end, { halign = "right", mouseOverText = menu.boardingData.phasedata[3].mouseOverText, color = function() return (boardingcheatsecrecy or C.IsInfoUnlockedForPlayer(target, "operator_details")) and Color["text_normal"] or unknowncolor end })
	--[[
	row[7]:setColSpan(2):createText((ReadText(1001, 9523) .. ReadText(1001, 120)), { x = Helper.standardTextOffsetx * 2, mouseOverText = menu.boardingData.phasedata[3].mouseOverText })		-- Crew strength, :
	row[9]:createText(function()
			local loccurrentboardingresistance = GetComponentData(target, "boardingresistance")
			local targetcrewstrength = loccurrentboardingresistance / math.max(maxpotentialboardingresistance, 1.0)
			--print("crewstrength: " .. tostring(targetcrewstrength) .. ", currentboardingresistance: " .. tostring(currentboardingresistance) .. ", maxpotentialboardingresistance: " .. tostring(maxpotentialboardingresistance))
			local crewdescription = ""
			for i = 1, #menu.boardingData.risklevels do
				if targetcrewstrength <= menu.boardingData.riskleveldata[ menu.boardingData.risklevels[i] ].threshold then
					crewdescription = menu.boardingData.riskleveldata[ menu.boardingData.risklevels[i] ].text
					break
				end
			end
			return (boardingcheatsecrecy or C.IsInfoUnlockedForPlayer(target, "operator_details")) and crewdescription or unknowntext
		end, { halign = "right", mouseOverText = menu.boardingData.phasedata[3].mouseOverText, color = function() return (boardingcheatsecrecy or C.IsInfoUnlockedForPlayer(target, "operator_details")) and Color["text_normal"] or unknowncolor end })
	--]]

	-- Ship Configuration
	local table_left = frame:addTable(2, { tabOrder = 4, x = Helper.borderSize, width = menu.contextMenuData.width / 2 - Helper.borderSize / 2 })

	row = table_left:addRow(false, { fixed = true, bgColor = Color["row_background_blue"] })
	row[1]:setBackgroundColSpan(2):createText(ReadText(1001, 9502) .. ReadText(1001, 120))		-- Configuring, :
	row[2]:createText(ffi.string(C.GetComponentName(menu.boardingData.selectedship)) .. " (" .. ffi.string(C.GetObjectIDCode(menu.boardingData.selectedship)) .. ")", { halign = "right" })

	row = table_left:addRow(false, { fixed = true, bgColor = Color["row_background_unselectable"] })
	row[1]:setColSpan(2):createText((ReadText(1001, 9524) .. ReadText(1001, 120)), { x = Helper.standardTextOffsetx * 2 })		-- Ship behaviour while engaging the target, :

	local dropdowndata2 = {}
	for _, actiondata in ipairs(menu.boardingData.shipactions) do
		table.insert(dropdowndata2, {id = actiondata.id, text = actiondata.text, icon = "", displayremoveoption = false})
	end

	-- TODO: make dropdown being active dependent on current phase? disable after op has started?
	row = table_left:addRow(true, { fixed = true })
	row[1]:setColSpan(2):createDropDown(dropdowndata2, {startOption = menu.boardingData.shipdata[menu.boardingData.selectedship].action, height = config.mapRowHeight, active = not activeop})
	row[1].handlers.onDropDownConfirmed = function(_, newaction) return menu.dropdownBoardingSetAction(menu.boardingData.selectedship, newaction) end

	titlerow = table_left:addRow(false, { fixed = true, bgColor = Color["row_background_unselectable"] })
	titlerow[1]:setColSpan(2):createText((ReadText(1001, 9529) .. ReadText(1001, 120)), { x = Helper.standardTextOffsetx * 3})	-- Select marines to board with, :
	titlerow[1].properties.helpOverlayID = "boarding_selectmarines"
	titlerow[1].properties.helpOverlayText = " "
	titlerow[1].properties.helpOverlayHeight = titlerow:getHeight()
	titlerow[1].properties.helpOverlayHighlightOnly = true
	titlerow[1].properties.helpOverlayScaling = false
	for _, leveldata in ipairs(menu.boardingData.marinelevels) do
		row = table_left:addRow(true, { fixed = true })
		-- TODO: set slider to readOnly depending on phase? will depend on whether or not we allow sending more marines later in the operation to reinforce.
		--print("assigned: " .. tostring(assignedmarines[menu.boardingData.selectedship][leveldata.skilllevel]) .. ", available: " .. tostring(availablemarines[leveldata.skilllevel]))
		--print("start: " .. tostring(menu.boardingData.shipdata[menu.boardingData.selectedship].assignedmarines[leveldata.skilllevel]) .. ", maxSelect: " .. tostring(menu.boardingData.shipdata[menu.boardingData.selectedship].marines[leveldata.skilllevel] > (targetcrewcapacity - totalassignedmarines + menu.boardingData.shipdata[menu.boardingData.selectedship].assignedmarines[leveldata.skilllevel]) and (targetcrewcapacity - totalassignedmarines + menu.boardingData.shipdata[menu.boardingData.selectedship].assignedmarines[leveldata.skilllevel]) or menu.boardingData.shipdata[menu.boardingData.selectedship].marines[leveldata.skilllevel]) .. "\n poss1: " .. tostring(targetcrewcapacity - totalassignedmarines + menu.boardingData.shipdata[menu.boardingData.selectedship].assignedmarines[leveldata.skilllevel]) .. "\n poss2: " .. tostring(menu.boardingData.shipdata[menu.boardingData.selectedship].marines[leveldata.skilllevel]) .. "\ntargetcrewcapacity: " .. tostring(targetcrewcapacity) .. "\ntotalassignedmarines: " .. tostring(totalassignedmarines))
		--print("skilllevel: " .. tostring(leveldata.skilllevel) .. ", groupmarines: " .. tostring(menu.boardingData.shipdata[menu.boardingData.selectedship].groupmarines[leveldata.skilllevel]) .. ", marines: " .. tostring(menu.boardingData.shipdata[menu.boardingData.selectedship].marines[leveldata.skilllevel]) .. ", assignedgroupmarines: " .. tostring(menu.boardingData.shipdata[menu.boardingData.selectedship].assignedgroupmarines[leveldata.skilllevel]) .. ", assignedmarines: " .. tostring(menu.boardingData.shipdata[menu.boardingData.selectedship].assignedmarines[leveldata.skilllevel]))
		row[1]:setColSpan(2):createSliderCell({ start = menu.boardingData.shipdata[menu.boardingData.selectedship].assignedgroupmarines[leveldata.skilllevel], max = menu.boardingData.shipdata[menu.boardingData.selectedship].groupmarines[leveldata.skilllevel], maxSelect = menu.boardingData.shipdata[menu.boardingData.selectedship].groupmarines[leveldata.skilllevel] > (targetcrewcapacity - totalassignedmarines + menu.boardingData.shipdata[menu.boardingData.selectedship].assignedgroupmarines[leveldata.skilllevel]) and (targetcrewcapacity - totalassignedmarines + menu.boardingData.shipdata[menu.boardingData.selectedship].assignedgroupmarines[leveldata.skilllevel]) or menu.boardingData.shipdata[menu.boardingData.selectedship].groupmarines[leveldata.skilllevel], height = config.mapRowHeight, x = Helper.standardTextOffsetx * 4, readOnly = activeop }):setText(leveldata.text)
		row[1].handlers.onSliderCellChanged = function(_, val) return menu.slidercellBoardingAssignedMarines(menu.boardingData.selectedship, leveldata.skilllevel, val) end
		row[1].handlers.onSliderCellConfirm = function() return menu.refreshContextFrame() end
		titlerow[1].properties.helpOverlayHeight = titlerow[1].properties.helpOverlayHeight + row:getHeight() + Helper.borderSize
	end

	row = table_left:addRow(false, { fixed = true, bgColor = Color["row_background_unselectable"] })
	row[1]:setBackgroundColSpan(2):createText((ReadText(1001, 9525) .. ReadText(1001, 120)), { x = Helper.standardTextOffsetx * 2 })		-- Boarding strength, :
	row[2]:createText(function()
			local locboardingstrength = boardingstrength
			if activeop then
				locboardingstrength = C.GetBoardingStrengthFromOperation(target, "player")
			end
			return locboardingstrength
		end, { halign = "right" })
	titlerow[1].properties.helpOverlayHeight = titlerow[1].properties.helpOverlayHeight + row:getHeight() + Helper.borderSize
	if activeop then
		row = table_left:addRow(false, { fixed = true, bgColor = Color["row_background_blue"] })
		row[1]:setColSpan(2):createText(ReadText(1001, 9526), { halign = "center" })		-- Total Casualties

		for lvl, leveldata in ipairs(menu.boardingData.marinelevels) do
			row = table_left:addRow(false, { bgColor = Color["row_background_unselectable"] })
			row[1]:setBackgroundColSpan(2):createText(leveldata.text)
			-- if boarding op had already started but is now finished, print last saved data.
			row[2]:createText(function()
					local locskilllevel = leveldata.skilllevel
					local loclvl = lvl
					--print("skill level: " .. tostring(locskilllevel) .. " lvl: " .. tostring(loclvl))
					if C.IsDefensibleBeingBoardedBy(target, "player") then
						--local oldcasualties = menu.boardingData.casualties[loclvl]
						menu.boardingData.casualties[loclvl] = C.GetBoardingCasualtiesOfTier(locskilllevel, target, "player")
						--if menu.boardingData.casualties[loclvl] ~= oldcasualties then
						--	print("updating casualties of tier: " .. loclvl .. ". from: " .. oldcasualties .. " to: " .. menu.boardingData.casualties[loclvl])
						--end
					end
					return menu.boardingData.casualties[loclvl]
				end, { halign = "right" })
		end
	end

	table_left.properties.y = table_bottom.properties.y - table_header.properties.y - table_left:getVisibleHeight() - Helper.borderSize

	-- name might be confusing. table containing the button for the topleft table, rather than the button on the top-left.
	local table_button_topleft = frame:addTable(1, { tabOrder = 3, x = Helper.borderSize, y = Helper.borderSize, width = table_left.properties.width })
	row = table_button_topleft:addRow(true, { fixed = true })
	-- TODO: activate button when mode boarding_selectplayerobject is implemented. disable depending on phase?
	--row[1]:createButton({ active = false }):setText(ReadText(1001, 9527), { halign = "center" })		-- Add ship to boarding operation
	--row[1].handlers.onClick = function() return menu.buttonBoardingAddShip() end

	-- Ships assigned to boarding operation. has to be initialized after table_bottom because we need that table's y-offset
	menu.boardingtable_shipselection = frame:addTable(3, { tabOrder = 2, x = Helper.borderSize, y = table_header.properties.y + table_header:getVisibleHeight() + Helper.borderSize, width = table_left.properties.width })
	menu.boardingtable_shipselection:setColWidth(2, config.mapRowHeight * 2)
	menu.boardingtable_shipselection:setColWidth(3, Helper.scaleY(config.mapRowHeight), false)

	row = menu.boardingtable_shipselection:addRow(false, { fixed = true, bgColor = Color["row_background_blue"] })
	row[1]:setColSpan(3):createText(ReadText(1001, 9528))		-- Ships assigned to boarding operation

	for _, shipid in ipairs(menu.boardingData.ships) do
		row = menu.boardingtable_shipselection:addRow({"boardingship", shipid}, {  })
		local nameappendix = ""
		if #menu.boardingData.shipdata[shipid].subordinates > 0 then
			nameappendix = (" + " .. #menu.boardingData.shipdata[shipid].subordinates .. " " .. ReadText(1001, 1504))		-- subordinates
		end
		row[1]:setBackgroundColSpan(3):createText((ffi.string(C.GetComponentName(shipid)) .. " (" .. ffi.string(C.GetObjectIDCode(shipid)) .. ")" .. nameappendix))
		--row[1]:setBackgroundColSpan(3):createText((ffi.string(C.GetComponentName(shipid)) .. nameappendix), { x = menu.boardingData.shipdata[shipid].issubordinate and (Helper.standardTextOffsetx + Helper.standardIndentStep) or nil })

		local nummarines = 0
		for _, leveldata in ipairs(menu.boardingData.marinelevels) do
			nummarines = nummarines + menu.boardingData.shipdata[shipid].groupmarines[leveldata.skilllevel]
		end
		row[2]:createText(nummarines, { halign = "right" })
		if not menu.boardingData.shipdata[shipid].issubordinate then
			row[3]:createButton({ height = row[3]:getWidth(), scaling = false }):setText("x", { halign = "center", font = Helper.standardFontBold })
			row[3].handlers.onClick = function() return menu.buttonBoardingRemoveShip(shipid) end
		end

		if menu.boardingData.selectedship == shipid then
			menu.boardingtable_shipselection:setSelectedRow(row.index)
		end
	end

	menu.boardingtable_shipselection.properties.maxVisibleHeight = table_left.properties.y - Helper.scaleY(table_button_topleft:getVisibleHeight()) - Helper.scaleY(table_header:getVisibleHeight()) - Helper.borderSize * 3
	table_button_topleft.properties.y = menu.boardingtable_shipselection.properties.y + menu.boardingtable_shipselection:getVisibleHeight() + Helper.borderSize
	--print("topleft maxvisibleheight: " .. tostring(menu.boardingtable_shipselection.properties.maxVisibleHeight) .. "\n left y offset: " .. tostring(table_left.properties.y) .. "\n buttontopleft height: " .. tostring(table_button_topleft:getVisibleHeight()) .. "\n header height: " .. tostring(table_header:getVisibleHeight()) .. "\n 3 borders: " .. tostring(Helper.borderSize * 3))

	-- Boarding Target
	local table_right = frame:addTable(2, { x = table_left.properties.x + table_left.properties.width + Helper.borderSize, y = menu.boardingtable_shipselection.properties.y, width = table_left.properties.width, height = table_bottom.properties.y - Helper.scaleY(table_header:getVisibleHeight())  - Helper.borderSize * 2 })
	table_right:setColWidthPercent(1, 20)

	row = table_right:addRow(false, { fixed = true, bgColor = Color["row_background_blue"] })
	row[1]:setColSpan(2):createText(ReadText(1001, 9503), { halign = "center" })	-- Boarding Target

	row = table_right:addRow(false, {  })
	row[1]:createText(ReadText(1001, 5) .. ReadText(1001, 120))		-- Ship, :
	row[2]:createText(targetname, { halign = "right" })

	row = table_right:addRow(false, {  })
	row[1]:createText(ReadText(1001, 43) .. ReadText(1001, 120))		-- Faction, :
	row[2]:createText(targetowner, { halign = "right" })

	row = table_right:addRow(false, {  })
	row[1]:setColSpan(2):createText("")

	row = table_right:addRow(false, {  })
	row[1]:createText(ReadText(1001, 1319) .. ReadText(1001, 120))		-- Turrets, :
	row[2]:createText(function()
			local locnumoperationalturrets = menu.getNumOperationalTurrets(target, numtotalturrets)
			return (boardingcheatsecrecy or C.IsInfoUnlockedForPlayer(target, "defence_status")) and (locnumoperationalturrets .. " / " .. numtotalturrets) or unknowntext
		end, { halign = "right", color = function() return (boardingcheatsecrecy or C.IsInfoUnlockedForPlayer(target, "defence_status")) and Color["text_normal"] or unknowncolor end })

	row = table_right:addRow(false, {  })
	row[1]:createText(ReadText(1001, 1) .. ReadText(1001, 120))		-- Hull, :
	row[2]:createText(function()
			local lochullpercentage = GetComponentData(target, "hullpercent")
			return (boardingcheatsecrecy or C.IsInfoUnlockedForPlayer(target, "defence_status")) and (lochullpercentage .. "%") or unknowntext
		end, { halign = "right", color = function() return (boardingcheatsecrecy or C.IsInfoUnlockedForPlayer(target, "defence_status")) and Color["text_normal"] or unknowncolor end })

	row = table_right:addRow(false, {  })
	row[1]:createText(ReadText(1001, 80) .. ReadText(1001, 120))		-- Crew, :
	row[2]:createText(function()
			local locnumdefendingcrew = menu.getNumDefendingCrew(target)
			return (boardingcheatsecrecy or C.IsInfoUnlockedForPlayer(target, "operator_details")) and (locnumdefendingcrew .. " / " .. targetcrewcapacity) or unknowntext
		end, { halign = "right", color = (boardingcheatsecrecy or C.IsInfoUnlockedForPlayer(target, "operator_details")) and Color["text_normal"] or unknowncolor })

	local table_button = frame:addTable(3, { tabOrder = 6, x = Helper.borderSize, y = table_bottom.properties.y + table_bottom:getVisibleHeight() + Helper.borderSize, width = menu.contextMenuData.width })
	table_button:setColWidthPercent(2, 15)
	table_button:setColWidthPercent(3, 15)

	row = table_button:addRow(true, { fixed = true, bgColor = Color["row_background_blue"] })
	-- handler: if no boarding op, create a boarding op with defined specifications. (and refresh menu?)
	-- if op already created, update boarding op data. (changes in ship and marine assignments.)
	-- approachthreshold == menu.boardingData.risk1
	-- insertionthreshold == menu.boardingData.risk2
	-- activate button only if anything was changed (number of marines, thresholds, actions)
	row[2]:createButton({ active = function() return menu.boardingData.iscapturable and menu.boardingData.changed and totalassignedmarines > 0 end, helpOverlayID = "boarding_operation_start", helpOverlayText = " ", helpOverlayHighlightOnly = true }):setText(activeop and ReadText(1001, 9531) or ReadText(1001, 9530), { halign = "center" })		-- Update Operation, Start Operation
	row[2].handlers.onClick = function() return menu.buttonUpdateBoardingOperation(activeop) end
	row[2].properties.uiTriggerID = "startboarding"
	row[3]:createButton({ active = true, helpOverlayID = "boarding_operation_cancel", helpOverlayText = " ", helpOverlayHighlightOnly = true  }):setText(activeop and ReadText(1001, 8035) or ReadText(1001, 64), { halign = "center" })		-- "Close Menu", "Cancel"
	row[3].handlers.onClick = function() return menu.closeContextMenu() end
	row[3].properties.uiTriggerID = "cancelboarding"

	if menu.contexttoprow then
		menu.boardingtable_shipselection:setTopRow(menu.contexttoprow)
		menu.contexttoprow = nil
	end
	if menu.contextselectedrow then
		menu.boardingtable_shipselection:setSelectedRow(menu.contextselectedrow)
		menu.contextselectedrow = nil
	end
end

function menu.createMissionContext(frame)
	AddUITriggeredEvent(menu.name, "mission_context", ConvertStringToLuaID(menu.contextMenuData.missionid))

	local tablespacing = Helper.standardTextHeight
	local maxObjectiveLines = 10

	-- description table
	local desctable = frame:addTable(3, { tabOrder = 3, highlightMode = "off", maxVisibleHeight = menu.contextMenuData.descriptionHeight, x = Helper.borderSize, y = Helper.borderSize, width = menu.contextMenuData.width })
	desctable:setColWidth(1, Helper.headerRowCenteredProperties.height)
	desctable:setColWidth(3, Helper.headerRowCenteredProperties.height)
	desctable:setDefaultColSpan(1, 3)

	-- kuertee start: callback
	if callbacks ["createMissionContext_startDescriptionTable"] then
		for _, callback in ipairs (callbacks ["createMissionContext_startDescriptionTable"]) do
			callback (desctable)
		end
	end
	-- kuertee end: callback

	-- title
	local visibleHeight

	if menu.contextMenuData.onlinechapter ~= "" then
		local row = desctable:addRow(false, { fixed = true, bgColor = Color["row_background_blue"] })
		row[1]:createText(ReadText(1001, 11363), Helper.titleTextProperties)
	end

	local row = desctable:addRow(false, { fixed = true })
	if menu.contextMenuData.onlinechapter ~= "" then
		local icon = "vt_type_" .. menu.contextMenuData.subtype .. "_mission"
		if not C.IsIconValid(icon) then
			DebugError("Unknown online mission type icon '" .. icon .. "'. [Florian]")
			icon = "solid"
		end
		row[1]:setColSpan(1):createIcon(icon, { width = Helper.headerRowCenteredProperties.height, height = Helper.headerRowCenteredProperties.height })
		row[2]:setBackgroundColSpan(2):createText(menu.contextMenuData.name, Helper.headerRowCenteredProperties)
		row[3]:createText(" ", Helper.headerRowCenteredProperties)
	else
		row[1]:createText(menu.contextMenuData.name, Helper.headerRowCenteredProperties)
	end

	-- briefing icon if any
	local icontable
	if menu.contextMenuData.briefingicon then
		icontable = frame:addTable(1, { tabOrder = 0, highlightMode = "off", maxVisibleHeight = menu.contextMenuData.descriptionHeight, x = Helper.borderSize, y = desctable.properties.y + desctable:getFullHeight() + Helper.borderSize, width = menu.contextMenuData.briefingiconwidth })

		local row = icontable:addRow(nil, {  })
		row[1]:createIcon(menu.contextMenuData.briefingicon, { scaling = false, height = menu.contextMenuData.briefingiconwidth })

		local row = icontable:addRow(nil, {  })
		row[1]:createText(menu.contextMenuData.briefingiconcaption, { wordwrap = true })
	end

	-- description
	for linenum, descline in ipairs(menu.contextMenuData.description) do
		local row = desctable:addRow(true, {  })
		row[1]:createText(descline, { scaling = false, fontsize = Helper.scaleFont(Helper.standardFont, Helper.standardFontSize), x = menu.contextMenuData.briefingiconwidth and (menu.contextMenuData.briefingiconwidth + Helper.borderSize + Helper.scaleX(Helper.standardTextOffsetx)) or nil, minRowHeight = Helper.scaleY(Helper.standardTextHeight) })
		if linenum == menu.contextMenuData.descriptionLines then
			visibleHeight = desctable:getFullHeight()
		end
	end
	if visibleHeight then
		desctable.properties.maxVisibleHeight = visibleHeight
	else
		desctable.properties.maxVisibleHeight = desctable:getFullHeight()
	end

	local objectiveOffsetY = desctable.properties.y + desctable:getVisibleHeight()
	if icontable then
		objectiveOffsetY = math.max(objectiveOffsetY, menu.contextMenuData.descriptionHeight)
	end
	objectiveOffsetY = objectiveOffsetY + tablespacing + Helper.borderSize

	-- objectives table
	local objectivetable = frame:addTable(2, { tabOrder = 4, highlightMode = "off", x = Helper.borderSize, y = objectiveOffsetY, maxVisibleHeight = menu.contextMenuData.objectiveHeight, width = menu.contextMenuData.width })
	objectivetable:setColWidthPercent(2, 25)
	objectivetable:setDefaultColSpan(1, 2)

	-- objectives
	local visibleHeight
	if menu.contextMenuData.threadtype ~= "" then
		-- title
		local row = objectivetable:addRow(false, { fixed = true, bgColor = Color["row_background_blue"] })
		row[1]:createText(ReadText(1001, 3418), Helper.headerRowCenteredProperties)
		if menu.contextMenuData.isoffer then
			if #menu.contextMenuData.briefingmissions > 0 then
				for i, details in ipairs(menu.contextMenuData.briefingmissions) do
					local row = objectivetable:addRow(true, {  })
					row[1]:setColSpan(1):createText(((menu.contextMenuData.threadtype == "sequential") and (i .. ReadText(1001, 120)) or "·") .. " " .. details.name, textProperties)
					local timeouttext = ((details.duration and (details.duration > 0)) and ConvertTimeString(details.duration, (details.duration >= 3600) and "%h:%M:%S" or "%M:%S") or "")
					row[2]:createText(timeouttext .. "  \27[missiontype_" .. details.type .. "]", { halign = "right" })

					if i == maxObjectiveLines then
						visibleHeight = objectivetable:getFullHeight()
					end
				end
			else
				local row = objectivetable:addRow(true, {  })
				row[1]:createText("--- " .. ReadText(1001, 3410) .. " ---")
			end
		else
			if #menu.contextMenuData.subMissions > 0 then
				for i, submissionEntry in ipairs(menu.contextMenuData.subMissions) do
					local row = objectivetable:addRow(true, {  })
					row[1]:setColSpan(1):createText(((menu.contextMenuData.threadtype == "sequential") and (i .. ReadText(1001, 120)) or "·") .. " " .. submissionEntry.name, textProperties)
					row[2]:createText(function () return menu.getSubMissionTimer(submissionEntry) end, { halign = "right" })
					if i == maxObjectiveLines then
						visibleHeight = objectivetable:getFullHeight()
					end
				end
			else
				local row = objectivetable:addRow(true, {  })
				row[1]:createText("--- " .. ReadText(1001, 3410) .. " ---")
			end
		end
	else
		-- title
		local row = objectivetable:addRow(false, { fixed = true, bgColor = Color["row_background_blue"] })
		row[1]:createText(ReadText(1001, 3402), Helper.headerRowCenteredProperties)
		if #menu.contextMenuData.briefingobjectives > 0 then
			for linenum, briefingobjective in ipairs(menu.contextMenuData.briefingobjectives) do
				local infotext = ""
				local textProperties = {}
				if linenum < menu.contextMenuData.activebriefingstep then
					infotext = " - " .. (briefingobjective.failed and ReadText(1001, 3422) or ReadText(1001, 3416))
					textProperties.color = Color["text_inactive"]
				elseif linenum == menu.contextMenuData.activebriefingstep then
					if (not menu.isOffer) and (menu.contextMenuData.missionid == C.GetActiveMissionID()) then
						textProperties.color = Color["text_mission"]
					end
				else
					if briefingobjective.completedoutofsequence then
						infotext = " - " .. ReadText(1001, 3416)
						textProperties.color = Color["text_inactive"]
					end
				end
				local row = objectivetable:addRow(true, {  })
				row[1]:setColSpan(briefingobjective.encyclopedia and 1 or 2):createText(briefingobjective.step .. ReadText(1001, 120) .. " " .. briefingobjective.text .. infotext, textProperties)

				if menu.infoTableMode == "mission" and linenum == menu.contextMenuData.activebriefingstep then
					if menu.contextMenuData.curProgress and menu.contextMenuData.maxProgress then
						if menu.contextMenuData.curProgress > 0 or menu.contextMenuData.maxProgress > 0 then
							if not string.find(briefingobjective.text, tostring(menu.contextMenuData.curprogress) .. " / ") then
								local row = objectivetable:addRow(true, {  })
								local progressText
								if menu.contextMenuData.progressname ~= nil then
									progressText = "    " .. menu.contextMenuData.progressname .. ReadText(1001, 120) .. " "
								else
									progressText = "    " .. ReadText(1001, 9513) .. ReadText(1001, 120) .. " "
								end
								progressText = progressText .. tostring(menu.contextMenuData.curProgress) .. " / " .. tostring(menu.contextMenuData.maxProgress)
								row [1]:setColSpan(2):createText(progressText, textProperties)
							end
						end
					end
				end

				if briefingobjective.encyclopedia then
					local buttonsize = Helper.scaleY(Helper.standardTextHeight)
					row[2]:createButton({ scaling = false, active = briefingobjective.encyclopedia.known, height = buttonsize, width = buttonsize, x = row[2]:getWidth() - buttonsize, mouseOverText = briefingobjective.encyclopedia.known and ReadText(1001, 2416) or ReadText(1026, 3259) }):setIcon("mm_externallink")
					row[2].handlers.onClick = function () Helper.closeMenuAndOpenNewMenu(menu, "EncyclopediaMenu", { 0, 0, briefingobjective.encyclopedia.mode, briefingobjective.encyclopedia.library, briefingobjective.encyclopedia.id, briefingobjective.encyclopedia.object }); menu.cleanup() end
				end
				if linenum == maxObjectiveLines then
					visibleHeight = objectivetable:getFullHeight()
				end
			end
		else
			local row = objectivetable:addRow(true, {  })
			row[1]:createText("--- " .. ReadText(1001, 3410) .. " ---")
		end
	end
	if visibleHeight then
		objectivetable.properties.maxVisibleHeight = visibleHeight
	else
		objectivetable.properties.maxVisibleHeight = objectivetable:getFullHeight()
	end

	-- bottom table (info and buttons)
	local bottomtable = frame:addTable(2, { tabOrder = 2, x = Helper.borderSize, y = objectivetable.properties.y + objectivetable:getVisibleHeight() + tablespacing, width = menu.contextMenuData.width, highlightMode = "off" })

	-- faction
	if menu.contextMenuData.factionName then
		local row = bottomtable:addRow(false, { fixed = true })
		row[1]:createText(ReadText(1001, 43) .. ReadText(1001, 120))
		row[2]:createText(menu.contextMenuData.factionName, { halign = "right" })
	end
	-- reward
	local rewardtext
	if menu.contextMenuData.rewardmoney ~= 0 then
		rewardtext = ConvertMoneyString(menu.contextMenuData.rewardmoney, false, true, 0, true) .. " " .. ReadText(1001, 101)
		if menu.contextMenuData.rewardtext ~= "" then
			rewardtext = rewardtext .. " \n" .. menu.contextMenuData.rewardtext
		end
	else
		rewardtext = menu.contextMenuData.rewardtext
	end
	local row = bottomtable:addRow(false, { fixed = true })
	row[1]:createText(ReadText(1001, 3301) .. ReadText(1001, 120))
	row[2]:createText(rewardtext, { halign = "right", wordwrap = true })
	-- difficulty
	if menu.contextMenuData.difficulty ~= 0 then
		local row = bottomtable:addRow(false, { fixed = true })
		row[1]:createText(ReadText(1001, 3403) .. ReadText(1001, 120))
		local difficulty, mouseovertext = ConvertMissionLevelString(menu.contextMenuData.difficulty)
		row[2]:createText(difficulty, { halign = "right", mouseOverText = mouseovertext })
	end
	-- time left
	local row = bottomtable:addRow(false, { fixed = true })
	row[1]:createText(ReadText(1001, 3404) .. ReadText(1001, 120))
	row[2]:createText(menu.getMissionContextTime, { halign = "right" })

	-- buttons
	if menu.contextMenuData.isoffer then
		-- Accept & Briefing
		local row = bottomtable:addRow(true, { fixed = true })
		local active = true
		local mouseovertext
		if C.IsMissionLimitReached(false, false, false) then
			active = false
			mouseovertext = ReadText(1026, 3242)
		elseif menu.contextMenuData.onlinechapter ~= "" then
			if C.HasAcceptedOnlineMission() then
				mouseovertext = ColorText["text_negative"] .. ReadText(1026, 11301)
			end
		end

		-- kuertee start: callback
		if active then
			if callbacks ["createMissionContext_getIsMissionAcceptable"] then
				for _, callback in ipairs (callbacks ["createMissionContext_getIsMissionAcceptable"]) do
					active = callback (menu.contextMenuData.missionid)
					if active == 0 or active == false then
						break
					end
				end
			end
		end
		-- kuertee end: callback

		row[1]:createButton({ active = active, mouseOverText = mouseovertext, helpOverlayID = "map_acceptmission", helpOverlayText = " ", helpOverlayHighlightOnly = true }):setText(ReadText(1001, 57), { halign = "center" })
		row[1].handlers.onClick = menu.buttonMissionOfferAccept
		row[1].properties.uiTriggerID = "missionofferaccept"

		-- kuertee start: callback
		local kEM_isBriefingAvailable = nil
		if callbacks ["createMissionContext_getIsMissionBriefingAvailable"] then
			for _, callback in ipairs (callbacks ["createMissionContext_getIsMissionBriefingAvailable"]) do
				kEM_isBriefingAvailable = callback (menu.contextMenuData.missionid)
				if kEM_isBriefingAvailable == 0 or kEM_isBriefingAvailable == false then
					break
				end
			end
		end
				
		if kEM_isBriefingAvailable == nil then
			-- Vanilla do original logic
			row[2]:createButton({  }):setText(ReadText(1001, 3326), { halign = "center" })
		else
			-- Emergent Missions is installed do modified logic
			row[2]:createButton({active = kEM_isBriefingAvailable}):setText(ReadText(1001, 3326), { halign = "center" })
		end
		-- kuertee end: callback

		row[2].handlers.onClick = menu.buttonMissionOfferBriefing
		row[2].properties.uiTriggerID = "missionofferbriefing"


		-- kuertee start: callback
		if callbacks ["createMissionContext_addMissionOfferButtons"] then
			for _, callback in ipairs (callbacks ["createMissionContext_addMissionOfferButtons"]) do
				active = callback (bottomtable, menu.contextMenuData.missionid)
			end
		end
		-- kuertee end: callback

	else
		-- Abort & Briefing
		local active = menu.contextMenuData.abortable
		local mouseovertext = ""
		if menu.contextMenuData.threadMissionID ~= 0 then
			local details = menu.getMissionIDInfoHelper(menu.contextMenuData.threadMissionID)
			active = active and (details.threadtype ~= "sequential")
			if details.threadtype == "sequential" then
				mouseovertext = ReadText(1026, 3405)
			end
		end
		local row = bottomtable:addRow(true, { fixed = true })
		row[1]:createButton({ active = active, mouseOverText = mouseovertext, helpOverlayID = "map_abortmission", helpOverlayText = " ",  helpOverlayHighlightOnly = true }):setText(ReadText(1001, 3407), { halign = "center" })
		row[1].handlers.onClick = menu.buttonMissionAbort
		row[1].properties.uiTriggerID = "missionabort"
		row[2]:createButton({  }):setText(ReadText(1001, 3326), { halign = "center" })
		row[2].handlers.onClick = menu.buttonMissionBriefing
		row[2].properties.uiTriggerID = "missionbriefing"
		local row

		-- kuertee start: allow buttons in guidance missions
		-- if menu.contextMenuData.type ~= "guidance" then
		-- kuertee end: allow buttons in guidance missions

			-- Set active
			local active = menu.contextMenuData.missionid == C.GetActiveMissionID()
			for _, submissionEntry in ipairs(menu.contextMenuData.subMissions) do
				if submissionEntry.active then
					active = true
				end
			end
			row = bottomtable:addRow(true, { fixed = true })
			row[1]:createButton({ helpOverlayID = "map_activatemission", helpOverlayText = " ",  helpOverlayHighlightOnly = true }):setText(active and ReadText(1001, 3413) or ReadText(1001, 3406), { halign = "center" })
			row[1].handlers.onClick = menu.buttonMissionActivate
			row[1].properties.uiTriggerID = "missionactivate"

		-- kuertee start: allow buttons in guidance missions
		-- end
		-- kuertee end: allow buttons in guidance missions

		-- deliver wares
		if #menu.contextMenuData.deliveryWares > 0 then
			if not row then
				row = bottomtable:addRow(true, { fixed = true })
			end

			row[2]:createButton({ active = menu.checkDeliverWaresCargo, mouseOverText = function () return menu.checkDeliverWaresCargo() and "" or (ColorText["text_error"] .. ReadText(1026, 3406)) end }):setText(ReadText(1001, 3423), { halign = "center" })
			row[2].handlers.onClick = menu.buttonMissionDeliverWares
			row[2].properties.uiTriggerID = "missiondeliverwares"
		end

		-- kuertee start: callback
		if callbacks ["createMissionContext_addMissionAcceptedButtons"] then
			for _, callback in ipairs (callbacks ["createMissionContext_addMissionAcceptedButtons"]) do
				active = callback (bottomtable, menu.contextMenuData.missionid)
			end
		end
		-- kuertee end: callback
	end
	local neededheight = bottomtable.properties.y + bottomtable:getFullHeight() + Helper.frameBorder
	if frame.properties.y + neededheight > Helper.viewHeight then
		frame.properties.y = Helper.viewHeight - neededheight
	end

	desctable.properties.nextTable = objectivetable.index
	objectivetable.properties.prevTable = desctable.index

	objectivetable.properties.nextTable = bottomtable.index
	bottomtable.properties.prevTable = objectivetable.index

	-- kuertee start: callback
	if callbacks ["createMissionContext_on_end"] then
		for _, callback in ipairs (callbacks ["createMissionContext_on_end"]) do
			callback (frame)
		end
	end
	-- kuertee end: callback
end

function menu.checkDeliverWaresCargo()
	local hascargo = true
	local cargo = GetComponentData(ConvertStringTo64Bit(tostring(menu.contextMenuData.deliveryWares.target)), "cargo") or {}
	for _, entry in ipairs(menu.contextMenuData.deliveryWares) do
		if (cargo[entry.ware] or 0) == 0 then
			hascargo = false
			break
		end
	end
	return hascargo
end

function menu.getMissionContextTime()
	if not menu.contextMenuData.expired then
		if (not menu.contextMenuData.isoffer) and menu.contextMenuData.missionid then
			local missiondetails = C.GetMissionIDDetails(menu.contextMenuData.missionid)
			local timeout = (missiondetails.timeLeft and missiondetails.timeLeft > -1) and missiondetails.timeLeft or (missiondetails.duration or -1)

			return (timeout > 0 and ConvertTimeString(timeout, (timeout >= 3600) and "%h:%M:%S" or "%M:%S") or "-")
		else
			return (menu.contextMenuData.timeout > 0 and ConvertTimeString(menu.contextMenuData.timeout, (menu.contextMenuData.timeout >= 3600) and "%h:%M:%S" or "%M:%S") or "-")
		end
	else
		return "-"
	end
end

function menu.getSubMissionTimer(submissionentry)
	local text
	if not submissionentry.expired then
		if not menu.isOffer then
			local missiondetails = C.GetMissionIDDetails(ConvertStringTo64Bit(submissionentry.ID))
			local timeout = (missiondetails.timeLeft and missiondetails.timeLeft > -1) and missiondetails.timeLeft or (missiondetails.duration or -1)

			text = (timeout > 0 and ConvertTimeString(timeout, (timeout >= 3600) and "%h:%M:%S" or "%M:%S") or "")
		else
			text = (submissionentry.timeout > 0 and ConvertTimeString(submissionentry.timeout, (submissionentry.timeout >= 3600) and "%h:%M:%S" or "%M:%S") or "")
		end
	else
		text = ""
	end

	return text .. "  \27[missiontype_" .. submissionentry.type .. "]"
end

function menu.createInfoContext(frame)
	local instance = menu.contextMenuData.instance

	local controllable = menu.contextMenuData.component
	local entity = menu.contextMenuData.entity
	local person = menu.contextMenuData.person
	local inv_ware = menu.contextMenuData.inv_ware
	local weaponmacro = menu.contextMenuData.weaponmacro
	local equipmentmacro = menu.contextMenuData.equipmentmacro
	local software = menu.contextMenuData.software
	local personrole = ""
	if not (controllable and (person or entity or inv_ware or weaponmacro or equipmentmacro or software)) then
		DebugError(string.format("menu.createInfoContext called with invalid controllable or invalid actor, invalid ware and invalid macro. controllable: %s, person: %s, entity: %s, inv_ware: %s, software: %s, weaponmacro: %s, equipmentmacro: %s", tostring(controllable), tostring(person), tostring(entity), tostring(inv_ware), tostring(software), tostring(weaponmacro), tostring(equipmentmacro)))
		return
	end
	if person then
		--print("person: " .. ffi.string(C.GetPersonName(person, controllable)) .. ", combinedskill: " .. C.GetPersonCombinedSkill(controllable, person, nil, nil))
		-- get real NPC if instantiated
		local instance = C.GetInstantiatedPerson(person, controllable)
		entity = (instance ~= 0 and instance or nil)
		personrole = ffi.string(C.GetPersonRole(person, controllable))
	end
	entity = entity and ConvertStringTo64Bit(tostring(entity)) or nil

	local loctable = frame:addTable(1, { tabOrder = 3, x = Helper.borderSize, y = Helper.borderSize, width = menu.contextMenuData.width, highlightMode = "off" })

	local title = ""
	local isunlocked = false
	if entity then
		isunlocked = IsInfoUnlockedForPlayer(controllable, "operator_name")
		title = Helper.unlockInfo(isunlocked, ffi.string(C.GetComponentName(entity)))
	elseif person then
		isunlocked = IsInfoUnlockedForPlayer(controllable, "name")
		title = Helper.unlockInfo(isunlocked, ffi.string(C.GetPersonName(person, controllable)))
	elseif inv_ware or software then
		title = GetWareData(inv_ware or software, "name")
	elseif weaponmacro or equipmentmacro then
		title = GetMacroData(weaponmacro or equipmentmacro, "name")
	end

	-- title
	local row = loctable:addRow(false, { fixed = true, bgColor = Color["row_background_blue"] })
	row[1]:createText(title, Helper.headerRowCenteredProperties)

	local oldpilot = GetComponentData(controllable, "assignedaipilot")
	if oldpilot then
		oldpilot = ConvertStringTo64Bit(tostring(oldpilot))
	end

	local transferscheduled = false
	local hasarrived = true
	if person then
		transferscheduled = C.IsPersonTransferScheduled(controllable, person)
		hasarrived = C.HasPersonArrived(controllable, person)
	end

	local player = C.GetPlayerID()
	if person then
		if GetComponentData(controllable, "isplayerowned") then
			if transferscheduled then
				local row = loctable:addRow("info_person_cancel_transfer", { fixed = true })
				row[1]:createButton({ bgColor = Color["button_background_hidden"], height = Helper.standardTextHeight }):setText(ReadText(1001, 9435))	-- Cancel all scheduled transfers
				row[1].handlers.onClick = function () return menu.infoSubmenuCancelTransfer(controllable, person) end
			elseif hasarrived then
				if (personrole == "service") or (personrole == "marine") then
					local printedtitle = C.IsComponentClass(controllable, "ship_s") and ReadText(1001, 4847) or ReadText(1001, 4848)	-- Pilot, Captain
					local row = loctable:addRow("info_person_promote", { fixed = true })
					row[1]:createButton({ bgColor = Color["button_background_hidden"], height = Helper.standardTextHeight, active = function () return menu.infoSubmenuReplacePilot(controllable, oldpilot, person, true, true, instance) end }):setText(ReadText(1001, 9433) .. " " .. printedtitle)	-- Promote to(followed by "captain" or "pilot")
					row[1].handlers.onClick = function () return menu.infoSubmenuReplacePilot(controllable, oldpilot, person, false, true, instance) end
				end
			end
		end
	end
	if person or (entity and (entity ~= player)) then
		if GetComponentData(controllable, "isplayerowned") then
			if (person and ((personrole == "service") or (personrole == "marine") or (personrole == "trainee_group") or (personrole == "unassigned"))) or (entity and GetComponentData(entity, "isplayerowned") and GetComponentData(entity, "caninitiatecomm")) then
				if hasarrived then
					-- work somewhere else
					local row = loctable:addRow("info_person_worksomewhere", { fixed = true })
					row[1]:createButton({ bgColor = Color["button_background_hidden"], height = Helper.standardTextHeight }):setText(ReadText(1002, 3008))
					if entity then
						row[1].handlers.onClick = function () Helper.closeMenuAndOpenNewMenu(menu, "MapMenu", { 0, 0, true, controllable, nil, "hire", { "signal", entity, 0 } }); menu.cleanup() end
					else
						row[1].handlers.onClick = function () Helper.closeMenuAndOpenNewMenu(menu, "MapMenu", { 0, 0, true, controllable, nil, "hire", { "signal", controllable, 0, person} }); menu.cleanup() end
					end
				end
				-- fire
				local row = loctable:addRow("info_person_fire", { fixed = true })
				row[1]:createButton({ bgColor = Color["button_background_hidden"], height = Helper.standardTextHeight }):setText(ReadText(1002, 15800))
				row[1].handlers.onClick = function () return menu.infoSubmenuFireNPCConfirm(controllable, entity, person, instance) end
			end
		end
	elseif inv_ware or weaponmacro or equipmentmacro or software then
		local row = loctable:addRow("info_inv_ware", { fixed = true })
		row[1]:createButton({ bgColor = Color["button_background_hidden"], height = Helper.standardTextHeight }):setText(ReadText(1001, 2416))	-- Show Encyclopedia Entry
		if inv_ware then
			row[1].handlers.onClick = function () Helper.closeMenuAndOpenNewMenu(menu, "EncyclopediaMenu", { 0, 0, "Wares", "inventory_wares", inv_ware }); menu.cleanup() end
		elseif weaponmacro then
			local library = GetMacroData(weaponmacro, "infolibrary")
			row[1].handlers.onClick = function () Helper.closeMenuAndOpenNewMenu(menu, "EncyclopediaMenu", { 0, 0, "Weapons", library, weaponmacro }); menu.cleanup() end
		elseif equipmentmacro then
			local library = GetMacroData(equipmentmacro, "infolibrary")
			local mode = "Equipment"
			if library == "mines" then
				mode = "Weapons"
			end
			row[1].handlers.onClick = function () Helper.closeMenuAndOpenNewMenu(menu, "EncyclopediaMenu", { 0, 0, mode, library, equipmentmacro }); menu.cleanup() end
		elseif software then
			row[1].handlers.onClick = function () Helper.closeMenuAndOpenNewMenu(menu, "EncyclopediaMenu", { 0, 0, "Equipment", "software", software }); menu.cleanup() end
		end
	end
	local conversationactor = entity
	if person and (not entity or C.GetContextByClass(entity, "container", false) ~= C.GetContextByClass(player, "container", false)) then
		-- Talking to person - either not instantiated as a real entity, or the instance is far away.
		-- Note: Only start comms with instantiated NPCs if they are on the player container, otherwise they are likely to get despawned during the conversation.
		conversationactor = { context = ConvertStringToLuaID(tostring(controllable)), person = ConvertStringToLuaID(tostring(person)) }
	end
	if person or entity then
		if (not transferscheduled) and hasarrived then
			row = loctable:addRow("info_actor_comm", { fixed = true })
			row[1]:createButton({ bgColor = Color["button_background_hidden"], height = Helper.standardTextHeight, active = ((not entity) or (entity ~= player)) and isunlocked }):setText(ReadText(1001, 3216))	-- (initiate comm)Comm
			row[1].handlers.onClick = function () menu.openCommWithActor(conversationactor) end
		end
	end

	-- adjust frame position
	local neededheight = loctable.properties.y + loctable:getVisibleHeight()
	if frame.properties.y + neededheight + Helper.frameBorder > Helper.viewHeight then
		menu.contextMenuData.yoffset = Helper.viewHeight - neededheight - Helper.frameBorder
		frame.properties.y = menu.contextMenuData.yoffset
	end
end

function menu.createSellShipsContext(frame)
	-- description table
	local ftable = frame:addTable(2, { tabOrder = 3, x = Helper.borderSize, y = Helper.borderSize, width = menu.contextMenuData.width, highlightMode = "off" })
	ftable:setColWidthPercent(1, 60)

	-- title
	local row = ftable:addRow(false, { fixed = true, bgColor = Color["row_background_blue"] })
	row[1]:setColSpan(2):createText(ReadText(1001, 7857), Helper.headerRowCenteredProperties)
	-- ships
	local issellingpossible = false
	menu.contextMenuData.totalprice = 0
	for i, data in ipairs(menu.contextMenuData.ships) do
		local errors, warnings = {}, {}
		local n = C.GetNumOrders(data)
		local buf = ffi.new("Order[?]", n)
		n = C.GetOrders(buf, n, data)
		for i = 0, n - 1 do
			if ffi.string(buf[i].orderdef) == "Equip" then
				errors[1] = ReadText(1001, 3267)
				break
			end
		end
		local hasanymod = GetComponentData(data, "hasanymod")
		if hasanymod then
			warnings[1] = ReadText(1001, 3268)
		end
		menu.contextMenuData.ships[i] = { data, errors }
		local ship = menu.contextMenuData.ships[i][1]
		local price = GetTotalValue(ship, true, menu.contextMenuData.shipyard)

		local color = Color["text_normal"]
		if #errors > 0 then
			color = Color["text_inactive"]
		else
			issellingpossible = true
			menu.contextMenuData.totalprice = menu.contextMenuData.totalprice + price
		end

		-- keep these selectable to support scrolling when selling a lot of ships
		local row = ftable:addRow(true, { interactive = false })
		row[1]:createText(ffi.string(C.GetComponentName(ship)) .. " (" .. ffi.string(C.GetObjectIDCode(ship)) .. ")", { color = color })
		row[2]:createText(ConvertMoneyString(price, false, true, 0, true) .. " " .. ReadText(1001, 101), { halign = "right", color = color })

		for _, error in ipairs(errors) do
			local row = ftable:addRow(true, { interactive = false })
			row[1]:setColSpan(2):createText(error, { halign = "right", color = Color["text_error"] })
		end
		for _, warning in ipairs(warnings) do
			local row = ftable:addRow(true, { interactive = false })
			row[1]:setColSpan(2):createText(warning, { halign = "right", color = Color["text_warning"] })
		end
	end
	-- button
	local row = ftable:addRow(true, {  })
	row[2]:createButton({ active = issellingpossible, height = Helper.standardTextHeight }):setText(ReadText(1001, 2917), { halign = "center" })
	row[2].handlers.onClick = menu.buttonSellShips

	if frame.properties.x + menu.contextMenuData.width > Helper.viewWidth then
		frame.properties.x = Helper.viewWidth - menu.contextMenuData.width - config.contextBorder
	end
	local height = frame:getUsedHeight()
	if frame.properties.y + height > Helper.viewHeight then
		local newypos = Helper.viewHeight - height - config.contextBorder
		frame.properties.y = math.max(config.contextBorder, newypos)
	end
end

function menu.createSelectContext(frame)
	-- description table
	local ftable = frame:addTable(1, { tabOrder = 3, x = Helper.borderSize, y = Helper.borderSize, width = menu.contextMenuData.width, highlightMode = "off" })

	-- title
	local row = ftable:addRow(false, { fixed = true, bgColor = Color["row_background_blue"] })
	row[1]:createText(Helper.unlockInfo(IsInfoUnlockedForPlayer(menu.contextMenuData.component, "name"), ffi.string(C.GetComponentName(menu.contextMenuData.component))), Helper.headerRowCenteredProperties)

	local row = ftable:addRow(true, { fixed = true })
	local active = true
	local mouseovertext = ""
	if menu.mode == "selectCV" then
		local assignedpilot, isplayerowned, isenemy = GetComponentData(menu.contextMenuData.component, "assignedpilot", "isplayerowned", "isenemy")
		local hasloop = ffi.new("bool[1]", 0)
		C.GetOrderQueueFirstLoopIdx(menu.contextMenuData.component, hasloop)

		if isenemy then
			active = false
			mouseovertext = ColorText["text_error"] .. ReadText(1026, 8014)
		elseif hasloop[0] then
			active = false
			mouseovertext = ColorText["text_error"] .. ReadText(1026, 7852)
		elseif menu.contextMenuData.component == C.GetPlayerOccupiedShipID() then
			active = false
			mouseovertext = ColorText["text_error"] .. ReadText(1026, 3224)
		elseif C.IsBuilderBusy(menu.contextMenuData.component) then
			active = false
			mouseovertext = ColorText["text_error"] .. ReadText(1026, 7820)
		elseif not assignedpilot then
			active = false
			mouseovertext = ColorText["text_error"] .. ReadText(1026, 7801)
		elseif not isplayerowned then
			local playermoney = GetPlayerMoney()
			local fee = tonumber(C.GetBuilderHiringFee())
			if playermoney < fee then
				active = false
				mouseovertext = ColorText["text_error"] .. ReadText(1026, 3222)
			end
		end
	elseif menu.mode == "selectComponent" then
		active = menu.checkForSelectComponent(menu.contextMenuData.component)
	end
	row[1]:createButton({ active = active, height = Helper.standardTextHeight, mouseOverText = mouseovertext, helpOverlayID = "selectactive", helpOverlayText = " ", helpOverlayHighlightOnly = true }):setText(ReadText(1001, 3102))
	row[1].handlers.onClick = menu.buttonSelectHandler
	row[1].properties.uiTriggerID = "selectactive"

	if frame.properties.x + menu.contextMenuData.width > Helper.viewWidth then
		frame.properties.x = Helper.viewWidth - menu.contextMenuData.width - config.contextBorder
	end
	local height = frame:getUsedHeight()
	if frame.properties.y + height > Helper.viewHeight then
		frame.properties.y = Helper.viewHeight - height - config.contextBorder
	end
end

function menu.createWeaponConfigContext(frame, instance)
	local ftable = frame:addTable(2, { tabOrder = 3, x = Helper.borderSize, y = Helper.borderSize, width = menu.contextMenuData.width })
	ftable:setColWidth(1, Helper.standardTextHeight)

	-- title
	local row = ftable:addRow(false, { fixed = true, bgColor = Color["row_background_blue"] })
	row[1]:setColSpan(2):createText(ReadText(1001, 1105), Helper.headerRowCenteredProperties)

	if not menu.contextMenuData.usedefault then
		for _, entry in ipairs(menu.contextMenuData.weaponsystems) do
			if entry.id == "default" then
				local row = ftable:addRow(true, {  })
				row[1]:createCheckBox(entry.active, { width = config.mapRowHeight, height = config.mapRowHeight })
				row[1].handlers.onClick = function () return menu.checkboxSetWeaponConfig(entry.id, not entry.active) end
				row[2]:createText(entry.name)
				break
			end
		end
	end

	ftable:addEmptyRow(1)

	if menu.contextMenuData.default then
		menu.contextMenuData.weaponsystems = {}
		local n = C.GetNumAllowedWeaponSystems()
		local buf = ffi.new("WeaponSystemInfo[?]", n)
		n = C.GetAllowedWeaponSystems(buf, n, menu.contextMenuData.component, 0, true)
		for i = 0, n - 1 do
			table.insert(menu.contextMenuData.weaponsystems, { id = ffi.string(buf[i].id), name = ffi.string(buf[i].name), active = buf[i].active })
		end
	end

	for _, entry in ipairs(menu.contextMenuData.weaponsystems) do
		if entry.id ~= "default" then
			local color = Color["text_normal"]
			if menu.contextMenuData.default then
				color = Color["text_inactive"]
			end
			local row = ftable:addRow(true, {  })
			row[1]:createCheckBox(entry.active, { width = config.mapRowHeight, height = config.mapRowHeight })
			row[1].handlers.onClick = function () return menu.checkboxSetWeaponConfig(entry.id, not entry.active) end
			row[2]:createText(entry.name, { color = color })
		end
	end

	local row = ftable:addRow(true, {  })
	row[1]:setColSpan(2):createButton({ active = not menu.contextMenuData.default }):setText(ReadText(1001, 5706), { halign = "center" })
	row[1].handlers.onClick = menu.buttonClearWeaponConfig

	local row = ftable:addRow(false, {  })
	row[1]:setColSpan(2):createText("")

	local row = ftable:addRow(true, {  })
	row[1]:setColSpan(2):createButton():setText(ReadText(1001, 2821), { halign = "center" })
	row[1].handlers.onClick = menu.buttonConfirmWeaponConfig

	local row = ftable:addRow(true, {  })
	row[1]:setColSpan(2):createButton():setText(ReadText(1001, 64), { halign = "center" })
	row[1].handlers.onClick = menu.buttonCancelWeaponConfig
end

-- update
menu.updateInterval = 0.01

function menu.onUpdate()
	local curtime = getElapsedTime()
	if menu.updatePeopleInfo and (menu.updatePeopleInfo <= curtime) then
		menu.refreshCrewInfo()
		menu.updatePeopleInfo = nil
	end

	if menu.mainFrame then
		menu.mainFrame:update()
	end
	if menu.infoFrame then
		menu.infoFrame:update()
	end
	if menu.infoFrame2 then
		menu.infoFrame2:update()
	end
	if menu.contextFrame then
		menu.contextFrame:update()
	end

	if menu.map and menu.holomap ~= 0 then
		local x, y = GetRenderTargetMousePosition(menu.map)
		C.SetMapRelativeMousePosition(menu.holomap, (x and y) ~= nil, x or 0, y or 0)
	end

	local refreshing = false
	if menu.refreshIF and (menu.refreshIF < curtime) then
		refreshing = true
		menu.refreshIF = nil
	end

	if menu.refreshMissionContext and (menu.refreshMissionContext.time < curtime) then
		menu.showMissionContext(menu.refreshMissionContext.id, false)
		menu.refreshMissionContext = nil
	end

	if menu.activatemap then
		-- pass relative screenspace of the holomap rendertarget to the holomap (value range = -1 .. 1)
		local renderX0, renderX1, renderY0, renderY1 = Helper.getRelativeRenderTargetSize(menu, config.mainFrameLayer, menu.map)
		local rendertargetTexture = GetRenderTargetTexture(menu.map)
		if rendertargetTexture then
			menu.holomap = C.AddHoloMap(rendertargetTexture, renderX0, renderX1, renderY0, renderY1, menu.rendertargetWidth / menu.rendertargetHeight, 1)
			if menu.holomap ~= 0 then
				C.ClearSelectedMapComponents(menu.holomap)
				if menu.showMultiverse then
					C.ShowMultiverseMap(menu.holomap)
				elseif menu.mode == "selectbuildlocation" then
					C.ShowBuildPlotPlacementMap(menu.holomap, menu.currentsector)
				else
					if menu.focuscomponent and menu.focusoffset then
						C.ShowUniverseMap2(menu.holomap, true, menu.showzone, menu.mode == "selectCV", menu.focuscomponent, menu.focusoffset)
						menu.focuscomponent = nil
					else
						local startpos = ffi.new("UIPosRot")
						C.ShowUniverseMap2(menu.holomap, true, menu.showzone, menu.mode == "selectCV", 0, startpos)
					end
					menu.focusoffset = nil
				end
			end

			if menu.focuscomponent then
				C.SetFocusMapComponent(menu.holomap, menu.focuscomponent, true)
			end

			if menu.mapstate then
				C.SetMapState(menu.holomap, menu.mapstate)
				menu.mapstate = nil
			end

			if menu.mode == "hire" then
				local classes = ffi.new("const char*[?]", 2)
				classes[0] = Helper.ffiNewString("ship")
				classes[1] = Helper.ffiNewString("station")
				C.SetMapObjectFilter(menu.holomap, classes, 2, 1, true)
				Helper.ffiClearNewHelper()
				C.ClearMapOrderParamObjectFilter(menu.holomap)
			elseif menu.mode == "selectComponent" then
				local numclasses = menu.modeparam[2] and #menu.modeparam[2] or 0
				local classes = ffi.new("const char*[?]", numclasses)
				if numclasses > 0 then
					for i, class in ipairs(menu.modeparam[2]) do
						classes[i - 1] = Helper.ffiNewString(class)
					end
				end
				C.SetMapObjectFilter(menu.holomap, classes, numclasses, menu.modeparam[4] or -1, false)
				Helper.ffiClearNewHelper()
				C.ClearMapOrderParamObjectFilter(menu.holomap)
			elseif menu.mode == "orderparam_object" then
				if type(menu.modeparam[5]) == "string" then
					C.SetMapDefaultOrderParamObjectFilter(menu.holomap, ConvertStringTo64Bit(tostring(menu.modeparam[4])), menu.modeparam[5] == "planneddefault", menu.modeparam[6])
				else
					C.SetMapOrderParamObjectFilter(menu.holomap, ConvertStringTo64Bit(tostring(menu.modeparam[4])), menu.modeparam[5], menu.modeparam[6])
				end
				C.ClearMapObjectFilter(menu.holomap)
			else
				C.ClearMapOrderParamObjectFilter(menu.holomap)
				C.ClearMapObjectFilter(menu.holomap)
			end
			Helper.textArrayHelper(menu.searchtext, function (numtexts, texts) return C.SetMapFilterString(menu.holomap, numtexts, texts) end, "text")
			menu.applyFilterSettings()

			menu.activatemap = false
			if menu.infoTableMode == "objectlist" then
				menu.refreshIF = getElapsedTime()
			end
		end
	end

	if not menu.refreshed then
		if menu.holomap and (menu.holomap ~= 0) then
			if menu.picking ~= menu.pickstate then
				menu.pickstate = menu.picking
				C.SetMapPicking(menu.holomap, menu.pickstate)
			end
		end
	end
	menu.refreshed = nil

	if menu.lock and curtime > menu.lock + 0.01 then
		menu.lock = nil
	end
	if menu.over then
		menu.refreshInfoFrame()
		menu.over = nil
		return
	end

	-- evaluate mouse cursor overrides
	if menu.holomap and (menu.holomap ~= 0) then
		menu.updateMouseCursor()
		if menu.plotData.active then
			local offset = ffi.new("UIPosRot")
			local offsetsector = C.GetBuildMapStationLocation2(menu.holomap, offset)
			if offsetsector ~= 0 then
				if C.IsCurrentBuildMapPlotPositionDiscovered(offsetsector, offset, menu.plotData.size.x * 1000, menu.plotData.size.y * 1000, menu.plotData.size.z * 1000) then
					local price = tonumber(C.GetBuildPlotPrice(offsetsector, offset, menu.plotData.size.x * 1000, menu.plotData.size.y * 1000, menu.plotData.size.z * 1000, "player"))
					SetMouseOverOverride(menu.map, ReadText(1001, 2808) .. ReadText(1001, 120) .. " " .. ConvertMoneyString(tostring(price), false, true, 0, true) .. " " .. ReadText(1001, 101))
				else
					SetMouseOverOverride(menu.map, nil)
				end
			end
		end
	end

	local range = 100
	if menu.contextMenuData and menu.contextMenuData.mouseOutPos then
		if (GetControllerInfo() ~= "gamepad") or (C.IsMouseEmulationActive()) then
			local curpos = table.pack(GetLocalMousePosition())
			if curpos[1] and ((curpos[1] > menu.contextMenuData.mouseOutPos[1] + range) or (curpos[1] < menu.contextMenuData.mouseOutPos[1] - range)) then
				menu.closeContextMenu()
			elseif curpos[2] and ((curpos[2] > menu.contextMenuData.mouseOutPos[2] + range) or (curpos[2] < menu.contextMenuData.mouseOutPos[2] - range)) then
				menu.closeContextMenu()
			end
		end
	end

	if menu.lastHighlightCheck + 1.0 < curtime then
		menu.lastHighlightCheck = curtime
		if menu.highlightLeftBar["mission"] then
			if C.GetActiveMissionID() == 0 then
				menu.highlightLeftBar["mission"] = nil
				menu.refreshMainFrame = true
			end
		end
		if menu.showMultiverse then
			local outcomes = GetVentureOutcomes()
			if (next(outcomes) ~= nil) ~= menu.highlightLeftBar["ventureoperation"] then
				menu.highlightLeftBar["ventureoperation"] = next(outcomes) ~= nil
				menu.refreshMainFrame = true
			end
		end
	end

	if ((menu.infoTableMode == "info") and ((menu.infoMode.left == "orderqueue") or (menu.infoMode.left == "orderqueue_advanced") or (menu.infoMode.left == "standingorders"))) or
	   ((menu.searchTableMode == "info") and ((menu.infoMode.right == "orderqueue") or (menu.infoMode.right == "orderqueue_advanced") or (menu.infoMode.right == "standingorders"))) then
		if menu.infoSubmenuObject and (menu.infoSubmenuObject ~= 0) then
			local orders = {}
			if menu.isInfoModeValidFor(menu.infoSubmenuObject, "orderqueue") then
				local n = C.GetNumOrders(menu.infoSubmenuObject)
				local buf = ffi.new("Order[?]", n)
				n = C.GetOrders(buf, n, menu.infoSubmenuObject)
				for i = 0, n - 1 do
					local entry = {}
					entry.state = ffi.string(buf[i].state)
					entry.orderdef = ffi.string(buf[i].orderdef)
					entry.actualparams = tonumber(buf[i].actualparams)
					table.insert(orders, entry)
				end
			end

			if (menu.infoTableMode == "info") and ((menu.infoMode.left == "orderqueue") or (menu.infoMode.left == "orderqueue_advanced") or (menu.infoMode.left == "standingorders")) then
				if menu.infoTableData.left.orders then
					if #orders ~= #menu.infoTableData.left.orders then
						refreshing = true
					else
						for i, order in ipairs(orders) do
							local oldorder = menu.infoTableData.left.orders[i]
							if (order.state ~= oldorder.state) or (order.orderdef ~= oldorder.orderdef) then
								refreshing = true
								break
							end
						end
					end
				end
			end
			if (menu.searchTableMode == "info") and ((menu.infoMode.right == "orderqueue") or (menu.infoMode.right == "orderqueue_advanced") or (menu.infoMode.right == "standingorders")) then
				if menu.infoTableData.right.orders then
					if #orders ~= #menu.infoTableData.right.orders then
						refreshing = true
					else
						for i, order in ipairs(orders) do
							local oldorder = menu.infoTableData.right.orders[i]
							if (order.state ~= oldorder.state) or (order.orderdef ~= oldorder.orderdef) then
								refreshing = true
								break
							end
						end
					end
				end
			end
		end
	end

	if menu.orderdrag and menu.orderdrag.isclick then
		local offset = table.pack(GetLocalMousePosition())
		if menu.leftdown and ((menu.leftdown.time + 0.5 < curtime) or Helper.comparePositions(menu.leftdown.position, offset, 5)) then
			menu.orderdrag.isclick = false
			if menu.orderdrag.isintermediate then
				if menu.orderdrag.component ~= C.GetPlayerOccupiedShipID() then
					local posrot = ffi.new("UIPosRot")
					local eclipticoffset = ffi.new("UIPosRot")
					local posrotcomponent = C.GetMapPositionOnEcliptic2(menu.holomap, posrot, false, 0, eclipticoffset)
					if posrotcomponent ~= 0 then
						local hasloop = ffi.new("bool[1]", 0)
						C.GetOrderQueueFirstLoopIdx(menu.orderdrag.component, hasloop)
						if C.IsOrderSelectableFor("MoveWait", menu.orderdrag.component) and GetComponentData(ConvertStringTo64Bit(tostring(menu.orderdrag.component)), "assignedpilot") and ((not hasloop[0]) or menu.orderdefbyid["MoveWait"].loopable) then
							local orderidx = C.CreateOrder(menu.orderdrag.component, "MoveWait", false)
							if orderidx > 0 then
								SetOrderParam(ConvertStringToLuaID(tostring(menu.orderdrag.component)), orderidx, 1, nil, { ConvertStringToLuaID(tostring(posrotcomponent)), {posrot.x, posrot.y, posrot.z} })
								SetOrderParam(ConvertStringToLuaID(tostring(menu.orderdrag.component)), orderidx, 5, nil, true)
								-- If we added the new move order in front of a default order, menu.orderdrag.order.queueidx == 0 -> change it to length of the queue for the new order now on the queue
								if menu.orderdrag.order.queueidx == 0 then
									menu.orderdrag.order.queueidx = C.GetNumOrders(menu.orderdrag.component)
								end
								C.AdjustOrder(menu.orderdrag.component, orderidx, menu.orderdrag.order.queueidx, menu.orderdrag.order.enabled, false, false)
							end
							if menu.infoTableMode == "mission" then
								menu.refreshIF = curtime
							end
						end
					else
						-- we should create a new order, but there is no valid position here (e.g. between clusters), store the need to create a new order for later
						menu.orderdrag.createneworder = true
					end
				end
			end
		end
	end
	if menu.orderdrag and (not menu.orderdrag.isclick) then
		if (menu.orderdrag.component ~= C.GetPlayerOccupiedShipID()) and GetComponentData(ConvertStringTo64Bit(tostring(menu.orderdrag.component)), "assignedpilot") then
			if menu.orderdrag.createneworder then
				local posrot = ffi.new("UIPosRot")
				local eclipticoffset = ffi.new("UIPosRot")
				local posrotcomponent = C.GetMapPositionOnEcliptic2(menu.holomap, posrot, false, 0, eclipticoffset)

				if posrotcomponent ~= 0 then
					local hasloop = ffi.new("bool[1]", 0)
					C.GetOrderQueueFirstLoopIdx(menu.orderdrag.component, hasloop)
					if C.IsOrderSelectableFor("MoveWait", menu.orderdrag.component) and GetComponentData(ConvertStringTo64Bit(tostring(menu.orderdrag.component)), "assignedpilot") and ((not hasloop[0]) or menu.orderdefbyid["MoveWait"].loopable) then
						local neworderidx = C.CreateOrder(menu.orderdrag.component, "MoveWait", false)
						if neworderidx > 0 then
							SetOrderParam(ConvertStringToLuaID(tostring(menu.orderdrag.component)), neworderidx, 1, nil, { ConvertStringToLuaID(tostring(posrotcomponent)), {posrot.x, posrot.y, posrot.z} })
							SetOrderParam(ConvertStringToLuaID(tostring(menu.orderdrag.component)), neworderidx, 5, nil, true)
							-- If we added the new move order in front of a default order, menu.orderdrag.order.queueidx == 0 -> change it to length of the queue for the new order now on the queue
							if menu.orderdrag.order.queueidx == 0 then
								menu.orderdrag.order.queueidx = C.GetNumOrders(menu.orderdrag.component)
							end
							C.AdjustOrder(menu.orderdrag.component, neworderidx, menu.orderdrag.order.queueidx, menu.orderdrag.order.enabled, false, false)
						end
						if menu.infoTableMode == "mission" then
							menu.refreshIF = curtime
						end
					end
					menu.orderdrag.createneworder = nil
				end
			end

			if not menu.orderdrag.createneworder then
				local posrot = ffi.new("UIPosRot")

				local paramidx = config.orderDragSupport[ffi.string(menu.orderdrag.orderdefid)]
				-- the order queue can change while we are dragging the new order (previous order stops because it was only waiting)
				-- recheck the pickedorder on the map and adjust the queueidx if there is a picked non-intermediate order (during dragging this must be the order we are dragging)
				local pickedorder = ffi.new("Order")
				local isintermediate = ffi.new("bool[1]", 0)
				local pickedordercomponent = C.GetPickedMapOrder(menu.holomap, pickedorder, isintermediate)
				if (pickedordercomponent == menu.orderdrag.component) and (not isintermediate[0]) then
					menu.orderdrag.order.queueidx = pickedorder.queueidx
				end

				local orderidx = (tonumber(menu.orderdrag.order.queueidx) == 0) and "default" or tonumber(menu.orderdrag.order.queueidx)
				local orderparams = GetOrderParams(ConvertStringToLuaID(tostring(menu.orderdrag.component)), orderidx)
				if next(orderparams) then
					if (orderparams[paramidx].type == "position") and (type(orderparams[paramidx].value[2]) == "table") then
						local eclipticoffset = ffi.new("UIPosRot", orderparams[paramidx].value[2])

						local posrotcomponent = C.GetMapPositionOnEcliptic2(menu.holomap, posrot, true, ConvertIDTo64Bit(orderparams[paramidx].value[1]), eclipticoffset)
						if posrotcomponent ~= 0 then
							SetOrderParam(ConvertStringToLuaID(tostring(menu.orderdrag.component)), orderidx, paramidx, nil, { ConvertStringToLuaID(tostring(posrotcomponent)), {posrot.x, posrot.y, posrot.z} })
						end
					else
						DebugError("menu.onUpdate(): Invalid order parameter used for orderdrag: " .. menu.orderdrag.orderdefid .. ", param '" .. paramidx .. "' of type '" .. orderparams[paramidx].type .. "'")
					end
				end
			end
		end
	end

	if menu.intersectordrag and menu.intersectordrag.isclick then
		local offset = table.pack(GetLocalMousePosition())
		if menu.leftdown and ((menu.leftdown.time + 0.5 < curtime) or Helper.comparePositions(menu.leftdown.position, offset, 5)) then
			menu.intersectordrag.isclick = false
		end
	end
	if menu.intersectordrag and (not menu.intersectordrag.isclick) then
		local posrot = ffi.new("UIPosRot")
		local currentsector = C.GetSubordinateGroupProtectedSector(menu.intersectordrag.component, menu.intersectordrag.group)
		local eclipticoffset = C.GetSubordinateGroupProtectedPosition(menu.intersectordrag.component, menu.intersectordrag.group)

		local posrotcomponent = C.GetMapPositionOnEcliptic2(menu.holomap, posrot, true, currentsector, eclipticoffset)
		if posrotcomponent ~= 0 then
			C.SetSubordinateGroupProtectedLocation(menu.intersectordrag.component, menu.intersectordrag.group, posrotcomponent, posrot)
		end
	end

	if menu.panningmap and menu.panningmap.isclick then
		local offset = table.pack(GetLocalMousePosition())
		if (menu.leftdown.time + 0.5 < curtime) or Helper.comparePositions(menu.leftdown.position, offset, 5) then
			menu.panningmap.isclick = false
		end
	end

	if menu.lastzoom then
		if not menu.zoom_newdir or menu.zoom_newdir ~= menu.lastzoom.dir then
			if menu.zoom_newdir then
				if menu.sound_zoom then
					StopPlayingSound(menu.sound_zoom)
				end
				menu.sound_zoom = nil
			end

			if menu.lastzoom.dir == "in" then
				menu.sound_zoom = StartPlayingSound("ui_scroll_zoomin")
				menu.zoom_newdir = "in"
			elseif menu.lastzoom.dir == "out" then
				menu.sound_zoom = StartPlayingSound("ui_scroll_zoomout")
				menu.zoom_newdir = "out"
			end
		elseif menu.sound_zoom and menu.lastzoom.time + 0.3 < curtime then
			StopPlayingSound(menu.sound_zoom)
			menu.sound_zoom = nil
			menu.zoom_newdir = nil
			menu.lastzoom = nil
		end
	end

	if menu.leftdown then
		if not menu.leftdown.wasmoved then
			local offset = table.pack(GetLocalMousePosition())
			if Helper.comparePositions(menu.leftdown.position, offset, 5) then
				menu.leftdown.wasmoved = true
			end
		end
		if menu.leftdown.wasmoved and menu.leftdown.time + 0.1 < curtime and not C.IsComponentClass(C.GetPickedMapComponent(menu.holomap), "object") then
			local currentmousepos = table.pack(GetLocalMousePosition())
			if menu.panningmap and Helper.comparePositions(menu.leftdown.dynpos, currentmousepos, 5) then
				if not menu.sound_panmap then
					menu.sound_panmap = StartPlayingSound("ui_scroll_wasd")
				end
				menu.leftdown.dynpos = currentmousepos
			elseif menu.sound_panmap then
				StopPlayingSound(menu.sound_panmap)
				menu.sound_panmap = nil
			end
		end
	end

	if menu.rightdown then
		if not menu.rightdown.wasmoved then
			local offset = table.pack(GetLocalMousePosition())
			if Helper.comparePositions(menu.rightdown.position, offset, 5) then
				menu.rightdown.wasmoved = true
			end
		end
		if menu.rightdown.wasmoved and menu.rightdown.time + 0.1 < curtime and not C.IsComponentClass(C.GetPickedMapComponent(menu.holomap), "object") then
			local currentmousepos = table.pack(GetLocalMousePosition())
			if menu.rotatingmap then
				if currentmousepos[2] > menu.rightdown.dynpos[2] then
					if menu.sound_rotatemap then
						if menu.sound_rotatemap.dir ~= "down" then
							if menu.sound_rotatemap.sound then
								StopPlayingSound(menu.sound_rotatemap.sound)
							end
							menu.sound_rotatemap = { sound = StartPlayingSound("ui_scroll_pitch_down"), dir = "down"}
						end
					else
						menu.sound_rotatemap = { sound = StartPlayingSound("ui_scroll_pitch_down"), dir = "down"}
					end
					menu.rightdown.dynpos = currentmousepos
				elseif currentmousepos[2] < menu.rightdown.dynpos[2] then
					if menu.sound_rotatemap then
						if menu.sound_rotatemap.dir ~= "up" then
							if menu.sound_rotatemap.sound then
								StopPlayingSound(menu.sound_rotatemap.sound)
							end
							menu.sound_rotatemap = { sound = StartPlayingSound("ui_scroll_pitch_up"), dir = "up"}
						end
					else
						menu.sound_rotatemap = { sound = StartPlayingSound("ui_scroll_pitch_up"), dir = "up"}
					end
					menu.rightdown.dynpos = currentmousepos
				elseif menu.rightdown.dynpos[1] ~= currentmousepos[1] then
					if menu.sound_rotatemap then
						if menu.sound_rotatemap.dir ~= "up" then
							if menu.sound_rotatemap.sound then
								StopPlayingSound(menu.sound_rotatemap.sound)
							end
							menu.sound_rotatemap = { sound = StartPlayingSound("ui_scroll_cirle"), dir = "rot"}
						end
					else
						menu.sound_rotatemap = { sound = StartPlayingSound("ui_scroll_cirle"), dir = "rot"}
					end
					menu.rightdown.dynpos = currentmousepos
				elseif menu.sound_rotatemap then
					if menu.sound_rotatemap.sound then
						StopPlayingSound(menu.sound_rotatemap.sound)
					end
					menu.sound_rotatemap = nil
				end
			end
		end
	end

	if (menu.infoTableMode == "objectlist") then
		if menu.lastrefresh + 2.0 < curtime then
			refreshing = true
		end
	end

	if Helper.hasExtension("multiverse") then
		if Helper.callExtensionFunction("multiverse", "updateVentures", menu) then
			refreshing = true
		end
	end

	if menu.infoSubmenuObject and (menu.infoSubmenuObject ~= 0) and (not IsValidComponent(menu.infoSubmenuObject)) then
		menu.infoSubmenuObject = 0
		refreshing = true
	end

	if refreshing and (not menu.noupdate) then
		menu.lastrefresh = curtime
		menu.refreshInfoFrame()
	end

	if menu.refreshFilterSettings then
		menu.applyFilterSettings()
		menu.refreshMainFrame = true
		menu.refreshFilterSettings = nil
	end

	if menu.inputModeHasChanged then
		if not menu.noupdate then
			menu.refreshMainFrame = true
			menu.inputModeHasChanged = nil
		end
	end

	if not menu.panningmap then
		if menu.refreshMainFrame then
			if not menu.createMainFrameRunning then
				if not menu.disregardFilterTable then
					menu.topRows.filterTable = GetTopRow(menu.searchField)
					menu.selectedRows.filterTable = Helper.currentTableRow[menu.searchField]
					menu.selectedCols.filterTable = Helper.currentTableCol[menu.searchField]
				end

				menu.selectedRows.sideBar = Helper.currentTableRow[menu.sideBar]
				menu.selectedRows.rightBar = Helper.currentTableRow[menu.rightBar]

				menu.createMainFrame(nil, (menu.contextMenuMode == "trade") and menu.contextMenuData.tradeModeHeight or nil, true)
				menu.disregardFilterTable = nil
				menu.refreshMainFrame = nil
			end
		end
	end

	if menu.contextMenuMode == "trade" then
		if (not menu.tradeSliderLock) then
			local playermoney = GetPlayerMoney()
			if playermoney ~= menu.contextMenuData.playerMoney then
				menu.contextMenuData.playerMoney = playermoney
				menu.queuetradecontextrefresh = true
			end
		end
	elseif menu.contextMenuMode == "rename" then
		if menu.contextMenuData.nameEditBox then
			ActivateEditBox(menu.contextMenuData.nameEditBox.id)
			menu.contextMenuData.nameEditBox = nil
		end
	end

	if menu.queuecontextrefresh and (menu.queuecontextrefresh < curtime) then
		menu.refreshContextFrame()
		menu.queuecontextrefresh = nil
	end

	if menu.queuetradecontextrefresh then
		menu.topRows.contextshiptable = GetTopRow(menu.contextshiptable)
		menu.selectedRows.contextshiptable = Helper.currentTableRow[menu.contextshiptable]
		menu.createContextFrame()
		menu.queuetradecontextrefresh = nil
	end
end

-- row changes
function menu.onRowChanged(row, rowdata, uitable, modified, input, source)
	-- Lock button over updates
	menu.lock = getElapsedTime()

	-- handle map modes without a holomap first
	if (menu.mode == "boardingcontext") and menu.boardingtable_shipselection and (uitable == menu.boardingtable_shipselection.id) and (type(rowdata) == "table") and (rowdata[1] == "boardingship") and C.IsComponentClass(rowdata[2], "defensible") and (menu.boardingData.selectedship ~= rowdata[2]) then
		--print("queueing refresh on next frame. ship: " .. ffi.string(C.GetComponentName(rowdata[2])) .. " " .. tostring(rowdata[2]))
		menu.boardingData.selectedship = rowdata[2]
		menu.queuecontextrefresh = menu.lock
	elseif menu.contextMenuMode == "trade" then
		if uitable == menu.contextshiptable then
			if rowdata then
				if (type(rowdata) == "table") and next(rowdata) then
					menu.selectedTradeWare = rowdata
				else
					menu.selectedTradeWare = nil
				end
				if (not menu.skipTradeRowChange) and (not menu.tradeSliderLock) then
					menu.queuetradecontextrefresh = true
				end
				menu.skipTradeRowChange = nil
			end
		end
	end

	if menu.holomap == 0 then
		return
	end

	if menu.showMultiverse then
		if (menu.ventureMode == "ventureoperation") or (menu.ventureMode == "ventureseason") then
			if uitable == menu.infoTable then
				Helper.callExtensionFunction("multiverse", "onRowChanged", menu, menu.ventureMode, row, rowdata, uitable, modified, input, source)
			end
		end
	else
		
		-- start Forleyor_infoCenter Callback:
		if callbacks ["ic_onRowChanged"] then
			for _, callback in ipairs (callbacks ["ic_onRowChanged"]) do
				callback (row, rowdata, uitable, modified, input, source)
			end
		end
		-- end Forleyor_infoCenter:

		if (menu.infoTableMode == "info") then
			if uitable == menu.infoTable then
				if (menu.infoMode.left == "objectinfo") or (menu.infoMode.left == "objectcrew") or (menu.infoMode.left == "objectloadout") then
					menu.selectedRows.infotableleft = row
					if menu.infoMode.left == "objectloadout" then
						local infomacrostolaunch = menu.infoTablePersistentData.left.macrostolaunch
						if (type(rowdata) == "table") and (rowdata[1] == "info_deploy") then
							if GetMacroData(rowdata[2], "islasertower") and (infomacrostolaunch.lasertower ~= rowdata[2]) then
								menu.infoTablePersistentData.left.macrostolaunch = { lasertower = rowdata[2] }
							elseif IsMacroClass(rowdata[2], "mine") and (infomacrostolaunch.mine ~= rowdata[2]) then
								menu.infoTablePersistentData.left.macrostolaunch = { mine = rowdata[2] }
							elseif IsMacroClass(rowdata[2], "navbeacon") and (infomacrostolaunch.navbeacon ~= rowdata[2]) then
								menu.infoTablePersistentData.left.macrostolaunch = { navbeacon = rowdata[2] }
							elseif IsMacroClass(rowdata[2], "resourceprobe") and (infomacrostolaunch.resourceprobe ~= rowdata[2]) then
								menu.infoTablePersistentData.left.macrostolaunch = { resourceprobe = rowdata[2] }
							elseif IsMacroClass(rowdata[2], "satellite") and (infomacrostolaunch.satellite ~= rowdata[2]) then
								menu.infoTablePersistentData.left.macrostolaunch = { satellite = rowdata[2] }
							end
						else
							menu.infoTablePersistentData.left.macrostolaunch = {}
						end
					end
				elseif (menu.infoMode.left == "orderqueue") or (menu.infoMode.left == "orderqueue_advanced") or (menu.infoMode.left == "standingorders") then
					if type(rowdata) == "table" then
						menu.infoTablePersistentData.left.selectedorder = rowdata
						menu.infoTablePersistentData.left.selectedorder.object = menu.infoSubmenuObject
					else
						menu.infoTablePersistentData.left.selectedorder = nil
					end
				end
			end

		-- kuertee start:
		-- elseif (menu.infoTableMode == "objectlist") or (menu.infoTableMode == "propertyowned") then
		elseif (string.find ("" .. tostring (menu.infoTableMode), "objectlist")) or (string.find ("" .. tostring (menu.infoTableMode), "propertyowned")) then
			-- kuertee end:

			if uitable == menu.infoTable then
				if type(rowdata) == "table" then
					local convertedComponent = ConvertIDTo64Bit(rowdata[2])
					if (source ~= "auto") and convertedComponent then
						local convertedcomponentclass = ffi.string(C.GetComponentClass(convertedComponent))
						if convertedcomponentclass  == "station" then
							AddUITriggeredEvent(menu.name, "selection_station", convertedComponent)
						end
						if (convertedcomponentclass  == "ship_s") or (convertedcomponentclass  == "ship_m") or (convertedcomponentclass  == "ship_l") or (convertedcomponentclass  == "ship_xl") then
							AddUITriggeredEvent(menu.name, "selection_ship", convertedComponent)
						end
						if (convertedcomponentclass == "resourceprobe") then
							AddUITriggeredEvent(menu.name, "selection_resourceprobe", convertedComponent)
						end

						if (menu.mode ~= "orderparam_object") and (input ~= "rightmouse") then
							menu.setInfoSubmenuObjectAndRefresh(convertedComponent)
						end
					end
					menu.updateSelectedComponents(modified, source == "auto", convertedComponent, row)
					menu.setSelectedMapComponents()
				else
					menu.updateSelectedComponents(modified, true, nil, row)
				end
			end
		elseif menu.infoTableMode == "plots" then
			if menu.plotDoNotUpdate then
				menu.plotDoNotUpdate = nil
			elseif menu.table_plotlist and (uitable == menu.table_plotlist.id) then
				menu.settoprow = GetTopRow(menu.table_plotlist)
				menu.setrow = Helper.currentTableRow[menu.table_plotlist]
				if not rowdata then
					print("rowdata empty. table id: " .. tostring(uitable) .. ", row: " .. tostring(row) .. ", rowdata: " .. tostring(rowdata))
				elseif input == "mouse" then
					--print("table id: " .. tostring(uitable) .. ", row: " .. tostring(row) .. ", rowdata: " .. tostring(rowdata) .. ", menu.table_plotlist.id: " .. tostring(menu.table_plotlist.id) .. ", uitable == menu.table_plotlist.id? " .. tostring(uitable == menu.table_plotlist.id))
					if rowdata ~= "plots_new" then
						C.SetFocusMapComponent(menu.holomap, rowdata, true)
					end
					menu.updatePlotData(rowdata)
				end
			end
		elseif (menu.infoTableMode == "missionoffer") or (menu.infoTableMode == "mission") then
			if uitable == menu.infoTable then
				if (menu.infoTableMode == "missionoffer") and (menu.missionOfferMode == "operation") then
					Helper.callExtensionFunction("multiverse", "onRowChanged", menu, "ventureoperation", row, rowdata, uitable, modified, input, source)
				else
					local oldmission = menu.missionModeCurrent
					if type(rowdata) == "table" then
						local missionid = ConvertStringTo64Bit(rowdata[1])
						menu.missionModeCurrent = rowdata[1]
						if menu.missionDoNotUpdate then
							menu.missionDoNotUpdate = nil
						elseif input == "mouse" then
							if menu.contextMenuData and menu.contextMenuData.missionid and (menu.contextMenuData.missionid == missionid) then
								menu.closeContextMenu()
								menu.missionModeContext = nil
							else
								menu.closeContextMenu()
								menu.showMissionContext(missionid)
								menu.missionModeContext = true
							end
						end
					elseif type(rowdata) == "string" then
						menu.missionModeCurrent = rowdata
						if menu.missionDoNotUpdate then
							menu.missionDoNotUpdate = nil
						elseif input == "mouse" then
							menu.closeContextMenu()
							menu.missionModeContext = nil
						end
					end
					if menu.missionDoNotUpdate then
						menu.missionDoNotUpdate = nil
					elseif menu.missionModeCurrent ~= oldmission then
						if source ~= "auto" then
							menu.refreshInfoFrame()
						end
					end
				end
			end
		end
	end

	if (menu.searchTableMode == "info") then
		if uitable == menu.infoTableRight then
			if (menu.infoMode.right == "objectinfo") or (menu.infoMode.right == "objectcrew") or (menu.infoMode.right == "objectloadout") then
				menu.selectedRows.infotableright = row
				if menu.infoMode.right == "objectloadout" then
					local infomacrostolaunch = menu.infoTablePersistentData.right.macrostolaunch
					if (type(rowdata) == "table") and (rowdata[1] == "info_deploy") then
						if GetMacroData(rowdata[2], "islasertower") and (infomacrostolaunch.lasertower ~= rowdata[2]) then
							menu.infoTablePersistentData.right.macrostolaunch = { lasertower = rowdata[2] }
						elseif IsMacroClass(rowdata[2], "mine") and (infomacrostolaunch.mine ~= rowdata[2]) then
							menu.infoTablePersistentData.right.macrostolaunch = { mine = rowdata[2] }
						elseif IsMacroClass(rowdata[2], "navbeacon") and (infomacrostolaunch.navbeacon ~= rowdata[2]) then
							menu.infoTablePersistentData.right.macrostolaunch = { navbeacon = rowdata[2] }
						elseif IsMacroClass(rowdata[2], "resourceprobe") and (infomacrostolaunch.resourceprobe ~= rowdata[2]) then
							menu.infoTablePersistentData.right.macrostolaunch = { resourceprobe = rowdata[2] }
						elseif IsMacroClass(rowdata[2], "satellite") and (infomacrostolaunch.satellite ~= rowdata[2]) then
							menu.infoTablePersistentData.right.macrostolaunch = { satellite = rowdata[2] }
						end
					else
						menu.infoTablePersistentData.right.macrostolaunch = {}
					end
				end
			elseif (menu.infoMode.right == "orderqueue") or (menu.infoMode.right == "orderqueue_advanced") or (menu.infoMode.right == "standingorders") then
				if type(rowdata) == "table" then
					menu.infoTablePersistentData.right.selectedorder = rowdata
					menu.infoTablePersistentData.right.selectedorder.object = menu.infoSubmenuObject
				else
					menu.infoTablePersistentData.right.selectedorder = nil
				end
			end
		end
	end
end

function menu.onRowChangedSound(row, rowdata, uitable, layer, modified, input)
	if (menu.frames[layer] == GetActiveFrame()) and (uitable == GetInteractiveObject(menu.frames[layer])) then
		local playsound = false
		if uitable == menu.infoTable then
			if (not menu.sound_rowChangedRowLeft) or (menu.sound_rowChangedRowLeft ~= row) then
				playsound = true
			end
		elseif uitable ~= menu.infoTableRight then
			if (not menu.sound_rowChangedRowRight) or (menu.sound_rowChangedRowRight ~= row) then
				playsound = true
			end
		else
			playsound = true
		end
		if playsound then
			PlaySound((uitable == menu.sideBar) and "ui_positive_hover_side" or "ui_positive_hover_normal")
		end
	end
	if uitable == menu.infoTable then
		menu.sound_rowChangedRowLeft = row
	elseif uitable == menu.infoTableRight then
		menu.sound_rowChangedRowRight = row
	end
end

function menu.setSelectedMapComponents()
	if menu.holomap and (menu.holomap ~= 0) then
		local numcomponents = 0
		for _, _ in pairs(menu.selectedcomponents) do
			numcomponents = numcomponents + 1
		end
		local components = ffi.new("UniverseID[?]", numcomponents)
		local i = 0
		for id, _ in pairs(menu.selectedcomponents) do
			components[i] = ConvertStringTo64Bit(id)
			i = i + 1
		end
		C.SetSelectedMapComponents(menu.holomap, components, numcomponents)
	end
end

function menu.onSelectElement(uitable, modified, row, isdblclick, input)
	local rowdata = Helper.getCurrentRowData(menu, uitable)
	if menu.showMultiverse then
		if menu.ventureMode == "ventureoperation" then
			if uitable == menu.infoTable then
				Helper.callExtensionFunction("multiverse", "onSelectRow", menu, menu.ventureMode, uitable, modified, row, isdblclick, input)
			elseif uitable == menu.contextinfotable then
				Helper.callExtensionFunction("multiverse", "onSelectRow", menu, menu.ventureMode, uitable, modified, row, isdblclick, input)
			end
		end
	else

		-- start Forleyor_infoCenter Callback:
		if callbacks ["ic_onSelectElement"] then
			for _, callback in ipairs (callbacks ["ic_onSelectElement"]) do
				callback (uitable, modified, row, isdblclick, input)
			end
		end
		-- end Forleyor_infoCenter:

		-- if (menu.infoTableMode == "objectlist") or (menu.infoTableMode == "propertyowned") then
		-- kuertee start: callback
		if (string.find ("" .. tostring (menu.infoTableMode), "objectlist")) or (string.find ("" .. tostring (menu.infoTableMode), "propertyowned")) then
			-- kuertee end: callback

			if uitable == menu.infoTable then
				if type(rowdata) == "table" then
					local convertedRowComponent = ConvertIDTo64Bit(rowdata[2])
					menu.setSelectedMapComponents()

					if convertedRowComponent and (convertedRowComponent ~= 0) then
						local isonlineobject, isplayerowned = GetComponentData(rowdata[2], "isonlineobject", "isplayerowned")
						if (isdblclick or (input ~= "mouse")) and (ffi.string(C.GetComponentClass(convertedRowComponent)) ~= "sector") then
							if string.find(rowdata[1], "subordinates") then
								local subordinates = menu.infoTableData.left.subordinates[tostring(rowdata[2])] or {}
								local groups = {}
								for _, subordinate in ipairs(subordinates) do
									local group = GetComponentData(subordinate, "subordinategroup")
									if group and group > 0 then
										if groups[group] then
											table.insert(groups[group].subordinates, subordinate)
										else
											groups[group] = { assignment = ffi.string(C.GetSubordinateGroupAssignment(convertedRowComponent, group)), subordinates = { subordinate } }
										end
									end
								end

								if groups[rowdata[3]] then
									C.SetFocusMapComponent(menu.holomap, ConvertIDTo64Bit(groups[rowdata[3]].subordinates[1]), true)
									menu.addSelectedComponents(groups[rowdata[3]].subordinates, modified ~= "shift")
								end
							elseif isplayerowned and isonlineobject then
								local assigneddock = ConvertIDTo64Bit(GetComponentData(convertedRowComponent, "assigneddock"))
								if assigneddock then
									local container = C.GetContextByClass(assigneddock, "container", false)
									if container then
										C.SetFocusMapComponent(menu.holomap, container, true)
									end
								end
							else
								C.SetFocusMapComponent(menu.holomap, convertedRowComponent, true)
							end
						end
					end
				end
			end
		elseif menu.infoTableMode == "plots" then
			if menu.plotDoNotUpdate then
				menu.plotDoNotUpdate = nil
			elseif menu.table_plotlist and (uitable == menu.table_plotlist.id) then
				if rowdata ~= "plots_new" then
					C.SetFocusMapComponent(menu.holomap, rowdata, true)
				end
				menu.updatePlotData(rowdata)
			end
		elseif (menu.infoTableMode == "missionoffer") or (menu.infoTableMode == "mission") then
			if uitable == menu.infoTable then
				if (menu.infoTableMode == "missionoffer") and (menu.missionOfferMode == "operation") then
					Helper.callExtensionFunction("multiverse", "onSelectRow", menu, "ventureoperation", uitable, modified, row, isdblclick, input)
				else
					if type(rowdata) == "table" then
						menu.missionModeCurrent = rowdata[1]
						local missionid = ConvertStringTo64Bit(rowdata[1])
						if menu.contextMenuData and menu.contextMenuData.missionid and (menu.contextMenuData.missionid == missionid) then
							menu.closeContextMenu()
							menu.missionModeContext = nil
						else
							menu.closeContextMenu()
							menu.showMissionContext(missionid)
							menu.missionModeContext = true
						end
					elseif type(rowdata) == "string" then
						menu.missionModeCurrent = rowdata
						if menu.missionDoNotUpdate then
							menu.missionDoNotUpdate = nil
						else
							menu.closeContextMenu()
							menu.missionModeContext = nil
						end
					end
				end
			end
		elseif (menu.infoTableMode == "info") then
			if (isdblclick or (input ~= "mouse")) then
				if (rowdata == "info_focus") or ((type(rowdata) == "table") and (rowdata[1] == "info_focus")) then
					C.SetFocusMapComponent(menu.holomap, menu.infoSubmenuObject, true)
				end
				if (menu.infoMode.left == "orderqueue") or (menu.infoMode.left == "orderqueue_advanced") then
					if (type(rowdata) == "table") and (type(rowdata[1]) == "number") then
						C.SetFocusMapOrder(menu.holomap, menu.infoSubmenuObject, rowdata[1], true)
					end
				end
			end
		end
	end

	if (menu.searchTableMode == "info") then
		if (isdblclick or (input ~= "mouse")) then
			if (rowdata == "info_focus") or ((type(rowdata) == "table") and (rowdata[1] == "info_focus")) then
				C.SetFocusMapComponent(menu.holomap, menu.infoSubmenuObject, true)
			end
			if (menu.infoMode.right == "orderqueue") or (menu.infoMode.right == "orderqueue_advanced") then
				if (type(rowdata) == "table") and (type(rowdata[1]) == "number") then
					C.SetFocusMapOrder(menu.holomap, menu.infoSubmenuObject, rowdata[1], true)
				end
			end
		end
	end
end

-- rendertarget selections
function menu.onRenderTargetSelect(modified)
	local offset = table.pack(GetLocalMousePosition())
	-- Check if the mouse button was down less than 0.5 seconds and the mouse was moved more than a distance of 5px
	if (not menu.leftdown) or ((menu.leftdown.time + 0.5 > getElapsedTime()) and not Helper.comparePositions(menu.leftdown.position, offset, 5)) then
		if menu.showMultiverse then
			local pickedplayer = C.GetPickedMultiverseMapPlayer(menu.holomap)
			-- TODO
		elseif menu.mode == "selectbuildlocation" then
			local station = 0
			if menu.plotData.active then
				local offset = ffi.new("UIPosRot")
				local offsetsector = C.GetBuildMapStationLocation2(menu.holomap, offset)
				if offsetsector ~= 0 then
					if C.IsCurrentBuildMapPlotValid(menu.holomap) then
						AddUITriggeredEvent(menu.name, "plotplaced")
						menu.plotData.sector = offsetsector
						station = C.ReserveBuildPlot(offsetsector, "player", menu.plotData.set, offset, menu.plotData.size.x * 1000, menu.plotData.size.y * 1000, menu.plotData.size.z * 1000)
						if GetComponentData(ConvertStringTo64Bit(tostring(offsetsector)), "isplayerowned") then
							local size = { x = menu.plotData.size.x * 1000, y = menu.plotData.size.y * 1000, z = menu.plotData.size.z * 1000 }
							local plotcenter = { x = offset.x, y = offset.y, z = offset.z }
							C.PayBuildPlotSize(station, size, plotcenter)
						end
						C.ClearMapBuildPlot(menu.holomap)
						menu.plotData.active = nil
						SetMouseOverOverride(menu.map, nil)
					else
						PlaySound("ui_target_set_fail")
					end
				end
			else
				local pickedcomponent = C.GetPickedMapComponent(menu.holomap)
				local pickedcomponentclass = ffi.string(C.GetRealComponentClass(pickedcomponent))
				if (pickedcomponentclass == "station") and GetComponentData(ConvertStringToLuaID(tostring(pickedcomponent)), "isplayerowned") then
					station = pickedcomponent
				end
			end

			if station ~= 0 then
				for _, row in ipairs(menu.table_plotlist.rows) do
					if row.rowdata == station then
						menu.setplotrow = row.index
						menu.setplottoprow = (row.index - config.plots.maxPlotRows + 1) > 1 and (row.index - config.plots.maxPlotRows + 1) or 1
						break
					end
				end

				menu.updatePlotData(station, true)
				menu.refreshInfoFrame()
			end
		elseif menu.mode == "orderparam_position" then
			local offset = ffi.new("UIPosRot")
			local eclipticoffset = ffi.new("UIPosRot")
			local offsetcomponent = C.GetMapPositionOnEcliptic2(menu.holomap, offset, false, 0, eclipticoffset)
			if offsetcomponent ~= 0 then
				local class = ffi.string(C.GetComponentClass(offsetcomponent))
				if (not menu.modeparam[2].inputparams.class) or (class == menu.modeparam[2].inputparams.class) then
					AddUITriggeredEvent(menu.name, menu.mode, ConvertStringToLuaID(tostring(offsetcomponent)))
					menu.modeparam[1]({ConvertStringToLuaID(tostring(offsetcomponent)), {offset.x, offset.y, offset.z}})
				elseif (menu.modeparam[2].inputparams.class == "zone") and (class == "sector") then
					offsetcomponent = C.GetZoneAt(offsetcomponent, offset)
					AddUITriggeredEvent(menu.name, menu.mode, ConvertStringToLuaID(tostring(offsetcomponent)))
					menu.modeparam[1]({ConvertStringToLuaID(tostring(offsetcomponent)), {offset.x, offset.y, offset.z}})
				end
			end
		elseif menu.mode == "orderparam_sector" then
			menu.mode = nil
		elseif (menu.mode == "orderparam_selectenemies") or (menu.mode == "orderparam_selectplayerdeployables") then
			menu.mode = nil
			menu.modeparam = {}
			SetMouseCursorOverride("default")
			menu.removeMouseCursorOverride(3)
		elseif menu.mode == "boardingcontext" then

		else
			if menu.searchField then
				Helper.confirmEditBoxInput(menu.searchField, 1, 7)
			end
			local pickedcomponent = C.GetPickedMapComponent(menu.holomap)
			local pickedorder = ffi.new("Order")
			local isintermediate = ffi.new("bool[1]", 0)
			local pickedordercomponent = C.GetPickedMapOrder(menu.holomap, pickedorder, isintermediate)
			local pickedcomponentclass = ffi.string(C.GetComponentClass(pickedcomponent))
			local ispickedcomponentship = C.IsComponentClass(pickedcomponent, "ship") and not C.IsUnit(pickedcomponent)
			local pickedtradeoffer = C.GetPickedMapTradeOffer(menu.holomap)
			if pickedordercomponent ~= 0 then
				local sectorcontext = C.GetContextByClass(pickedordercomponent, "sector", false)
				if sectorcontext ~= menu.currentsector then
					menu.currentsector = sectorcontext
				end

				menu.createInfoFrame()
			elseif pickedtradeoffer ~= 0 then
				local tradeid = ConvertStringToLuaID(tostring(pickedtradeoffer))
				local tradedata = GetTradeData(tradeid)
				if tradedata.ware then
					local setting, rawwarelist = menu.getTradeWareFilter(true)
					local found = false
					for i, ware in ipairs(rawwarelist) do
						if ware == tradedata.ware then
							found = i
							break
						end
					end
					AddUITriggeredEvent(menu.name, "filterwareselected", tradedata.isbuyoffer and "buyoffer" or "selloffer")
					if found then
						menu.removeFilterOption(setting, setting.id, found)
					else
						menu.setFilterOption("layer_trade", setting, setting.id, tradedata.ware)
					end
				end
			elseif pickedcomponent ~= 0 then
				local pickedcomponent64 = ConvertStringTo64Bit(tostring(pickedcomponent))
				if (not menu.sound_selectedelement) or (menu.sound_selectedelement ~= pickedcomponent) or (modified == "ctrl") or (modified == "shift") then
					local isselected = menu.isSelectedComponent(pickedcomponent)
					if (not isselected) and (modified == "shift") then
						PlaySound("ui_positive_multiselect")
					elseif modified == "ctrl" then
						if isselected then
							PlaySound("ui_positive_deselect")
						else
							PlaySound("ui_positive_multiselect")
						end
					elseif (pickedcomponentclass == "sector") then
						PlaySound("ui_positive_deselect")
					else
						PlaySound("ui_positive_select")
					end
				end
				menu.sound_selectedelement = pickedcomponent
				if menu.mode ~= "orderparam_object" then
					if not menu.handlePlannedDefaultOrderRendertargetSelect(false) then
						return
					end

					menu.setInfoSubmenuObjectAndRefresh(pickedcomponent64)
				end

				if pickedcomponentclass == "sector" then
					AddUITriggeredEvent(menu.name, "selection_reset")
					menu.clearSelectedComponents()
					if pickedcomponent ~= menu.currentsector then
						menu.currentsector = pickedcomponent
						menu.updateMapAndInfoFrame()
					end
				elseif (#menu.searchtext == 0) or Helper.textArrayHelper(menu.searchtext, function (numtexts, texts) return C.FilterComponentByText(pickedcomponent, numtexts, texts, true) end) then
					local isconstruction = IsComponentConstruction(pickedcomponent64)
					if (C.IsComponentOperational(pickedcomponent) and (pickedcomponentclass ~= "player") and (pickedcomponentclass ~= "collectablewares") and (not menu.createInfoFrameRunning)) or
						(pickedcomponentclass == "gate") or (pickedcomponentclass == "asteroid") or isconstruction
					then
						local sectorcontext = C.GetContextByClass(pickedcomponent, "sector", false)
						if sectorcontext ~= menu.currentsector then
							menu.currentsector = sectorcontext
						end

						if modified == "ctrl" then
							menu.toggleSelectedComponent(pickedcomponent)
						else
							if pickedcomponentclass == "station" then
								AddUITriggeredEvent(menu.name, "selection_station", pickedcomponent64)
							end
							if (pickedcomponentclass == "ship_s") or (pickedcomponentclass == "ship_m") or (pickedcomponentclass == "ship_l") or (pickedcomponentclass == "ship_xl") then
								AddUITriggeredEvent(menu.name, "selection_ship", pickedcomponent64)
							end
							if (pickedcomponentclass == "resourceprobe") then
								AddUITriggeredEvent(menu.name, "selection_resourceprobe", pickedcomponent64)
							end

							local newmode
							if (menu.mode ~= "selectComponent") or (menu.modeparam[3] ~= "deployables") then

								-- kuertee start:
								-- if menu.infoTableMode == "objectlist" then
								if string.find ("" .. tostring (menu.infoTableMode), "objectlist") then
									-- kuertee end:

									local isdeployable = GetComponentData(pickedcomponent64, "isdeployable")
									if isdeployable or (pickedcomponentclass == "lockbox") then
										newmode = "deployables"
									elseif menu.objectMode ~= "objectall" then
										if C.IsRealComponentClass(pickedcomponent, "station") then
											newmode = "stations"
										elseif ispickedcomponentship then
											local found = false
											local commanderlist = GetAllCommanders(pickedcomponent64)
											for i, entry in ipairs(commanderlist) do
												if IsComponentClass(entry, "station") then
													found = true
													break
												end
											end
											if found then
												newmode = "stations"
											else
												newmode = "ships"
											end
										end
									end

									-- kuertee start:
									-- elseif menu.infoTableMode == "propertyowned" then
								elseif string.find ("" .. tostring (menu.infoTableMode), "propertyowned") then
									-- kuertee end:

									local isplayerowned, isdeployable = GetComponentData(pickedcomponent64, "isplayerowned", "isdeployable")
									if isplayerowned then
										if isdeployable or (pickedcomponentclass == "lockbox") then
											newmode = "deployables"
										elseif menu.propertyMode ~= "propertyall" then
											if C.IsRealComponentClass(pickedcomponent, "station") then
												newmode = "stations"
											elseif ispickedcomponentship then
												local found = false
												local commanderlist = GetAllCommanders(pickedcomponent64)
												for i, entry in ipairs(commanderlist) do
													if IsComponentClass(entry, "station") then
														found = true
														break
													end
												end
												local subordinates = GetSubordinates(pickedcomponent64)
												if found then
													newmode = "stations"
												else
													if (#commanderlist > 0) or (#subordinates > 0) then
														newmode = "fleets"
													else
														newmode = "unassignedships"
													end
												end
											end
										end
									end

									-- start: mycu call-back
									if callbacks ["onRenderTargetSelect_on_propertyowned_newmode"] then
										for _, callback in ipairs (callbacks ["onRenderTargetSelect_on_propertyowned_newmode"]) do
											result = callback (pickedcomponent64, newmode)
											if result then
												newmode = result.newmode
											end
										end
									end
									-- end: mycu call-back

								end
							end
							menu.addSelectedComponent(pickedcomponent, not modified)
							if newmode then

								-- kuertee start:
								-- if menu.infoTableMode == "objectlist" then
								if string.find ("" .. tostring (menu.infoTableMode), "objectlist") then
									-- kuertee end:

									if newmode ~= menu.objectMode then
										menu.objectMode = newmode
										menu.refreshInfoFrame()
									end

									-- kuertee start:
									-- elseif menu.infoTableMode == "propertyowned" then
								elseif string.find ("" .. tostring (menu.infoTableMode), "propertyowned") then
									-- kuertee end:

									if newmode ~= menu.propertyMode then
										menu.propertyMode = newmode
										menu.refreshInfoFrame()
									end
								end
							end
						end
					end
				end
			else
				if (menu.mode ~= "info") or (not menu.infoMode.left) or (menu.infoMode.left == "objectinfo") or (menu.infoMode.left == "objectcrew") or (menu.infoMode.left == "objectloadout") or (menu.infoMode.left == "objectlogbook") then
					AddUITriggeredEvent(menu.name, "selection_reset")
					menu.clearSelectedComponents()
				end
			end
		end
	end
	menu.leftdown = nil
end

-- rendertarget doubleclick
function menu.onRenderTargetDoubleClick(modified)
	local pickedcomponent = C.GetPickedMapComponent(menu.holomap)
	if pickedcomponent ~= 0 then
		if not C.IsComponentClass(pickedcomponent, "sector") then
			if modified == "shift" then
				C.AddSimilarMapComponentsToSelection(menu.holomap, pickedcomponent)
			elseif modified ~= "ctrl" then
				C.SetFocusMapComponent(menu.holomap, pickedcomponent, true)
			end

			local components = {}
			Helper.ffiVLA(components, "UniverseID", C.GetNumMapSelectedComponents, C.GetMapSelectedComponents, menu.holomap)
			if #components > 0 then
				menu.addSelectedComponents(components)
			else
				menu.clearSelectedComponents()
			end
		end
	end
end

-- rendertarget mouse input helper
function menu.onRenderTargetMouseDown(modified)
	menu.leftdown = { time = getElapsedTime(), position = table.pack(GetLocalMousePosition()), dynpos = table.pack(GetLocalMousePosition()) }

	local pickedorder = ffi.new("Order")
	local buf = ffi.new("bool[1]", 0)
	local pickedordercomponent = C.GetPickedMapOrder(menu.holomap, pickedorder, buf)
	local isintermediate = buf[0]
	local pickedintersectordefense = C.GetPickedMapInterSectorDefence(menu.holomap)
	if pickedordercomponent ~= 0 then
		if (menu.mode ~= "orderparam_object") and (menu.mode ~= "orderparam_position") then
			if not modified then
				if not menu.handlePlannedDefaultOrderRendertargetSelect(false) then
					return
				end

				menu.setInfoSubmenuObjectAndRefresh(ConvertStringTo64Bit(tostring(pickedordercomponent)))
			end

			menu.addSelectedComponent(pickedordercomponent, true)

			if GetComponentData(ConvertStringTo64Bit(tostring(pickedordercomponent)), "isplayerowned") then
				local orderdef = ffi.new("OrderDefinition")
				if C.GetOrderDefinition(orderdef, pickedorder.orderdef) then
					local orderdefid = ffi.string(orderdef.id)
					if isintermediate or config.orderDragSupport[orderdefid] then
						menu.orderdrag = { component = pickedordercomponent, order = pickedorder, orderdefid = isintermediate and "MoveWait" or orderdefid, isintermediate = isintermediate, isclick = true }
					end
				end
			end
		end
	elseif pickedintersectordefense.controllableid ~= 0 then
		if (menu.mode ~= "orderparam_object") and (menu.mode ~= "orderparam_position") then
			if GetComponentData(ConvertStringTo64Bit(tostring(pickedintersectordefense.controllableid)), "isplayerowned") then
				menu.intersectordrag = { component = pickedintersectordefense.controllableid, group = pickedintersectordefense.group, isclick = true }
			end
		end
	else
		if modified == "shift" then
			C.StartMapBoxSelect(menu.holomap, menu.mode == "orderparam_selectenemies")
		else
			C.StartPanMap(menu.holomap)
			menu.panningmap = { isclick = true }
			menu.noupdate = true
		end
	end

	-- kuertee start: distance tool
	distanceTool_from_posRot = ffi.new("UIPosRot")
	local eclipticoffset = ffi.new("UIPosRot")
	distanceTool_from_component = C.GetMapPositionOnEcliptic2(menu.holomap, distanceTool_from_posRot, false, 0, eclipticoffset)
    -- kuertee end
end

function menu.onRenderTargetMouseUp(modified)
	if menu.orderdrag then
		if not menu.orderdrag.isclick then
			if (menu.orderdrag.component ~= C.GetPlayerOccupiedShipID()) and GetComponentData(ConvertStringTo64Bit(tostring(menu.orderdrag.component)), "assignedpilot") then
				local posrot = ffi.new("UIPosRot")

				local paramidx = config.orderDragSupport[ffi.string(menu.orderdrag.orderdefid)]
				local orderidx = (tonumber(menu.orderdrag.order.queueidx) == 0) and "default" or tonumber(menu.orderdrag.order.queueidx)
				local orderparams = GetOrderParams(ConvertStringToLuaID(tostring(menu.orderdrag.component)), orderidx)
				if next(orderparams) then
					if (orderparams[paramidx].type == "position") and (type(orderparams[paramidx].value[2]) == "table") then
						local eclipticoffset = ffi.new("UIPosRot", orderparams[paramidx].value[2])

						local posrotcomponent = C.GetMapPositionOnEcliptic2(menu.holomap, posrot, true, ConvertIDTo64Bit(orderparams[paramidx].value[1]), eclipticoffset)
						if posrotcomponent ~= 0 then
							SetOrderParam(ConvertStringToLuaID(tostring(menu.orderdrag.component)), orderidx, paramidx, nil, { ConvertStringToLuaID(tostring(posrotcomponent)), {posrot.x, posrot.y, posrot.z} })
						end
					else
						DebugError("menu.onRenderTargetMouseUp(): Invalid order parameter used for orderdrag: " .. menu.orderdrag.orderdefid .. ", param '" .. paramidx .. "' of type '" .. orderparams[paramidx].type .. "'")
					end
				end
			end
		end
		menu.orderdrag = nil
	elseif menu.intersectordrag then
		if not menu.intersectordrag.isclick then
			local posrot = ffi.new("UIPosRot")
			local currentsector = C.GetSubordinateGroupProtectedSector(menu.intersectordrag.component, menu.intersectordrag.group)
			local eclipticoffset = C.GetSubordinateGroupProtectedPosition(menu.intersectordrag.component, menu.intersectordrag.group)

			local posrotcomponent = C.GetMapPositionOnEcliptic2(menu.holomap, posrot, true, currentsector, eclipticoffset)
			if posrotcomponent ~= 0 then
				C.SetSubordinateGroupProtectedLocation(menu.intersectordrag.component, menu.intersectordrag.group, posrotcomponent, posrot)
			end
		end
		menu.intersectordrag = nil
	elseif menu.panningmap then
		C.StopPanMap(menu.holomap)
		menu.noupdate = false
		if menu.sound_panmap then
			StopPlayingSound(menu.sound_panmap)
			menu.sound_panmap = nil
		end
		if menu.infoTableMode == "objectlist" then
			if not menu.panningmap.isclick then
				menu.refreshInfoFrame()
			end
		elseif menu.infoTableMode == "plots" and menu.plotData.component then
			if not menu.panningmap.isclick then
				-- update plot position and price
				menu.updatePlotData()
			end
		end
		menu.panningmap = nil
	else
		C.StopMapBoxSelect(menu.holomap)
		local components = {}
		Helper.ffiVLA(components, "UniverseID", C.GetNumMapSelectedComponents, C.GetMapSelectedComponents, menu.holomap)
		if #components > 0 then
			menu.setInfoSubmenuObjectAndRefresh(ConvertStringTo64Bit(tostring(components[1])))
			menu.sound_selectedelement = components[i]
			PlaySound("ui_positive_multiselect")
		end
		if menu.mode == "orderparam_selectenemies" then
			for i = #components, 1, -1 do
				local component = components[i]
				if component == menu.modeparam[1] then
					table.remove(components, i)
				elseif (not C.IsComponentClass(component, "ship")) and (not C.IsComponentClass(component, "station")) then
					table.remove(components, i)
				end
			end
			for id, _ in pairs(menu.selectedcomponents) do
				local selectedcomponent = ConvertStringTo64Bit(id)
				local hasloop = ffi.new("bool[1]", 0)
				C.GetOrderQueueFirstLoopIdx(selectedcomponent, hasloop)
				if (selectedcomponent ~= C.GetPlayerOccupiedShipID()) and GetComponentData(selectedcomponent, "assignedpilot") and ((not hasloop[0]) or menu.orderdefbyid["Attack"].loopable) then
					if GetComponentData(selectedcomponent, "isplayerowned") then
						menu.orderAttackMultiple(selectedcomponent, menu.modeparam[1], components, menu.modeparam[2])
					end
				end
			end
			menu.mode = nil
			menu.modeparam = {}
			menu.removeMouseCursorOverride(3)
			menu.refreshInfoFrame()
		elseif menu.mode == "orderparam_selectplayerdeployables" then
			for i = #components, 1, -1 do
				local component = ConvertStringTo64Bit(tostring(components[i]))
				if not GetComponentData(component, "isdeployable") then
					table.remove(components, i)
				end
			end
			menu.orderCollectDeployables(menu.modeparam[1], components, menu.modeparam[2])
			menu.mode = nil
			menu.modeparam = {}
			menu.removeMouseCursorOverride(3)
			menu.refreshInfoFrame()
		else
			if #components > 0 then
				menu.addSelectedComponents(components, false)
			end
		end
	end
end

--[[
-- NOTE: When these functions are defined, regular MMB handling in the input system will be blocked
function menu.onRenderTargetMiddleMouseDown()
end

function menu.onRenderTargetMiddleMouseUp()
end
]]

function menu.onRenderTargetRightMouseDown()
	if (menu.mode ~= "boardingcontext") and (menu.contextMenuMode ~= "onlinemode") and (menu.contextMenuMode ~= "onlinereward") then
		menu.closeContextMenu()
	end
	menu.rightdown = { time = getElapsedTime(), position = table.pack(GetLocalMousePosition()) , dynpos = table.pack(GetLocalMousePosition()) }

	C.StartRotateMap(menu.holomap)
	menu.rotatingmap = true
	menu.noupdate = true
end

function menu.onRenderTargetRightMouseUp(modified)
	local offset = table.pack(GetLocalMousePosition())

	-- Check if the mouse was moved more than a distance of 5px
	if menu.rightdown and (not Helper.comparePositions(menu.rightdown.position, offset, 5)) and (not menu.rightdown.wasmoved) and (menu.mode ~= "boardingcontext") then
		if (menu.mode == "orderparam_position") then
			menu.resetOrderParamMode()
		elseif menu.mode == "selectbuildlocation" then
			if menu.plotData.active then
				C.ClearMapBuildPlot(menu.holomap)
				menu.plotData.active = nil
				SetMouseOverOverride(menu.map, nil)
			end
		elseif menu.mode == "orderparam_selectenemies" then
			menu.mode = nil
			menu.modeparam = {}
			menu.removeMouseCursorOverride(3)
		else
			local pickedcomponent = C.GetPickedMapComponent(menu.holomap)
			local pickedorder = ffi.new("Order")
			local isintermediate = ffi.new("bool[1]", 0)
			local pickedordercomponent = C.GetPickedMapOrder(menu.holomap, pickedorder, isintermediate)
			local pickedtradeoffer = C.GetPickedMapTradeOffer(menu.holomap)
			local pickedmissionoffer = C.GetPickedMapMissionOffer(menu.holomap)
			local pickedmission = C.GetPickedMapMission(menu.holomap)
			local pickedsyncpoint = C.GetPickedMapSyncPoint(menu.holomap)
			local pickedsyncpointorder = ffi.new("Order")
			local pickedsyncpointordercomponent = C.GetPickedMapSyncPointOwningOrder(menu.holomap, pickedsyncpointorder)
			local pickedintersectordefense = C.GetPickedMapInterSectorDefence(menu.holomap)

			local posrot = ffi.new("UIPosRot")
			local eclipticoffset = ffi.new("UIPosRot")
			local posrotcomponent = C.GetMapPositionOnEcliptic2(menu.holomap, posrot, false, 0, eclipticoffset)

			-- kuertee start: distance tool
			distanceTool_to_posRot = posrot
			distanceTool_to_component = posrotcomponent
    
    			Helper.distanceTool_distance = nil
			if distanceTool_from_component and distanceTool_from_posRot then
				local posFrom, sectorFrom, posTo, sectorTo
				if C.IsComponentClass (distanceTool_from_component, "sector") then
					posFrom = distanceTool_from_posRot
					sectorFrom = distanceTool_from_component
				else
					posFrom = C.GetObjectPositionInSector (distanceTool_from_component)
					sectorFrom = ConvertIDTo64Bit(GetComponentData(distanceTool_from_component, "sectorid"))
				end
				if C.IsComponentClass (distanceTool_to_component, "sector") then
					posTo = distanceTool_to_posRot
					sectorTo = distanceTool_to_component
				else
					posTo = C.GetObjectPositionInSector (distanceTool_to_component)
					sectorTo = ConvertIDTo64Bit(GetComponentData(distanceTool_to_component, "sectorid"))
				end
				if sectorFrom == sectorTo then
					local x_delta = math.abs (posTo.x - posFrom.x)
					local y_delta = math.abs (posTo.y - posFrom.y)
					local z_delta = math.abs (posTo.z - posFrom.z)
					Helper.distanceTool_distance = math.pow (math.pow (x_delta, 2) + math.pow (y_delta, 2) + math.pow (z_delta, 2), 0.5)
				end
			end
			distanceTool_from_posRot = distanceTool_to_posRot
			distanceTool_from_component = distanceTool_to_component
		    -- kuertee end

			local playerships, otherobjects, playerdeployables = menu.getSelectedComponentCategories()
			if pickedordercomponent ~= 0 then
				if GetComponentData(ConvertStringTo64Bit(tostring(pickedordercomponent)), "isplayerowned") then
					if menu.mode ~= nil then
						PlaySound("ui_menu_interact_btn_selectinvalid_core")
					else
						menu.interactMenuComponent = pickedcomponent
						Helper.openInteractMenu(menu, { component = pickedordercomponent, order = pickedorder, offsetcomponent = posrotcomponent, offset = posrot, playerships = playerships, otherobjects = otherobjects, playerdeployables = playerdeployables })
					end
				end
			elseif pickedsyncpoint ~= 0 then
				if menu.mode ~= nil then
					PlaySound("ui_menu_interact_btn_selectinvalid_core")
				else
					Helper.openInteractMenu(menu, { syncpoint = pickedsyncpoint, playerships = playerships, otherobjects = otherobjects, playerdeployables = playerdeployables })
				end
			elseif pickedsyncpointordercomponent ~= 0 then
				if menu.mode ~= nil then
					PlaySound("ui_menu_interact_btn_selectinvalid_core")
				else
					Helper.openInteractMenu(menu, { component = pickedsyncpointordercomponent, syncpointorder = pickedsyncpointorder, playerships = playerships, otherobjects = otherobjects, playerdeployables = playerdeployables })
				end
			elseif pickedintersectordefense.controllableid ~= 0 then
				if menu.mode ~= nil then
					PlaySound("ui_menu_interact_btn_selectinvalid_core")
				else
					Helper.openInteractMenu(menu, { component = pickedintersectordefense.controllableid, intersectordefencegroup = pickedintersectordefense.group, playerships = playerships, otherobjects = otherobjects, playerdeployables = playerdeployables })
				end
			elseif pickedmission ~= 0 then
				if menu.mode ~= nil then
					PlaySound("ui_menu_interact_btn_selectinvalid_core")
				else
					Helper.openInteractMenu(menu, { mission = ConvertStringTo64Bit(tostring(pickedmission)), playerships = playerships, otherobjects = otherobjects, playerdeployables = playerdeployables })
				end
			elseif pickedtradeoffer ~= 0 then
				if menu.mode == nil then
					local tradeid = ConvertStringToLuaID(tostring(pickedtradeoffer))
					local tradedata = GetTradeData(tradeid)

					local issingleloopship, selectedcomponent
					if menu.getNumSelectedComponents() == 1 then
						local component = next(menu.selectedcomponents)
						selectedcomponent = ConvertStringTo64Bit(component)
						local hasloop = ffi.new("bool[1]", 0)
						C.GetOrderQueueFirstLoopIdx(selectedcomponent, hasloop)
						issingleloopship = hasloop[0]
					end

					if issingleloopship then
						menu.contextMenuMode = "tradeloop"
						menu.contextMenuData = { component = ConvertIDTo64Bit(tradedata.station), currentShip = selectedcomponent, orders = {}, loop = tradedata.isbuyoffer and "SingleSell" or "SingleBuy", ware = tradedata.ware, reservecargo = true }

						local offsetx = offset[1] + Helper.viewWidth / 2
						local offsety = Helper.viewHeight / 2 - offset[2]

						menu.createContextFrame(config.tradeLoopWidth, nil, offsetx, offsety)
					else
						local tradesubscription = GetComponentData(tradedata.station, "tradesubscription")
						if tradesubscription and (tradedata.amount > 0) then
							menu.contextMenuMode = "trade"
							menu.contextMenuData = { component = ConvertIDTo64Bit(tradedata.station), orders = {}, tradeid = tradeid }

							local numwarerows, numinforows = menu.initTradeContextData()
							menu.updateTradeContextDimensions(numwarerows, numinforows)
							AddUITriggeredEvent(menu.name, "pickedtradeoffer", tradedata.isbuyoffer and "buyoffer" or "selloffer")

							local width = menu.tradeContext.width
							local height = menu.tradeContext.shipheight + menu.tradeContext.buttonheight + 1 * Helper.borderSize

							local offsetx = offset[1] + Helper.viewWidth / 2
							if offsetx + width > Helper.viewWidth - Helper.frameBorder then
								offsetx = Helper.viewWidth - width - Helper.frameBorder
							end
							local offsety = Helper.viewHeight / 2 - offset[2]
							if offsety + height > Helper.viewHeight - Helper.frameBorder then
								offsety = Helper.viewHeight - height - Helper.frameBorder
							end

							menu.createContextFrame(width, height, offsetx, offsety)
						else
							menu.interactMenuComponent = tradedata.station

							local missions = {}
							Helper.ffiVLA(missions, "MissionID", C.GetNumMapComponentMissions, C.GetMapComponentMissions, menu.holomap, ConvertIDTo64Bit(tradedata.station))

							local playerships, otherobjects, playerdeployables = menu.getSelectedComponentCategories()
							Helper.openInteractMenu(menu, { component = tradedata.station, offsetcomponent = posrotcomponent, offset = posrot, playerships = playerships, otherobjects = otherobjects, playerdeployables = playerdeployables, componentmissions = missions })
						end
					end
				else
					PlaySound("ui_menu_interact_btn_selectinvalid_core")
				end
			elseif pickedmissionoffer ~= 0 then
				if menu.mode == nil then
					menu.contextMenuMode = "mission"
					local width = Helper.scaleX(config.missionContextWidth)
					local height = menu.prepareMissionContextData(nil, tostring(pickedmissionoffer), width)

					local offsetx = offset[1] + Helper.viewWidth / 2
					local offsety = Helper.viewHeight / 2 - offset[2]

					if offsetx + width > Helper.viewWidth then
						offsetx = Helper.viewWidth - width - config.contextBorder
					end
					if offsety + height > Helper.viewHeight then
						offsety = Helper.viewHeight - height - config.contextBorder
					end

					menu.createContextFrame(width, height, offsetx, offsety)
					if menu.holomap ~= 0 then
						C.SetMapRenderMissionGuidance(menu.holomap, pickedmissionoffer)
					end
				else
					PlaySound("ui_menu_interact_btn_selectinvalid_core")
				end
			elseif pickedcomponent ~= 0 then
				local convertedComponent = ConvertStringTo64Bit(tostring(pickedcomponent))
				if modified ~= "ctrl" then
					if menu.mode == "hire" then
						if C.IsComponentClass(convertedComponent, "controllable") and (not C.IsComponentClass(convertedComponent, "spacesuit")) then
							local isplayerowned, isdock, isonlineobject = GetComponentData(convertedComponent, "isplayerowned", "isdock", "isonlineobject")
							if (isplayerowned or (isdock and C.IsComponentClass(convertedComponent, "station"))) and (not isonlineobject) then
								menu.contextMenuMode = "hire"
								menu.contextMenuData = { hireObject = convertedComponent, xoffset = offset[1] + Helper.viewWidth / 2, yoffset = Helper.viewHeight / 2 - offset[2] }

								local width = Helper.scaleX(config.hireContextWidth)
								if menu.contextMenuData.xoffset + width > Helper.viewWidth then
									menu.contextMenuData.xoffset = Helper.viewWidth - width - Helper.frameBorder
								end

								menu.createContextFrame(width, nil, menu.contextMenuData.xoffset, menu.contextMenuData.yoffset)
							end
						end
					elseif menu.mode == "selectCV" then
						if C.IsComponentClass(pickedcomponent, "ship") and GetComponentData(convertedComponent, "primarypurpose") == "build" then
							menu.contextMenuData = { component = convertedComponent, xoffset = offset[1] + Helper.viewWidth / 2, yoffset = Helper.viewHeight / 2 - offset[2] }
							menu.contextMenuMode = "select"
							menu.createContextFrame(menu.selectWidth)
						end
					elseif menu.mode == "orderparam_object" then
						if menu.checkForOrderParamObject(convertedComponent) then
							menu.contextMenuData = { component = convertedComponent, xoffset = offset[1] + Helper.viewWidth / 2, yoffset = Helper.viewHeight / 2 - offset[2]  }
							menu.contextMenuMode = "select"
							menu.createContextFrame(menu.selectWidth)
						end
					elseif menu.mode == "selectComponent" then
						if menu.checkForSelectComponent(pickedcomponent) then
							menu.contextMenuData = { component = convertedComponent, xoffset = offset[1] + Helper.viewWidth / 2, yoffset = Helper.viewHeight / 2 - offset[2] }
							menu.contextMenuMode = "select"
							menu.createContextFrame(menu.selectWidth)
						end
					else
						menu.interactMenuComponent = pickedcomponent

						local missions = {}
						Helper.ffiVLA(missions, "MissionID", C.GetNumMapComponentMissions, C.GetMapComponentMissions, menu.holomap, pickedcomponent)

						local playerships, otherobjects, playerdeployables = menu.getSelectedComponentCategories()
						Helper.openInteractMenu(menu, { component = pickedcomponent, offsetcomponent = posrotcomponent, offset = posrot, playerships = playerships, otherobjects = otherobjects, playerdeployables = playerdeployables, componentmissions = missions })
					end
				else
					local offsetx = offset[1] + Helper.viewWidth / 2
					local offsety = Helper.viewHeight / 2 - offset[2]

					menu.defaultInteraction(pickedcomponent, posrot, posrotcomponent ~= 0, offsetx, offsety)
				end
			end
		end
	end
	menu.rightdown = nil
	if menu.rotatingmap then
		C.StopRotateMap(menu.holomap)
		menu.noupdate = false
		if menu.sound_rotatemap and menu.sound_rotatemap.sound then
			StopPlayingSound(menu.sound_rotatemap.sound)
			menu.sound_rotatemap = nil
		end
		menu.rotatingmap = nil
		if menu.infoTableMode == "objectlist" then
			menu.refreshInfoFrame()
		end
	end
end

function menu.prepareMissionContextData(missionid, missionofferid, width)
	if missionid then
		local missionid64 = ConvertStringTo64Bit(missionid)
		local missiondetails = C.GetMissionIDDetails(missionid64)
		local onlineinfo = C.GetMissionOnlineInfo(missionid64)
		local onlinechapter, onlineid = ffi.string(onlineinfo.chapter), ffi.string(onlineinfo.onlineid)
		menu.contextMenuData = {
			isoffer = false,
			missionid = missionid64,
			name = ffi.string(missiondetails.missionName),
			rawdescription = ffi.string(missiondetails.missionDescription),
			difficulty = missiondetails.difficulty,
			rewardmoney = tonumber(missiondetails.reward) / 100,
			rewardtext = ffi.string(missiondetails.rewardText),
			activebriefingstep = missiondetails.activeBriefingStep,
			briefingmissions = {},
			timeout = (missiondetails.timeLeft and missiondetails.timeLeft > -1) and missiondetails.timeLeft or (missiondetails.duration or -1),
			abortable = missiondetails.abortable,
			offeractor = nil,
			expired = false,
			threadtype = ffi.string(missiondetails.threadType),
			threadMissionID = ConvertStringTo64Bit(tostring(missiondetails.threadMissionID)),
			type = ffi.string(missiondetails.mainType),
			subtype = ffi.string(missiondetails.subType),
			onlinechapter = onlinechapter,
			onlineID = onlineid
		}
		if menu.contextMenuData.threadtype == "" then
			local objectivedata = C.GetMissionIDObjective2(missionid64)
			menu.contextMenuData.objectiveText = ffi.string(objectivedata.objectiveText)
			menu.contextMenuData.progressname = ffi.string(objectivedata.progressname)
			menu.contextMenuData.curProgress = objectivedata.curProgress
			menu.contextMenuData.maxProgress = objectivedata.maxProgress
		end

		local briefingicon = C.GetMissionBriefingIcon(missionid64)
		if ffi.string(briefingicon.icon) ~= "" then
			menu.contextMenuData.briefingicon = ffi.string(briefingicon.icon)
			menu.contextMenuData.briefingiconcaption = ffi.string(briefingicon.caption)
			menu.contextMenuData.briefingiconwidth = math.floor(config.missionContextIconWidthFactor * width)
		end

		menu.contextMenuData.briefingobjectives = {}
		for i = 1, tonumber(missiondetails.numBriefingObjectives) do
			local objective = C.GetMissionObjectiveStep3(missionid64, i)
			table.insert(menu.contextMenuData.briefingobjectives, { step = objective.step, text = ffi.string(objective.text), failed = objective.failed, completedoutofsequence = objective.completedoutofsequence })
		end
		menu.contextMenuData.subMissions = {}
		local buf = {}
		Helper.ffiVLA(buf, "MissionID", C.GetNumMissionThreadSubMissions, C.GetMissionThreadSubMissions, missionid64)
		for _, submission in ipairs(buf) do
			local submissionEntry = menu.getMissionIDInfoHelper(submission)
			table.insert(menu.contextMenuData.subMissions, submissionEntry)
		end

		menu.contextMenuData.deliveryWares = {}
		local n = C.GetNumMissionDeliveryWares(missionid64)
		if n > 0 then
			local buf = ffi.new("MissionWareDeliveryInfo[1]")
			buf[0].numwares = n
			buf[0].wares = Helper.ffiNewHelper("UIWareAmount[?]", n)
			C.GetMissionDeliveryWares(buf, missionid64)
			menu.contextMenuData.deliveryWares.target = buf[0].target
			for i = 0, buf[0].numwares - 1 do
				table.insert(menu.contextMenuData.deliveryWares, { ware = ffi.string(buf[0].wares[i].wareid), amount = buf[0].wares[i].amount })
			end
		end

		local descriptionwidth = width
		if menu.contextMenuData.briefingicon then
			descriptionwidth = descriptionwidth - menu.contextMenuData.briefingiconwidth - Helper.borderSize
		end
		descriptionwidth = descriptionwidth - 2 * Helper.scaleX(Helper.standardTextOffsetx)
		menu.contextMenuData.description = GetTextLines(menu.contextMenuData.rawdescription, Helper.standardFont, Helper.scaleFont(Helper.standardFont, Helper.standardFontSize), descriptionwidth)
		menu.contextMenuData.descriptionWidth = descriptionwidth

		local faction = ffi.string(missiondetails.faction)
		if faction ~= "" then
			local factionDetails = C.GetFactionDetails(faction)
			local factionName = ffi.string(factionDetails.factionName)
			if factionName ~= "" then
				menu.contextMenuData.factionName = factionName
			end
		end
	elseif missionofferid then
		local missionofferid64 = ConvertStringTo64Bit(missionofferid)
		local name, description, difficulty, threadtype, maintype, subtype, subtypename, faction, rewardmoney, rewardtext, briefingobjectives, activebriefingstep, briefingmissions, oppfaction, licence, missiontime, duration, abortable, guidancedisabled, associatedcomponent, alertLevel, offeractor, offercomponent = GetMissionOfferDetails(ConvertStringToLuaID(missionofferid))
		local onlineinfo = C.GetMissionOnlineInfo(missionofferid64)
		local onlinechapter, onlineid = ffi.string(onlineinfo.chapter), ffi.string(onlineinfo.onlineid)
		menu.contextMenuData = {
			isoffer = true,
			missionid = missionofferid64,
			name = name,
			rawdescription = description,
			difficulty = difficulty,
			rewardmoney = rewardmoney,
			rewardtext = rewardtext,
			briefingobjectives = briefingobjectives,
			activebriefingstep = activebriefingstep,
			briefingmissions = briefingmissions,
			timeout = duration or -1,
			abortable = nil,
			offeractor = offeractor,
			expired = false,
			threadtype = threadtype,
			subMissions = {},
			type = maintype,
			subtype = subtype,
			onlinechapter = onlinechapter,
			onlineID = onlineid,
		}
		local briefingicon = C.GetMissionBriefingIcon(missionofferid64)
		if ffi.string(briefingicon.icon) ~= "" then
			menu.contextMenuData.briefingicon = ffi.string(briefingicon.icon)
			menu.contextMenuData.briefingiconcaption = ffi.string(briefingicon.caption)
			menu.contextMenuData.briefingiconwidth = math.floor(config.missionContextIconWidthFactor * width)
		end

		menu.contextMenuData.deliveryWares = {}
		local n = C.GetNumMissionDeliveryWares(missionofferid64)
		if n > 0 then
			local buf = ffi.new("MissionWareDeliveryInfo[1]")
			buf[0].numwares = n
			buf[0].wares = Helper.ffiNewHelper("UIWareAmount[?]", n)
			C.GetMissionDeliveryWares(buf, missionofferid64)
			menu.contextMenuData.deliveryWares.target = buf[0].target
			for i = 0, buf[0].numwares - 1 do
				table.insert(menu.contextMenuData.deliveryWares, { ware = ffi.string(buf[0].wares[i].wareid), amount = buf[0].wares[i].amount })
			end
		end

		local descriptionwidth = width
		if menu.contextMenuData.briefingicon then
			descriptionwidth = descriptionwidth - menu.contextMenuData.briefingiconwidth - Helper.borderSize
		end
		descriptionwidth = descriptionwidth - 2 * Helper.scaleX(Helper.standardTextOffsetx)
		menu.contextMenuData.description = GetTextLines(menu.contextMenuData.rawdescription, Helper.standardFont, Helper.scaleFont(Helper.standardFont, Helper.standardFontSize), descriptionwidth)
		menu.contextMenuData.descriptionWidth = descriptionwidth

		if faction then
			local factionDetails = C.GetFactionDetails(faction)
			local factionName = ffi.string(factionDetails.factionName)
			if factionName ~= "" then
				menu.contextMenuData.factionName = factionName
			end
		end
	end
	if menu.contextMenuData and menu.contextMenuData.briefingobjectives then
		for i, entry in ipairs(menu.contextMenuData.briefingobjectives) do
			local mode, object
			local library, item, item2 = GetMissionObjectiveEncyclopediaReference(menu.contextMenuData.missionid, i)
			local known = true
			if library then
				if library == "Galaxy" then
					mode = library
					object = item
					known = C.IsKnownToPlayer(ConvertIDTo64Bit(object))
				elseif library == "Blueprints" then
					mode = library
					library = item
					item = item2

					local macro = GetWareData(item2, "component")
					local macrolibrary = GetMacroData(macro, "infolibrary")
					AddKnownItem(macrolibrary, macro)
				else
					AddKnownItem(library, item)
				end
				entry.encyclopedia = { mode = mode, library = library, id = item, object = object, known = known }
			end
		end
	end

	local textHeight = math.ceil(C.GetTextHeight(" ", Helper.standardFont, Helper.scaleFont(Helper.standardFont, Helper.standardFontSize), 0))

	local descriptionminwidth = width - Helper.scrollbarWidth
	if menu.contextMenuData.briefingicon then
		descriptionminwidth = descriptionminwidth - menu.contextMenuData.briefingiconwidth - Helper.borderSize
	end
	descriptionminwidth = descriptionminwidth - 2 * Helper.scaleX(Helper.standardTextOffsetx)

	-- restrict number of visible lines for both description table and objectives table - if there are more lines, we need a scrollbar
	menu.contextMenuData.descriptionLines = #menu.contextMenuData.description
	local maxdescriptionlines = 10
	local briefingiconheight = 0
	if menu.contextMenuData.briefingicon then
		local iconwidth = menu.contextMenuData.briefingiconwidth
		local captionheight = math.ceil(C.GetTextHeight(menu.contextMenuData.briefingiconcaption, Helper.standardFont, Helper.scaleFont(Helper.standardFont, Helper.standardFontSize), iconwidth - 2 * Helper.scaleX(Helper.standardTextOffsetx)))
		-- cap the captionheight at 5 lines
		if captionheight > 5 * (textHeight + Helper.borderSize) then
			local lines = GetTextLines(menu.contextMenuData.briefingiconcaption, Helper.standardFont, Helper.scaleFont(Helper.standardFont, Helper.standardFontSize), iconwidth - 2 * Helper.scaleX(Helper.standardTextOffsetx))
			menu.contextMenuData.briefingiconcaption = ""
			for i = 1, 5 do
				if i > 1 then
					menu.contextMenuData.briefingiconcaption = menu.contextMenuData.briefingiconcaption .. " "
				end
				menu.contextMenuData.briefingiconcaption = menu.contextMenuData.briefingiconcaption .. lines[i]
			end
			menu.contextMenuData.briefingiconcaption = utf8.sub(menu.contextMenuData.briefingiconcaption, 1, -3) .. "..."
			captionheight = math.ceil(C.GetTextHeight(menu.contextMenuData.briefingiconcaption, Helper.standardFont, Helper.scaleFont(Helper.standardFont, Helper.standardFontSize), iconwidth - 2 * Helper.scaleX(Helper.standardTextOffsetx)))
		end

		briefingiconheight = iconwidth + captionheight + Helper.borderSize
		maxdescriptionlines = math.ceil(1.5 * briefingiconheight / (textHeight + Helper.borderSize))
	end
	if menu.contextMenuData.descriptionLines > maxdescriptionlines then
		menu.contextMenuData.description = GetTextLines(menu.contextMenuData.rawdescription, Helper.standardFont, Helper.scaleFont(Helper.standardFont, Helper.standardFontSize), descriptionminwidth)
		menu.contextMenuData.descriptionLines = maxdescriptionlines
		menu.contextMenuData.descriptionWidth = descriptionminwidth
	end

	if menu.contextMenuData.threadtype ~= "" then
		if menu.contextMenuData.isoffer then
			menu.contextMenuData.objectiveLines = math.max(#menu.contextMenuData.briefingmissions, 1)
		else
			menu.contextMenuData.objectiveLines = math.max(#menu.contextMenuData.subMissions, 1)
		end
	else
		menu.contextMenuData.objectiveLines = math.max(#menu.contextMenuData.briefingobjectives, 1)
	end

	local minwidth = width - Helper.scrollbarWidth
	menu.contextMenuData.objectiveWidth = width
	if menu.contextMenuData.objectiveLines > 10 then
		menu.contextMenuData.objectiveLines = 10
		menu.contextMenuData.objectiveWidth = minwidth
	end
	menu.contextMenuData.bottomLines = 3 + (menu.contextMenuData.factionName and 1 or 0) + ((menu.contextMenuData.difficulty ~= 0) and 1 or 0) + (menu.contextMenuData.isoffer and 0 or 1)

	local tablespacing = Helper.standardTextHeight
	local headerHeight = Helper.scaleY(Helper.headerRow1Offsety) + Helper.scaleY(Helper.headerRow1Height - Helper.headerRow1Offsety)
	menu.contextMenuData.descriptionYOffset = Helper.borderSize
	menu.contextMenuData.descriptionHeight = headerHeight + math.max(menu.contextMenuData.descriptionLines * (textHeight + Helper.borderSize), briefingiconheight)
	menu.contextMenuData.objectiveYOffset = menu.contextMenuData.descriptionYOffset + menu.contextMenuData.descriptionHeight + tablespacing
	menu.contextMenuData.objectiveHeight = headerHeight + menu.contextMenuData.objectiveLines * (textHeight + Helper.borderSize)
	menu.contextMenuData.bottomYOffset = menu.contextMenuData.objectiveYOffset + menu.contextMenuData.objectiveHeight + tablespacing
	menu.contextMenuData.bottomHeight = menu.contextMenuData.bottomLines * (textHeight + Helper.borderSize)

	return menu.contextMenuData.bottomYOffset + menu.contextMenuData.bottomHeight + Helper.borderSize
end

function menu.showMissionContext(missionid, isoffer)
	menu.contextMenuMode = "mission"
	local width = Helper.scaleX(config.missionContextWidth)
	local height
	if ((not menu.showMultiverse) and (menu.infoTableMode == "mission")) or (isoffer == false) then
		height = menu.prepareMissionContextData(missionid, nil, width)
	else
		height = menu.prepareMissionContextData(nil, missionid, width)
	end

	local offsetx = menu.infoTableOffsetX + menu.infoTableWidth + Helper.borderSize + config.contextBorder
	local offsety = menu.infoTableOffsetY

	menu.createContextFrame(width, height, offsetx, offsety)
	if menu.holomap ~= 0 then
		C.SetMapRenderMissionGuidance(menu.holomap, ConvertStringTo64Bit(missionid))
	end
end

function menu.getSelectedComponentCategories()
	local playerships, otherobjects, playerdeployables = {}, {}, {}, {}

	for id, _ in pairs(menu.selectedcomponents) do
		local selectedcomponent = ConvertStringTo64Bit(id)
		local isplayerowned, isdeployable = GetComponentData(selectedcomponent, "isplayerowned", "isdeployable")
		if isdeployable then
			if isplayerowned then
				table.insert(playerdeployables, selectedcomponent)
			end
		elseif C.IsComponentClass(selectedcomponent, "ship") then
			if isplayerowned then
				table.insert(playerships, selectedcomponent)
			else
				table.insert(otherobjects, selectedcomponent)
			end
		elseif C.IsRealComponentClass(selectedcomponent, "station") or C.IsRealComponentClass(selectedcomponent, "ship") then
			table.insert(otherobjects, selectedcomponent)
		end
	end

	return playerships, otherobjects, playerdeployables
end

function menu.onRenderTargetCombinedScrollDown(step)
	local curtime = getElapsedTime()
	C.ZoomMap(menu.holomap, step)
	if not menu.lastzoom or menu.lastzoom.dir ~= "out" or menu.lastzoom.time + 1.0 < curtime then
		menu.lastzoom = { time = curtime, dir = "out" }
	end
end

function menu.onRenderTargetCombinedScrollUp(step)
	local curtime = getElapsedTime()
	C.ZoomMap(menu.holomap, -step)
	if not menu.lastzoom or menu.lastzoom.dir ~= "in" or menu.lastzoom.time + 1.0 < curtime then
		menu.lastzoom = { time = curtime, dir = "in" }
	end
end

-- button mouse helper

function menu.onButtonOverSound(uitable, row, col, button, input)
	if not menu.sound_selectedelement or button ~= menu.sound_selectedelement then
		if input == "mouse" then
			if (not menu.sound_buttonOverLock) then
				PlaySound((uitable == menu.sideBar) and "ui_positive_hover_side" or "ui_positive_hover_normal")
				menu.sound_buttonOverLock = true
			end
		end
	end
	menu.sound_selectedelement = button
end

function menu.onButtonDown()
	menu.noupdate = true
	PlaySound("ui_positive_click")
end

function menu.onButtonUp()
	menu.noupdate = false
	--PlaySound("ui_positive_click")
end

-- table mouse input helper
function menu.onTableMouseOut(uitable, row)
	if menu.currentMouseOverTable and (uitable == menu.currentMouseOverTable) then
		menu.currentMouseOverTable = nil
		if menu.holomap ~= 0 then
			menu.picking = true
		end
	end
end

function menu.onTableMouseOver(uitable, row)
	menu.currentMouseOverTable = uitable
	if menu.holomap ~= 0 then
		menu.picking = false
	end
end

function menu.onTableScrollBarDown()
	menu.noupdate = true
	PlaySound("ui_sbar_table_down")
end

function menu.onTableScrollBarUp()
	menu.noupdate = false
end

function menu.onEditboxRightMouseClick()
	if (menu.mode == "orderparam_position") then
		menu.resetOrderParamMode()
	end
end

function menu.onTableRightMouseClick(uitable, row, posx, posy)
	-- start Forleyor_infoCenter Callback:
	if callbacks ["ic_onTableRightMouseClick"] then
		for _, callback in ipairs (callbacks ["ic_onTableRightMouseClick"]) do
			callback (uitable, row, posx, posy)
		end
	end
	-- end Forleyor_infoCenter:

	if (menu.mode == "orderparam_position") then
		menu.resetOrderParamMode()
	else
		if row > (menu.numFixedRows or 0) then
			local rowdata = menu.rowDataMap[uitable] and menu.rowDataMap[uitable][row]
			if not menu.showMultiverse then

				-- kuertee start:
				-- if (menu.infoTableMode == "objectlist") or (menu.infoTableMode == "propertyowned") then
				if (string.find ("" .. tostring (menu.infoTableMode), "objectlist")) or (string.find ("" .. tostring (menu.infoTableMode), "propertyowned")) then
					-- kuertee end:

					if uitable == menu.infoTable then
						if type(rowdata) == "table" then
							local convertedRowComponent = ConvertIDTo64Bit(rowdata[2])
							if convertedRowComponent and (convertedRowComponent ~= 0) then
								local x, y = GetLocalMousePosition()
								if x == nil then
									-- gamepad case
									if posx ~= nil then
										x = posx + Helper.viewWidth / 2
										y = posy + Helper.viewHeight / 2
									end
								else
									x = x + Helper.viewWidth / 2
									y = Helper.viewHeight / 2 - y
								end

								if menu.mode == "hire" then
									local isplayerowned, isonlineobject = GetComponentData(convertedRowComponent, "isplayerowned", "isonlineobject")
									if isplayerowned and C.IsComponentClass(convertedRowComponent, "controllable") and (not C.IsComponentClass(convertedRowComponent, "spacesuit")) and (not isonlineobject) then
										menu.contextMenuMode = "hire"
										menu.contextMenuData = { hireObject = convertedRowComponent, xoffset = x, yoffset = y }

										local width = Helper.scaleX(config.hireContextWidth)
										if menu.contextMenuData.xoffset + width > Helper.viewWidth then
											menu.contextMenuData.xoffset = Helper.viewWidth - width - Helper.frameBorder
										end

										menu.createContextFrame(width, nil, menu.contextMenuData.xoffset, menu.contextMenuData.yoffset)
									end
								elseif menu.mode == "selectCV" then
									menu.contextMenuData = { component = convertedRowComponent, xoffset = x, yoffset = y }
									menu.contextMenuMode = "select"
									menu.createContextFrame(menu.selectWidth)
								elseif menu.mode == "orderparam_object" then
									if menu.checkForOrderParamObject(convertedRowComponent) then
										menu.contextMenuData = { component = convertedRowComponent, xoffset = x, yoffset = y }
										menu.contextMenuMode = "select"
										menu.createContextFrame(menu.selectWidth)
									end
								elseif menu.mode == "selectComponent" then
									if menu.checkForSelectComponent(convertedRowComponent) then
										menu.contextMenuData = { component = convertedRowComponent, xoffset = x, yoffset = y }
										menu.contextMenuMode = "select"
										menu.createContextFrame(menu.selectWidth)
									end
								else
									local missions = {}
									Helper.ffiVLA(missions, "MissionID", C.GetNumMapComponentMissions, C.GetMapComponentMissions, menu.holomap, convertedRowComponent)

									local playerships, otherobjects, playerdeployables = menu.getSelectedComponentCategories()
									if rowdata[1] == "construction" then
										menu.interactMenuComponent = convertedRowComponent
										Helper.openInteractMenu(menu, { component = convertedRowComponent, playerships = playerships, otherobjects = otherobjects, playerdeployables = playerdeployables, mouseX = posx, mouseY = posy, construction = rowdata[3], componentmissions = missions })
									elseif string.find(rowdata[1], "subordinates") then
										menu.interactMenuComponent = convertedRowComponent
										Helper.openInteractMenu(menu, { component = convertedRowComponent, playerships = playerships, otherobjects = otherobjects, playerdeployables = playerdeployables, mouseX = posx, mouseY = posy, subordinategroup = rowdata[3], componentmissions = missions })
									else
										menu.interactMenuComponent = convertedRowComponent
										Helper.openInteractMenu(menu, { component = convertedRowComponent, playerships = playerships, otherobjects = otherobjects, playerdeployables = playerdeployables, mouseX = posx, mouseY = posy, componentmissions = missions })
									end
								end
							end
						end
					end
				elseif menu.infoTableMode == "info" then
					if uitable == menu.infoTable then
						menu.prepareInfoContext(rowdata, "left")
					end
				elseif menu.infoTableMode == "missionoffer" then
					if uitable == menu.infoTable then
						if type(rowdata) == "table" then
							menu.closeContextMenu()

							local missionid = ConvertStringTo64Bit(rowdata[1])
							local playerships, otherobjects, playerdeployables = menu.getSelectedComponentCategories()
							Helper.openInteractMenu(menu, { missionoffer = missionid, playerships = playerships, otherobjects = otherobjects, playerdeployables = playerdeployables })
						end
					end
				elseif menu.infoTableMode == "mission" then
					if uitable == menu.infoTable then
						if type(rowdata) == "table" then
							menu.closeContextMenu()

							local missionid = ConvertStringTo64Bit(rowdata[1])
							local playerships, otherobjects, playerdeployables = menu.getSelectedComponentCategories()
							Helper.openInteractMenu(menu, { mission = missionid, playerships = playerships, otherobjects = otherobjects, playerdeployables = playerdeployables })
						end
					end
				end

			else
				if menu.ventureMode == "ventureseason" then
					if menu.seasonMode.left == "ventureteam" then
						if uitable == menu.infoTable then
							if type(rowdata) == "table" then
								if not rowdata.isplayer then
									menu.closeContextMenu()

									local x, y = GetLocalMousePosition()

									menu.contextMenuMode = "ventureteammembercontext"
									menu.contextMenuData = { teammember = rowdata, xoffset = x + Helper.viewWidth / 2, yoffset = Helper.viewHeight / 2 - y }

									local width = Helper.scaleX(config.ventureTeamContextWidth)
									if menu.contextMenuData.xoffset + width > Helper.viewWidth then
										menu.contextMenuData.xoffset = Helper.viewWidth - width - Helper.frameBorder
									end

									menu.createContextFrame(width, nil, menu.contextMenuData.xoffset, menu.contextMenuData.yoffset)
								end
							end
						end
					end
				elseif menu.ventureMode == "venturecontacts" then
					if uitable == menu.infoTable then
						if type(rowdata) == "table" then
							menu.closeContextMenu()

							local x, y = GetLocalMousePosition()

							menu.contextMenuMode = "venturecontactcontext"
							menu.contextMenuData = { contact = rowdata, xoffset = x + Helper.viewWidth / 2, yoffset = Helper.viewHeight / 2 - y }

							local width = Helper.scaleX(config.ventureContactContextWidth)
							if menu.contextMenuData.xoffset + width > Helper.viewWidth then
								menu.contextMenuData.xoffset = Helper.viewWidth - width - Helper.frameBorder
							end

							menu.createContextFrame(width, nil, menu.contextMenuData.xoffset, menu.contextMenuData.yoffset)
						end
					end
				end
			end

			if menu.searchTableMode == "info" then
				if uitable == menu.infoTableRight then
					menu.prepareInfoContext(rowdata, "right")
				end
			end
		else
			menu.closeContextMenu()
		end
	end
end

function menu.prepareInfoContext(rowdata, instance)
	-- controllable: rowdata[3], actor: rowdata[2]
	-- actor may be a member of a ship's crew (person) or a ship's pilot, depending on rowdata[1]. actor should never be the player.
	if (type(rowdata) == "table") and (type(rowdata[3]) == "number") and C.IsComponentClass(rowdata[3], "controllable") then
		local controllable = rowdata[3]
		local person, entity, inv_ware, weaponmacro, equipmentmacro, software
		local isplayerowned, assignedpilot, assignedaipilot, tradenpc, shiptrader, individualtrainee = GetComponentData(rowdata[3], "isplayerowned", "assignedpilot", "assignedaipilot", "tradenpc", "shiptrader", "individualtrainee")
		if rowdata[1] == "info_crewperson" then
			if isplayerowned and C.IsPerson(rowdata[2], controllable) then
				person = rowdata[2]
			end
		elseif rowdata[1] == "info_crewnpc" then
			if GetComponentData(rowdata[2], "isplayerowned") then
				entity = rowdata[2]
			end
		elseif (rowdata[1] == "info_manager") or (rowdata[1] == "info_pilot") or (rowdata[1] == "info_shiptrader") or (rowdata[1] == "info_individualtrainee") then
			if isplayerowned or C.CanPlayerCommTarget(rowdata[2]) then
				-- ship captain
				if C.IsComponentClass(controllable, "ship") and ((ConvertStringTo64Bit(tostring(assignedpilot)) == rowdata[2]) or (ConvertStringTo64Bit(tostring(assignedaipilot)) == rowdata[2])) then
					entity = rowdata[2]
				-- station manager or shiptrader
				elseif C.IsComponentClass(controllable, "station") and ((ConvertStringTo64Bit(tostring(tradenpc)) == rowdata[2]) or (ConvertStringTo64Bit(tostring(shiptrader)) == rowdata[2]) or (ConvertStringTo64Bit(tostring(individualtrainee)) == rowdata[2])) then
					entity = rowdata[2]
				end
			end
		elseif rowdata[1] == "info_inventory" then
			inv_ware = rowdata[2]
		elseif rowdata[1] == "info_weapon" then
			weaponmacro = rowdata[2]
		elseif (rowdata[1] == "info_equipment") or (rowdata[1] == "info_deploy") then
			equipmentmacro = rowdata[2]
		elseif rowdata[1] == "info_software" then
			software = rowdata[2]
		end

		if person or entity or inv_ware or weaponmacro or equipmentmacro or software then
			--print("person: " .. ffi.string(C.GetPersonName(rowdata[2], rowdata[3])) .. ", combinedskill: " .. C.GetPersonCombinedSkill(rowdata[3], rowdata[2], nil, nil))
			local x, y = GetLocalMousePosition()
			menu.contextMenuData = { component = controllable, person = person, entity = entity, inv_ware = inv_ware, weaponmacro = weaponmacro, equipmentmacro = equipmentmacro, software = software, xoffset = x + Helper.viewWidth / 2, yoffset = Helper.viewHeight / 2 - y, instance = instance }
			menu.contextMenuMode = "info_context"
			menu.createContextFrame(menu.selectWidth)
		end
	end
end

function menu.onButtonRightMouseClick()
	if (menu.mode == "orderparam_position") then
		menu.resetOrderParamMode()
	end
end

function menu.onInteractiveElementChanged(element)
	menu.lastactivetable = element
end

-- close menu handler
function menu.onCloseElement(dueToClose, layer)
	PlaySound("ui_negative_back")
	if (menu.contextMenuMode == "onlinemode") or ((menu.contextMenuMode == "onlinereward") and (not menu.contextMenuData.allowClose)) then
		Helper.closeMenu(menu, dueToClose)
		menu.cleanup()
		return
	end

	if menu.closeContextMenu(dueToClose) then
		return
	end

	if (menu.mode == "orderparam_object") or (menu.mode == "orderparam_position") then
		menu.resetOrderParamMode()
		return
	end

	if (menu.mode ~= "hire") and (not menu.minimized) and (dueToClose == "back") then
		if menu.showMultiverse then
			if menu.ventureMode then
				menu.deactivateObjectList()
				return
			end
		else
			if menu.infoTableMode then
				menu.deactivateObjectList()
				return
			end
		end
	end

	if (layer == nil) or (layer == config.mainFrameLayer) or (layer == config.infoFrameLayer) or (layer == config.infoFrameLayer2) then
		if dueToClose == "minimize" then
			if not menu.minimized then
				menu.closeContextMenu()
				Helper.minimizeMenu(menu, ReadText(1001, 3245))
			else
				Helper.restoreMenu(menu)
			end
		else
			Helper.closeMenu(menu, dueToClose)
			menu.cleanup()
		end
	elseif layer == config.contextFrameLayer then
		Helper.clearFrame(menu, layer)
	end
end

-- helper functions

function menu.initPlotList()
	if not menu.plots then
		menu.plots = {}
	end

	local playerobjects = GetContainedStationsByOwner("player", nil, true)
	for _, object in ipairs(playerobjects) do
		--print(GetComponentData(object, "name") .. " " .. tostring(object) .. " has " .. tostring(numstationmodules) .. " modules.")
		local object64 = ConvertIDTo64Bit(object)
		local sector64 = ConvertIDTo64Bit(GetComponentData(object, "sectorid"))
		local owner = GetComponentData(sector64, "owner")
		local inownedspace = (owner ~= "ownerless") and (owner ~= "xenon")
		local size = C.GetBuildPlotSize(object64)
		local boughtrawsize = C.GetPaidBuildPlotSize(object64)
		local paid = (not inownedspace) or (boughtrawsize.x > 0) or (boughtrawsize.y > 0) or (boughtrawsize.z > 0)
		local fullprice = tonumber(C.GetBuildPlotPrice(sector64, C.GetObjectPositionInSector(object64), size.x, size.y, size.z, "player"))
		local buf = ffi.new("bool[1]", 0)
		local plotpayment = tonumber(C.GetBuildPlotPayment(object64, buf))
		local haspositionchanged = buf[0]
		local fullypaid = ((not inownedspace) or ((boughtrawsize.x >= size.x) and (boughtrawsize.y >= size.y) and (boughtrawsize.z >= size.z))) and ((not haspositionchanged) or (plotpayment >= fullprice))

		local found = false
		for j, plot in ipairs(menu.plots) do
			if plot.station == object64 then
				found = true
				if plot.removed then
					table.remove(menu.plots, j)
				else
					plot.paid = paid
					plot.fullypaid = fullypaid
					plot.permanent = C.GetNumStationModules(object64, true, true) > 0
					-- plot.boughtrawcenteroffset is set at menu.buttonBuyPlot() when a plot is bought.
				end
				break
			end
		end
		if not found then
			table.insert(menu.plots, { station = object64, paid = paid, fullypaid = fullypaid, permanent = C.GetNumStationModules(object64, true, true) > 0, boughtrawcenteroffset = C.GetPaidBuildPlotCenterOffset(object64), removed = nil })
		end
	end
end

function menu.isInfoModeValidFor(object, mode)
	if object == nil or object == 0 then
		print(TraceBack())
	end
	local isonlineobject, isplayerowned, macro = GetComponentData(object, "isonlineobject", "isplayerowned", "macro")
	if isplayerowned and isonlineobject then
		return false
	end

	if (mode == "objectinfo") or (mode == "objectlogbook") then
		local isdatavault, islandmark = GetComponentData(object, "isdatavault", "islandmark")
		if	C.IsComponentClass(object, "ship") or
			C.IsRealComponentClass(object, "station") or
			C.IsComponentClass(object, "buildstorage") or
			C.IsComponentClass(object, "sector") or
			C.IsComponentClass(object, "gate") or
			C.IsComponentClass(object, "mine") or
			C.IsComponentClass(object, "navbeacon") or
			C.IsComponentClass(object, "resourceprobe") or
			C.IsComponentClass(object, "satellite") or
			C.IsComponentClass(object, "asteroid") or
			(C.IsComponentClass(object, "object") and (isdatavault or islandmark))
		then
			return true
		end
	elseif (mode == "objectcrew") or (mode == "objectloadout") then
		if C.IsRealComponentClass(object, "ship_xs") then
			return false
		elseif GetMacroData(macro, "islasertower") then
			return false
		elseif C.IsComponentClass(object, "ship") or C.IsComponentClass(object, "station") then
			return true
		end
	elseif mode == "orderqueue" then
		if isplayerowned and C.IsComponentClass(object, "ship") and (not C.IsUnit(object)) then
			return true
		end
	elseif mode == "standingorders" then
		if isplayerowned and (C.IsComponentClass(object, "ship") or C.IsComponentClass(object, "station")) and (not C.IsUnit(object)) then
			return true
		end
	elseif mode == "orderqueue_advanced" then
		if isplayerowned and C.IsComponentClass(object, "ship") and (not C.IsUnit(object)) then
			return true
		end
	else
		local text = ""
		for i, entry in ipairs(config.infoCategories) do
			if not entry.empty then
				if i == #config.infoCategories then
					text = text .. " and "
				elseif i > 1 then
					text = text .. ", "
				end
				text = text .. "'" .. entry.category .. "'"
			end
		end
		DebugError("menu.isInfoModeValidFor called with invalid mode: " .. tostring(mode) .. ". valid modes are " .. text)
	end

	return false
end

function menu.getNumDefendingCrew(objectid)
	local numdefendingcrew = 0
	local numpeople = C.GetNumAllRoles()
	local peopledata = ffi.new("PeopleInfo[?]", numpeople)
	numpeople = C.GetPeople2(peopledata, numpeople, objectid, true)
	local loccounter = 0
	for i = 0, numpeople - 1 do
		if ffi.string(peopledata[i].id) == "marine" or ffi.string(peopledata[i].id) == "service" then
			numdefendingcrew = numdefendingcrew + peopledata[i].amount
			loccounter = loccounter + 1
			if loccounter == 2 then
				loccounter = nil
				break
			end
		end
	end
	return numdefendingcrew
end

function menu.getNumOperationalTurrets(objectid, numtotalturrets)
	numoperationalturrets = 0
	for i = 1, numtotalturrets do
		local currentcomponent = ConvertStringTo64Bit(tostring(C.GetUpgradeSlotCurrentComponent(objectid, "turret", i)))
		if currentcomponent and currentcomponent ~= 0 and IsComponentOperational(currentcomponent) then
			numoperationalturrets = numoperationalturrets + 1
		end
	end
	return numoperationalturrets
end

function menu.infoChangeObjectName(objectid, text, textchanged)
	if textchanged then
		SetComponentName(objectid, text)
	end

	-- [UniTrader's Advanced Renaming] Forleyor start: callback
	if callbacks ["utRenaming_infoChangeObjectName"] then
		for _, callback in ipairs (callbacks ["utRenaming_infoChangeObjectName"]) do
			callback (objectid, text, textchanged)
		end
	end
	-- [UniTrader's Advanced Renaming] Forleyor end: callback

	menu.noupdate = false
	menu.refreshInfoFrame()
end

function menu.infoCombineLoadoutComponents(components)
	local locmacros = {}
	for _, val in ipairs(components) do
		local val64 = ConvertStringTo64Bit(tostring(val))
		local locmacro, hullpercent, shieldpercent, hull, shield = GetComponentData(val64, "macro", "hullpercent", "shieldpercent")
		local isoperational = IsComponentOperational(val64)
		local isconstruction = IsComponentConstruction(val64)
		if not locmacros[locmacro] then
			if isoperational then
				locmacros[locmacro] = { count = 1, hullpercent = hullpercent, shieldpercent = shieldpercent, construction = 0, wreck = 0 }
			elseif isconstruction then
				locmacros[locmacro] = { count = 0, hullpercent = 0, shieldpercent = 0, construction = 1, wreck = 0 }
			else
				locmacros[locmacro] = { count = 0, hullpercent = 0, shieldpercent = 0, construction = 0, wreck = 1 }
			end
		else
			if isoperational then
				locmacros[locmacro].count = locmacros[locmacro].count + 1
				locmacros[locmacro].hullpercent = locmacros[locmacro].hullpercent + hullpercent
				locmacros[locmacro].shieldpercent = locmacros[locmacro].shieldpercent + shieldpercent
			elseif isconstruction then
				locmacros[locmacro].construction = locmacros[locmacro].construction + 1
			else
				locmacros[locmacro].wreck = locmacros[locmacro].wreck + 1
			end
		end
	end
	return locmacros
end

function menu.infoSetWeaponGroup(objectid, weaponid, primary, group, active)
	--print("setting weapon " .. ffi.string(C.GetComponentName(weaponid)) .. " of object " .. ffi.string(C.GetComponentName(objectid)) .. " for group " .. tostring(group) .. " of set primary? " .. tostring(primary) .. " to " .. tostring(active))
	C.SetWeaponGroup(objectid, weaponid, primary, group, active)
	menu.refreshInfoFrame()
end

function menu.infoWeaponGroupCheckBoxColor(objectid, groupidx, primary)
	return (C.GetDefensibleActiveWeaponGroup(objectid, primary) == groupidx) and Color["weapon_group_highlight"] or Color["checkbox_background_default"]
end

function menu.infoUpdatePeople()
	menu.updatePeopleInfo = menu.updatePeopleInfo or getElapsedTime()
end

function menu.refreshCrewInfo()
	local refreshinfoframe, refreshinfoframe2 = false, false
	if (menu.infoMode.left == "objectinfo") or (menu.infoMode.left == "objectcrew") then
		if menu.infoSubmenuObject and C.IsComponentClass(menu.infoSubmenuObject, "ship") then
			menu.infoSubmenuPrepareCrewInfo("left")
		end
		refreshinfoframe = true
	end
	if (menu.infoMode.right == "objectinfo") or (menu.infoMode.right == "objectcrew") then
		if menu.infoSubmenuObject and C.IsComponentClass(menu.infoSubmenuObject, "ship") then
			menu.infoSubmenuPrepareCrewInfo("right")
		end
		refreshinfoframe2 = true
	end

	if refreshinfoframe then
		menu.refreshInfoFrame()
		-- menu.refreshInfoFrame() already triggers menu.refreshInfoFrame2()
	elseif refreshinfoframe2 then
		menu.refreshInfoFrame2()
	end
end

function menu.isModuleTypeExtended(station, type)
	for i, entry in ipairs(menu.extendedmoduletypes) do
		if IsSameComponent(entry.id, station) then
			return entry.moduletypes[type]
		end
	end
	return false
end

function menu.isSubordinateExtended(name, group)
	return menu.extendedsubordinates[name .. group] ~= false
end

function menu.isDockedShipsExtended(name, isstation)
	if isstation then
		return menu.extendeddockedships[name] ~= nil
	else
		return menu.extendeddockedships[name] ~= false
	end
end

function menu.isConstructionExtended(name)
	return menu.extendedconstruction[name] ~= nil
end

function menu.isPropertyExtended(name)
	return menu.extendedproperty[name] ~= nil
end

function menu.isOrderExtended(controllable, orderidx, instance, default)
	for i, entry in ipairs(menu.extendedorders) do
		if entry.id == controllable then
			return entry.orders[orderidx .. instance]
		end
	end
	if default ~= nil then
		table.insert(menu.extendedorders, { id = controllable, orders = { [orderidx .. instance] = default } })
		return default
	end
	return false
end

function menu.isCommander(component, group)
	for id, _ in pairs(menu.selectedcomponents) do
		local selectedcomponent = ConvertStringTo64Bit(id)
		if C.IsComponentClass(selectedcomponent, "controllable") then
			local directcommander = GetCommander(selectedcomponent)
			local commanderlist = GetAllCommanders(selectedcomponent)
			local prevcommander
			for i, entry in ipairs(commanderlist) do
				if IsSameComponent(entry, component) then
					if group then
						if IsSameComponent(entry, directcommander) then
							-- This is the direct commander, check if the group matches
							local selectedgroup = GetComponentData(selectedcomponent, "subordinategroup")
							return group == selectedgroup
						elseif prevcommander then
							-- This is a commander in the chain, get the previous commander's group and check if it matches
							local selectedgroup = GetComponentData(prevcommander, "subordinategroup")
							return group == selectedgroup
						else
							-- This is a commander in the chain, but not the direct commander and there was no previous commander?
							DebugError("menu.isCommander() found a commander, but could not reconstruct the chain of command!")
							return false
						end
					else
						return true
					end
				end
				prevcommander = entry
			end
		end
	end
	return false
end

function menu.isDockContext(component)
	for id, _ in pairs(menu.selectedcomponents) do
		local selectedcomponent = ConvertStringTo64Bit(id)
		if GetComponentData(selectedcomponent, "isdocked") then
			local containercontext = C.GetContextByClass(selectedcomponent, "container", false)
			while containercontext ~= 0 do
				if containercontext == component then
					return true
				end
				containercontext = C.GetContextByClass(containercontext, "container", false)
			end
		end
	end
	return false
end

function menu.isConstructionContext(component)
	for id, _ in pairs(menu.selectedcomponents) do
		local selectedcomponent = ConvertStringTo64Bit(id)
		if IsComponentConstruction(selectedcomponent) then
			local containercontext = C.GetContextByClass(selectedcomponent, "container", false)
			while containercontext ~= 0 do
				if containercontext == component then
					return true
				end
				containercontext = C.GetContextByClass(containercontext, "container", false)
			end
		end
	end
	return false
end

function menu.extendModuleType(station, type, notoggle)
	local found = false
	for i, entry in ipairs(menu.extendedmoduletypes) do
		if IsSameComponent(entry.id, station) then
			found = true
			if (not notoggle) and entry.moduletypes[type] then
				entry.moduletypes[type] = nil
				menu.clearSelectedComponents()
				menu.highlightedbordercomponent = station
				menu.highlightedbordermoduletype = type
			else
				entry.moduletypes[type] = true
			end
		end
	end
	if not found then
		table.insert(menu.extendedmoduletypes, {id = station, moduletypes = { [type] = true } })
	end
end

function menu.extendOrder(controllable, orderidx, instance)
	local found = false
	for i, entry in ipairs(menu.extendedorders) do
		if entry.id == controllable then
			found = true
			if entry.orders[orderidx .. instance] then
				entry.orders[orderidx .. instance] = nil
			else
				entry.orders[orderidx .. instance] = true
			end
			break
		end
	end
	if not found then
		table.insert(menu.extendedorders, {id = controllable, orders = { [orderidx .. instance] = true } })
	end
end

function menu.swapExtendedOrder(controllable, oldorderidx, neworderidx, instance)
	for i, entry in ipairs(menu.extendedorders) do
		if entry.id == controllable then
			local temp = entry.orders[neworderidx .. instance]
			entry.orders[neworderidx .. instance] = entry.orders[oldorderidx .. instance]
			entry.orders[oldorderidx .. instance] = temp
			break
		end
	end
end

function menu.setOrderParamFromMode(controllable, order, param, index, value, instance)
	SetOrderParam(controllable, order, param, index, value)

	menu.resetOrderParamMode()
end

function menu.resetOrderParamMode()
	if menu.currentInfoMode then
		menu.infoTableMode = menu.currentInfoMode[1]
		menu.infoMode.left = menu.currentInfoMode[2]
		menu.currentInfoMode = nil
	end
	menu.settoprow = menu.modeparam[3]
	menu.mode = nil
	menu.modeparam = {}

	C.ClearMapOrderParamObjectFilter(menu.holomap)
	C.ClearMapObjectFilter(menu.holomap)

	menu.removeMouseCursorOverride(3)

	menu.refreshMainFrame = true
	menu.refreshInfoFrame(0, 0)
end

function menu.onEditBoxActivated(widget)
	menu.noupdate = true
end

function menu.searchTextChanged(_, text, textchanged)
	menu.searchFieldContextText = utf8.lower(text)
	if menu.contextMenuMode ~= "searchfield" then
		menu.contextMenuMode = "searchfield"
		menu.contextMenuData = {}
		menu.createContextFrame(menu.searchEditBoxData.width, nil, menu.searchEditBoxData.x, menu.searchEditBoxData.y, true)
	else
		menu.refreshContextFrame()
	end
end

function menu.searchTextConfirmed(_, text, textchanged)
	if textchanged then
		AddUITriggeredEvent(menu.name, "searchconfirmed")

		local ware = menu.economyWares[utf8.lower(text)]
		local sector = menu.knownSectors[utf8.lower(text)]
		if ware then
			local setting, list = menu.getTradeWareFilter(true)
			local found = false
			for _, filterware in ipairs(list) do
				if filterware == ware then
					found = true
				end
			end

			if not found then
				menu.setFilterOption("layer_trade", setting, setting.id, ware)
			else
				if not __CORE_DETAILMONITOR_MAPFILTER["layer_trade"] then
					__CORE_DETAILMONITOR_MAPFILTER["layer_trade"] = true
					menu.applyFilterSettings()
				end
			end
		elseif sector then
			__CORE_DETAILMONITOR_MAPFILTER_SAVE["searchsectors"] = __CORE_DETAILMONITOR_MAPFILTER_SAVE["searchsectors"] or {}
			local sectorfilter = __CORE_DETAILMONITOR_MAPFILTER_SAVE["searchsectors"]
			local found = false
			for _, sectorentry in ipairs(sectorfilter) do
				if tostring(sector) == sectorentry then
					found = true
					break
				end
			end
			if not found then
				table.insert(sectorfilter, tostring(sector))
			end

			menu.setSectorFilter()
		else
			table.insert(menu.searchtext, { text = text })
			Helper.textArrayHelper(menu.searchtext, function (numtexts, texts) return C.SetMapFilterString(menu.holomap, numtexts, texts) end, "text")
		end
		menu.refreshMainFrame = true
	end
	menu.noupdate = false

	if menu.contextMenuMode == "searchfield" then
		menu.closeContextMenu()
	end

	menu.refreshInfoFrame()
end

function menu.setSectorFilter()
	__CORE_DETAILMONITOR_MAPFILTER_SAVE["searchsectors"] = __CORE_DETAILMONITOR_MAPFILTER_SAVE["searchsectors"] or {}
	local numsectors = #__CORE_DETAILMONITOR_MAPFILTER_SAVE["searchsectors"]
	local components = ffi.new("UniverseID[?]", numsectors)
	for i, sector in ipairs(__CORE_DETAILMONITOR_MAPFILTER_SAVE["searchsectors"]) do
		components[i - 1] = C.ConvertStringTo64Bit(sector)
	end

	C.SetMapFilterSectors(menu.holomap, numsectors, components)
end

function menu.getTradeWareFilter(force)
	local setting = config.layersettings["layer_trade"][1]
	local list = {}
	-- only return the values if the filter is active
	if force or menu.getFilterOption("layer_trade", false) then
		list = menu.getFilterOption(setting.id, setting.savegame) or {}
	end
	return setting, list
end

function menu.removeExtendedOrder(controllable, orderidx, instance)
	for i, entry in ipairs(menu.extendedorders) do
		if entry.id == controllable then
			entry.orders[orderidx .. instance] = nil
			for i = orderidx + 1, #menu.infoTableData[instance].orders do
				entry.orders[(i - 1) .. instance] = entry.orders[i]
			end
			entry.orders[#menu.infoTableData[instance].orders .. instance] = nil
			break
		end
	end
end

function menu.addShipToBoardingOperation(shipid, shipdata)
	--print("ship: " .. ffi.string(C.GetComponentName(shipid)) .. " " .. tostring(shipid) .. ", actionid: " .. tostring(shipdata.action))
	-- NB: actionid also applies to subordinates. explicitly assigned ships that are all subordinates should be in menu.boardingData.shipdata and not in subordinates. assignedmarines are distributed among shipid and all subordinates. assignedmarines starts from shipid, overflow among subordinates in no particular order.
	local actionid = shipdata.action
	local assignedmarines = {}
	local remainingmarines = {}
	local subordinates = shipdata.subordinates

	--print("ship: " .. ffi.string(C.GetComponentName(shipid)) .. ", actionid: " .. tostring(actionid) .. ", num subordinates: " .. tostring(#subordinates))
	for _, leveldata in ipairs(menu.boardingData.marinelevels) do
		if not menu.boardingData.shipdata[shipid].assignedgroupmarines[leveldata.skilllevel] then
			table.insert(assignedmarines, 0)
		else
			table.insert(assignedmarines, menu.boardingData.shipdata[shipid].assignedgroupmarines[leveldata.skilllevel])
		end
	end

	-- get number of marines per tier on shipid
	local numtiers = #menu.boardingData.marinelevels
	local tierdata = ffi.new("RoleTierData[?]", numtiers)
	numtiers = C.GetRoleTiers2(tierdata, numtiers, shipid, "marine", false)

	-- add each ship and subordinate to the boarding operation.
	local marinelist = ffi.new("uint32_t[?]", numtiers)
	local marineskilllevellist = ffi.new("uint32_t[?]", numtiers)
	for i = 0, numtiers - 1 do
		marinelist[i] = math.min(assignedmarines[i+1], tierdata[i].amount)
		marineskilllevellist[i] = menu.boardingData.marinelevels[i+1].skilllevel
		table.insert(remainingmarines, assignedmarines[i+1] - marinelist[i])
		--print("primary attacker. index: " .. tostring(i) .. ", num marines: " .. tostring(marinelist[i]) .. ", skill level: " .. tostring(marineskilllevellist[i]))
	end

	if menu.isShipAlreadyBoarding(shipid) then
		if not C.UpdateAttackerOfBoardingOperation(menu.boardingData.target, shipid, "player", actionid, marinelist, marineskilllevellist, numtiers) then
			DebugError("Failed updating boarding ship " .. ffi.string(C.GetComponentName(shipid)) .. " " .. tostring(shipid))
		end
	else
		if not C.AddAttackerToBoardingOperation(menu.boardingData.target, shipid, "player", actionid, marinelist, marineskilllevellist, numtiers) then
			DebugError("Failed adding " .. ffi.string(C.GetComponentName(shipid)) .. " " .. tostring(shipid) .. " to boarding operation attacking " .. ffi.string(C.GetComponentName(menu.boardingData.target)) .. " " .. tostring(menu.boardingData.target))
		end
	end

	for _, subordinateid in ipairs(subordinates) do
		if not menu.boardingData.shipdata[subordinateid].isprimaryboarder then
			-- get number of marines per tier in subordinateid
			numtiers = C.GetRoleTiers2(tierdata, numtiers, subordinateid, "marine", false)
			for i = 0, numtiers - 1 do
				marinelist[i] = math.min(remainingmarines[i+1], tierdata[i].amount)
				marineskilllevellist[i] = menu.boardingData.marinelevels[i+1].skilllevel
				remainingmarines[i+1] = remainingmarines[i+1] - marinelist[i]
				--print("subordinate. index: " .. tostring(i) .. ", num marines: " .. tostring(marinelist[i]) .. ", skill level: " .. tostring(marineskilllevellist[i]))
			end

			if menu.isShipAlreadyBoarding(subordinateid) then
				if not C.UpdateAttackerOfBoardingOperation(menu.boardingData.target, subordinateid, "player", actionid, marinelist, marineskilllevellist, numtiers) then
					DebugError("Failed updating boarding ship " .. ffi.string(C.GetComponentName(subordinateid)) .. " " .. tostring(subordinateid))
				end
			else
				--print("adding " .. ffi.string(C.GetComponentName(subordinateid)) .. " to boarding operation")
				if not C.AddAttackerToBoardingOperation(menu.boardingData.target, subordinateid, "player", actionid, marinelist, marineskilllevellist, numtiers) then
					DebugError("Failed adding " .. ffi.string(C.GetComponentName(subordinateid)) .. " " .. tostring(subordinateid) .. " to boarding operation attacking " .. ffi.string(C.GetComponentName(menu.boardingData.target)) .. " " .. tostring(menu.boardingData.target))
				end
			end
		end
	end
end

function menu.isShipAlreadyBoarding(shipid)
	local numattackers = C.GetNumAttackersOfBoardingOperation(menu.boardingData.target, "player")
	local attackers = ffi.new("UniverseID[?]", numattackers)
	numattackers = C.GetAttackersOfBoardingOperation(attackers, numattackers, menu.boardingData.target, "player")
	local alreadyboarding = false
	for i = 0, numattackers do
		if shipid == ConvertStringTo64Bit(tostring(attackers[i])) then
			alreadyboarding = true
			break
		end
	end

	return alreadyboarding
end

function menu.updateHolomap()
	if (menu.mode == "tradecontext") or (menu.mode == "dropwarescontext") or (menu.mode == "renamecontext") or (menu.mode == "changelogocontext") or (menu.mode == "crewtransfercontext") or (menu.mode == "venturepatroninfo") or (menu.mode == "venturereport") then
		return
	elseif (menu.infoMode.left == "objectlogbook") or (menu.infoMode.right == "objectlogbook")  then
		return
	end

	if not menu.lastUpdateHolomapTime then
		menu.lastUpdateHolomapTime = 0
	end
	local curTime = getElapsedTime()
	if menu.lastUpdateHolomapTime < curTime - 5 and not menu.noupdate then
		menu.lastUpdateHolomapTime = curTime
		menu.refreshInfoFrame()
	end
end

function menu.syncMapFilterWithConfig()
	__CORE_DETAILMONITOR_MAPFILTER["think_diplomacy_highlightvisitor"] = C.GetConfigSetting("highlightvisitors") ~= 0
end

function menu.importMenuParameters()
	menu.showzone = menu.param[3] ~= 0

	menu.focuscomponent = ConvertIDTo64Bit(menu.param[4])
	menu.selectfocuscomponent = true
	if not menu.focuscomponent then
		local softtargetinfo = C.GetSofttarget2()
		if softtargetinfo.softtargetID ~= 0 then
			if C.IsComponentClass(softtargetinfo.softtargetID, "space") or C.IsComponentClass(softtargetinfo.softtargetID, "object") then
				menu.focuscomponent = softtargetinfo.softtargetID
				if C.IsComponentClass(menu.focuscomponent, "zone") and (ffi.string(softtargetinfo.softtargetConnectionName) == "") then
					menu.focuscomponent = C.GetContextByClass(menu.focuscomponent, "sector", false)
					menu.focusoffset = C.GetPlayerTargetOffset()
				end
			else
				menu.focuscomponent = C.GetPlayerObjectID()
				menu.selectfocuscomponent = nil
			end
		else
			menu.focuscomponent = C.GetPlayerObjectID()
			menu.selectfocuscomponent = nil
		end
	end

	if C.IsComponentClass(menu.focuscomponent, "highway") then
		menu.currentsector = ConvertIDTo64Bit(GetComponentData(ConvertStringTo64Bit(tostring(menu.focuscomponent)), "sourcesector")) or 0
	else
		menu.currentsector = C.GetContextByClass(menu.focuscomponent, "sector", true)
	end
	menu.mode = menu.param[6]
	menu.modeparam = menu.param[7] or {}
	menu.initMultiverse = menu.param[8]
	menu.focusoffset = menu.param[9]
end

function menu.prepareEconomyWares()
	if not menu.economyWares then
		menu.economyWares = {}
		local n = C.GetNumWares("economy", false, "", "")
		local buf = ffi.new("const char*[?]", n)
		n = C.GetWares(buf, n, "economy", false, "", "")
		for i = 0, n - 1 do
			local ware = ffi.string(buf[i])
			local name = GetWareData(ware, "name")

			-- strip color code from temp strings
			if utf8.find(name, "^\027M") then
				name = utf8.sub(name, 3)
			end
			if utf8.find(name, "\027X$") then
				name = utf8.sub(name, 1, -3)
			end

			menu.economyWares[utf8.lower(name)] = ware
		end
	end
end

function menu.prepareKnownSectors()
	menu.knownSectors = {}
	local clusters = GetClusters(true)
	for _, cluster in ipairs(clusters) do
		sectors = GetSectors(cluster)
		for i, sector in ipairs(sectors) do
			local name = GetComponentData(sector, "name")

			-- strip color code from temp strings
			if utf8.find(name, "^\027M") then
				name = utf8.sub(name, 3)
			end
			if utf8.find(name, "\027X$") then
				name = utf8.sub(name, 1, -3)
			end

			menu.knownSectors[utf8.lower(name)] = sector
		end
	end
end

function menu.checkForOrderParamObject(component)
	if type(menu.modeparam[5]) == "string" then
		return C.FilterComponentForDefaultOrderParamObjectMode(ConvertStringTo64Bit(tostring(component)), ConvertStringTo64Bit(tostring(menu.modeparam[4])), menu.modeparam[5] == "planneddefault", menu.modeparam[6])
	else
		return C.FilterComponentForOrderParamObjectMode(ConvertStringTo64Bit(tostring(component)), ConvertStringTo64Bit(tostring(menu.modeparam[4])), menu.modeparam[5], menu.modeparam[6])
	end
end

function menu.checkForSelectComponent(component)
	local numclasses = menu.modeparam[2] and #menu.modeparam[2] or 0
	local classes = ffi.new("const char*[?]", numclasses)
	if numclasses > 0 then
		for i, class in ipairs(menu.modeparam[2]) do
			classes[i - 1] = Helper.ffiNewString(class)
		end
	end
	local result = C.FilterComponentForMapMode(component, classes, numclasses, menu.modeparam[4] or -1, false)
	Helper.ffiClearNewHelper()

	return result
end

function menu.plotCourse(object, offset)
	local convertedObject = ConvertStringToLuaID(tostring(object))
	if menu.mode or (object == C.GetPlayerControlledShipID()) then
		PlaySound("ui_target_set_fail")
		return -- no plot course to playership or when menu.mode is set
	end

	if IsSameComponent(GetActiveGuidanceMissionComponent(), convertedObject) then
		C.EndGuidance()
	else
		if offset == nil then
			offset = ffi.new("UIPosRot", 0)
		elseif C.IsComponentClass(object, "sector") then
			object = C.GetZoneAt(object, offset)
		end
		C.SetGuidance(object, offset)
	end

	menu.settoprow = GetTopRow(menu.selecttable)
	menu.setrow = Helper.currentTableRow[menu.selecttable]
	if not menu.createInfoFrameRunning then
		menu.createInfoFrame()
	end
end

function menu.getParamValue(type, value, inputparams)
	local result

	if type == "bool" then
		result = (value ~= 0) and ReadText(1001, 2617) or ReadText(1001, 2618)
	elseif type == "length" then
		if inputparams and inputparams.step and (inputparams.step >= 1000) then
			result = tostring(math.floor(value / 1000)) .. " " .. ReadText(1001, 107)
		else
			result = tostring(value) .. " " .. ReadText(1001, 107)
		end
	elseif type == "time" then
		result = tostring(value) .. " " .. ReadText(1001, 100)
	elseif type == "money" then
		result = ConvertMoneyString(value, false, true, 0, true) .. " " .. ReadText(1001, 101)
	elseif type == "object" then
		if IsComponentClass(value, "space") then
			local name, sector, cluster = GetComponentData(value, "name", "sector", "cluster")
			result = ((cluster ~= "") and (cluster .. " / ") or "") .. ((sector ~= "") and (sector .. " / ") or "") .. name
		else
			result = GetComponentData(value, "name")
		end
	elseif type == "sector" then
		local name, sector, cluster = "", "", ""
		if value then
			name, sector, cluster = GetComponentData(value, "name", "sector", "cluster")
		end
		result = ((cluster ~= "") and (cluster .. " / ") or "") .. ((sector ~= "") and (sector .. " / ") or "") .. name
	elseif type == "ware" then
		result = GetWareData(value, "name")
	elseif type == "macro" then
		result = GetMacroData(value, "name")
	elseif type == "trade_ware" then
		result = (value[1] and ReadText(1001, 2917) or ReadText(1001, 2916)) .. " " .. GetWareData(value[2], "name")
	elseif type == "trade_amount" then
		result = value[1] and (tostring(value[1]) .. " (" .. string.format(ReadText(1001, 3246), tostring(value[2])) .. ")") or ""
	elseif type == "position" then
		local name, sectorid, clusterid = GetComponentData(value[1], "name", "sectorid", "clusterid")
		result = ""
		if clusterid then
			local sectors = GetSectors(clusterid)
			local clustername, systemid = GetComponentData(clusterid, "name", "systemid")
			if (#sectors > 1) or (systemid ~= 0) then
				result = clustername .. "\n"
			end
		end
		result = result .. (sectorid and (GetComponentData(sectorid, "name") .. "\n") or "") .. name
	else
		result = tostring(value)
	end

	return result
end

function menu.closeContextMenu(dueToClose)
	AddUITriggeredEvent(menu.name, "contextmenu_close")

	if Helper.closeInteractMenu() then
		return true
	end
	if menu.contextMenuMode then
		if menu.contextMenuMode == "trade" then
			if C.IsComponentOperational(menu.contextMenuData.currentShip) then
				SetVirtualCargoMode(ConvertStringToLuaID(tostring(menu.contextMenuData.currentShip)), false)
			end
			if menu.contextMenuData.wareexchange then
				if C.IsComponentOperational(menu.contextMenuData.component) then
					SetVirtualCargoMode(ConvertStringToLuaID(tostring(menu.contextMenuData.component)), false)
				end
			end
			menu.selectedTradeWare = nil
		elseif menu.contextMenuMode == "mission" then
			if menu.holomap ~= 0 then
				C.SetMapRenderMissionGuidance(menu.holomap, 0)
			end
			if menu.contextMenuData.isoffer then
				UnregisterEvent("missionofferremoved", menu.onMissionOfferRemoved)
			else
				UnregisterEvent("missionremoved", menu.onMissionRemoved)
			end
		elseif menu.contextMenuMode == "boardingcontext" then
			-- restore old mode and old info table mode
			menu.mode = menu.oldmode
			menu.oldmode = nil
			menu.infoTableMode = menu.oldInfoTableMode
			menu.refreshMainFrame = true
			menu.oldInfoTableMode = nil
			menu.boardingData = {}
			menu.contexttoprow = nil
			menu.contextselectedrow = nil
		elseif (menu.contextMenuMode == "onlinemode") then
			if dueToClose == "back" then
				return false
			end
		elseif (menu.contextMenuMode == "onlinereward") then
			OnlineClearLogbookRewards()
		elseif (menu.contextMenuMode == "ventureconfig") or (menu.contextMenuMode == "venturecreateparty") or (menu.contextMenuMode == "ventureoutcome") or (menu.contextMenuMode == "venturefriendlist") then
			if not Helper.callExtensionFunction("multiverse", "closeContextMenu", menu, menu.contextMenuMode, dueToClose) then
				return true
			end
		elseif menu.contextMenuMode == "changelogo" then
			if menu.contextMenuData.origlogo ~= nil then
				C.SetFleetLogo(menu.contextMenuData.component, menu.contextMenuData.origlogo)
			end
		elseif menu.contextMenuMode == "venturereport" then
			Helper.sendChatWindowCallback("unlock")
		elseif menu.contextMenuMode == "set_orderparam_sector" then
			if menu.picking then
				local offset = ffi.new("UIPosRot")
				local eclipticoffset = ffi.new("UIPosRot")
				local offsetcomponent = C.GetMapPositionOnEcliptic2(menu.holomap, offset, false, 0, eclipticoffset)
				if offsetcomponent ~= 0 then
					if C.IsComponentClass(offsetcomponent, "sector") then
						menu.mode = "orderparam_sector"
						local luaoffsetcomponent = ConvertStringToLuaID(tostring(offsetcomponent))
						SetOrderParam(ConvertStringTo64Bit(tostring(menu.infoSubmenuObject)), menu.contextMenuData.order, menu.contextMenuData.param, menu.contextMenuData.index, luaoffsetcomponent)
						AddUITriggeredEvent(menu.name, menu.contextMenuMode, luaoffsetcomponent)
						menu.refreshInfoFrame()
					end
				end
			end
		end
		-- REMOVE this block once the mouse out/over event order is correct -> This should be unnessecary due to the global tablemouseout event reseting the picking
		if menu.currentMouseOverTable and (
			(menu.currentMouseOverTable == menu.contexttable)
			or (menu.currentMouseOverTable == menu.contextshiptable)
			or (menu.currentMouseOverTable == menu.contextbuttontable)
			or (menu.currentMouseOverTable == menu.contextdesctable)
			or (menu.currentMouseOverTable == menu.contextobjectivetable)
			or (menu.currentMouseOverTable == menu.contextbottomtable)
			or (menu.currentMouseOverTable == contextobjectivetable)
			or (menu.contextMenuMode == "boardingcontext")
			or (menu.contextMenuMode == "dropwares")
			or (menu.contextMenuMode == "crewtransfer")
			or (menu.contextMenuMode == "rename")
			or (menu.contextMenuMode == "changelogo")
			or (menu.contextMenuMode == "userquestion")
			or (menu.contextMenuMode == "venturepatron")
			or (menu.contextMenuMode == "venturereport")
			or (menu.contextMenuMode == "ventureteammembercontext")
			or (menu.contextMenuMode == "venturecontactcontext")
			or (menu.contextMenuMode == "filter_multiselectlist")
			or (menu.contextMenuMode == "hire")
		) then
			menu.picking = true
			menu.currentMouseOverTable = nil
		end
		-- END
		menu.contextFrame = nil
		Helper.clearFrame(menu, config.contextFrameLayer)
		menu.contextMenuData = {}
		menu.contextMenuMode = nil
		if (menu.mode == "tradecontext") or (menu.mode == "dropwarescontext") or (menu.mode == "renamecontext") or (menu.mode == "changelogocontext") or (menu.mode == "crewtransfercontext") or(menu.mode == "venturepatroninfo") or (menu.mode == "venturereport") or menu.closemapwithmenu then
			Helper.closeMenu(menu, dueToClose)
			menu.cleanup()
		end
		return true
	end
	return false
end

function menu.onInteractMenuCallback(type, param)
	if type == "attackmultiple" then
		menu.mode = "orderparam_selectenemies"
		menu.modeparam = param
		menu.setMouseCursorOverride("targetred", 3)
	elseif type == "collectdeployables" then
		menu.mode = "orderparam_selectplayerdeployables"
		menu.modeparam = param
		menu.setMouseCursorOverride("target", 3)
	elseif type == "boardingcontext" then
		-- accessing boarding menu from within the map
		local width = Helper.viewWidth * 0.6
		local height = Helper.viewHeight * 0.7
		local xoffset = Helper.viewWidth * 0.2
		local yoffset = Helper.viewHeight * 0.15
		menu.contextMenuMode = "boardingcontext"
		menu.contextMenuData = { target = param[1], boarders = param[2] }
		menu.createContextFrame(width, height, xoffset, yoffset)
	elseif type == "comm" then
		menu.openComm(param)
	elseif type == "close" then
		menu.onCloseElement("close")
	elseif type == "info" then
		if param[2] then
			menu.extendedinfo = {}
			for _, loccategory in ipairs(param[2]) do
				menu.extendedinfo[loccategory] = true
			end
		end
		menu.openDetails(param[1])
	elseif type == "mission" then
		menu.infoTableMode = "mission"
		menu.missionMode = param[1]
		menu.missionModeCurrent = tostring(param[2])
		if param[3] then
			menu.expandedMissionGroups[param[2]] = true
		end
		menu.refreshMainFrame = true
		menu.refreshInfoFrame()
		if not param[3] then
			menu.showMissionContext(param[2])
			menu.missionModeContext = true
		end
	elseif type == "missionaccepted" then
		if menu.missionOfferList then
			local found = false
			for i, entry in ipairs(menu.missionOfferList["plot"] or {}) do
				if ConvertStringTo64Bit(entry.ID) == param[1] then
					found = true
					entry.accepted = true
					menu.highlightLeftBar["mission"] = true
					menu.refreshMainFrame = true
					break
				end
			end
			if not found then
				for _, data in ipairs(menu.missionOfferList["guild"] or {}) do
					for _, entry in ipairs(data.missions) do
						if ConvertStringTo64Bit(entry.ID) == param[1] then
							found = true
							entry.accepted = true
							menu.highlightLeftBar["mission"] = true
							menu.refreshMainFrame = true
							break
						end
					end
					if found then
						break
					end
				end
			end
			if not found then
				for i, entry in ipairs(menu.missionOfferList["other"] or {}) do
					if ConvertStringTo64Bit(entry.ID) == param[1] then
						found = true
						entry.accepted = true
						menu.highlightLeftBar["mission"] = true
						menu.refreshMainFrame = true
						break
					end
				end
			end
		end
		menu.refreshIF = getElapsedTime()
	elseif type == "newconversation" then
		Helper.closeMenuForNewConversation(menu, param[1], param[2], param[3])
		menu.cleanup()
	elseif type == "newmenu" then
		Helper.closeMenuAndOpenNewMenu(menu, param[1], param[2])
		menu.cleanup()
	elseif type == "refresh" then
		menu.refreshInfoFrame()
	elseif type == "sellships" then
		menu.contextMenuData = { shipyard = param[1], ships = param[2], xoffset = param[3], yoffset = param[4] }
		menu.contextMenuMode = "sellships"
		menu.createContextFrame(menu.sellShipsWidth)
	elseif type == "tradecontext" then
		local mousepos = C.GetCenteredMousePos()
		menu.contextMenuData = { component = param[1], currentShip = param[5], xoffset = mousepos.x + Helper.viewWidth / 2, yoffset = mousepos.y + Helper.viewHeight / 2, loop = param[4] }
		if menu.contextMenuData.loop then
			menu.buttonContextTradeLoop()
		else
			menu.buttonContextTrade(param[3])
		end
	elseif type == "dropwarescontext" then
		local mousepos = C.GetCenteredMousePos()
		menu.contextMenuMode = "dropwares"
		menu.contextMenuData = { mode = param[1], entity = param[2], xoffset = mousepos.x + Helper.viewWidth / 2, yoffset = mousepos.y + Helper.viewHeight / 2, wares = {} }

		if menu.contextMenuData.mode == "inventory" then
			local inventory = GetInventory(menu.contextMenuData.entity)
			local onlineitems = OnlineGetUserItems()

			for ware, entry in pairs(inventory) do
				local ispersonalupgrade = GetWareData(ware, "ispersonalupgrade")
				if (not ispersonalupgrade) and (not onlineitems[ware]) then
					table.insert(menu.contextMenuData.wares, { ware = ware, name = entry.name, amount = entry.amount })
				end
			end
			table.sort(menu.contextMenuData.wares, Helper.sortName)
		end

		local height = (#menu.contextMenuData.wares + 5) * (Helper.scaleY(config.mapRowHeight) + Helper.borderSize)
		if menu.contextMenuData.yoffset + height > Helper.viewHeight then
			menu.contextMenuData.yoffset = Helper.viewHeight - height - Helper.frameBorder
		end
		if menu.contextMenuData.xoffset + config.dropInventoryWidth > Helper.viewWidth then
			menu.contextMenuData.xoffset = Helper.viewWidth - config.dropInventoryWidth - Helper.frameBorder
		end

		menu.createContextFrame(config.dropInventoryWidth, nil, menu.contextMenuData.xoffset, menu.contextMenuData.yoffset)
	elseif type == "crewtransfercontext" then
		local mousepos = C.GetCenteredMousePos()
		menu.contextMenuMode = "crewtransfer"
		menu.contextMenuData = { leftShip = param[1], rightShip = param[2], extendedTier = {}, xoffset = mousepos.x + Helper.viewWidth / 2, yoffset = mousepos.y + Helper.viewHeight / 2 }

		local width = Helper.scaleX(config.crewTransferWidth)
		if menu.contextMenuData.xoffset + width > Helper.viewWidth then
			menu.contextMenuData.xoffset = Helper.viewWidth - width - Helper.frameBorder
		end

		menu.createContextFrame(width, nil, menu.contextMenuData.xoffset, menu.contextMenuData.yoffset)
	elseif type == "renamecontext" then
		local mousepos = C.GetCenteredMousePos()
		menu.contextMenuMode = "rename"

		-- kuertee start: multi-rename
		-- menu.contextMenuData = { component = param[1], fleetrename = param[2], xoffset = mousepos.x + Helper.viewWidth / 2, yoffset = mousepos.y + Helper.viewHeight / 2 }
		menu.contextMenuData = {
			component = param[1],
			fleetrename = param[2],
			uix_multiRename_objects = param[3],
			xoffset = mousepos.x + Helper.viewWidth / 2,
			yoffset = mousepos.y + Helper.viewHeight / 2
		}
		-- kuertee end: multi-rename

		local width = Helper.scaleX(config.renameWidth)
		if menu.contextMenuData.xoffset + width > Helper.viewWidth then
			menu.contextMenuData.xoffset = Helper.viewWidth - width - Helper.frameBorder
		end

		menu.createContextFrame(width, nil, menu.contextMenuData.xoffset, menu.contextMenuData.yoffset)
	elseif type == "changelogocontext" then
		local mousepos = C.GetCenteredMousePos()
		menu.contextMenuMode = "changelogo"
		menu.contextMenuData = { component = param[1], origlogo = {}, currentlogo = {}, xoffset = mousepos.x + Helper.viewWidth / 2, yoffset = mousepos.y + Helper.viewHeight / 2 }

		local buf = C.GetCurrentFleetLogo(menu.contextMenuData.component)
		menu.contextMenuData.origlogo = { file = ffi.string(buf.file), icon = ffi.string(buf.icon), ispersonal = buf.ispersonal }
		menu.contextMenuData.currentlogo = menu.contextMenuData.origlogo

		local width = Helper.scaleX(config.changeLogoWidth)
		if menu.contextMenuData.xoffset + width > Helper.viewWidth then
			menu.contextMenuData.xoffset = Helper.viewWidth - width - Helper.frameBorder
		end

		menu.createContextFrame(width, nil, menu.contextMenuData.xoffset, menu.contextMenuData.yoffset)
	elseif type == "selectsubordinates" then
		local subordinates = GetSubordinates(param[1])
		local groupShips = {}
		for _, subordinate in ipairs(subordinates) do
			local group = GetComponentData(subordinate, "subordinategroup")
			if group and group > 0 then
				if group == param[2] then
					table.insert(groupShips, subordinate)
				end
			end
		end

		if #groupShips > 0 then
			C.SetFocusMapComponent(menu.holomap, ConvertIDTo64Bit(groupShips[1]), true)
			menu.addSelectedComponents(groupShips)
		end
	elseif type == "venturepatroninfo" then
		local mousepos = C.GetCenteredMousePos()
		menu.contextMenuMode = "venturepatron"
		menu.contextMenuData = { component = param[1], xoffset = mousepos.x + Helper.viewWidth / 2, yoffset = mousepos.y + Helper.viewHeight / 2 }

		local width = Helper.scaleX(config.venturePatronWidth)
		if menu.contextMenuData.xoffset + width > Helper.viewWidth then
			menu.contextMenuData.xoffset = Helper.viewWidth - width - Helper.frameBorder
		end

		menu.createContextFrame(width, nil, menu.contextMenuData.xoffset, menu.contextMenuData.yoffset)
	elseif type == "venturereport" then
		local mousepos = C.GetCenteredMousePos()
		menu.contextMenuMode = "venturereport"
		menu.contextMenuData = { mode = "venturereport", submode = param[1], reason = param[2], timestamp = param[3], author = param[4], transactionid = param[5], userid = param[6], xoffset = mousepos.x + Helper.viewWidth / 2, yoffset = mousepos.y + Helper.viewHeight / 2 }

		local width = Helper.scaleX(config.venturePatronWidth)
		if menu.contextMenuData.xoffset + width > Helper.viewWidth then
			menu.contextMenuData.xoffset = Helper.viewWidth - width - Helper.frameBorder
		end

		menu.createContextFrame(width, nil, menu.contextMenuData.xoffset, menu.contextMenuData.yoffset)
	elseif type == "markashostile" then
		menu.contextMenuMode = "userquestion"
		menu.contextMenuData = { mode = "markashostile", controllable = param[1], xoffset = (Helper.viewWidth - Helper.scaleX(400)) / 2, yoffset = Helper.viewHeight / 2, saveOption = false }

		if __CORE_DETAILMONITOR_USERQUESTION[menu.contextMenuData.mode] then
			-- continue immediately
			menu.buttonConfirmUserQuestion()
		else
			menu.createContextFrame(Helper.scaleX(400), nil, menu.contextMenuData.xoffset, menu.contextMenuData.yoffset)
		end
	elseif type == "refreshcrew" then
		if menu.infoTableMode == "info" then
			if menu.infoMode.left == "objectcrew" then
				menu.infoTablePersistentData["left"].resetcrew = true
			end
		end
		if menu.searchTableMode == "info" then
			if menu.infoMode.right == "objectcrew" then
				menu.infoTablePersistentData["right"].resetcrew = true
			end
		end
		menu.refreshInfoFrame()
	end
end

function menu.updateSelectedComponents(modified, keepselection, changedComponent, changedrow)
	local components = {}
	local rows, highlightedborderrow = GetSelectedRows(menu.infoTable)

	-- determine whether the component we are changing is now selected or unselected
	local ischangedselected = false
	for _, row in ipairs(rows) do
		if row == changedrow then
			ischangedselected = true
			break
		end
	end

	for _, row in ipairs(rows) do
		local rowdata = menu.rowDataMap[menu.infoTable][row]
		if type(rowdata) == "table" then
			if (rowdata[1] ~= "moduletype") and (not string.find(rowdata[1], "subordinates")) and (rowdata[1] ~= "dockedships") and (rowdata[1] ~= "constructions") then
				-- for docked ships in the PO the ship can be listed twice in the menu, do not keep the component due to the selection in the other line if the changed line is now unselected
				if rowdata[1] == "construction" then
					if rowdata[3].component ~= 0 then
						if ischangedselected or (rowdata[3].component ~= changedComponent) then
							table.insert(components, ConvertStringTo64Bit(tostring(rowdata[3].component)))
						end
					end
				elseif ischangedselected or (C.ConvertStringTo64Bit(tostring(rowdata[2])) ~= changedComponent) then
					table.insert(components, rowdata[2])
				end
			end
		end
	end

	if modified or keepselection then
		for id in pairs(menu.selectedcomponents) do
			local component = ConvertStringTo64Bit(id)
			-- keep gates, satellites, etc. selected even if they don't have their own list entries
			if C.IsComponentClass(component, "gate") or C.IsComponentClass(component, "asteroid") or C.IsComponentClass(component, "buildstorage") or C.IsComponentClass(component, "highwayentrygate") or C.IsComponentClass(component, "highway") then
				table.insert(components, component)
			end

			-- kuertee start:
			-- if menu.infoTableMode == "propertyowned" then
			if string.find ("" .. tostring (menu.infoTableMode), "propertyowned") then
				-- kuertee end:

				local isplayerowned, isdeployable = GetComponentData(component, "isplayerowned", "isdeployable")
				if not isplayerowned then
					-- keep npc ships selected
					table.insert(components, component)
				elseif menu.propertyMode ~= "propertyall" then
					-- keep other property selected that is currently not displayed
					if (menu.propertyMode ~= "stations") and C.IsRealComponentClass(component, "station") then
						table.insert(components, component)
					end
					if (modified ~= "ctrl") or (component ~= changedComponent) then
						if C.IsComponentClass(component, "ship") then
							table.insert(components, component)
						end
					end
				end
				if (menu.propertyMode ~= "deployables") and (isdeployable or C.IsComponentClass(component, "lockbox")) then
					table.insert(components, component)
				end

				-- kuertee start:
				-- elseif menu.infoTableMode == "objectlist" then
			elseif string.find ("" .. tostring (menu.infoTableMode), "objectlist") then
				-- kuertee end:

				local isdeployable = GetComponentData(component, "isdeployable")
				if menu.objectMode ~= "objectall" then
					-- keep other property selected that is currently not displayed
					if (menu.objectMode ~= "stations") and C.IsRealComponentClass(component, "station") then
						table.insert(components, component)
					end
					if (modified ~= "ctrl") or (component ~= changedComponent) then
						if C.IsComponentClass(component, "ship") then
							table.insert(components, component)
						end
					end
				end
				if (menu.objectMode ~= "deployables") and (isdeployable or C.IsComponentClass(component, "lockbox")) then
					table.insert(components, component)
				end
			end
		end
	end

	local rowdata = menu.rowDataMap[menu.infoTable][highlightedborderrow]
	if type(rowdata) == "table" then
		menu.highlightedbordercomponent = rowdata[2]
		if rowdata[1] == "construction" then
			if rowdata[3].component ~= 0 then
				menu.highlightedbordercomponent = ConvertStringTo64Bit(tostring(rowdata[3].component))
			end
		end
		local oldselectedstationcategory = menu.selectedstationcategory
		menu.highlightedbordermoduletype = nil
		menu.highlightedborderstationcategory = nil
		menu.selectedstationcategory = nil
		menu.highlightedplannedmodule = nil
		menu.highlightedconstruction = nil
		menu.selectedconstruction = nil
		menu.selectedfleetcommander = nil
		if rowdata[1] == "moduletype" then
			menu.highlightedbordermoduletype = rowdata[3]
		elseif rowdata[1] == "module" then
			menu.highlightedbordermoduletype = rowdata[3]
			if rowdata[6] then
				menu.highlightedbordercomponent = rowdata[5]
				menu.highlightedplannedmodule = rowdata[6]
			end
		elseif string.find(rowdata[1], "subordinates") then
			menu.highlightedborderstationcategory = rowdata[1]
			if (keepselection and (oldselectedstationcategory == rowdata[1])) or (modified ~= "ctrl") then
				menu.selectedstationcategory = rowdata[1]
			end
			menu.selectedfleetcommander = ConvertIDTo64Bit(rowdata[2])
		elseif rowdata[1] == "dockedships" then
			menu.highlightedborderstationcategory = "dockedships"
		elseif rowdata[1] == "constructions" then
			menu.highlightedborderstationcategory = "constructions"
		elseif rowdata[1] == "construction" then
			menu.highlightedconstruction = rowdata[3]
			if (modified ~= "ctrl") then
				menu.selectedconstruction = rowdata[3]
			end
		end
		menu.highlightedbordersection = nil
	elseif type(rowdata) == "string" then
		menu.highlightedbordercomponent = nil
		menu.highlightedbordermoduletype = nil
		menu.highlightedborderstationcategory = nil
		menu.selectedstationcategory = nil
		menu.highlightedconstruction = nil
		menu.selectedconstruction = nil
		menu.selectedfleetcommander = nil
		menu.highlightedbordersection = rowdata
	end

	C.SetMapSelectedFleetCommander(menu.holomap, menu.selectedfleetcommander or 0)
	menu.addSelectedComponents(components, modified)
end

function menu.updateTableSelection(lastcomponent)
	menu.refreshMainFrame = true

	-- if (menu.infoTableMode == "objectlist") or (menu.infoTableMode == "propertyowned") then
	-- kuertee start:
	if (string.find ("" .. tostring (menu.infoTableMode), "objectlist")) or (string.find ("" .. tostring (menu.infoTableMode), "propertyowned")) then
		-- kuertee end:

		-- check if sections need to be extended - if so we need a refresh
		local refresh = false
		for id in pairs(menu.selectedcomponents) do
			local component = ConvertStringTo64Bit(id)
			-- build queues contain components that are not connected to the universe yet
			if IsValidComponent(component) then
				local commanderlist = C.IsComponentClass(component, "controllable") and GetAllCommanders(component) or {}
				for i, entry in ipairs(commanderlist) do
					if (not menu.isPropertyExtended(tostring(entry))) then
						menu.extendedproperty[tostring(entry)] = true
						refresh = true
					end
				end
			end
		end
		if refresh then
			menu.refreshInfoFrame()
			return
		end

		if menu.rowDataMap[menu.infoTable] then
			local rows = {}
			local curRow
			for row, rowdata in pairs(menu.rowDataMap[menu.infoTable]) do
				if type(rowdata) == "table" then
					if rowdata[1] == nil then
						print(TraceBack())
					end
					if (rowdata[1] ~= "moduletype") and (not string.find(rowdata[1], "subordinates")) and (rowdata[1] ~= "dockedships") and (rowdata[1] ~= "constructions") and (rowdata[1] ~= "construction") and menu.isSelectedComponent(rowdata[2]) then
						table.insert(rows, row)
						if ConvertStringTo64Bit(tostring(rowdata[2])) == lastcomponent then
							curRow = row
						end
					elseif (rowdata[1] == "construction") and (rowdata[3].component ~= 0) and menu.isSelectedComponent(rowdata[3].component) then
						table.insert(rows, row)
						if ConvertStringTo64Bit(tostring(rowdata[3].component)) == lastcomponent then
							curRow = row
						end
					elseif (rowdata[1] == "construction") and rowdata[2] and menu.selectedconstruction and (menu.selectedconstruction.id == rowdata[3].id) then
						table.insert(rows, row)
						if ConvertStringTo64Bit(tostring(rowdata[2])) == lastcomponent then
							curRow = row
						end
					elseif string.find(rowdata[1], "subordinates") and (rowdata[1] == menu.selectedstationcategory) then
						table.insert(rows, row)
					end
				end
			end
			SetSelectedRows(menu.infoTable, rows, curRow or (Helper.currentTableRow[menu.infoTable] or 0))
		end
	end
	menu.setSelectedMapComponents()
end

function menu.addSelectedComponent(component, clear, noupdate)
	component = ConvertStringTo64Bit(tostring(component))
	if clear ~= false then
		menu.selectedcomponents = {}
	end

	local add = true
	local hasonlynpcs = true
	for id, _ in pairs(menu.selectedcomponents) do
		local selectedcomponent = ConvertStringTo64Bit(id)
		if GetComponentData(selectedcomponent, "isplayerowned") then
			hasonlynpcs = false
			break
		end
	end
	-- build queues contain components that are not connected to the universe yet
	if (not IsValidComponent(component)) or (not GetComponentData(component, "isplayerowned")) then
		if hasonlynpcs then
			-- replace
			menu.selectedcomponents = {}
		else
			-- don't add
			add = false
		end
	else
		if hasonlynpcs then
			-- replace
			menu.selectedcomponents = {}
		else
			-- add -> nothing to do
		end
	end

	if add then
		menu.selectedcomponents[tostring(component)] = {}
	end
	if not noupdate then
		menu.updateTableSelection(component)
	end
end

function menu.addSelectedComponents(components, clear)
	if clear ~= false then
		menu.selectedcomponents = {}
	end
	for _, component in ipairs(components) do
		menu.addSelectedComponent(component, false, true)
	end
	menu.updateTableSelection()
end

function menu.removeSelectedComponent(component)
	component = ConvertStringTo64Bit(tostring(component))
	menu.selectedcomponents[tostring(component)] = nil
	menu.updateTableSelection()
end

function menu.toggleSelectedComponent(component)
	if menu.isSelectedComponent(component) then
		menu.removeSelectedComponent(component)
	else
		menu.addSelectedComponent(component, false)
	end
end

function menu.isSelectedComponent(component)
	component = ConvertStringTo64Bit(tostring(component))
	return menu.selectedcomponents[tostring(component)] ~= nil
end

function menu.clearSelectedComponents()
	menu.selectedcomponents = {}
	menu.updateTableSelection()
end

function menu.getNumSelectedComponents()
	local count = 0
	for _, _ in pairs(menu.selectedcomponents) do
		count = count + 1
	end
	return count
end

function menu.getShipList(includePlayerOccupiedShip, includeShipsWithOrderLoops)
	local ships = GetTradeShipList()
	local playeroccupiedship = ConvertStringToLuaID(tostring(C.GetPlayerOccupiedShipID()))
	for i = #ships, 1, -1 do
		local ship = ships[i]
		local commander = GetCommander(ship.shipid)
		local hasloop = ffi.new("bool[1]", 0)
		C.GetOrderQueueFirstLoopIdx(ConvertIDTo64Bit(ship.shipid), hasloop)
		local isplayeroccupiedship = IsSameComponent(ship.shipid, playeroccupiedship)

		if commander and not IsSameComponent(commander, playeroccupiedship) then
			table.remove(ships, i)
		elseif GetComponentData(ship.shipid, "isdeployable") then
			table.remove(ships, i)
		elseif #GetTransportUnitMacros(GetComponentData(ship.shipid, "macro")) == 0 then
			table.remove(ships, i)
		elseif (not includePlayerOccupiedShip) and isplayeroccupiedship then
			-- remove the player occupied ship
			table.remove(ships, i)
		elseif (not includeShipsWithOrderLoops) and hasloop[0] and ((not includePlayerOccupiedShip) or (not isplayeroccupiedship)) then
			-- remove loop ship unless it is the player occupied ship and we keep the player occupied ship
			table.remove(ships, i)
		end
	end

	return ships
end

function menu.updateTradeContextDimensions(numwarerows, numinforows)
	local warescrollwindowsize = 6
	local numwarningrows = 2

	local textheight = math.ceil(C.GetTextHeight("", Helper.standardFont, math.floor(Helper.scaleFont(Helper.standardFont, Helper.standardFontSize)), 0))
	local rowHeight = math.max(Helper.slidercellMinHeight, textheight)

	menu.tradeContext = {
		width = config.tradeContextMenuWidth,			-- ca 800 px in 1920x1080
		warescrollwindowsize = warescrollwindowsize,
		numwarerows = numwarerows,
		shipheight = Helper.scaleY(Helper.headerRow1Height) + Helper.borderSize + 1 + (math.min(warescrollwindowsize, numwarerows) + 1) * (Helper.borderSize + rowHeight),
		numinforows = numinforows,
		numwarningrows = numwarningrows,
		buttonheight = 1 + (numinforows + numwarningrows + 2) * (Helper.borderSize + rowHeight),
	}
end

function menu.getFilterTradeWaresOptions()
	local result = {}
	for name, ware in pairs(menu.economyWares) do
		table.insert(result, ware)
	end
	return result
end

function menu.getFilterTradeVolumeOptions()
	local params = C.GetMapTradeVolumeParameter()
	local icon = "\27[" .. ffi.string(params.icon) .."]"
	local color = { r = params.color.red, g = params.color.green, b = params.color.blue, a = params.color.alpha }

	local result = {
		{ id = 0,				text = ReadText(1001, 8359), text2 = "",														icon = "", displayremoveoption = false }, -- None
		{ id = params.volume_s,	text = ReadText(1001, 2853), text2 = Helper.convertColorToText(color) .. icon,					icon = "", displayremoveoption = false }, -- Small
		{ id = params.volume_m,	text = ReadText(1001, 2854), text2 = Helper.convertColorToText(color) .. icon .. icon,			icon = "", displayremoveoption = false }, -- Medium
		{ id = params.volume_l,	text = ReadText(1001, 2855), text2 = Helper.convertColorToText(color) .. icon .. icon .. icon,	icon = "", displayremoveoption = false }, -- Large
	}
	return result
end

function menu.getFilterTradePlayerOfferOptions(buysellswitch)
	local result = {
		{ id = 0,	text = (buysellswitch and ReadText(1001, 8309) or ReadText(1001, 8308)) .. ReadText(1001, 120) .. " " .. ReadText(1001, 11206),	icon = "", displayremoveoption = false }, -- All
		{ id = 1,	text = (buysellswitch and ReadText(1001, 8309) or ReadText(1001, 8308)) .. ReadText(1001, 120) .. " " .. ReadText(1001, 11207),	icon = "", displayremoveoption = false }, -- Player only
		{ id = 2,	text = (buysellswitch and ReadText(1001, 8309) or ReadText(1001, 8308)) .. ReadText(1001, 120) .. " " .. ReadText(1001, 11208),	icon = "", displayremoveoption = false }, -- Non-Player only
	}
	return result
end

function menu.getFilterThinkAlertOptions()
	local result = {
		{ id = 0, text = ReadText(1001, 4054), icon = "", displayremoveoption = false }, -- none
		{ id = 3, text = ReadText(1001, 4053), icon = "", displayremoveoption = false }, -- high
		{ id = 2, text = ReadText(1001, 4052), icon = "", displayremoveoption = false }, -- medium
		{ id = 1, text = ReadText(1001, 4051), icon = "", displayremoveoption = false }, -- low
	}
	return result
end

function menu.getFilterOption(id, savegame)
	local settings = __CORE_DETAILMONITOR_MAPFILTER
	if savegame then

		-- kuertee start: __CORE_DETAILMONITOR_MAPFILTER_SAVE is reset on /reloadui
		if not __CORE_DETAILMONITOR_MAPFILTER_SAVE then
			__CORE_DETAILMONITOR_MAPFILTER_SAVE = {}
		end
		-- kuertee end: __CORE_DETAILMONITOR_MAPFILTER_SAVE is reset on /reloadui

		settings = __CORE_DETAILMONITOR_MAPFILTER_SAVE
	end

	return settings[id]
end

function menu.setFilterOption(mode, setting, id, value, index)
	local settings = __CORE_DETAILMONITOR_MAPFILTER
	if setting.savegame then
		settings = __CORE_DETAILMONITOR_MAPFILTER_SAVE
	end

	if setting.type == "multiselectlist" then
		settings[id] = settings[id] or {}
		if value then
			if index then
				settings[id][index] = value
			else
				if type(value) == "table" then
					local sorted = {}
					for ware in pairs(value) do
						table.insert(sorted, ware)
					end
					table.sort(sorted, Helper.sortWareName)
					settings[id] = {}
					for _, ware in ipairs(sorted) do
						table.insert(settings[id], ware)
					end
					menu.closeContextMenu()
				else
					table.insert(settings[id], value)
				end
			end
		else
			if menu.contextMenuMode == "filter_multiselectlist" then
				menu.setFilterOption(menu.displayedFilterLayer, menu.contextMenuData.setting, menu.contextMenuData.setting.id, menu.contextMenuData.selectedWares)
			else
				menu.contextMenuMode = "filter_multiselectlist"
				menu.contextMenuData = { setting = setting, id = id, value = value }
				menu.createContextFrame(280, Helper.viewHeight - 100, Helper.viewWidth - menu.infoTableOffsetX - menu.infoTableWidth - config.contextBorder - 280, 100)
			end
		end
	elseif setting.type == "checkbox" then
		settings[id] = not settings[id]
	elseif setting.type == "slidercell" then
		settings[id] = value
	elseif setting.type == "dropdown" then
		settings[id] = tonumber(value)
	end

	if not settings[mode] then
		settings[mode] = true
		menu.applyFilterSettings()
	else
		setting.callback(setting)
	end
end

function menu.removeFilterOption(setting, id, index)
	local settings = __CORE_DETAILMONITOR_MAPFILTER
	if setting.savegame then
		settings = __CORE_DETAILMONITOR_MAPFILTER_SAVE
	end

	if setting.type == "multiselectlist" then
		settings[id] = settings[id] or {}
		table.remove(settings[id], index)
		setting.callback(setting)
	end
end

function menu.upgradeMapFilterVersion()
	local oldversion = __CORE_DETAILMONITOR_MAPFILTER.version

	if oldversion < 3 then
		__CORE_DETAILMONITOR_MAPFILTER["other_misc_ecliptic"] = true
	end
	if oldversion < 5 then
		__CORE_DETAILMONITOR_MAPFILTER["layer_think"] = true
	end
	if oldversion < 6 then
		__CORE_DETAILMONITOR_MAPFILTER["trade_storage_container"] = true
	end
	if oldversion < 7 then
		__CORE_DETAILMONITOR_MAPFILTER["think_alert"] = 3
	end
	if oldversion < 8 then
		__CORE_DETAILMONITOR_MAPFILTER["mining_resource_display"] = true
		__CORE_DETAILMONITOR_MAPFILTER["other_misc_civilian"] = true
	end
	if oldversion < 9 then
		__CORE_DETAILMONITOR_MAPFILTER["trade_offer_number"] = 3
	end
	if oldversion < 10 then
		__CORE_DETAILMONITOR_MAPFILTER["trade_volume"] = 0
	end
	if oldversion < 11 then
		__CORE_DETAILMONITOR_MAPFILTER["other_misc_allyorderqueue"] = true
	end
	if oldversion < 12 then
		__CORE_DETAILMONITOR_MAPFILTER["other_misc_wrecks"] = true
	end
	if oldversion < 13 then
		__CORE_DETAILMONITOR_MAPFILTER["think_diplomacy_factioncolor"] = false
		__CORE_DETAILMONITOR_MAPFILTER["trade_playeroffer_buy"] = 0
		__CORE_DETAILMONITOR_MAPFILTER["trade_playeroffer_sell"] = 0
	end
	if oldversion < 14 then
		__CORE_DETAILMONITOR_MAPFILTER["other_misc_selection_lines"] = true
	end
	if oldversion < 15 then
		__CORE_DETAILMONITOR_MAPFILTER["think_diplomacy_highlightvisitor"] = true
	end
	if oldversion < 16 then
		__CORE_DETAILMONITOR_MAPFILTER["trade_relation_enemy"] = true
		__CORE_DETAILMONITOR_MAPFILTER["other_misc_opacity"] = false
		__CORE_DETAILMONITOR_MAPFILTER["other_misc_gate_connections"] = true
	end
	if oldversion < 17 then
		if __CORE_DETAILMONITOR_MAPFILTER["trade_price_maxprice"] == 5000 then
			__CORE_DETAILMONITOR_MAPFILTER["trade_price_maxprice"] = 10000
		end
	end
	if oldversion < 18 then
		__CORE_DETAILMONITOR_MAPFILTER["other_misc_coveroverride"] = false
	end
	if oldversion < 19 then
		if __CORE_DETAILMONITOR_MAPFILTER["trade_price_maxprice"] == 10000 then
			__CORE_DETAILMONITOR_MAPFILTER["trade_price_maxprice"] = 0
		end
	end
	if oldversion < 20 then
		__CORE_DETAILMONITOR_MAPFILTER["other_misc_rendersatelliteradarrange"] = true
	end

	__CORE_DETAILMONITOR_MAPFILTER.version = config.mapfilterversion
end

function menu.upgradeMapFilterSaveVersion()
	-- kuertee start: __CORE_DETAILMONITOR_MAPFILTER_SAVE is reset on /reloadui
	if not __CORE_DETAILMONITOR_MAPFILTER_SAVE then
		__CORE_DETAILMONITOR_MAPFILTER_SAVE = {}
	end
	-- kuertee end: __CORE_DETAILMONITOR_MAPFILTER_SAVE is reset on /reloadui

	local oldversion = __CORE_DETAILMONITOR_MAPFILTER_SAVE.version

	if oldversion < 1 then
		__CORE_DETAILMONITOR_MAPFILTER_SAVE["trade_wares"]				= Helper.tableCopy(__CORE_DETAILMONITOR_MAPFILTER["trade_wares"])
		__CORE_DETAILMONITOR_MAPFILTER_SAVE["trade_storage_container"]	= __CORE_DETAILMONITOR_MAPFILTER["trade_storage_container"]
		__CORE_DETAILMONITOR_MAPFILTER_SAVE["trade_storage_solid"]		= __CORE_DETAILMONITOR_MAPFILTER["trade_storage_solid"]
		__CORE_DETAILMONITOR_MAPFILTER_SAVE["trade_storage_liquid"]		= __CORE_DETAILMONITOR_MAPFILTER["trade_storage_liquid"]
		__CORE_DETAILMONITOR_MAPFILTER_SAVE["trade_storage_condensate"]	= __CORE_DETAILMONITOR_MAPFILTER["trade_storage_condensate"]
	end

	__CORE_DETAILMONITOR_MAPFILTER_SAVE.version = config.mapfiltersaveversion
end

function menu.applyFilterSettings()
	for mode, settings in pairs(config.layersettings) do
		local active = menu.getFilterOption(mode, false) or false
		if settings.callback then
			settings.callback(active)
		end
		if active then
			for _, setting in ipairs(settings) do
				setting.callback(setting)
			end
		end
	end

	menu.setSectorFilter()
end

function menu.setMouseCursorOverride(cursor, priority)
	menu.mouseCursorOverrides[priority] = cursor
	menu.setMouseCursor()
end

function menu.removeMouseCursorOverride(priority)
	menu.mouseCursorOverrides[priority] = nil
	menu.setMouseCursor()
end

function menu.clearMouseCursorOverrides()
	menu.mouseCursorOverrides = { [1] = "default" }
	menu.setMouseCursor()
end

function menu.setMouseCursor()
	local highestPriority = table.maxn(menu.mouseCursorOverrides)
	if menu.mouseCursorOverrides[highestPriority] ~= menu.currentMouseCursor then
		menu.currentMouseCursor = menu.mouseCursorOverrides[highestPriority]
		SetMouseCursorOverride(menu.currentMouseCursor)
	end
end

function menu.updateMouseCursor()
	local occupiedship = C.GetPlayerOccupiedShipID()

	local hasplayerselectedship = false
	for id, _ in pairs(menu.selectedcomponents) do
		local selectedcomponent = ConvertStringTo64Bit(id)
		if IsValidComponent(selectedcomponent) then
			if C.IsComponentClass(selectedcomponent, "ship") and GetComponentData(selectedcomponent, "isplayerowned") then
				if selectedcomponent ~= occupiedship then
					hasplayerselectedship = true
				end
			end
		else
			menu.removeSelectedComponent(selectedcomponent)
		end
	end

	local cursor
	if menu.showMultiverse then
		local pickedplayer = C.GetPickedMultiverseMapPlayer(menu.holomap)
		if pickedplayer.id ~= 0 then
			cursor = "cursor"
		elseif menu.picking then
			cursor = "crossarrows"
		end
	elseif menu.plotData and menu.plotData.active then
		-- plot mode
		local offset = ffi.new("UIPosRot")
		local offsetsector = C.GetBuildMapStationLocation2(menu.holomap, offset)
		if offsetsector ~= 0 then
			cursor = "cursorplus"
		else
			cursor = "unavailable"
		end
	else
		local shiftpressed = C.IsShiftPressed()
		local controlpressed = C.IsControlPressed()
		local pickedcomponent = C.GetPickedMapComponent(menu.holomap)
		local pickedcomponentclass = ffi.string(C.GetComponentClass(pickedcomponent))
		local pickedorder = ffi.new("Order")
		local buf = ffi.new("bool[1]", 0)
		local pickedordercomponent = C.GetPickedMapOrder(menu.holomap, pickedorder, buf)
		local isintermediate = buf[0]
		local pickedtradeoffer = C.GetPickedMapTradeOffer(menu.holomap)
		local pickedmission = C.GetPickedMapMission(menu.holomap)
		local pickedsyncpoint = C.GetPickedMapSyncPoint(menu.holomap)
		local pickedsyncpointorder = ffi.new("Order")
		local pickedsyncpointordercomponent = C.GetPickedMapSyncPointOwningOrder(menu.holomap, pickedsyncpointorder)

		if pickedordercomponent ~= 0 then
			if GetComponentData(ConvertStringTo64Bit(tostring(pickedordercomponent)), "isplayerowned") then
				-- orders
				if pickedordercomponent ~= occupiedship then
					if isintermediate then
						cursor = "cursorplus"
					else
						cursor = "cursormove"
					end
				else
					cursor = "cursor"
				end
			end
		elseif pickedmission ~= 0 then
			-- guidance
			cursor = "cursor"
		elseif pickedsyncpoint ~= 0 then
			-- sync point
			cursor = "cursor"
		elseif pickedsyncpointordercomponent ~= 0 then
			-- order sync point
			cursor = "cursor"
		elseif pickedtradeoffer ~= 0 then
			-- trade offers
			cursor = "trade"
		elseif pickedcomponent ~= 0 then
			if menu.picking then
				if shiftpressed then
					-- changing selection
					if (pickedcomponentclass ~= "player") and (pickedcomponentclass ~= "ship_xs") and (pickedcomponentclass ~= "highwayentrygate") and (pickedcomponentclass ~= "collectablewares") and (pickedcomponentclass ~= "gate") and (pickedcomponentclass ~= "asteroid") and (pickedcomponentclass ~= "sector") then
						if C.IsComponentOperational(pickedcomponent) and GetComponentData(ConvertStringTo64Bit(tostring(pickedcomponent)), "isplayerowned") then
							cursor = "cursorplus"
						end
					end
				elseif controlpressed then
					-- default interactions
					if C.IsComponentClass(pickedcomponent, "sector") then
						if hasplayerselectedship then
							cursor = "movehere"
						end
					elseif GetComponentData(ConvertStringTo64Bit(tostring(pickedcomponent)), "isenemy") then
						if hasplayerselectedship then
							cursor = "targetred"
						end
					elseif C.IsComponentClass(pickedcomponent, "station") then
						local issingleloopship
						if menu.getNumSelectedComponents() == 1 then
							local component = next(menu.selectedcomponents)
							local selectedcomponent = ConvertStringTo64Bit(component)
							local hasloop = ffi.new("bool[1]", 0)
							C.GetOrderQueueFirstLoopIdx(selectedcomponent, hasloop)
							issingleloopship = hasloop[0]
						end

						if not issingleloopship then
							cursor = "trade"
						end
					end
				elseif pickedcomponentclass ~= "player" then
					local playerships = menu.getSelectedComponentCategories()
					for i = #playerships, 1, -1 do
						local ship = playerships[i]
						if ship == pickedcomponent then
							table.remove(playerships, i)
						end
					end
					if #playerships > 0 then
						if C.IsComponentClass(pickedcomponent, "sector") then
							cursor = "crossarrowsorder"
						else
							cursor = "cursororder"
						end
					end
				end
			end
		end
		-- map pan & rot
		if menu.picking then
			if not cursor then
				if (pickedcomponent == 0) or (not C.IsComponentClass(pickedcomponent, "object")) then
					if shiftpressed then
						cursor = "boxselect"
					else
						cursor = "crossarrows"
					end
				end
			end
		end
	end
	if cursor then
		menu.setMouseCursorOverride(cursor, 2)
	else
		menu.removeMouseCursorOverride(2)
	end
end

function menu.getDropDownTurretModeOption(defensibleorturret, context, path, group)
	if (context == nil) and (path == nil) and (group == nil) then
		return ffi.string(C.GetWeaponMode(defensibleorturret))
	elseif context == "all" then
		local allmode
		for i, turret in ipairs(menu.turrets) do
			if (path == nil) or (path == C.IsComponentClass(turret, "missileturret")) then
				local mode = ffi.string(C.GetWeaponMode(turret))
				if allmode == nil then
					allmode = mode
				elseif allmode ~= mode then
					allmode = ""
					break
				end
			end
		end
		for i, group in ipairs(menu.turretgroups) do
			if group.operational > 0 then
				if (path == nil) or (path == IsMacroClass(group.currentmacro, "missileturret")) then
					local mode = ffi.string(C.GetTurretGroupMode2(defensibleorturret, group.context, group.path, group.group))
					if allmode == nil then
						allmode = mode
					elseif allmode ~= mode then
						allmode = ""
						break
					end
				end
			end
		end
		return allmode or ""
	end
	return ffi.string(C.GetTurretGroupMode2(defensibleorturret, context, path, group))
end

function menu.areTurretsArmed(defensibleorturret, ismissile)
	local alldisarmed = true
	for i, turret in ipairs(menu.turrets) do
		if (ismissile == nil) or (ismissile == C.IsComponentClass(turret, "missileturret")) then
			if C.IsWeaponArmed(turret) then
				alldisarmed = false
				break
			end
		end
	end
	for i, group in ipairs(menu.turretgroups) do
		if group.operational > 0 then
			if (ismissile == nil) or (ismissile == IsMacroClass(group.currentmacro, "missileturret")) then
				if C.IsTurretGroupArmed(defensibleorturret, group.context, group.path, group.group) then
					alldisarmed = false
					break
				end
			end
		end
	end
	return not alldisarmed
end

function menu.updateSubordinateGroupInfo(controllable)
	local curtime = getElapsedTime()
	if (not menu.lastSubordinateGroupUpdate) or (curtime > menu.lastSubordinateGroupUpdate) then
		menu.lastSubordinateGroupUpdate = curtime
		local subordinates = GetSubordinates(controllable)
		menu.subordinategroups = {}
		for _, subordinate in ipairs(subordinates) do
			local subordinate64 = ConvertIDTo64Bit(subordinate)
			local group = GetComponentData(subordinate, "subordinategroup")
			if group and group > 0 then
				if menu.subordinategroups[group] then
					local isdocked = C.GetContextByClass(subordinate64, "container", true) == controllable
					if isdocked then
						menu.subordinategroups[group].numdockedatcommander = menu.subordinategroups[group].numdockedatcommander + 1
					end
					table.insert(menu.subordinategroups[group].subordinates, subordinate)
				else
					local isdocked = C.GetContextByClass(subordinate64, "container", true) == controllable
					menu.subordinategroups[group] = { assignment = ffi.string(C.GetSubordinateGroupAssignment(controllable, group)), subordinates = { subordinate }, numdockedatcommander = isdocked and 1 or 0 }
				end
			end
		end
	end
end

function menu.buttonActiveSubordinateGroupLaunch(inputobject, i)
	menu.updateSubordinateGroupInfo(inputobject)
	if menu.subordinategroups[i] then
		return (menu.subordinategroups[i].assignment ~= "trade") and (menu.subordinategroups[i].assignment ~= "mining") and (menu.subordinategroups[i].assignment ~= "follow") and (menu.subordinategroups[i].assignment ~= "assist") and (menu.subordinategroups[i].assignment ~= "supplyfleet")
	end
	return false
end

function menu.etaSorter(a, b)
	if (a.eta < 0) then
		return false
	elseif (b.eta < 0) then
		return true
	end
	return a.eta < b.eta
end

-- sums up all ware reservation amounts and returns the total (single integer)
function menu.getReservationsAmountTotal(contextcomponent)
	local total = 0
	local n = C.GetNumContainerWareReservations2(contextcomponent, false, false, true)
	local reservations = ffi.new("WareReservationInfo2[?]", n)
	n = C.GetContainerWareReservations2(reservations, n, contextcomponent, false, false, true)
	for i = 0, n - 1 do
		local buyflag = reservations[i].isbuyreservation and "selloffer" or "buyoffer"
		if not Helper.dirtyreservations[tostring(reservations[i].tradedealid)] then
			if buyflag == "buyoffer" then
				total = total + reservations[i].amount
			else
				total = total - reservations[i].amount
			end
		end
	end

	return total
end

-- sums up all ware reservation amounts sorted by transport type and returns the result as a list
function menu.getReservationsVolumeByTransportType(contextcomponent)
	local amounts = {}
	local n = C.GetNumContainerWareReservations2(contextcomponent, false, false, true)
	local reservations = ffi.new("WareReservationInfo2[?]", n)
	n = C.GetContainerWareReservations2(reservations, n, contextcomponent, false, false, true)
	for i = 0, n - 1 do
		local storagetype, volume = GetWareData(ffi.string(reservations[i].ware), "transport", "volume")
		local buyflag = reservations[i].isbuyreservation and "selloffer" or "buyoffer"
		if not Helper.dirtyreservations[tostring(reservations[i].tradedealid)] then
			if not amounts[storagetype] then
				amounts[storagetype] = 0
			end

			if buyflag == "buyoffer" then
				amounts[storagetype] = amounts[storagetype] + reservations[i].amount * volume
			else
				amounts[storagetype] = amounts[storagetype] - reservations[i].amount * volume
			end
		end
	end

	return amounts
end

-- sums up all ware reservation amounts sorted by ware type and returns the result as a list
function menu.getReservationsAmountByWareType(contextcomponent)
	local amounts = {}
	local n = C.GetNumContainerWareReservations2(contextcomponent, false, false, true)
	local reservations = ffi.new("WareReservationInfo2[?]", n)
	n = C.GetContainerWareReservations2(reservations, n, contextcomponent, false, false, true)
	for i = 0, n - 1 do
		local ware = ffi.string(reservations[i].ware)
		local buyflag = reservations[i].isbuyreservation and "selloffer" or "buyoffer"
		if not Helper.dirtyreservations[tostring(reservations[i].tradedealid)] then
			if not amounts[ware] then
				amounts[ware] = 0
			end

			if buyflag == "buyoffer" then
				amounts[ware] = amounts[ware] + reservations[i].amount
			else
				amounts[ware] = amounts[ware] - reservations[i].amount
			end
		end
	end

	return amounts
end

-- Returns the color and function needed to initiate a ware button for the ObjectInfoTab and the SelectedObjectInfo
-- NOTE: this function is designed to run in a loop, therefore filteroptionlist and setting is not part of the function
--
-- filteroptionlist needs to be the return of menu.getFilterOption
-- setting needs to be the return of config.layersettings["layer_trade"][1]
-- contextware is the ware to do all the checks against
--
-- returns color white if the contextware can be found in filteroptionlist or if filteroptionlist is empty, returns grey otherwise
-- returns function to remove the ware from the tradefilter if the contextware can be found in filteroptionlist, returns function to add the ware otherwise
function menu.getWareButtonColorAndScript(filteroptionlist, setting, contextware)
	local index
	for i, entry in ipairs(filteroptionlist) do
		if (entry == contextware) then
			index = i
			break
		end
	end

	local color = Color["text_normal"]
	local script

	if menu.getFilterOption("layer_trade", false) then
		if (#filteroptionlist ~= 0) and (not index) then
			color = Color["text_inactive"]
		end
		if index then
			script = function () menu.removeFilterOption(setting, setting.id, index) end
		else
			script = function () menu.setFilterOption("layer_trade", setting, setting.id, contextware) end
		end
	end

	return color, script
end

-- Takes in storage level, capacity and reservation amount and returns a formatted string like "4,928 k (+5,184) / 5,000 k m3"
-- NOTE: maxcapacity is optional in which case the return is like: "1,295 k (+425)"
function menu.formatWareAmount(currentamount, futureamount, maxcapacity)
	local formattedstring = ConvertIntegerString(futureamount, true, 2, true) .. ((futureamount ~= currentamount) and (" (" .. string.format("%s%s", ((futureamount - currentamount) > 0) and "+" or "", ConvertIntegerString(futureamount - currentamount, true, 2, true)) .. ")") or "")
	if maxcapacity ~= nil then
		formattedstring = formattedstring  .. " / " .. ConvertIntegerString(maxcapacity, true, 2, true) .. " " .. ReadText(1001, 110)
	end
	return formattedstring
end

function menu.getAmountTextWidth(amounttext)
	return math.ceil(C.GetTextWidth(amounttext, Helper.standardFont, menu.selectedShipsTableData.fontsize)) + 2 * Helper.standardTextOffsetx
end

-- Adds a row into a table that shows the name of a transporttype and its fillinglevel expressed with a bar and in numbers
-- Function takes in a table with the following attributes
--	inputtable: the table to add the row to
--	barcolumn: the column the bar should exist in
--	textcolumn: the column the text should exist in
--	textcolspan: the column span of the text
--	currentamount: storage's current filling level
--	futureamount: storage's filling level after all reserved ware exchanges have happened
--	maxcapacity: storage's maximum capacity
--	transporttypename: the displayed text
function menu.addCapacityRow(data)
	row = data.inputtable:addRow(true, { interactive = false })
	row[data.textcolumn]:setColSpan(data.textcolspan)

	local mouseovertext
	local amounttext = menu.formatWareAmount(data.currentamount, data.futureamount, data.maxcapacity)
	local text = ReadText(1001, 1402) .. " (" .. data.transporttypename .. ")" .. ReadText(1001, 120)
	local truncatedtext = TruncateText(text, Helper.standardFont, menu.selectedShipsTableData.fontsize, row[data.textcolumn]:getWidth() - menu.getAmountTextWidth(amounttext))
	if truncatedtext ~= text then
		mouseovertext = text .. " " .. amounttext
	end

	local textxoffset = 1 + Helper.borderSize
	local barxoffset = textxoffset + row[data.barcolumn]:getColSpanWidth()
	local width = row[data.textcolumn]:getColSpanWidth()
	row[data.barcolumn]:createStatusBar({ current = data.futureamount, start = data.currentamount, max = data.maxcapacity, cellBGColor = Color["row_background"], valueColor = Color["slider_value"], posChangeColor = Color["flowchart_slider_diff2"], negChangeColor = Color["flowchart_slider_diff1"], markerColor = Color["statusbar_marker_hidden"], width = width, x = barxoffset, scaling = false })
	row[data.textcolumn]:createIcon("solid", { color = Color["icon_transparent"], height = menu.selectedShipsTableData.textHeight, mouseOverText = mouseovertext })
	row[data.textcolumn]:setText(truncatedtext, {x = textxoffset})
	row[data.textcolumn]:setText2(amounttext, { halign = "right", x = Helper.standardTextOffsetx })
end

-- Adds a row into a table that shows a button labled with the ware's name and its amount expressed with a bar and in numbers
-- Function takes in a table with the following attributes
--	inputtable: the table to add the row to
--	barcolumn: the column the bar should exist in
--	buttoncolumn: the column the button should exist in
--	buttoncolspan: the column span of the button
--	currentamount: ware's current amount
--	futureamount: ware's amount after all reserved exchanges have happened
--	maxcapacity: ware's maximum capacity
--	warename: name of the ware
--	textcolor: the color to display the text in
--	buttonscript: the function to execute when clicking the button
function menu.addWareInfoButtonRow(data)
	row = data.inputtable:addRow(true)
	row[data.buttoncolumn]:setColSpan(data.buttoncolspan)

	local mouseovertext
	local amounttext = menu.formatWareAmount(data.currentamount, data.futureamount)
	local truncatedtext = TruncateText(data.warename, Helper.standardFont, menu.selectedShipsTableData.fontsize, row[data.buttoncolumn]:getWidth() - menu.getAmountTextWidth(amounttext))
	if truncatedtext ~= data.warename then
		mouseovertext = data.warename .. " " .. amounttext
	end

	local barxoffset = 1 + Helper.borderSize + row[data.barcolumn]:getColSpanWidth()
	local width = row[data.buttoncolumn]:getColSpanWidth()
	row[data.barcolumn]:createStatusBar({ current = data.futureamount, start = data.currentamount, max = data.maxcapacity, cellBGColor = Color["row_background"], valueColor = Color["slider_value"], posChangeColor = Color["flowchart_slider_diff2"], negChangeColor = Color["flowchart_slider_diff1"], markerColor = Color["statusbar_marker_hidden"], width = width, x = barxoffset, scaling = false })
	row[data.buttoncolumn]:createButton({ height = menu.selectedShipsTableData.textHeight, mouseOverText = mouseovertext })
	row[data.buttoncolumn]:setText(truncatedtext, { color = data.textcolor, x = Helper.standardIndentStep })
	row[data.buttoncolumn]:setText2(amounttext, { halign = "right", x = Helper.standardTextOffsetx, color = data.textcolor })
	row[data.buttoncolumn].handlers.onClick = data.buttonscript
end

function menu.setInfoSubmenuObjectAndRefresh(component)
	menu.infoSubmenuObject = component
	if menu.infoTableMode == "info" then
		menu.refreshInfoFrame(nil, 0)
	elseif menu.searchTableMode == "info" then
		menu.refreshInfoFrame2(nil, 0)
	end
end

-- kuertee start:
function menu.registerCallback (callbackName, callbackFunction)
	-- note 1: format is generally [function name]_[action]. e.g.: in kuertee_menu_transporter, "display_on_set_room_active" overrides the room's active property with the return of the callback.
	-- note 2: events have the word "_on_" followed by a PRESENT TENSE verb. e.g.: in kuertee_menu_transporter, "display_on_set_buttontable" is called after all of the rows of buttontable are set.
	-- note 3: new callbacks can be added or existing callbacks can be edited. but commit your additions/changes to the mod's GIT repository.
	-- note 4: search for the callback names to see where they are executed.
	-- note 5: if a callback requires a return value, return it in an object var. e.g. "display_on_set_room_active" requires a return of {active = true | false}.

	-- to find callbacks available for this menu,
	-- reg-ex search for callbacks\[\".*\]

	if callbacks [callbackName] == nil then
		callbacks [callbackName] = {}
	end
	table.insert (callbacks [callbackName], callbackFunction)
end

function menu.deregisterCallback(callbackName, callbackFunction)
	-- for i, callback in ipairs(callbacks[callbackName]) do
	if callbacks[callbackName] and #callbacks[callbackName] > 0 then
		for i = #callbacks[callbackName], 1, -1 do
			if callbacks[callbackName][i] == callbackFunction then
				table.remove(callbacks[callbackName], i)
			end
		end
	end
end

function menu.setSelectComponentMode (returnsection, classlist, category, playerowned, customheading, screenname)
	menu.old_mode = menu.mode
	menu.old_modeparam = menu.modeparam
	menu.old_infoTableMode = menu.infoTableMode

	menu.mode = "selectComponent"
	menu.modeparam = {
		returnsection,
		classlist,
		category,
		playerowned,
		customheading,
		screenname
	}
	menu.infoTableMode = "propertyowned"
	menu.closeContextMenu()
	menu.refreshMainFrame = true
	menu.refreshInfoFrame()
end

function menu.sortDistanceFromPlayer (a, b, invert)
	local distance_a = C.GetDistanceBetween (ConvertStringTo64Bit (tostring (a.id)), ConvertStringTo64Bit (tostring (C.GetPlayerID ())))
	local distance_b = C.GetDistanceBetween (ConvertStringTo64Bit (tostring (b.id)), ConvertStringTo64Bit (tostring (C.GetPlayerID ())))
	if invert then
		return distance_a > distance_b
	else
		return distance_a < distance_b
	end
end

function menu.sortDistanceFromObject (a, b, invert)
	local distance_a = C.GetDistanceBetween (ConvertStringTo64Bit (tostring (a.id)), ConvertStringTo64Bit (tostring (menu.infoSubmenuObject)))
	local distance_b = C.GetDistanceBetween (ConvertStringTo64Bit (tostring (b.id)), ConvertStringTo64Bit (tostring (menu.infoSubmenuObject)))
	if invert then
		return distance_a > distance_b
	else
		return distance_a < distance_b
	end
end

function menu.sortDanger (a, b, invert)
	-- danger = menu.object.dps * purpose.fighter * 100
	-- uint32_t GetDefensibleDPS(DPSData* result, UniverseID defensibleid, bool primary, bool secondary, bool lasers, bool missiles, bool turrets, bool includeheat, bool includeinactive);
	-- local activedpstable = ffi.new("DPSData[?]", 6)
	-- local numtotalquadrants = C.GetDefensibleDPS(activedpstable, ship, true, true, true, false, false, false, false)
	-- hasactiveguns = activedpstable[0].dps > 0
	-- local inactivedpstable = ffi.new("DPSData[?]", 6)
	-- local numtotalquadrants = C.GetDefensibleDPS(inactivedpstable, ship, true, true, true, false, false, false, true)
	-- hasinactiveguns = inactivedpstable[0].dps > 0
	local purpose_a = GetComponentData(a, "primarypurpose")
	local dpsTable_a = ffi.new("DPSData[?]", 6)
	C.GetDefensibleDPS(dpsTable_a, a, true, true, true, false, true, false, false)
	local danger_a = dpsTable_a[0].dps + dpsTable_a[1].dps + dpsTable_a[2].dps + dpsTable_a[3].dps + dpsTable_a[4].dps + dpsTable_a[5].dps
	if purpose_a == "fighter" then
		danger_a = danger_a * 100
	end
	local purpose_b = GetComponentData(b, "primarypurpose")
	local dpsTable_b = ffi.new("DPSData[?]", 6)
	C.GetDefensibleDPS(dpsTable_b, b, true, true, true, false, true, false, false)
	local danger_b = dpsTable_b[0].dps + dpsTable_b[1].dps + dpsTable_b[2].dps + dpsTable_b[3].dps + dpsTable_b[4].dps + dpsTable_b[5].dps
	if purpose_b == "fighter" then
		danger_b = danger_b * 100
	end
	if danger_a == danger_b then
		return menu.sortCombinedSkill(a, b, invert)
	elseif invert then
		return danger_a > danger_b
	else
		return danger_a < danger_b
	end
end

function menu.sortCombinedSkill(a, b, invert)
	local name_a = GetComponentData(a, "name")
	local name_b = GetComponentData(b, "name")
	local idCode_a = ffi.string(C.GetObjectIDCode(a))
	local idCode_b = ffi.string(C.GetObjectIDCode(b))
	local skill_a, skill_b = 0, 0
	local isLaserTower_a = GetMacroData(GetComponentData(a, "macro"), "islasertower")
	if C.IsRealComponentClass(a, "ship") and (not isLaserTower_a) then
		skill_a = math.floor(C.GetShipCombinedSkill(a) * 15 / 100)
	end
	local isLaserTower_b = GetMacroData(GetComponentData(b, "macro"), "islasertower")
	if C.IsRealComponentClass(b, "ship") and (not isLaserTower_b) then
		skill_b = math.floor(C.GetShipCombinedSkill(b) * 15 / 100)
	end
	if invert then
		if skill_a == skill_b then
			-- name and idcode sorts are always ascending
			if name_a == name_b then
				return idCode_a < idCode_b
			else
				return name_a < name_b
			end
		else
			return skill_a > skill_b
		end
	else
		if skill_a == skill_b then
			-- name and idcode sorts are always ascending
			if name_a == name_b then
				return idCode_a < idCode_b
			else
				return name_a < name_b
			end
		else
			return skill_a < skill_b
		end
	end
end

function menu.loadModLuas()
	if Helper then
		Helper.loadModLuas(menu.name, "menu_map_uix")
	end
end
-- kuertee end

init()
